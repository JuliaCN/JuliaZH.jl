# [æ¨¡å—](@id modules)

Julia ä¸­çš„æ¨¡å—æœ‰åŠ©äºå°†ä»£ç ç»„ç»‡æˆè¿è´¯çš„éƒ¨åˆ†ã€‚ å®ƒä»¬åœ¨è¯­æ³•ä¸Šä»¥ `module Name ... end` ç•Œå®šï¼Œå¹¶å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. æ¨¡å—æ˜¯ç‹¬ç«‹çš„å‘½åç©ºé—´ï¼Œæ¯ä¸ªéƒ½å¼•å…¥äº†ä¸€ä¸ªæ–°çš„å…¨å±€ä½œç”¨åŸŸã€‚ è¿™å¾ˆæœ‰ç”¨ï¼Œå› ä¸ºå®ƒå…è®¸å¯¹ä¸åŒçš„å‡½æ•°æˆ–å…¨å±€å˜é‡ä½¿ç”¨ç›¸åŒçš„åç§°è€Œä¸ä¼šå‘ç”Ÿå†²çªï¼Œåªè¦å®ƒä»¬åœ¨ä¸åŒçš„æ¨¡å—ä¸­å³å¯ã€‚
    

2. æ¨¡å—å…·æœ‰ç”¨äºå‘½åç©ºé—´ç®¡ç†çš„å·¥å…·ï¼šæ¯ä¸ªæ¨¡å—å®šä¹‰ä¸€ç»„å®ƒ`export`çš„åç§°ï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨ `using` å’Œ `import` ä»å…¶ä»–æ¨¡å—å¯¼å…¥åç§°ï¼ˆæˆ‘ä»¬å°†åœ¨ä¸‹é¢è§£é‡Šè¿™äº›ï¼‰ã€‚
    

3. æ¨¡å—å¯ä»¥é¢„ç¼–è¯‘ä»¥åŠ å¿«åŠ è½½é€Ÿåº¦ï¼Œå¹¶å¯èƒ½åŒ…å«ç”¨äºè¿è¡Œæ—¶åˆå§‹åŒ–çš„ä»£ç ã€‚

é€šå¸¸ï¼Œåœ¨è¾ƒå¤§çš„ Julia åŒ…ä¸­ï¼Œä½ ä¼šçœ‹åˆ°æ¨¡å—çš„ä»£ç ç»„ç»‡æˆæ–‡ä»¶ï¼Œä¾‹å¦‚

```julia
module SomeModule

# export, using, import statements are usually here; we discuss these below

include("file1.jl")
include("file2.jl")

end
```

æ–‡ä»¶å’Œæ–‡ä»¶åå¤§å¤šä¸æ¨¡å—æ— å…³ï¼›æ¨¡å—ä»…ä¸æ¨¡å—è¡¨è¾¾å¼ç›¸å…³è”ã€‚
æ¯ä¸ªæ¨¡å—å¯ä»¥æœ‰å¤šä¸ªæ–‡ä»¶ï¼Œæ¯ä¸ªæ–‡ä»¶å¯ä»¥æœ‰å¤šä¸ªæ¨¡å—ã€‚
`include` çš„è¡Œä¸ºå°±åƒåœ¨åŒ…å«æ¨¡å—çš„å…¨å±€ä½œç”¨åŸŸå†…æ‰§è¡Œæºæ–‡ä»¶çš„å†…å®¹ä¸€æ ·ã€‚
åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ç®€çŸ­å’Œç®€åŒ–çš„ç¤ºä¾‹ï¼Œå› æ­¤æˆ‘ä»¬ä¸ä¼šä½¿ç”¨ `include`ã€‚

æˆ‘ä»¬æ¨èä¸è¦ç¼©è¿›æ¨¡å—çš„ä¸»ä½“ï¼Œå› ä¸ºè¿™é€šå¸¸ä¼šå¯¼è‡´æ•´ä¸ªæ–‡ä»¶è¢«ç¼©è¿›ã€‚ æ­¤å¤–ï¼Œé€šå¸¸ä½¿ç”¨ `UpperCamelCase` ä½œä¸ºæ¨¡å—åç§°ï¼ˆå°±åƒç±»å‹ä¸€æ ·ï¼‰ï¼Œå¹¶åœ¨é€‚ç”¨æ—¶ä½¿ç”¨å¤æ•°å½¢å¼ï¼Œç‰¹åˆ«æ˜¯å¦‚æœæ¨¡å—åŒ…å«ç±»ä¼¼å‘½åçš„æ ‡è¯†ç¬¦ï¼Œä»¥é¿å…åç§°å†²çªã€‚ ä¾‹å¦‚ï¼Œ

```julia
module FastThings

struct FastThing
    ...
end

end
```

## [å‘½åç©ºé—´ç®¡ç†](@id namespace-management)

å‘½åç©ºé—´ç®¡ç†æ˜¯æŒ‡è¯­è¨€æä¾›çš„è®¾æ–½ï¼Œç”¨äºä½¿æ¨¡å—ä¸­çš„åç§°åœ¨å…¶ä»–æ¨¡å—ä¸­å¯ç”¨ã€‚ æˆ‘ä»¬åœ¨ä¸‹é¢è¯¦ç»†è®¨è®ºç›¸å…³çš„æ¦‚å¿µå’ŒåŠŸèƒ½ã€‚

### åˆæ ¼çš„åç§°

å…¨å±€ä½œç”¨åŸŸå†…çš„å‡½æ•°ã€å˜é‡å’Œç±»å‹çš„åç§°ï¼Œå¦‚`sin`ã€`ARGS`å’Œ`UnitRange`å§‹ç»ˆå±äºä¸€ä¸ªæ¨¡å—ï¼Œç§°ä¸º*æ¯æ¨¡å—*ï¼Œä¾‹å¦‚ï¼Œå¯ä»¥ä¸[`parentmodule`](@ref)äº¤äº’æ¥æ‰¾åˆ°è¯¥æ¨¡å—

```jldoctest
julia> parentmodule(UnitRange)
Base
```

ä¹Ÿå¯ä»¥é€šè¿‡åœ¨å®ƒä»¬çš„æ¨¡å—å‰é¢åŠ ä¸Šå‰ç¼€æ¥å¼•ç”¨å®ƒä»¬çš„çˆ¶æ¨¡å—ä¹‹å¤–çš„è¿™äº›åç§°ï¼Œä¾‹å¦‚`Base.UnitRange`ã€‚ è¿™ç§°ä¸º*é™å®šåç§°*ã€‚ çˆ¶æ¨¡å—å¯ä»¥ä½¿ç”¨åƒ`Base.Math.sin`è¿™æ ·çš„å­æ¨¡å—é“¾æ¥è®¿é—®ï¼Œå…¶ä¸­`Base.Math`è¢«ç§°ä¸º*æ¨¡å—è·¯å¾„*ã€‚ ç”±äºå¥æ³•æ­§ä¹‰ï¼Œé™å®šåªåŒ…å«ç¬¦å·çš„åç§°ï¼Œä¾‹å¦‚è¿ç®—ç¬¦ï¼Œéœ€è¦æ’å…¥å†’å·ï¼Œä¾‹å¦‚ `Base.:+`ã€‚ å°‘æ•°è¿ç®—ç¬¦è¿˜éœ€è¦æ‹¬å·ï¼Œä¾‹å¦‚ `Base.:(==)`ã€‚

å¦‚æœä¸€ä¸ªåç§°æ˜¯é™å®šçš„ï¼Œé‚£ä¹ˆå®ƒæ€»æ˜¯*å¯è®¿é—®çš„*ï¼Œåœ¨å‡½æ•°çš„æƒ…å†µä¸‹ï¼Œå®ƒä¹Ÿå¯ä»¥é€šè¿‡ä½¿ç”¨é™å®šçš„åç§°ä½œä¸ºå‡½æ•°åç§°æ¥æ·»åŠ æ–¹æ³•ã€‚

åœ¨ä¸€ä¸ªæ¨¡å—ä¸­ï¼Œä¸€ä¸ªå˜é‡åå¯ä»¥é€šè¿‡å°†å…¶å£°æ˜ `global x` ä¸èµ‹å€¼è€Œâ€œä¿ç•™â€ã€‚ è¿™å¯ä»¥é˜²æ­¢åœ¨åŠ è½½æ—¶é—´ååˆå§‹åŒ–çš„å…¨å±€å˜é‡çš„åç§°å†²çªã€‚ è¯­æ³•`M.x = y` ä¸é€‚ç”¨äºåœ¨å¦ä¸€ä¸ªæ¨¡å—ä¸­åˆ†é…ä¸€ä¸ªå…¨å±€å˜é‡ï¼› å…¨å±€åˆ†é…éœ€è¦åœ¨æ¨¡å—æœ¬åœ°è¿›è¡Œæ“ä½œã€‚

### å¯¼å‡ºåˆ—è¡¨

åç§°ï¼ˆæŒ‡å‡½æ•°ã€ç±»å‹ã€å…¨å±€å˜é‡å’Œå¸¸é‡ï¼‰å¯ä»¥é€šè¿‡ `export` æ·»åŠ åˆ°æ¨¡å—çš„ *å¯¼å‡ºåˆ—è¡¨*ï¼š
è¿™äº›æ˜¯ `using` æ¨¡å—æ—¶å¯¼å…¥çš„ç¬¦å·ã€‚
é€šå¸¸ï¼Œå®ƒä»¬ä½äºæˆ–é è¿‘æ¨¡å—å®šä¹‰çš„é¡¶éƒ¨ï¼Œä»¥ä¾¿æºä»£ç çš„è¯»è€…å¯ä»¥è½»æ¾æ‰¾åˆ°å®ƒä»¬ï¼Œå¦‚ï¼š
```jldoctest module_manual
julia> module NiceStuff
       export nice, DOG
       struct Dog end      # singleton type, not exported
       const DOG = Dog()   # named instance, exported
       nice(x) = "nice $x" # function, exported
       end;

```

ä½†è¿™åªæ˜¯ä¸€ä¸ªé£æ ¼å»ºè®®â€”â€”ä¸€ä¸ªæ¨¡å—å¯ä»¥åœ¨ä»»æ„ä½ç½®æœ‰å¤šä¸ª `export` è¯­å¥ã€‚

å¯¼å‡ºæ„æˆ APIï¼ˆåº”ç”¨ç¨‹åºæ¥å£ï¼‰ä¸€éƒ¨åˆ†çš„åç§°æ˜¯å¾ˆå¸¸è§çš„ã€‚ åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œå¯¼å‡ºåˆ—è¡¨å»ºè®®ç”¨æˆ·åº”è¯¥ä½¿ç”¨`nice`å’Œ`DOG`ã€‚ ç„¶è€Œï¼Œç”±äºé™å®šåç§°æ€»æ˜¯ä½¿æ ‡è¯†ç¬¦å¯è®¿é—®ï¼Œè¿™åªæ˜¯ç»„ç»‡ API çš„ä¸€ä¸ªé€‰é¡¹ï¼šä¸å…¶ä»–è¯­è¨€ä¸åŒï¼ŒJulia æ²¡æœ‰çœŸæ­£éšè—æ¨¡å—å†…éƒ¨çš„åŠŸèƒ½ã€‚

æ­¤å¤–ï¼ŒæŸäº›æ¨¡å—æ ¹æœ¬ä¸å¯¼å‡ºåç§°ã€‚ è¿™é€šå¸¸æ˜¯å› ä¸ºä»–ä»¬çš„ API ä¸­ä½¿ç”¨å¸¸ç”¨è¯ï¼ˆä¾‹å¦‚`derivative`ï¼‰ï¼Œè¿™å¾ˆå®¹æ˜“ä¸å…¶ä»–æ¨¡å—çš„å¯¼å‡ºåˆ—è¡¨å‘ç”Ÿå†²çªã€‚ æˆ‘ä»¬å°†åœ¨ä¸‹é¢çœ‹åˆ°å¦‚ä½•ç®¡ç†åç§°å†²çªã€‚

### å•ç‹¬ä½¿ç”¨`using`å’Œ`import`

åŠ è½½æ¨¡å—æœ€å¸¸è§çš„æ–¹å¼å¯èƒ½æ˜¯`using ModuleName`ã€‚ è¿™ [åŠ è½½](@ref code-loading) ä¸ `ModuleName` å…³è”çš„ä»£ç ï¼Œå¹¶å¼•å…¥

1. æ¨¡å—åç§°

2. å’Œå¯¼å‡ºåˆ—è¡¨çš„å…ƒç´ åˆ°å‘¨å›´çš„å…¨å±€å‘½åç©ºé—´ä¸­ã€‚

ä¸¥æ ¼æ¥è¯´ï¼Œå£°æ˜ `using ModuleName` æ„å‘³ç€ä¸€ä¸ªåä¸º `ModuleName` çš„æ¨¡å—å¯ç”¨äºæ ¹æ®éœ€è¦è§£æåç§°ã€‚ å½“é‡åˆ°å½“å‰æ¨¡å—ä¸­æ²¡æœ‰å®šä¹‰çš„å…¨å±€å˜é‡æ—¶ï¼Œç³»ç»Ÿä¼šåœ¨`ModuleName`å¯¼å‡ºçš„å˜é‡ä¸­æŸ¥æ‰¾ï¼Œæ‰¾åˆ°å°±ä½¿ç”¨ã€‚ è¿™æ„å‘³ç€å½“å‰æ¨¡å—ä¸­è¯¥å…¨å±€å˜é‡çš„æ‰€æœ‰ä½¿ç”¨éƒ½å°†è§£æä¸º`ModuleName`ä¸­è¯¥å˜é‡çš„å®šä¹‰ã€‚

To load a module from a package, the statement `using ModuleName` can be used.
To load a module from a locally defined module, a dot needs to be added before the module name like `using .ModuleName`.

ç»§ç»­æˆ‘ä»¬çš„ä¾‹å­ï¼Œ

```jldoctest module_manual
julia> using .NiceStuff
```

å°†åŠ è½½ä¸Šé¢çš„ä»£ç ï¼Œä½¿ `NiceStuff`ï¼ˆæ¨¡å—åç§°ï¼‰ã€`DOG` å’Œ `nice` å¯ç”¨ã€‚ `Dog` ä¸åœ¨å¯¼å‡ºåˆ—è¡¨ä¸­ï¼Œä½†å¦‚æœåç§°è¢«æ¨¡å—è·¯å¾„ï¼ˆè¿™é‡Œåªæ˜¯æ¨¡å—åç§°ï¼‰é™å®šä¸º `NiceStuff.Dog`ï¼Œåˆ™å¯ä»¥è®¿é—®å®ƒã€‚

é‡è¦çš„æ˜¯ï¼Œ**å¯¼å‡ºåˆ—è¡¨åªåœ¨`using ModuleName` çš„å½¢å¼ä¸‹èµ·ä½œç”¨**ã€‚

ç›¸åï¼Œ

```jldoctest module_manual
julia> import .NiceStuff
```

*ä»…*å°†æ¨¡å—åç§°å¸¦å…¥ä½œç”¨åŸŸã€‚ ç”¨æˆ·éœ€è¦ä½¿ç”¨ `NiceStuff.DOG`ã€`NiceStuff.Dog` å’Œ `NiceStuff.nice` æ¥è®¿é—®å…¶å†…å®¹ã€‚
é€šå¸¸ï¼Œå½“ç”¨æˆ·æƒ³è¦ä¿æŒå‘½åç©ºé—´å¹²å‡€æ—¶ï¼Œåœ¨ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ `import ModuleName`ã€‚
æ­£å¦‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚ä¸­çœ‹åˆ°çš„ï¼Œ`import .NiceStuff` ç­‰åŒäº `using .NiceStuff: NiceStuff`ã€‚

ä½ å¯ä»¥ç”¨é€—å·åˆ†éš”ç¬¦æ¥ç»„åˆç›¸åŒç±»å‹çš„å¤šä¸ª`using`å’Œ`import`è¯­å¥ï¼Œä¾‹å¦‚ï¼š

```jldoctest module_manual
julia> using LinearAlgebra, Statistics
```

### å…·æœ‰ç‰¹å®šæ ‡è¯†ç¬¦çš„`using` å’Œ `import` ï¼Œå¹¶æ·»åŠ æ–¹æ³•

å½“ `using ModuleName:` æˆ– `import ModuleName:` åè·Ÿä»¥é€—å·åˆ†éš”çš„åç§°åˆ—è¡¨æ—¶ï¼Œæ¨¡å—ä¼šè¢«åŠ è½½ï¼Œä½† *åªæœ‰é‚£äº›ç‰¹å®šçš„åç§°æ‰ä¼šè¢«è¯­å¥å¸¦å…¥å‘½åç©ºé—´*ã€‚ ä¾‹å¦‚ï¼Œ

```jldoctest module_manual
julia> using .NiceStuff: nice, DOG
```

å°†å¯¼å…¥åç§°`nice`å’Œ`DOG`ã€‚

é‡è¦çš„æ˜¯ï¼Œæ¨¡å—åç§° `NiceStuff` *ä¸ä¼š*å‡ºç°åœ¨å‘½åç©ºé—´ä¸­ã€‚
å¦‚æœè¦ä½¿å…¶å¯è®¿é—®ï¼Œåˆ™å¿…é¡»æ˜ç¡®åˆ—å‡ºå®ƒï¼Œå¦‚ï¼š
```jldoctest module_manual
julia> using .NiceStuff: nice, DOG, NiceStuff
```

Juliaæœ‰ä¸¤ç§å½¢å¼æ¥è¡¨ç¤ºä¼¼ä¹ç›¸åŒçš„å†…å®¹ï¼Œå› ä¸ºåªæœ‰ `import ModuleName:f` å…è®¸åœ¨ *æ²¡æœ‰æ¨¡å—è·¯å¾„*çš„æƒ…å†µä¸‹å‘ `f` æ·»åŠ æ–¹æ³•ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä»¥ä¸‹ç¤ºä¾‹å°†ç»™å‡ºä¸€ä¸ªé”™è¯¯ï¼š

```jldoctest module_manual
julia> using .NiceStuff: nice

julia> struct Cat end

julia> nice(::Cat) = "nice ğŸ˜¸"
ERROR: invalid method definition in Main: function NiceStuff.nice must be explicitly imported to be extended
Stacktrace:
 [1] top-level scope
   @ none:0
 [2] top-level scope
   @ none:1

```

æ­¤é”™è¯¯å¯é˜²æ­¢æ„å¤–å°†æ–¹æ³•æ·»åŠ åˆ°ä½ ä»…æ‰“ç®—ä½¿ç”¨çš„å…¶ä»–æ¨¡å—ä¸­çš„å‡½æ•°ã€‚

æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ ä½ å§‹ç»ˆå¯ä»¥ä½¿ç”¨æ¨¡å—è·¯å¾„é™å®šå‡½æ•°åç§°ï¼š
```jldoctest module_manual
julia> using .NiceStuff

julia> struct Cat end

julia> NiceStuff.nice(::Cat) = "nice ğŸ˜¸"

```

æˆ–è€…ï¼Œä½ å¯ä»¥`import`ç‰¹å®šçš„å‡½æ•°åç§°ï¼š
```jldoctest module_manual
julia> import .NiceStuff: nice

julia> struct Cat end

julia> nice(::Cat) = "nice ğŸ˜¸"
nice (generic function with 2 methods)
```

ä½ é€‰æ‹©å“ªä¸€ä¸ªå–å†³äºä½ çš„ä»£ç é£æ ¼ã€‚ç¬¬ä¸€ç§å½¢å¼è¡¨æ˜ä½ æ­£åœ¨å‘å¦ä¸€ä¸ªæ¨¡å—ä¸­çš„å‡½æ•°æ·»åŠ ä¸€ä¸ªæ–¹æ³•ï¼ˆè¯·è®°ä½ï¼Œå¯¼å…¥å’Œæ–¹æ³•å®šä¹‰å¯èƒ½åœ¨å•ç‹¬çš„æ–‡ä»¶ä¸­ï¼‰ï¼Œè€Œç¬¬äºŒç§å½¢å¼è¾ƒçŸ­ï¼Œå¦‚æœä½ å®šä¹‰äº†å¤šä¸ªæ–¹æ³•ï¼Œè¿™ä¸€ç‚¹å°¤å…¶æ–¹ä¾¿ã€‚

ä¸€æ—¦ä¸€ä¸ªå˜é‡é€šè¿‡ `using` æˆ– `import` å¼•å…¥ï¼Œå½“å‰æ¨¡å—å°±ä¸èƒ½åˆ›å»ºåŒåçš„å˜é‡äº†ã€‚è€Œä¸”å¯¼å…¥çš„å˜é‡æ˜¯åªè¯»çš„ï¼Œç»™å…¨å±€å˜é‡èµ‹å€¼åªèƒ½å½±å“åˆ°ç”±å½“å‰æ¨¡å—æ‹¥æœ‰çš„å˜é‡ï¼Œå¦åˆ™ä¼šæŠ¥é”™ã€‚

### ç”¨`as`æ¥é‡å‘½å

ç”±`import` æˆ–`using` å¼•å…¥ä½œç”¨åŸŸçš„æ ‡è¯†ç¬¦å¯ä»¥ç”¨å…³é”®å­—`as` é‡å‘½åã€‚ è¿™å¯¹äºè§£å†³åç§°å†²çªä»¥åŠç¼©çŸ­åç§°å¾ˆæœ‰ç”¨ã€‚ ä¾‹å¦‚ï¼Œ`Base` å¯¼å‡ºå‡½æ•°å`read`ï¼Œä½†CSV.jl åŒ…ä¹Ÿæä¾›äº†`CSV.read`ã€‚ å¦‚æœæˆ‘ä»¬è¦å¤šæ¬¡è°ƒç”¨ CSV è¯»å–ï¼Œåˆ é™¤ `CSV.` é™å®šç¬¦ä¼šå¾ˆæ–¹ä¾¿ã€‚ ä½†æ˜¯ï¼Œæˆ‘ä»¬æŒ‡çš„æ˜¯`Base.read`è¿˜æ˜¯`CSV.read`æ˜¯æ¨¡æ£±ä¸¤å¯çš„ï¼š

```julia-repl
julia> read;

julia> import CSV: read
WARNING: ignoring conflicting import of CSV.read into Main
```

é‡å‘½åæä¾›äº†ä¸€ä¸ªè§£å†³æ–¹æ¡ˆï¼š

```julia-repl
julia> import CSV: read as rd
```

å¯¼å…¥çš„åŒ…æœ¬èº«ä¹Ÿå¯ä»¥é‡å‘½åï¼š

```julia
import BenchmarkTools as BT
```

`as` ä»…åœ¨å°†å•ä¸ªæ ‡è¯†ç¬¦å¼•å…¥ä½œç”¨åŸŸæ—¶æ‰ä¸ `using` ä¸€èµ·ä½¿ç”¨ã€‚ ä¾‹å¦‚ï¼Œ`using CSV: read as rd` æœ‰æ•ˆï¼Œä½†`using CSV as C` æ— æ•ˆï¼Œå› ä¸ºå®ƒå¯¹ `CSV` ä¸­çš„æ‰€æœ‰å¯¼å‡ºåç§°è¿›è¡Œæ“ä½œã€‚

### æ··åˆä½¿ç”¨å¤šä¸ª `using` å’Œ `import` è¯­å¥

å½“ä½¿ç”¨ä¸Šè¿°ä»»ä½•å½¢å¼çš„å¤šä¸ª `using` æˆ– `import` è¯­å¥æ—¶ï¼Œå®ƒä»¬çš„æ•ˆæœå°†æŒ‰ç…§å®ƒä»¬å‡ºç°çš„é¡ºåºç»„åˆã€‚ ä¾‹å¦‚ï¼Œ

```jldoctest module_manual
julia> using .NiceStuff         # exported names and the module name

julia> import .NiceStuff: nice  # allows adding methods to unqualified functions

```

ä¼šå°† `NiceStuff` çš„æ‰€æœ‰å¯¼å‡ºåç§°å’Œæ¨¡å—åç§°æœ¬èº«å¸¦å…¥ä½œç”¨åŸŸï¼Œå¹¶ä¸”è¿˜å…è®¸å‘ `nice` æ·»åŠ æ–¹æ³•è€Œä¸ç”¨æ¨¡å—åç§°ä½œä¸ºå‰ç¼€ã€‚

### å¤„ç†åç§°å†²çª

è€ƒè™‘ä¸¤ä¸ªï¼ˆæˆ–æ›´å¤šï¼‰åŒ…å¯¼å‡ºç›¸åŒåç§°çš„æƒ…å†µï¼Œå¦‚

```jldoctest module_manual
julia> module A
       export f
       f() = 1
       end
A
julia> module B
       export f
       f() = 2
       end
B
```

`using .A, .B` è¯­å¥æœ‰æ•ˆï¼Œä½†æ˜¯å½“ä½ å°è¯•è°ƒç”¨ `f` æ—¶ï¼Œä½ ä¼šæ”¶åˆ°è­¦å‘Š

```jldoctest module_manual
julia> using .A, .B

julia> f
WARNING: both B and A export "f"; uses of it in module Main must be qualified
ERROR: UndefVarError: `f` not defined
```

åœ¨è¿™é‡Œï¼ŒJulia æ— æ³•ç¡®å®šæ‚¨æŒ‡çš„æ˜¯å“ªä¸ª `f`ï¼Œå› æ­¤ä½ å¿…é¡»åšå‡ºé€‰æ‹©ã€‚ å¸¸ç”¨çš„è§£å†³æ–¹æ³•æœ‰ä»¥ä¸‹å‡ ç§ï¼š

1. åªéœ€ç»§ç»­ä½¿ç”¨é™å®šåç§°ï¼Œå¦‚`A.f` å’Œ`B.f`ã€‚ è¿™ä½¿ä»£ç çš„è¯»è€…å¯ä»¥æ¸…æ¥šåœ°äº†è§£ä¸Šä¸‹æ–‡ï¼Œç‰¹åˆ«æ˜¯å¦‚æœ `f` æ°å¥½é‡åˆä½†åœ¨ä¸åŒçš„åŒ…ä¸­å…·æœ‰ä¸åŒçš„å«ä¹‰ã€‚ ä¾‹å¦‚ï¼Œ`degree`åœ¨æ•°å­¦ã€è‡ªç„¶ç§‘å­¦å’Œæ—¥å¸¸ç”Ÿæ´»ä¸­æœ‰å¤šç§ç”¨é€”ï¼Œè¿™äº›å«ä¹‰åº”è¯¥åˆ†å¼€ã€‚

2. ä½¿ç”¨ä¸Šé¢çš„ `as` å…³é”®å­—é‡å‘½åä¸€ä¸ªæˆ–ä¸¤ä¸ªæ ‡è¯†ç¬¦ï¼Œä¾‹å¦‚

   ```jldoctest module_manual
   julia> using .A: f as f

   julia> using .B: f as g

   ```

   ä¼šä½¿`B.f` å¯ç”¨ä½œ`g`ã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å‡è®¾æ‚¨ä¹‹å‰æ²¡æœ‰ä½¿ç”¨ `using A`ï¼Œ
   è¿™ä¼šæŠŠ`f`ä»£å…¥å‘½åç©ºé—´ã€‚

3. å½“é—®é¢˜ä¸­çš„å¤šä¸ªåç§°*ç¡®å®*æœ‰ç›¸åŒçš„å«ä¹‰æ—¶ï¼Œé€šå¸¸ä¸€ä¸ªæ¨¡å—ä¼šä»å¦ä¸€ä¸ªæ¨¡å—å¯¼å…¥å®ƒï¼Œæˆ–è€…æœ‰ä¸€ä¸ªè½»é‡çº§çš„â€œåŸºç¡€â€åŒ…ï¼Œå®ƒçš„å”¯ä¸€åŠŸèƒ½æ˜¯å®šä¹‰è¿™æ ·çš„æ¥å£ï¼Œå¯ä»¥è¢«å…¶ä»–åŒ…ä½¿ç”¨ã€‚æŒ‰ç…§æƒ¯ä¾‹ï¼Œè¿™äº›åŒ…åä»¥ `...Base` ç»“å°¾ï¼ˆè¿™ä¸ Julia çš„ `Base` æ¨¡å—æ— å…³ï¼‰

### é»˜è®¤é¡¶å±‚å®šä¹‰ä»¥åŠè£¸æ¨¡å—

æ¨¡å—è‡ªåŠ¨åŒ…å« `using Core`ã€`using Base` ä»¥åŠ [`eval`](@ref) å’Œ [`include`](@ref) å‡½æ•°çš„å®šä¹‰ï¼Œè¿™äº›å‡½æ•°åœ¨è¯¥æ¨¡å—çš„å…¨å±€ä½œç”¨åŸŸå†…è®¡ç®—è¡¨è¾¾å¼/æ–‡ä»¶ .

å¦‚æœä¸éœ€è¦è¿™äº›é»˜è®¤å®šä¹‰ï¼Œå¯ä»¥ä½¿ç”¨å…³é”®å­— [`baremodule`](@ref) æ¥å®šä¹‰æ¨¡å—ï¼ˆæ³¨æ„ï¼š`Core` ä»ç„¶æ˜¯å¯¼å…¥çš„ï¼‰ã€‚ å°± `baremodule` è€Œè¨€ï¼Œä¸€ä¸ªæ ‡å‡†çš„ `module` çœ‹èµ·æ¥åƒè¿™æ ·ï¼š

```
baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
include(p) = Base.include(Mod, p)

...

end
```

If even `Core` is not wanted, a module that imports nothing and defines no names at all can be defined with `Module(:YourNameHere, false, false)` and code can be evaluated into it with [`@eval`](@ref) or [`Core.eval`](@ref):
```jldoctest
julia> arithmetic = Module(:arithmetic, false, false)
Main.arithmetic

julia> @eval arithmetic add(x, y) = $(+)(x, y)
add (generic function with 1 method)

julia> arithmetic.add(12, 13)
25
```

### æ ‡å‡†æ¨¡å—

æœ‰ä¸‰ä¸ªé‡è¦çš„æ ‡å‡†æ¨¡å—ï¼š
* [`Core`](@ref) åŒ…å«äº†è¯­è¨€â€œå†…ç½®â€çš„æ‰€æœ‰åŠŸèƒ½ã€‚
* [`Base`](@ref) åŒ…å«äº†ç»å¤§å¤šæ•°æƒ…å†µä¸‹éƒ½ä¼šç”¨åˆ°çš„åŸºæœ¬åŠŸèƒ½ã€‚
* [`Main`](@ref) æ˜¯é¡¶å±‚æ¨¡å—ï¼Œå½“ julia å¯åŠ¨æ—¶ï¼Œä¹Ÿæ˜¯å½“å‰æ¨¡å—ã€‚

!!! note "Standard library modules"
    é»˜è®¤æƒ…å†µä¸‹ï¼ŒJulia é™„å¸¦äº†ä¸€äº›æ ‡å‡†åº“æ¨¡å—ã€‚ é™¤äº†ä½ ä¸éœ€è¦æ˜¾å¼å®‰è£…å®ƒä»¬ä¹‹å¤–ï¼Œå®ƒä»¬çš„è¡Œä¸ºä¸å¸¸è§„ Julia åŒ…ç±»ä¼¼ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨æƒ³æ‰§è¡Œä¸€äº›å•å…ƒæµ‹è¯•ï¼Œä½ å¯ä»¥æŒ‰å¦‚ä¸‹æ–¹å¼åŠ è½½ `Test` æ ‡å‡†åº“ï¼š
    ```julia
    using Test
    ```

## å­æ¨¡å—å’Œç›¸å¯¹è·¯å¾„

æ¨¡å—å¯ä»¥åŒ…å« *å­æ¨¡å—*ï¼ŒåµŒå¥—ç›¸åŒçš„è¯­æ³•`module ... end`ã€‚ å®ƒä»¬å¯ç”¨äºå¼•å…¥å•ç‹¬çš„å‘½åç©ºé—´ï¼Œè¿™æœ‰åŠ©äºç»„ç»‡å¤æ‚çš„ä»£ç åº“ã€‚ è¯·æ³¨æ„ï¼Œæ¯ä¸ª `module` éƒ½å¼•å…¥äº†è‡ªå·±çš„ [ä½œç”¨åŸŸ](@ref scope-of-variables)ï¼Œå› æ­¤å­æ¨¡å—ä¸ä¼šè‡ªåŠ¨ä»å…¶çˆ¶æ¨¡å—â€œç»§æ‰¿â€åç§°ã€‚

å»ºè®®å­æ¨¡å—åœ¨ `using` å’Œ `import` è¯­å¥ä¸­ä½¿ç”¨ *ç›¸å¯¹æ¨¡å—é™å®šç¬¦* æ¥å¼•ç”¨å°é—­çˆ¶æ¨¡å—ä¸­çš„å…¶ä»–æ¨¡å—ï¼ˆåŒ…æ‹¬åè€…ï¼‰ã€‚ ç›¸å¯¹æ¨¡å—é™å®šç¬¦ä»¥å¥ç‚¹ (`.`) å¼€å¤´ï¼Œå®ƒå¯¹åº”äºå½“å‰æ¨¡å—ï¼Œæ¯ä¸ªè¿ç»­çš„ `.` éƒ½æŒ‡å‘å½“å‰æ¨¡å—çš„çˆ¶çº§ã€‚ å¦‚æœ‰å¿…è¦ï¼Œè¿™åº”è¯¥è·Ÿåœ¨æ¨¡å—ä¹‹åï¼Œæœ€åæ˜¯è¦è®¿é—®çš„å®é™…åç§°ï¼Œæ‰€æœ‰åç§°éƒ½ä»¥`.`åˆ†éš”ã€‚

è€ƒè™‘ä»¥ä¸‹ç¤ºä¾‹ï¼Œå…¶ä¸­å­æ¨¡å—`SubA`å®šä¹‰äº†ä¸€ä¸ªå‡½æ•°ï¼Œç„¶ååœ¨å…¶â€œå…„å¼Ÿâ€æ¨¡å—ä¸­è¿›è¡Œæ‰©å±•ï¼š

```jldoctest module_manual
julia> module ParentModule
       module SubA
       export add_D  # exported interface
       const D = 3
       add_D(x) = x + D
       end
       using .SubA  # brings `add_D` into the namespace
       export add_D # export it from ParentModule too
       module SubB
       import ..SubA: add_D # relative path for a â€œsiblingâ€ module
       struct Infinity end
       add_D(x::Infinity) = x
       end
       end;

```

ä½ å¯èƒ½ä¼šåœ¨åŒ…ä¸­çœ‹åˆ°ä»£ç ï¼Œåœ¨ç±»ä¼¼çš„æƒ…å†µä¸‹ï¼Œå®ƒä½¿ç”¨
```jldoctest module_manual
julia> import .ParentModule.SubA: add_D

```
ç„¶è€Œï¼Œè¿™æ˜¯é€šè¿‡ [ä»£ç åŠ è½½](@ref code-loading) æ“ä½œçš„ï¼Œå› æ­¤ä»…å½“ `ParentModule` åœ¨åŒ…ä¸­æ—¶æ‰æœ‰æ•ˆã€‚ æœ€å¥½ä½¿ç”¨ç›¸å¯¹è·¯å¾„ã€‚

è¯·æ³¨æ„ï¼Œå¦‚æœä½ æ­£åœ¨è¯„ä¼°å€¼ï¼Œå®šä¹‰çš„é¡ºåºä¹Ÿå¾ˆé‡è¦ã€‚ è€ƒè™‘

```julia
module TestPackage

export x, y

x = 0

module Sub
using ..TestPackage
z = y # ERROR: UndefVarError: `y` not defined
end

y = 1

end
```

å…¶ä¸­ `Sub` åœ¨å®šä¹‰ä¹‹å‰å°è¯•ä½¿ç”¨ `TestPackage.y`ï¼Œå› æ­¤å®ƒæ²¡æœ‰å€¼ã€‚

å‡ºäºç±»ä¼¼çš„åŸå› ï¼Œä½ ä¸èƒ½ä½¿ç”¨å¾ªç¯é¡ºåºï¼š

```julia
module A

module B
using ..C # ERROR: UndefVarError: `C` not defined
end

module C
using ..B
end

end
```

## æ¨¡å—åˆå§‹åŒ–å’Œé¢„ç¼–è¯‘

å› ä¸ºæ‰§è¡Œæ¨¡å—ä¸­çš„æ‰€æœ‰è¯­å¥é€šå¸¸éœ€è¦ç¼–è¯‘å¤§é‡ä»£ç ï¼Œå¤§å‹æ¨¡å—å¯èƒ½éœ€è¦å‡ ç§’é’Ÿæ‰èƒ½åŠ è½½ã€‚Julia ä¼šåˆ›å»ºæ¨¡å—çš„é¢„ç¼–è¯‘ç¼“å­˜ä»¥å‡å°‘è¿™ä¸ªæ—¶é—´ã€‚

Precompiled module files (sometimes called "cache files") are created and used automatically when `import` or `using` loads a module.  If the cache file(s) do not yet exist, the module will be compiled and saved for future reuse. You can also manually call [`Base.compilecache(Base.identify_package("modulename"))`](@ref) to create these files without loading the module. The resulting
cache files will be stored in the `compiled` subfolder of `DEPOT_PATH[1]`. If nothing about your system changes,
such cache files will be used when you load the module with `import` or `using`.

Precompilation cache files store definitions of modules, types, methods, and constants. They may also store method specializations and the code generated for them, but this typically requires that the developer add explicit [`precompile`](@ref) directives or execute workloads that force compilation during the package build.

However, if you update the module's dependencies or change its source code, the module is automatically
recompiled upon `using` or `import`. Dependencies are modules it
imports, the Julia build, files it includes, or explicit dependencies declared by [`include_dependency(path)`](@ref)
in the module file(s).

For file dependencies, a change is determined by examining whether the modification time (`mtime`)
of each file loaded by `include` or added explicitly by `include_dependency` is unchanged, or equal
to the modification time truncated to the nearest second (to accommodate systems that can't copy
mtime with sub-second accuracy). It also takes into account whether the path to the file chosen
by the search logic in `require` matches the path that had created the precompile file. It also takes
into account the set of dependencies already loaded into the current process and won't recompile those
modules, even if their files change or disappear, in order to avoid creating incompatibilities between
the running system and the precompile cache.
Finally, it takes account of changes in any [compile-time preferences](@ref preferences).

If you know that a module is *not* safe to precompile
(for example, for one of the reasons described below), you should
put `__precompile__(false)` in the module file (typically placed at the top).
This will cause `Base.compilecache` to throw an error, and will cause `using` / `import` to load it
directly into the current process and skip the precompile and caching.
This also thereby prevents the module from being imported by any other precompiled module.

åœ¨å¼€å‘æ¨¡å—çš„æ—¶å€™ï¼Œä½ å¯èƒ½éœ€è¦äº†è§£ä¸€äº›ä¸å¢é‡ç¼–è¯‘ç›¸å…³çš„å›ºæœ‰è¡Œä¸ºã€‚ä¾‹å¦‚ï¼Œå¤–éƒ¨çŠ¶æ€ä¸ä¼šè¢«ä¿ç•™ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦æ˜¾å¼åˆ†ç¦»è¿è¡Œæ—¶ä¸ç¼–è¯‘æœŸçš„éƒ¨åˆ†ã€‚Julia å…è®¸ä½ å®šä¹‰ä¸€ä¸ª `__init__()` å‡½æ•°æ¥æ‰§è¡Œä»»ä½•éœ€è¦åœ¨è¿è¡Œæ—¶å‘ç”Ÿçš„åˆå§‹åŒ–ã€‚åœ¨ç¼–è¯‘æœŸï¼ˆ`--output-*`ï¼‰ï¼Œæ­¤å‡½æ•°å°†ä¸ä¼šè¢«è°ƒç”¨ã€‚ä½ å¯ä»¥å‡è®¾åœ¨ä»£ç çš„ç”Ÿå­˜å‘¨æœŸä¸­ï¼Œæ­¤å‡½æ•°åªä¼šè¢«è¿è¡Œä¸€æ¬¡ã€‚å½“ç„¶ï¼Œå¦‚æœæœ‰å¿…è¦ï¼Œä½ ä¹Ÿå¯ä»¥æ‰‹åŠ¨è°ƒç”¨å®ƒï¼Œä½†åœ¨é»˜è®¤çš„æƒ…å†µä¸‹ï¼Œè¯·å‡å®šæ­¤å‡½æ•°æ˜¯ä¸ºäº†å¤„ç†ä¸æœ¬æœºçŠ¶æ€ç›¸å…³çš„ä¿¡æ¯ï¼Œæ³¨æ„è¿™äº›ä¿¡æ¯ä¸éœ€è¦ï¼Œæ›´ä¸åº”è¯¥å­˜å…¥é¢„ç¼–è¯‘é•œåƒã€‚æ­¤å‡½æ•°ä¼šåœ¨æ¨¡å—è¢«å¯¼å…¥åˆ°å½“å‰è¿›ç¨‹ä¹‹åè¢«è°ƒç”¨ï¼Œè¿™åŒ…æ‹¬åœ¨ä¸€ä¸ªå¢é‡ç¼–è¯‘ä¸­å¯¼å…¥è¯¥æ¨¡å—çš„æ—¶å€™ï¼ˆ`--output-incremental=yes`ï¼‰ï¼Œä½†åœ¨å®Œæ•´ç¼–è¯‘æ—¶è¯¥å‡½æ•°ä¸ä¼šè¢«è°ƒç”¨ã€‚

ç‰¹åˆ«çš„ï¼Œå¦‚æœä½ åœ¨æ¨¡å—é‡Œå®šä¹‰äº†ä¸€ä¸ªåä¸º `__init__()` çš„å‡½æ•°ï¼Œé‚£ä¹ˆ Julia åœ¨åŠ è½½è¿™ä¸ªæ¨¡å—ä¹‹åä¼šåœ¨ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶ï¼ˆruntimeï¼‰ç«‹åˆ»è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡ `import`ï¼Œ`using`ï¼Œæˆ–è€… `require` åŠ è½½æ—¶ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´ `__init__` åªä¼šåœ¨æ¨¡å—ä¸­æ‰€æœ‰å…¶å®ƒå‘½ä»¤éƒ½æ‰§è¡Œå®Œä»¥åè¢«è°ƒç”¨ä¸€æ¬¡ã€‚å› ä¸ºè¿™ä¸ªå‡½æ•°å°†åœ¨æ¨¡å—å®Œå…¨è½½å…¥åè¢«è°ƒç”¨ï¼Œä»»ä½•å­æ¨¡å—æˆ–è€…å·²ç»è½½å…¥çš„æ¨¡å—éƒ½å°†åœ¨å½“å‰æ¨¡å—è°ƒç”¨ `__init__` **ä¹‹å‰** è°ƒç”¨è‡ªå·±çš„ `__init__` å‡½æ•°ã€‚

`__init__`çš„å…¸å‹ç”¨æ³•æœ‰äºŒï¼Œä¸€æ˜¯ç”¨äºè°ƒç”¨å¤–éƒ¨ C åº“çš„è¿è¡Œæ—¶åˆå§‹åŒ–å‡½æ•°ï¼ŒäºŒæ˜¯ç”¨äºåˆå§‹åŒ–æ¶‰åŠåˆ°å¤–éƒ¨åº“æ‰€è¿”å›çš„æŒ‡é’ˆçš„å…¨å±€å¸¸é‡ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æ­£åœ¨è°ƒç”¨ä¸€ä¸ª C åº“ `libfoo`ï¼Œå®ƒè¦æ±‚æˆ‘ä»¬åœ¨è¿è¡Œæ—¶è°ƒç”¨`foo_init()` è¿™ä¸ªåˆå§‹åŒ–å‡½æ•°ã€‚å‡è®¾æˆ‘ä»¬è¿˜æƒ³å®šä¹‰ä¸€ä¸ªå…¨å±€å¸¸é‡ `foo_data_ptr`ï¼Œå®ƒä¿å­˜ `libfoo` æ‰€å®šä¹‰çš„ `void *foo_data()` å‡½æ•°çš„è¿”å›å€¼â€”â€”å¿…é¡»åœ¨è¿è¡Œæ—¶ï¼ˆè€Œéç¼–è¯‘æ—¶ï¼‰åˆå§‹åŒ–è¿™ä¸ªå¸¸é‡ï¼Œå› ä¸ºæŒ‡é’ˆåœ°å€ä¸æ˜¯å›ºå®šçš„ã€‚å¯ä»¥é€šè¿‡åœ¨æ¨¡å—ä¸­å®šä¹‰ `__init__` å‡½æ•°æ¥å®Œæˆè¿™ä¸ªæ“ä½œã€‚

```julia
const foo_data_ptr = Ref{Ptr{Cvoid}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Cvoid, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())
    nothing
end
```

æ³¨æ„ï¼Œåœ¨åƒ `__init__` è¿™æ ·çš„å‡½æ•°é‡Œå®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡æ˜¯å®Œå…¨å¯ä»¥çš„ï¼Œè¿™æ˜¯åŠ¨æ€è¯­è¨€çš„ä¼˜ç‚¹ä¹‹ä¸€ã€‚ä½†æ˜¯æŠŠå…¨å±€ä½œç”¨åŸŸçš„å€¼å®šä¹‰æˆå¸¸é‡ï¼Œå¯ä»¥è®©ç¼–è¯‘å™¨èƒ½ç¡®å®šè¯¥å€¼çš„ç±»å‹ï¼Œå¹¶ä¸”èƒ½è®©ç¼–è¯‘å™¨ç”Ÿæˆæ›´å¥½çš„ä¼˜åŒ–è¿‡çš„ä»£ç ã€‚æ˜¾ç„¶ï¼Œä½ çš„æ¨¡å—ï¼ˆModuleï¼‰ä¸­ï¼Œä»»ä½•å…¶ä»–ä¾èµ–äº `foo_data_ptr` çš„å…¨å±€é‡ä¹Ÿå¿…é¡»åœ¨ `__init__` ä¸­è¢«åˆå§‹åŒ–ã€‚

æ¶‰åŠå¤§å¤šæ•°ä¸æ˜¯ç”± [`ccall`](@ref) ç”Ÿæˆçš„ Julia å¯¹è±¡çš„å¸¸é‡ä¸éœ€è¦æ”¾åœ¨ `__init__` ä¸­ï¼šå®ƒä»¬çš„å®šä¹‰å¯ä»¥ä»ç¼“å­˜çš„æ¨¡å—æ˜ åƒä¸­é¢„ç¼–è¯‘å’ŒåŠ è½½ã€‚ è¿™åŒ…æ‹¬å¤æ‚çš„å †åˆ†é…å¯¹è±¡ï¼Œå¦‚æ•°ç»„ã€‚ ä½†æ˜¯ï¼Œä»»ä½•è¿”å›åŸå§‹æŒ‡é’ˆå€¼çš„ä¾‹ç¨‹éƒ½å¿…é¡»åœ¨è¿è¡Œæ—¶è°ƒç”¨æ‰èƒ½ä½¿é¢„ç¼–è¯‘å·¥ä½œï¼ˆ[`Ptr`](@ref) å¯¹è±¡å°†å˜æˆç©ºæŒ‡é’ˆï¼Œé™¤éå®ƒä»¬éšè—åœ¨ [`isbits`](@ref) ç›®çš„ï¼‰ã€‚ è¿™åŒ…æ‹¬ Julia å‡½æ•° [`@cfunction`](@ref) å’Œ [`pointer`](@ref) çš„è¿”å›å€¼ã€‚

å­—å…¸å’Œé›†åˆç±»å‹ï¼Œæˆ–è€…é€šå¸¸ä»»ä½•ä¾èµ–äº `hash(key)` æ–¹æ³•çš„ç±»å‹ï¼Œéƒ½æ˜¯æ¯”è¾ƒæ£˜æ‰‹çš„æƒ…å†µã€‚
é€šå¸¸å½“é”®æ˜¯æ•°å­—ã€å­—ç¬¦ä¸²ã€ç¬¦å·ã€èŒƒå›´ã€`Expr` æˆ–è¿™äº›ç±»å‹çš„ç»„åˆï¼ˆé€šè¿‡æ•°ç»„ã€å…ƒç»„ã€é›†åˆã€æ˜ å°„å¯¹ç­‰ï¼‰æ—¶ï¼Œå¯ä»¥å®‰å…¨åœ°é¢„ç¼–è¯‘å®ƒä»¬ã€‚ä½†æ˜¯ï¼Œå¯¹äºä¸€äº›å…¶å®ƒçš„é”®ç±»å‹ï¼Œä¾‹å¦‚ `Function` æˆ– `DataType`ã€ä»¥åŠè¿˜æ²¡æœ‰å®šä¹‰æ•£åˆ—æ–¹æ³•çš„é€šç”¨ç”¨æˆ·å®šä¹‰ç±»å‹ï¼Œå›é€€ï¼ˆfallbackï¼‰çš„æ•£åˆ—ï¼ˆ`hash`ï¼‰æ–¹æ³•ä¾èµ–äºå¯¹è±¡çš„å†…å­˜åœ°å€ï¼ˆé€šè¿‡ `objectid`ï¼‰ï¼Œå› æ­¤å¯èƒ½ä¼šåœ¨æ¯æ¬¡è¿è¡Œæ—¶å‘ç”Ÿå˜åŒ–ã€‚
å¦‚æœæ‚¨æœ‰è¿™äº›å…³é”®ç±»å‹ä¸­çš„ä¸€ç§ï¼Œæˆ–è€…æ‚¨ä¸ç¡®å®šï¼Œä¸ºäº†å®‰å…¨èµ·è§ï¼Œæ‚¨å¯ä»¥åœ¨æ‚¨çš„ `__init__` å‡½æ•°ä¸­åˆå§‹åŒ–è¿™ä¸ªå­—å…¸ã€‚æˆ–è€…ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ [`IdDict`](@ref) å­—å…¸ç±»å‹ï¼Œå®ƒæ˜¯ç”±é¢„ç¼–è¯‘ä¸“é—¨å¤„ç†çš„ï¼Œå› æ­¤åœ¨ç¼–è¯‘æ—¶åˆå§‹åŒ–æ˜¯å®‰å…¨çš„ã€‚

å½“ä½¿ç”¨é¢„ç¼–è¯‘æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»è¦æ¸…æ¥šåœ°åŒºåˆ†ä»£ç çš„ç¼–è¯‘é˜¶æ®µå’Œè¿è¡Œé˜¶æ®µã€‚åœ¨æ­¤æ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬ä¼šæ›´æ¸…æ¥šå‘ç° Julia çš„ç¼–è¯‘å™¨å¯ä»¥æ‰§è¡Œä»»ä½• Julia ä»£ç ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç”¨äºç”Ÿæˆç¼–è¯‘åä»£ç çš„ç‹¬ç«‹çš„è§£é‡Šå™¨ã€‚

å…¶å®ƒå·²çŸ¥çš„æ½œåœ¨å¤±è´¥åœºæ™¯åŒ…æ‹¬ï¼š

1. å…¨å±€è®¡æ•°å™¨ï¼Œä¾‹å¦‚ï¼šä¸ºäº†è¯•å›¾å”¯ä¸€çš„æ ‡è¯†å¯¹è±¡ã€‚è€ƒè™‘ä»¥ä¸‹ä»£ç ç‰‡æ®µï¼š
    

   ```julia
   mutable struct UniquedById
       myid::Int
       let counter = 0
           UniquedById() = new(counter += 1)
       end
   end
   ```

   å°½ç®¡è¿™æ®µä»£ç çš„ç›®æ ‡æ˜¯ç»™æ¯ä¸ªå®ä¾‹èµ‹ä¸€ä¸ªå”¯ä¸€çš„ IDï¼Œä½†è®¡æ•°å™¨çš„å€¼ä¼šåœ¨ä»£ç ç¼–è¯‘ç»“æŸæ—¶è¢«è®°å½•ã€‚ä»»ä½•å¯¹æ­¤å¢é‡ç¼–è¯‘æ¨¡å—çš„åç»­ä½¿ç”¨ï¼Œè®¡æ•°å™¨éƒ½å°†ä»åŒä¸€ä¸ªå€¼å¼€å§‹è®¡æ•°ã€‚
    
    

   æ³¨æ„ `objectid` ï¼ˆå·¥ä½œåŸç†æ˜¯å–å†…å­˜æŒ‡é’ˆçš„ hashï¼‰ä¹Ÿæœ‰ç±»ä¼¼çš„é—®é¢˜ï¼Œè¯·æŸ¥é˜…ä¸‹é¢å…³äº `Dict` çš„ç”¨æ³•ã€‚
    

   ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯ç”¨å®æ•æ‰ [`@__MODULE__`](@ref)ï¼Œå¹¶å°†å®ƒä¸ç›®å‰çš„ `counter` å€¼ä¸€èµ·ä¿å­˜ã€‚ç„¶è€Œï¼Œæ›´å¥½çš„æ–¹æ¡ˆæ˜¯å¯¹ä»£ç è¿›è¡Œé‡æ–°è®¾è®¡ï¼Œä¸è¦ä¾èµ–è¿™ç§å…¨å±€çŠ¶æ€å˜é‡ã€‚
    
2. åƒ `Dict` å’Œ `Set` è¿™ç§å…³è”é›†åˆéœ€è¦åœ¨ `__init__` ä¸­ re-hashã€‚Julia åœ¨æœªæ¥å¾ˆå¯èƒ½ä¼šæä¾›ä¸€ä¸ªæœºåˆ¶æ¥æ³¨å†Œåˆå§‹åŒ–å‡½æ•°ã€‚
    
3. ä¾èµ–ç¼–è¯‘æœŸçš„å‰¯ä½œç”¨ä¼šåœ¨åŠ è½½æ—¶è”“å»¶ã€‚ä¾‹å­åŒ…æ‹¬ï¼šæ›´æ”¹å…¶å®ƒ Julia æ¨¡å—é‡Œçš„æ•°ç»„æˆ–å˜é‡ï¼Œæ“ä½œæ–‡ä»¶æˆ–è®¾å¤‡çš„å¥æŸ„ï¼Œä¿å­˜æŒ‡å‘å…¶å®ƒç³»ç»Ÿèµ„æºï¼ˆåŒ…æ‹¬å†…å­˜ï¼‰çš„æŒ‡é’ˆã€‚
    
    
4. æ— æ„ä¸­ä»å…¶å®ƒæ¨¡å—ä¸­â€œæ‹·è´â€äº†å…¨å±€çŠ¶æ€ï¼šé€šè¿‡ç›´æ¥å¼•ç”¨çš„æ–¹å¼è€Œä¸æ˜¯é€šè¿‡æŸ¥æ‰¾çš„æ–¹å¼ã€‚ä¾‹å¦‚ï¼Œåœ¨å…¨å±€ä½œç”¨åŸŸä¸‹ï¼š
    

   ```julia
   #mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#
   # instead use accessor functions:
   getstdout() = Base.stdout #= best option =#
   # or move the assignment into the runtime:
   __init__() = global mystdout = Base.stdout #= also works =#
   ```

æ­¤å¤„ä¸ºé¢„ç¼–è¯‘ä¸­çš„æ“ä½œé™„åŠ äº†è‹¥å¹²é™åˆ¶ï¼Œä»¥å¸®åŠ©ç”¨æˆ·é¿å…å…¶ä»–è¯¯æ“ä½œï¼š

1. è°ƒç”¨ [`eval`](@ref) æ¥åœ¨å¦ä¸€ä¸ªæ¨¡å—ä¸­å¼•å‘å‰¯ä½œç”¨ã€‚å½“å¢é‡é¢„ç¼–è¯‘è¢«æ ‡è®°æ—¶ï¼Œè¯¥æ“ä½œåŒæ—¶ä¼šå¯¼è‡´æŠ›å‡ºä¸€ä¸ªè­¦å‘Šã€‚
    
2. å½“ `__init__()` å·²ç»å¼€å§‹æ‰§è¡Œåï¼Œåœ¨å±€éƒ¨ä½œç”¨åŸŸä¸­å£°æ˜ `global const`ï¼ˆè§ issue #12010ï¼Œè®¡åˆ’ä¸ºæ­¤æƒ…å†µæ·»åŠ ä¸€ä¸ªé”™è¯¯æç¤ºï¼‰
    
3. åœ¨å¢é‡é¢„ç¼–è¯‘æ—¶æ›¿æ¢æ¨¡å—æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚

ä¸€äº›å…¶ä»–éœ€è¦æ³¨æ„çš„ç‚¹ï¼š

1. åœ¨æºä»£ç æ–‡ä»¶æœ¬èº«è¢«ä¿®æ”¹ä¹‹åï¼Œä¸ä¼šæ‰§è¡Œä»£ç é‡è½½æˆ–ç¼“å­˜å¤±æ•ˆåŒ–å¤„ç†ï¼ˆåŒ…æ‹¬ç”± `Pkg.update` æ‰§è¡Œçš„ä¿®æ”¹ï¼Œæ­¤å¤–åœ¨ `Pkg.rm` æ‰§è¡Œåä¹Ÿæ²¡æœ‰æ¸…ç†æ“ä½œï¼‰
    
2. å˜å½¢æ•°ç»„çš„å†…å­˜å…±äº«ç‰¹æ€§ä¼šè¢«é¢„ç¼–è¯‘å¿½ç•¥ï¼ˆæ¯ä¸ªæ•°ç»„æ ·è²Œéƒ½ä¼šè·å¾—ä¸€ä¸ªæ‹·è´ï¼‰
    
3. æ–‡ä»¶ç³»ç»Ÿåœ¨ç¼–è¯‘æœŸé—´å’Œè¿è¡ŒæœŸé—´è¢«å‡è®¾ä¸ºä¸å˜çš„ï¼Œæ¯”å¦‚ä½¿ç”¨ [`@__FILE__`](@ref)/`source_path()` åœ¨è¿è¡ŒæœŸé—´å¯»æ‰¾èµ„æºã€æˆ–ä½¿ç”¨ BinDeps å® `@checked_lib`ã€‚æœ‰æ—¶è¿™æ˜¯ä¸å¯é¿å…çš„ã€‚ä½†æ˜¯å¯èƒ½çš„è¯ï¼Œåœ¨ç¼–è¯‘æœŸå°†èµ„æºå¤åˆ¶åˆ°æ¨¡å—é‡Œé¢æ˜¯ä¸ªå¥½åšæ³•ï¼Œè¿™æ ·åœ¨è¿è¡ŒæœŸé—´ï¼Œå°±ä¸éœ€è¦å»å¯»æ‰¾å®ƒä»¬äº†ã€‚
    
    
    
4. `WeakRef` å¯¹è±¡å’Œå®Œæˆå™¨ç›®å‰åœ¨åºåˆ—åŒ–å™¨ä¸­æ— æ³•è¢«æ°å½“åœ°å¤„ç†ï¼ˆåœ¨æ¥ä¸‹æ¥çš„å‘è¡Œç‰ˆä¸­å°†ä¿®å¤ï¼‰ã€‚
    
5. é€šå¸¸ï¼Œæœ€å¥½é¿å…å»æ•æ‰å†…éƒ¨å…ƒæ•°æ®å¯¹è±¡çš„å¼•ç”¨ï¼Œå¦‚ `Method`ã€`MethodInstance`ã€`TypeMapLevel`ã€`TypeMapEntry` åŠè¿™äº›å¯¹è±¡çš„å­—æ®µï¼Œå› ä¸ºè¿™ä¼šè¿·æƒ‘åºåˆ—åŒ–å™¨ï¼Œä¸”å¯èƒ½ä¼šå¼•å‘ä½ ä¸æƒ³è¦çš„ç»“æœã€‚æ­¤æ“ä½œä¸è¶³ä»¥æˆä¸ºä¸€ä¸ªé”™è¯¯ï¼Œä½†ä½ éœ€åšå¥½å‡†å¤‡ï¼šç³»ç»Ÿä¼šå°è¯•æ‹·è´ä¸€éƒ¨åˆ†ï¼Œç„¶ååˆ›å»ºå…¶ä½™éƒ¨åˆ†çš„å•ä¸ªç‹¬ç«‹å®ä¾‹ã€‚
    
    
    
    

åœ¨å¼€å‘æ¨¡å—æ—¶ï¼Œå…³é—­å¢é‡é¢„ç¼–è¯‘å¯èƒ½ä¼šæœ‰æ‰€å¸®åŠ©ã€‚å‘½ä»¤è¡Œæ ‡è®° `--compiled-modules={yes|no}` å¯ä»¥è®©ä½ åˆ‡æ¢é¢„ç¼–è¯‘çš„å¼€å¯å’Œå…³é—­ã€‚
å½“ Julia é™„åŠ  `--compiled-modules=no` å¯åŠ¨ï¼Œåœ¨è½½å…¥æ¨¡å—å’Œæ¨¡å—ä¾èµ–æ—¶ï¼Œç¼–è¯‘ç¼“å­˜ä¸­çš„åºåˆ—åŒ–æ¨¡å—ä¼šè¢«å¿½ç•¥ã€‚
More fine-grained control is available with `--pkgimages=no`, which suppresses only
native-code storage during precompilation. 
`Base.compilecache` ä»å¯ä»¥è¢«æ‰‹åŠ¨è°ƒç”¨ã€‚
æ­¤å‘½ä»¤è¡Œæ ‡è®°çš„çŠ¶æ€ä¼šè¢«ä¼ é€’ç»™ `Pkg.build`ï¼Œç¦æ­¢å…¶åœ¨å®‰è£…ã€æ›´æ–°ã€æ˜¾å¼æ„å»ºåŒ…æ—¶è§¦å‘è‡ªåŠ¨é¢„ç¼–è¯‘ã€‚

You can also debug some precompilation failures with environment variables. Setting
`JULIA_VERBOSE_LINKING=true` may help resolve failures in linking shared libraries of compiled
native code. See the **Developer Documentation** part of the Julia manual,
where you will find further details in the section documenting Julia's internals under "Package Images".
