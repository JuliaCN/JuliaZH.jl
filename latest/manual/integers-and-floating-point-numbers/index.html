<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>整数和浮点数 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/integers-and-floating-point-numbers/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li class="current"><a class="toctext" href>整数和浮点数</a><ul class="internal"><li><a class="toctext" href="#整数-1">整数</a></li><li><a class="toctext" href="#浮点数-1">浮点数</a></li><li><a class="toctext" href="#任意精度算术-1">任意精度算术</a></li><li><a class="toctext" href="#man-numeric-literal-coefficients-1">数值字面量系数</a></li><li><a class="toctext" href="#零和一的字面量-1">零和一的字面量</a></li></ul></li><li><a class="toctext" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和分数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">接口</a></li><li><a class="toctext" href="../modules/">Modules</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">元编程</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">分析</a></li><li><a class="toctext" href="../stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li><a class="toctext" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">Essentials</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">Arrays</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../base/c/">C Interface</a></li><li><a class="toctext" href="../../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>整数和浮点数</a></li></ul><a class="edit-page" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/doc/src/manual/integers-and-floating-point-numbers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>整数和浮点数</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="整数和浮点数-1" href="#整数和浮点数-1">整数和浮点数</a></h1><p>整数和浮点值是算术和计算的基础。这些数值的内置表示被称作数值原始类型（numeric primitive），且整数和浮点数在代码中作为立即数时称作数值字面量（numeric literal）。例如，<code>1</code> 是个整型字面量，<code>1.0</code> 是个浮点型字面量，它们在内存中作为对象的二进制表示就是数值原始类型。</p><p>Julia 提供了很丰富的原始数值类型，并基于它们定义了一整套算术操作，还提供按位运算符以及一些标准数学函数。这些函数能够直接映射到现代计算机原生支持的数值类型及运算上，因此 Julia 可以充分地利用运算资源。此外，Julia 还为<a href="#任意精度算术-1">任意精度算术</a>提供了软件支持，对于无法使用原生硬件表示的数值类型，Julia 也能够高效地处理其数值运算。当然，这需要相对的牺牲一些性能。</p><p>以下是 Julia 的原始数值类型：</p><ul><li><strong>整数类型：</strong></li></ul><table><tr><th>类型</th><th>带符号？</th><th>比特数</th><th>最小值</th><th>最大值</th></tr><tr><td><a href="../../base/numbers/#Core.Int8"><code>Int8</code></a></td><td>✓</td><td>8</td><td>-2^7</td><td>2^7 - 1</td></tr><tr><td><a href="../../base/numbers/#Core.UInt8"><code>UInt8</code></a></td><td></td><td>8</td><td>0</td><td>2^8 - 1</td></tr><tr><td><a href="../../base/numbers/#Core.Int16"><code>Int16</code></a></td><td>✓</td><td>16</td><td>-2^15</td><td>2^15 - 1</td></tr><tr><td><a href="../../base/numbers/#Core.UInt16"><code>UInt16</code></a></td><td></td><td>16</td><td>0</td><td>2^16 - 1</td></tr><tr><td><a href="../../base/numbers/#Core.Int32"><code>Int32</code></a></td><td>✓</td><td>32</td><td>-2^31</td><td>2^31 - 1</td></tr><tr><td><a href="../../base/numbers/#Core.UInt32"><code>UInt32</code></a></td><td></td><td>32</td><td>0</td><td>2^32 - 1</td></tr><tr><td><a href="../../base/numbers/#Core.Int64"><code>Int64</code></a></td><td>✓</td><td>64</td><td>-2^63</td><td>2^63 - 1</td></tr><tr><td><a href="../../base/numbers/#Core.UInt64"><code>UInt64</code></a></td><td></td><td>64</td><td>0</td><td>2^64 - 1</td></tr><tr><td><a href="../../base/numbers/#Core.Int128"><code>Int128</code></a></td><td>✓</td><td>128</td><td>-2^127</td><td>2^127 - 1</td></tr><tr><td><a href="../../base/numbers/#Core.UInt128"><code>UInt128</code></a></td><td></td><td>128</td><td>0</td><td>2^128 - 1</td></tr><tr><td><a href="../../base/numbers/#Core.Bool"><code>Bool</code></a></td><td>N/A</td><td>8</td><td><code>false</code> (0)</td><td><code>true</code> (1)</td></tr></table><ul><li><strong>浮点类型:</strong></li></ul><table><tr><th>类型</th><th>精度</th><th>比特数</th></tr><tr><td><a href="../../base/numbers/#Core.Float16"><code>Float16</code></a></td><td><a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">half</a></td><td>16</td></tr><tr><td><a href="../../base/numbers/#Core.Float32"><code>Float32</code></a></td><td><a href="https://en.wikipedia.org/wiki/Single_precision_floating-point_format">single</a></td><td>32</td></tr><tr><td><a href="../../base/numbers/#Core.Float64"><code>Float64</code></a></td><td><a href="https://en.wikipedia.org/wiki/Double_precision_floating-point_format">double</a></td><td>64</td></tr></table><p>此外，对<a href="../complex-and-rational-numbers/#复数和分数-1">复数和分数</a>的完整支持是在这些原始数据类型之上建立起来的。多亏了 Julia 有一个很灵活的、用户可扩展的<a href="../conversion-and-promotion/#conversion-and-promotion-1">类型提升系统</a>，所有的数值类型都无需显式转换就可以很自然地相互进行运算。</p><h2><a class="nav-anchor" id="整数-1" href="#整数-1">整数</a></h2><p>整数字面量以标准形式表示：</p><pre><code class="language-julia-repl">julia&gt; 1
1

julia&gt; 1234
1234</code></pre><p>整型字面量的默认类型取决于目标系统是 32 位架构还是 64 位的：</p><pre><code class="language-julia-repl"># 32-bit system:
julia&gt; typeof(1)
Int32

# 64-bit system:
julia&gt; typeof(1)
Int64</code></pre><p>Julia 的内部变量 <a href="../../base/constants/#Base.Sys.WORD_SIZE"><code>Sys.WORD_SIZE</code></a> 表明了目标系统是 32 位还是 64 位：</p><pre><code class="language-julia-repl"># 32-bit system:
julia&gt; Sys.WORD_SIZE
32

# 64-bit system:
julia&gt; Sys.WORD_SIZE
64</code></pre><p>Julia 也定义了 <code>Int</code> 与 <code>UInt</code> 类型，它们分别是系统有符号和无符号的原生整数类型的别名。</p><pre><code class="language-julia-repl"># 32-bit system:
julia&gt; Int
Int32
julia&gt; UInt
UInt32

# 64-bit system:
julia&gt; Int
Int64
julia&gt; UInt
UInt64</code></pre><p>那些超过 32 位表示范围的大整数，如果能用 64 位表示，那么无论是什么系统都会用 64 位表示：</p><pre><code class="language-julia-repl"># 32-bit or 64-bit system:
julia&gt; typeof(3000000000)
Int64</code></pre><p>无符号整数通过 <code>0x</code> 前缀以及十六进制数 <code>0-9a-f</code> 输入和输出（输入也可以使用大写的 <code>A-F</code>）。无符号值的位数决定于使用的十六进制数字的数量：</p><pre><code class="language-julia-repl">julia&gt; 0x1
0x01

julia&gt; typeof(ans)
UInt8

julia&gt; 0x123
0x0123

julia&gt; typeof(ans)
UInt16

julia&gt; 0x1234567
0x01234567

julia&gt; typeof(ans)
UInt32

julia&gt; 0x123456789abcdef
0x0123456789abcdef

julia&gt; typeof(ans)
UInt64

julia&gt; 0x11112222333344445555666677778888
0x11112222333344445555666677778888

julia&gt; typeof(ans)
UInt128</code></pre><p>这种做法是由于当人们使用无符号十六进制字面量表示整数值，通常会用它们来表示一个固定的数值字节序列，而不仅仅是个整数值。</p><p>还记得这个 <a href="../../base/base/#ans"><code>ans</code></a> 变量吗？它存着交互式会话中上一个表达式的运算结果，但以其他方式运行的 Julia 代码中没有这个变量。</p><p>二进制和八进制字面量也支持：</p><pre><code class="language-julia-repl">julia&gt; 0b10
0x02

julia&gt; typeof(ans)
UInt8

julia&gt; 0o010
0x08

julia&gt; typeof(ans)
UInt8

julia&gt; 0x00000000000000001111222233334444
0x00000000000000001111222233334444

julia&gt; typeof(ans)
UInt128</code></pre><p>二进制、八进制和十六进制的字面量都会产生无符号的整数类型。当字面量不是开头全是 0 时，它们二进制数据项的位数会是最少需要的位数。当开头都是 0 时，位数决定于一个字面量的最少需要位数，这里的字面量指的是一个有着同样长度但开头都为 <code>1</code> 的数。这样用户就可以控制位数了。那些无法使用 <code>UInt128</code> 类型存储下的值无法写成这样的字面量。</p><p>二进制、八进制和十六进制的字面量可以在前面紧接着加一个负号 <code>-</code>，这样可以产生一个和原字面量有着同样位数而值为原数的补码的数（二补数）：</p><pre><code class="language-julia-repl">julia&gt; -0x2
0xfe

julia&gt; -0x0002
0xfffe</code></pre><p>整型等原始数值类型的最小和最大可表示的值可用 <a href="../../base/base/#Base.typemin"><code>typemin</code></a> 和 <a href="../../base/base/#Base.typemax"><code>typemax</code></a> 函数得到：</p><pre><code class="language-julia-repl">julia&gt; (typemin(Int32), typemax(Int32))
(-2147483648, 2147483647)

julia&gt; for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]
           println(&quot;$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]&quot;)
       end
   Int8: [-128,127]
  Int16: [-32768,32767]
  Int32: [-2147483648,2147483647]
  Int64: [-9223372036854775808,9223372036854775807]
 Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
  UInt8: [0,255]
 UInt16: [0,65535]
 UInt32: [0,4294967295]
 UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]</code></pre><p><a href="../../base/base/#Base.typemin"><code>typemin</code></a> 和 <a href="../../base/base/#Base.typemax"><code>typemax</code></a> 返回的值的类型总与所给参数的类型相同。 （上面的表达式用了一些我们目前还没有介绍的功能，包括 <a href="../control-flow/#man-loops-1">for 循环</a>、<a href="../strings/#man-strings-1">字符串</a>和<a href="../metaprogramming/#插值-1">插值</a>，但对于已有一些编程经验的用户应该是很容易理解的。）</p><h3><a class="nav-anchor" id="溢出行为-1" href="#溢出行为-1">溢出行为</a></h3><p>Julia 中，在超过一个类型最大可表示的值时会导致循环行为：</p><pre><code class="language-julia-repl">julia&gt; x = typemax(Int64)
9223372036854775807

julia&gt; x + 1
-9223372036854775808

julia&gt; x + 1 == typemin(Int64)
true</code></pre><p>因此，Julia 的整数算术实际上是<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%AE%97%E6%95%B8">模算数</a>的一种形式，它反映了现代计算机实现底层算术的特点。在可能有溢出产生的程序中，对最值边界出现循环进行显式检查是必要的。否则，推荐使用<a href="#任意精度算术-1">任意精度算术</a>中的 <a href="../../base/numbers/#Base.GMP.BigInt"><code>BigInt</code></a> 类型作为替代。</p><h3><a class="nav-anchor" id="除法错误-1" href="#除法错误-1">除法错误</a></h3><p><code>div</code> 函数的整数除法有两种异常情况：除以零，以及使用 -1 去除最小的负数（<a href="../../base/base/#Base.typemin"><code>typemin</code></a>）。 这两种情况都会抛出一个 <a href="../../base/base/#Core.DivideError"><code>DivideError</code></a> 错误。 <code>rem</code> 取余函数和 <code>mod</code> 取模函数在除零时抛出 <a href="../../base/base/#Core.DivideError"><code>DivideError</code></a> 错误。</p><h2><a class="nav-anchor" id="浮点数-1" href="#浮点数-1">浮点数</a></h2><p>浮点数字面量也使用标准格式表示，必要时可使用 <a href="https://en.wikipedia.org/wiki/Scientific_notation#E-notation">E-表示法</a>：</p><pre><code class="language-julia-repl">julia&gt; 1.0
1.0

julia&gt; 1.
1.0

julia&gt; 0.5
0.5

julia&gt; .5
0.5

julia&gt; -1.23
-1.23

julia&gt; 1e10
1.0e10

julia&gt; 2.5e-4
0.00025</code></pre><p>上面的结果都是 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> 值。使用 <code>f</code> 替代 <code>e</code> 可以得到 <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a> 的字面量：</p><pre><code class="language-julia-repl">julia&gt; 0.5f0
0.5f0

julia&gt; typeof(ans)
Float32

julia&gt; 2.5f-4
0.00025f0</code></pre><p>数值容易就能转换成 <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a>：</p><pre><code class="language-julia-repl">julia&gt; Float32(-1.5)
-1.5f0

julia&gt; typeof(ans)
Float32</code></pre><p>也存在十六进制的浮点数字面量，但只适用于 [<code>Float64</code>] 值。一般使用 <code>p</code> 前缀及以 2 为底的指数来表示：</p><pre><code class="language-julia-repl">julia&gt; 0x1p0
1.0

julia&gt; 0x1.8p3
12.0

julia&gt; 0x.4p-1
0.125

julia&gt; typeof(ans)
Float64</code></pre><p>Julia 也支持半精度浮点数（<a href="../../base/numbers/#Core.Float16"><code>Float16</code></a>），但它们是由软件实现的，且使用 <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a> 进行计算。</p><pre><code class="language-julia-repl">julia&gt; sizeof(Float16(4.))
2

julia&gt; 2*Float16(4.)
Float16(8.0)</code></pre><p>下划线 <code>_</code> 可用作数字分隔符：</p><pre><code class="language-julia-repl">julia&gt; 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010
(10000, 5.0e-9, 0xdeadbeef, 0xb2)</code></pre><h3><a class="nav-anchor" id="浮点数中的零-1" href="#浮点数中的零-1">浮点数中的零</a></h3><p>浮点数有<a href="https://zh.wikipedia.org/wiki/%E2%88%920">两个零</a>，正零和负零。它们相互相等但有着不同的二进制表示，可以使用 <a href="../../base/numbers/#Base.bitstring"><code>bitstring</code></a> 函数来查看：</p><pre><code class="language-julia-repl">julia&gt; 0.0 == -0.0
true

julia&gt; bitstring(0.0)
&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;

julia&gt; bitstring(-0.0)
&quot;1000000000000000000000000000000000000000000000000000000000000000&quot;</code></pre><h3><a class="nav-anchor" id="特殊的浮点值-1" href="#特殊的浮点值-1">特殊的浮点值</a></h3><p>有三种特定的标准浮点值不和实数轴上任何一点对应：</p><table><tr><th><code>Float16</code></th><th><code>Float32</code></th><th><code>Float64</code></th><th>名称</th><th>描述</th></tr><tr><td><code>Inf16</code></td><td><code>Inf32</code></td><td><code>Inf</code></td><td>正无穷</td><td>一个大于所有有限浮点数的数</td></tr><tr><td><code>-Inf16</code></td><td><code>-Inf32</code></td><td><code>-Inf</code></td><td>负无穷</td><td>一个小于所有有限浮点数的数</td></tr><tr><td><code>NaN16</code></td><td><code>NaN32</code></td><td><code>NaN</code></td><td>不是数（Not a Number）</td><td>一个不和任何浮点值（包括自己）相等（<code>==</code>）的值</td></tr></table><p>对于这些非有限浮点值相互之间以及关于其它浮点值的顺序的更多讨论，请参见<a href="../mathematical-operations/#数值比较-1">数值比较</a>。根据 <a href="https://en.wikipedia.org/wiki/IEEE_754_revision">IEEE 754 标准</a>，这些浮点值是某些算术运算的结果：</p><pre><code class="language-julia-repl">julia&gt; 1/Inf
0.0

julia&gt; 1/0
Inf

julia&gt; -5/0
-Inf

julia&gt; 0.000001/0
Inf

julia&gt; 0/0
NaN

julia&gt; 500 + Inf
Inf

julia&gt; 500 - Inf
-Inf

julia&gt; Inf + Inf
Inf

julia&gt; Inf - Inf
NaN

julia&gt; Inf * Inf
Inf

julia&gt; Inf / Inf
NaN

julia&gt; 0 * Inf
NaN</code></pre><p><a href="../../base/base/#Base.typemin"><code>typemin</code></a> 和 <a href="../../base/base/#Base.typemax"><code>typemax</code></a> 函数同样适用于浮点类型：</p><pre><code class="language-julia-repl">julia&gt; (typemin(Float16),typemax(Float16))
(-Inf16, Inf16)

julia&gt; (typemin(Float32),typemax(Float32))
(-Inf32, Inf32)

julia&gt; (typemin(Float64),typemax(Float64))
(-Inf, Inf)</code></pre><h3><a class="nav-anchor" id="机器精度-1" href="#机器精度-1">机器精度</a></h3><p>大多数实数都无法用浮点数准确地表示，因此有必要知道两个相邻可表示的浮点数间的距离。它通常被叫做<a href="https://en.wikipedia.org/wiki/Machine_epsilon">机器精度</a>。</p><p>Julia 提供了 <a href="../../stdlib/Dates/#Base.eps"><code>eps</code></a> 函数，它可以给出 <code>1.0</code> 与下一个Julia能表示的浮点数之间的差值：</p><pre><code class="language-julia-repl">julia&gt; eps(Float32)
1.1920929f-7

julia&gt; eps(Float64)
2.220446049250313e-16

julia&gt; eps() # same as eps(Float64)
2.220446049250313e-16</code></pre><p>这些值分别是 <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a> 中的 <code>2.0^-23</code> 和 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> 中的 <code>2.0^-52</code>。<a href="../../stdlib/Dates/#Base.eps"><code>eps</code></a> 函数也可以接受一个浮点值作为参数，然后给出这个值与下一个可表示的值直接的绝对差。也就是说，<code>eps(x)</code> 产生一个和 <code>x</code> 类型相同的值使得 <code>x + eps(x)</code> 是比 <code>x</code> 更大的下一个可表示的浮点值：</p><pre><code class="language-julia-repl">julia&gt; eps(1.0)
2.220446049250313e-16

julia&gt; eps(1000.)
1.1368683772161603e-13

julia&gt; eps(1e-27)
1.793662034335766e-43

julia&gt; eps(0.0)
5.0e-324</code></pre><p>两个相邻可表示的浮点数之间的距离并不是常数，数值越小，间距越小，数值越大，间距越大。换句话说，可表示的浮点数在实数轴上的零点附近最稠密，并沿着远离零点的方向以指数型的速度变得越来越稀疏。根据定义，<code>eps(1.0)</code> 与 <code>eps(Float64)</code> 相等，因为 <code>1.0</code> 是个 64 位浮点值。</p><p>Julia 也提供了 <a href="../../base/numbers/#Base.nextfloat"><code>nextfloat</code></a> 和 <a href="../../base/numbers/#Base.prevfloat"><code>prevfloat</code></a> 两个函数分别返回基于参数的下一个更大或更小的可表示的浮点数：</p><pre><code class="language-julia-repl">julia&gt; x = 1.25f0
1.25f0

julia&gt; nextfloat(x)
1.2500001f0

julia&gt; prevfloat(x)
1.2499999f0

julia&gt; bitstring(prevfloat(x))
&quot;00111111100111111111111111111111&quot;

julia&gt; bitstring(x)
&quot;00111111101000000000000000000000&quot;

julia&gt; bitstring(nextfloat(x))
&quot;00111111101000000000000000000001&quot;</code></pre><p>这个例子体现了一般原则，即相邻可表示的浮点数也有着相邻的二进制整数表示。</p><h3><a class="nav-anchor" id="舍入模式-1" href="#舍入模式-1">舍入模式</a></h3><p>一个数如果没有精确的浮点表示，就必须被舍入到一个合适的可表示的值。然而，如果想的话，可以根据舍入模式改变舍入的方式，如 <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 标准</a> 所述。 </p><p>Julia 所使用的默认模式总是 <a href="../../base/math/#Base.Rounding.RoundNearest"><code>RoundNearest</code></a>，指舍入到最接近的可表示的值，这个被舍入的值会使用尽量少的有效位数。</p><h3><a class="nav-anchor" id="基础知识与参考文献-1" href="#基础知识与参考文献-1">基础知识与参考文献</a></h3><p>浮点算术带来了很多微妙之处，它们可能对于那些不熟悉底层实现细节的用户会是很出人意料的。然而，这些微妙之处在大部分科学计算的书籍中以及以下的参考资料中都有详细介绍:</p><ul><li>浮点算术的权威指南是 <a href="http://standards.ieee.org/findstds/standard/754-2008.html">IEEE 754-2008 标准</a>； 然而这篇标准在网上无法免费获得。</li><li>关于浮点数是如何表示的，想要一个简单而明白的介绍的话，可以看 John D. Cook 的<a href="https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/">文章</a> 以及他关于从这种表示与实数理想的抽象化的差别中产生的一些问题的<a href="https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/">介绍</a></li><li>同样推荐 Bruce Dawson 的<a href="https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats">一系列关于浮点数的博客文章</a>。</li><li>想要一个对浮点数和使用浮点数计算时产生的数值精度问题的极好的、有深度的讨论，可以参见 David Goldberg 的文章 <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;rep=rep1&amp;type=pdf">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>。</li><li>更多延伸文档，包括浮点数的历史、基础理论、问题以及数值计算中很多其它主题的讨论，可以参见 <a href="https://en.wikipedia.org/wiki/William_Kahan">William Kahan</a> 的<a href="https://people.eecs.berkeley.edu/~wkahan/">写作集</a>。他以“浮点数之父”闻名。特别感兴趣的话可以看 <a href="https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html">An Interview with the Old Man of Floating-Point</a>。</li></ul><h2><a class="nav-anchor" id="任意精度算术-1" href="#任意精度算术-1">任意精度算术</a></h2><p>为了允许使用任意精度的整数与浮点数，Julia 分别包装了 <a href="https://gmplib.org">GNU Multiple Precision Arithmetic Library (GMP)</a> 以及 <a href="http://www.mpfr.org">GNU MPFR Library</a>。Julia 中的 <a href="../../base/numbers/#Base.GMP.BigInt"><code>BigInt</code></a> 与 <a href="../../base/numbers/#Base.MPFR.BigFloat"><code>BigFloat</code></a> 两种类型分别提供了任意精度的整数和浮点数。</p><p>存在从原始数字类型创建它们的构造器，也可以使用 <a href="../../base/numbers/#Base.parse"><code>parse</code></a> 从 <code>AbstractString</code> 来构造它们。一旦被创建，它们就可以像所有其它数值类型一样参与算术（也是多亏了 Julia 的<a href="../conversion-and-promotion/#conversion-and-promotion-1">类型提升和转换机制</a>）。</p><pre><code class="language-julia-repl">julia&gt; BigInt(typemax(Int64)) + 1
9223372036854775808

julia&gt; parse(BigInt, &quot;123456789012345678901234567890&quot;) + 1
123456789012345678901234567891

julia&gt; parse(BigFloat, &quot;1.23456789012345678901&quot;)
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia&gt; BigFloat(2.0^66) / 3
2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19

julia&gt; factorial(BigInt(40))
815915283247897734345611269596115894272000000000</code></pre><p>然而，上面的原始类型与 <a href="../../base/numbers/#Base.GMP.BigInt"><code>BigInt</code></a>/<a href="../../base/numbers/#Base.MPFR.BigFloat"><code>BigFloat</code></a> 之间的类型提升并不是自动的，需要明确地指定：</p><pre><code class="language-julia-repl">julia&gt; x = typemin(Int64)
-9223372036854775808

julia&gt; x = x - 1
9223372036854775807

julia&gt; typeof(x)
Int64

julia&gt; y = BigInt(typemin(Int64))
-9223372036854775808

julia&gt; y = y - 1
-9223372036854775809

julia&gt; typeof(y)
BigInt</code></pre><p><a href="../../base/numbers/#Base.MPFR.BigFloat"><code>BigFloat</code></a> 的默认精度（有效数字的位数）和舍入模式可以通过调用 <a href="../../base/numbers/#Base.MPFR.setprecision"><code>setprecision</code></a> 和 <a href="../../base/numbers/#Base.Rounding.setrounding-Tuple{Type,Any}"><code>setrounding</code></a> 来全局地改变，所有之后的计算都会根据这些改变进行。还有一种方法，可以使用同样的函数以及 <code>do</code>-block 来只在运行一个特定代码块时改变精度和舍入模式：</p><pre><code class="language-julia-repl">julia&gt; setrounding(BigFloat, RoundUp) do
           BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
       end
1.100000000000000000000000000000000000000000000000000000000000000000000000000003

julia&gt; setrounding(BigFloat, RoundDown) do
           BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
       end
1.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia&gt; setprecision(40) do
           BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
       end
1.1000000000004</code></pre><h2><a class="nav-anchor" id="man-numeric-literal-coefficients-1" href="#man-numeric-literal-coefficients-1">数值字面量系数</a></h2><p>为了让常见的数值公式和表达式更清楚，Julia 允许变量直接跟在一个数值字面量后，暗指乘法。这可以让写多项式变得很清楚：</p><pre><code class="language-julia-repl">julia&gt; x = 3
3

julia&gt; 2x^2 - 3x + 1
10

julia&gt; 1.5x^2 - .5x + 1
13.0</code></pre><p>也会让写指数函数变得更加优雅：</p><pre><code class="language-julia-repl">julia&gt; 2^2x
64</code></pre><p>数值字面量系数的优先级跟一元运算符相同，比如说取相反数。所以 <code>2^3x</code> 会被解析成 <code>2^(3x)</code>，而 <code>2x^3</code> 会被解析成 <code>2*(x^3)</code>。</p><p>数值字面量也能作为被括号表达式的系数：</p><pre><code class="language-julia-repl">julia&gt; 2(x-1)^2 - 3(x-1) + 1
3</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>用于隐式乘法的数值字面量系数的优先级高于其它的二元运算符，例如乘法（<code>*</code>）和除法（<code>/</code>、<code>\</code> 以及 <code>//</code>）。这意味着，比如说，<code>1 / 2im</code> 等于 <code>-0.5im</code> 以及 <code>6 // 2(2+1)</code> 等于 <code>1 // 1</code>。</p></div></div><p>此外，括号表达式可以被用作变量的系数，暗指表达式与变量相乘：</p><pre><code class="language-julia-repl">julia&gt; (x-1)x
6</code></pre><p>但是，无论是把两个括号表达式并列，还是把变量放在括号表达式之前，都不会被用作暗指乘法：</p><pre><code class="language-julia-repl">julia&gt; (x-1)(x+1)
ERROR: MethodError: objects of type Int64 are not callable

julia&gt; x(x+1)
ERROR: MethodError: objects of type Int64 are not callable</code></pre><p>这两种表达式都会被解释成函数调用：所有不是数值字面量的表达式，后面紧跟一个括号，就会被解释成使用括号内的值来调用函数（更多关于函数的信息请参见<a href="../faq/#函数-1">函数</a>）。因此，在这两种情况中，都会因为左手边的值并不是函数而产生错误</p><p>上述的语法糖显著地降低了在写通常的数学公式时的视觉噪音。注意数值字面量系数和后面用来相乘的标识符或括号表达式之间不能有空格。</p><h3><a class="nav-anchor" id="语法冲突-1" href="#语法冲突-1">语法冲突</a></h3><p>并列的字面量系数语法可能和两种数值字面量语法产生冲突：十六进制整数字面量以及浮点字面量的工程表示法。下面是几种会产生语法冲突的情况：</p><ul><li>十六进制整数字面量 <code>0xff</code> 可能被解释成数值字面量 <code>0</code> 乘以变量 <code>xff</code>。</li><li>浮点字面量表达式 <code>1e10</code> 可以被解释成 <code>1</code> 乘以变量 <code>e10</code>，与之等价的 <code>E</code> 形式也存在类似的情况。</li><li>32比特的浮点数字面量 <code>1.5f22</code> 被解释成数值 <code>1.5</code> 乘以变量 <code>f22</code>。</li></ul><p>在这些所有的情况中，都使用这样的解释方法来解决二义性：</p><ul><li><code>0x</code> 开头的表达式总是十六进制字面量。</li><li>数值开头跟着 <code>e</code> 和 <code>E</code> 的表达式总是浮点字面量。</li><li>数值开头跟着 <code>f</code> 的表达式总是32比特浮点字面量。</li></ul><p>由于历史原因 <code>E</code> 和 <code>e</code> 在数值字面量上是等价的，与之不同的是，<code>F</code> 只是一个行为和 <code>f</code> 不同的字母。因此开头为 <code>F</code> 的表达式将会被 解析为一个数值字面量乘以一个变量，例如 <code>1.5F22</code>等价于 <code>1.5 * F22</code>。</p><h2><a class="nav-anchor" id="零和一的字面量-1" href="#零和一的字面量-1">零和一的字面量</a></h2><p>Julia 提供了 0 和 1 的字面量函数，可以返回特定类型或所给变量的类型。</p><table><tr><th>函数</th><th>描述</th></tr><tr><td><a href="../../base/numbers/#Base.zero"><code>zero(x)</code></a></td><td><code>x</code> 类型或变量 <code>x</code> 的类型的零字面量</td></tr><tr><td><a href="../../base/numbers/#Base.one"><code>one(x)</code></a></td><td><code>x</code> 类型或变量 <code>x</code> 的类型的一字面量</td></tr></table><p>这些函数在<a href="../mathematical-operations/#数值比较-1">数值比较</a>中可以用来避免不必要的<a href="../conversion-and-promotion/#conversion-and-promotion-1">类型转换</a>带来的开销。</p><p>例如：</p><pre><code class="language-julia-repl">julia&gt; zero(Float32)
0.0f0

julia&gt; zero(1.0)
0.0

julia&gt; one(Int32)
1

julia&gt; one(BigFloat)
1.0</code></pre><footer><hr/><a class="previous" href="../variables/"><span class="direction">Previous</span><span class="title">变量</span></a><a class="next" href="../mathematical-operations/"><span class="direction">Next</span><span class="title">数学运算和初等函数</span></a></footer></article></body></html>
