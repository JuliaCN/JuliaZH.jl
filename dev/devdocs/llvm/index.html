<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Working with LLVM · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/llvm/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-options/">命令行选项</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox" checked/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../types/">More about types</a></li><li><a class="tocitem" href="../object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../functions/">Julia 函数</a></li><li><a class="tocitem" href="../cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../subarrays/">子数组</a></li><li><a class="tocitem" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../sysimg/">System Image Building</a></li><li class="is-active"><a class="tocitem" href>Working with LLVM</a><ul class="internal"><li><a class="tocitem" href="#Overview-of-Julia-to-LLVM-Interface"><span>Overview of Julia to LLVM Interface</span></a></li><li><a class="tocitem" href="#Building-Julia-with-a-different-version-of-LLVM"><span>Building Julia with a different version of LLVM</span></a></li><li><a class="tocitem" href="#Passing-options-to-LLVM"><span>Passing options to LLVM</span></a></li><li><a class="tocitem" href="#Debugging-LLVM-transformations-in-isolation"><span>Debugging LLVM transformations in isolation</span></a></li><li><a class="tocitem" href="#Improving-LLVM-optimizations-for-Julia"><span>Improving LLVM optimizations for Julia</span></a></li><li><a class="tocitem" href="#The-jlcall-calling-convention"><span>The jlcall calling convention</span></a></li><li><a class="tocitem" href="#GC-root-placement"><span>GC root placement</span></a></li></ul></li><li><a class="tocitem" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../boundscheck/">边界检查</a></li><li><a class="tocitem" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../require/">Module loading</a></li><li><a class="tocitem" href="../inference/">类型推导</a></li><li><a class="tocitem" href="../ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Documentation</a></li><li><a class="is-disabled">Documentation of Julia&#39;s Internals</a></li><li class="is-active"><a href>Working with LLVM</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Working with LLVM</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/devdocs-zh_cn/translate/#zh_CN/llvmmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Working-with-LLVM"><a class="docs-heading-anchor" href="#Working-with-LLVM">Working with LLVM</a><a id="Working-with-LLVM-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-LLVM" title="Permalink"></a></h1><p>This is not a replacement for the LLVM documentation, but a collection of tips for working on LLVM for Julia.</p><h2 id="Overview-of-Julia-to-LLVM-Interface"><a class="docs-heading-anchor" href="#Overview-of-Julia-to-LLVM-Interface">Overview of Julia to LLVM Interface</a><a id="Overview-of-Julia-to-LLVM-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-Julia-to-LLVM-Interface" title="Permalink"></a></h2><p>Julia dynamically links against LLVM by default. Build with <code>USE_LLVM_SHLIB=0</code> to link statically.</p><p>The code for lowering Julia AST to LLVM IR or interpreting it directly is in directory <code>src/</code>.</p><table><tr><th style="text-align: left">File</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>builtins.c</code></td><td style="text-align: left">Builtin functions</td></tr><tr><td style="text-align: left"><code>ccall.cpp</code></td><td style="text-align: left">Lowering <a href="../../base/c/#ccall"><code>ccall</code></a></td></tr><tr><td style="text-align: left"><code>cgutils.cpp</code></td><td style="text-align: left">Lowering utilities, notably for array and tuple accesses</td></tr><tr><td style="text-align: left"><code>codegen.cpp</code></td><td style="text-align: left">Top-level of code generation, pass list, lowering builtins</td></tr><tr><td style="text-align: left"><code>debuginfo.cpp</code></td><td style="text-align: left">Tracks debug information for JIT code</td></tr><tr><td style="text-align: left"><code>disasm.cpp</code></td><td style="text-align: left">Handles native object file and JIT code diassembly</td></tr><tr><td style="text-align: left"><code>gf.c</code></td><td style="text-align: left">Generic functions</td></tr><tr><td style="text-align: left"><code>intrinsics.cpp</code></td><td style="text-align: left">Lowering intrinsics</td></tr><tr><td style="text-align: left"><code>llvm-simdloop.cpp</code></td><td style="text-align: left">Custom LLVM pass for <a href="../../base/base/#Base.SimdLoop.@simd"><code>@simd</code></a></td></tr><tr><td style="text-align: left"><code>sys.c</code></td><td style="text-align: left">I/O and operating system utility functions</td></tr></table><p>Some of the <code>.cpp</code> files form a group that compile to a single object.</p><p>The difference between an intrinsic and a builtin is that a builtin is a first class function that can be used like any other Julia function.  An intrinsic can operate only on unboxed data, and therefore its arguments must be statically typed.</p><h3 id="Alias-Analysis"><a class="docs-heading-anchor" href="#Alias-Analysis">Alias Analysis</a><a id="Alias-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Alias-Analysis" title="Permalink"></a></h3><p>Julia currently uses LLVM&#39;s <a href="http://llvm.org/docs/LangRef.html#tbaa-metadata">Type Based Alias Analysis</a>. To find the comments that document the inclusion relationships, look for <code>static MDNode*</code> in <code>src/codegen.cpp</code>.</p><p>The <code>-O</code> option enables LLVM&#39;s <a href="http://llvm.org/docs/AliasAnalysis.html#the-basicaa-pass">Basic Alias Analysis</a>.</p><h2 id="Building-Julia-with-a-different-version-of-LLVM"><a class="docs-heading-anchor" href="#Building-Julia-with-a-different-version-of-LLVM">Building Julia with a different version of LLVM</a><a id="Building-Julia-with-a-different-version-of-LLVM-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Julia-with-a-different-version-of-LLVM" title="Permalink"></a></h2><p>The default version of LLVM is specified in <code>deps/Versions.make</code>. You can override it by creating a file called <code>Make.user</code> in the top-level directory and adding a line to it such as:</p><pre><code class="language-none">LLVM_VER = 12.0.1</code></pre><p>Besides the LLVM release numerals, you can also use <code>LLVM_VER = svn</code> to build against the latest development version of LLVM.</p><p>You can also specify to build a debug version of LLVM, by setting either <code>LLVM_DEBUG = 1</code> or <code>LLVM_DEBUG = Release</code> in your <code>Make.user</code> file. The former will be a fully unoptimized build of LLVM and the latter will produce an optimized build of LLVM. Depending on your needs the latter will suffice and it quite a bit faster. If you use <code>LLVM_DEBUG = Release</code> you will also want to set <code>LLVM_ASSERTIONS = 1</code> to enable diagnostics for different passes. Only <code>LLVM_DEBUG = 1</code> implies that option by default.</p><h2 id="Passing-options-to-LLVM"><a class="docs-heading-anchor" href="#Passing-options-to-LLVM">Passing options to LLVM</a><a id="Passing-options-to-LLVM-1"></a><a class="docs-heading-anchor-permalink" href="#Passing-options-to-LLVM" title="Permalink"></a></h2><p>You can pass options to LLVM via the environment variable <code>JULIA_LLVM_ARGS</code>. Here are example settings using <code>bash</code> syntax:</p><ul><li><code>export JULIA_LLVM_ARGS=-print-after-all</code> dumps IR after each pass.</li><li><code>export JULIA_LLVM_ARGS=-debug-only=loop-vectorize</code> dumps LLVM <code>DEBUG(...)</code> diagnostics for loop vectorizer. If you get warnings about &quot;Unknown command line argument&quot;, rebuild LLVM with <code>LLVM_ASSERTIONS = 1</code>.</li></ul><h2 id="Debugging-LLVM-transformations-in-isolation"><a class="docs-heading-anchor" href="#Debugging-LLVM-transformations-in-isolation">Debugging LLVM transformations in isolation</a><a id="Debugging-LLVM-transformations-in-isolation-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging-LLVM-transformations-in-isolation" title="Permalink"></a></h2><p>On occasion, it can be useful to debug LLVM&#39;s transformations in isolation from the rest of the Julia system, e.g. because reproducing the issue inside <code>julia</code> would take too long, or because one wants to take advantage of LLVM&#39;s tooling (e.g. bugpoint). To get unoptimized IR for the entire system image, pass the <code>--output-unopt-bc unopt.bc</code> option to the system image build process, which will output the unoptimized IR to an <code>unopt.bc</code> file. This file can then be passed to LLVM tools as usual. <code>libjulia</code> can function as an LLVM pass plugin and can be loaded into LLVM tools, to make julia-specific passes available in this environment. In addition, it exposes the <code>-julia</code> meta-pass, which runs the entire Julia pass-pipeline over the IR. As an example, to generate a system image, one could do:</p><pre><code class="language-none">opt -load libjulia-internal.so -julia -o opt.bc unopt.bc
llc -o sys.o opt.bc
cc -shared -o sys.so sys.o</code></pre><p>This system image can then be loaded by <code>julia</code> as usual.</p><p>It is also possible to dump an LLVM IR module for just one Julia function, using:</p><pre><code class="language-julia">fun, T = +, Tuple{Int,Int} # Substitute your function of interest here
optimize = false
open(&quot;plus.ll&quot;, &quot;w&quot;) do file
    println(file, InteractiveUtils._dump_function(fun, T, false, false, false, true, :att, optimize, :default))
end</code></pre><p>These files can be processed the same way as the unoptimized sysimg IR shown above.</p><h2 id="Improving-LLVM-optimizations-for-Julia"><a class="docs-heading-anchor" href="#Improving-LLVM-optimizations-for-Julia">Improving LLVM optimizations for Julia</a><a id="Improving-LLVM-optimizations-for-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Improving-LLVM-optimizations-for-Julia" title="Permalink"></a></h2><p>Improving LLVM code generation usually involves either changing Julia lowering to be more friendly to LLVM&#39;s passes, or improving a pass.</p><p>If you are planning to improve a pass, be sure to read the <a href="http://llvm.org/docs/DeveloperPolicy.html">LLVM developer policy</a>. The best strategy is to create a code example in a form where you can use LLVM&#39;s <code>opt</code> tool to study it and the pass of interest in isolation.</p><ol><li>Create an example Julia code of interest.</li><li>Use <code>JULIA_LLVM_ARGS=-print-after-all</code> to dump the IR.</li><li>Pick out the IR at the point just before the pass of interest runs.</li><li>Strip the debug metadata and fix up the TBAA metadata by hand.</li></ol><p>The last step is labor intensive.  Suggestions on a better way would be appreciated.</p><h2 id="The-jlcall-calling-convention"><a class="docs-heading-anchor" href="#The-jlcall-calling-convention">The jlcall calling convention</a><a id="The-jlcall-calling-convention-1"></a><a class="docs-heading-anchor-permalink" href="#The-jlcall-calling-convention" title="Permalink"></a></h2><p>Julia has a generic calling convention for unoptimized code, which looks somewhat as follows:</p><pre><code class="language-c">jl_value_t *any_unoptimized_call(jl_value_t *, jl_value_t **, int);</code></pre><p>where the first argument is the boxed function object, the second argument is an on-stack array of arguments and the third is the number of arguments. Now, we could perform a straightforward lowering and emit an alloca for the argument array. However, this would betray the SSA nature of the uses at the call site, making optimizations (including GC root placement), significantly harder. Instead, we emit it as follows:</p><pre><code class="language-llvm">%bitcast = bitcast @any_unoptimized_call to %jl_value_t *(*)(%jl_value_t *, %jl_value_t *)
call cc 37 %jl_value_t *%bitcast(%jl_value_t *%arg1, %jl_value_t *%arg2)</code></pre><p>The special <code>cc 37</code> annotation marks the fact that this call site is really using the jlcall calling convention. This allows us to retain the SSA-ness of the uses throughout the optimizer. GC root placement will later lower this call to the original C ABI. In the code the calling convention number is represented by the <code>JLCALL_F_CC</code> constant. In addition, there is the <code>JLCALL_CC</code> calling convention which functions similarly, but omits the first argument.</p><h2 id="GC-root-placement"><a class="docs-heading-anchor" href="#GC-root-placement">GC root placement</a><a id="GC-root-placement-1"></a><a class="docs-heading-anchor-permalink" href="#GC-root-placement" title="Permalink"></a></h2><p>GC root placement is done by an LLVM pass late in the pass pipeline. Doing GC root placement this late enables LLVM to make more aggressive optimizations around code that requires GC roots, as well as allowing us to reduce the number of required GC roots and GC root store operations (since LLVM doesn&#39;t understand our GC, it wouldn&#39;t otherwise know what it is and is not allowed to do with values stored to the GC frame, so it&#39;ll conservatively do very little). As an example, consider an error path</p><pre><code class="language-julia">if some_condition()
    #= Use some variables maybe =#
    error(&quot;An error occurred&quot;)
end</code></pre><p>During constant folding, LLVM may discover that the condition is always false, and can remove the basic block. However, if GC root lowering is done early, the GC root slots used in the deleted block, as well as any values kept alive in those slots only because they were used in the error path, would be kept alive by LLVM. By doing GC root lowering late, we give LLVM the license to do any of its usual optimizations (constant folding, dead code elimination, etc.), without having to worry (too much) about which values may or may not be GC tracked.</p><p>However, in order to be able to do late GC root placement, we need to be able to identify a) which pointers are GC tracked and b) all uses of such pointers. The goal of the GC placement pass is thus simple:</p><p>Minimize the number of needed GC roots/stores to them subject to the constraint that at every safepoint, any live GC-tracked pointer (i.e. for which there is a path after this point that contains a use of this pointer) is in some GC slot.</p><h3 id="Representation"><a class="docs-heading-anchor" href="#Representation">Representation</a><a id="Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Representation" title="Permalink"></a></h3><p>The primary difficulty is thus choosing an IR representation that allows us to identify GC-tracked pointers and their uses, even after the program has been run through the optimizer. Our design makes use of three LLVM features to achieve this:</p><ul><li>Custom address spaces</li><li>Operand Bundles</li><li>Non-integral pointers</li></ul><p>Custom address spaces allow us to tag every point with an integer that needs to be preserved through optimizations. The compiler may not insert casts between address spaces that did not exist in the original program and it must never change the address space of a pointer on a load/store/etc operation. This allows us to annotate which pointers are GC-tracked in an optimizer-resistant way. Note that metadata would not be able to achieve the same purpose. Metadata is supposed to always be discardable without altering the semantics of the program. However, failing to identify a GC-tracked pointer alters the resulting program behavior dramatically - it&#39;ll probably crash or return wrong results. We currently use three different address spaces (their numbers are defined in <code>src/codegen_shared.cpp</code>):</p><ul><li>GC Tracked Pointers (currently 10): These are pointers to boxed values that may be put into a GC frame. It is loosely equivalent to a <code>jl_value_t*</code> pointer on the C side. N.B. It is illegal to ever have a pointer in this address space that may not be stored to a GC slot.</li><li>Derived Pointers (currently 11): These are pointers that are derived from some GC tracked pointer. Uses of these pointers generate uses of the original pointer. However, they need not themselves be known to the GC. The GC root placement pass MUST always find the GC tracked pointer from which this pointer is derived and use that as the pointer to root.</li><li>Callee Rooted Pointers (currently 12): This is a utility address space to express the notion of a callee rooted value. All values of this address space MUST be storable to a GC root (though it is possible to relax this condition in the future), but unlike the other pointers need not be rooted if passed to a call (they do still need to be rooted if they are live across another safepoint between the definition and the call).</li><li>Pointers loaded from tracked object (currently 13): This is used by arrays, which themselves contain a pointer to the managed data. This data area is owned by the array, but is not a GC-tracked object by itself. The compiler guarantees that as long as this pointer is live, the object that this pointer was loaded from will keep being live.</li></ul><h3 id="Invariants"><a class="docs-heading-anchor" href="#Invariants">Invariants</a><a id="Invariants-1"></a><a class="docs-heading-anchor-permalink" href="#Invariants" title="Permalink"></a></h3><p>The GC root placement pass makes use of several invariants, which need to be observed by the frontend and are preserved by the optimizer.</p><p>First, only the following address space casts are allowed:</p><ul><li>0-&gt;{Tracked,Derived,CalleeRooted}: It is allowable to decay an untracked pointer to any of the others. However, do note that the optimizer has broad license to not root such a value. It is never safe to have a value in address space 0 in any part of the program if it is (or is derived from) a value that requires a GC root.</li><li>Tracked-&gt;Derived: This is the standard decay route for interior values. The placement pass will look for these to identify the base pointer for any use.</li><li>Tracked-&gt;CalleeRooted: Addrspace CalleeRooted serves merely as a hint that a GC root is not required. However, do note that the Derived-&gt;CalleeRooted decay is prohibited, since pointers should generally be storable to a GC slot, even in this address space.</li></ul><p>Now let us consider what constitutes a use:</p><ul><li>Loads whose loaded values is in one of the address spaces</li><li>Stores of a value in one of the address spaces to a location</li><li>Stores to a pointer in one of the address spaces</li><li>Calls for which a value in one of the address spaces is an operand</li><li>Calls in jlcall ABI, for which the argument array contains a value</li><li>Return instructions.</li></ul><p>We explicitly allow load/stores and simple calls in address spaces Tracked/Derived. Elements of jlcall argument arrays must always be in address space Tracked (it is required by the ABI that they are valid <code>jl_value_t*</code> pointers). The same is true for return instructions (though note that struct return arguments are allowed to have any of the address spaces). The only allowable use of an address space CalleeRooted pointer is to pass it to a call (which must have an appropriately typed operand).</p><p>Further, we disallow <code>getelementptr</code> in addrspace Tracked. This is because unless the operation is a noop, the resulting pointer will not be validly storable to a GC slot and may thus not be in this address space. If such a pointer is required, it should be decayed to addrspace Derived first.</p><p>Lastly, we disallow <code>inttoptr</code>/<code>ptrtoint</code> instructions in these address spaces. Having these instructions would mean that some <code>i64</code> values are really GC tracked. This is problematic, because it breaks that stated requirement that we&#39;re able to identify GC-relevant pointers. This invariant is accomplished using the LLVM &quot;non-integral pointers&quot; feature, which is new in LLVM 5.0. It prohibits the optimizer from making optimizations that would introduce these operations. Note we can still insert static constants at JIT time by using <code>inttoptr</code> in address space 0 and then decaying to the appropriate address space afterwards.</p><h3 id="Supporting-[ccall](@ref)"><a class="docs-heading-anchor" href="#Supporting-[ccall](@ref)">Supporting <a href="../../base/c/#ccall"><code>ccall</code></a></a><a id="Supporting-[ccall](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Supporting-[ccall](@ref)" title="Permalink"></a></h3><p>One important aspect missing from the discussion so far is the handling of <a href="../../base/c/#ccall"><code>ccall</code></a>. <a href="../../base/c/#ccall"><code>ccall</code></a> has the peculiar feature that the location and scope of a use do not coincide. As an example consider:</p><pre><code class="language-julia">A = randn(1024)
ccall(:foo, Cvoid, (Ptr{Float64},), A)</code></pre><p>In lowering, the compiler will insert a conversion from the array to the pointer which drops the reference to the array value. However, we of course need to make sure that the array does stay alive while we&#39;re doing the <a href="../../base/c/#ccall"><code>ccall</code></a>. To understand how this is done, first recall the lowering of the above code:</p><pre><code class="language-julia">return $(Expr(:foreigncall, :(:foo), Cvoid, svec(Ptr{Float64}), 0, :(:ccall), Expr(:foreigncall, :(:jl_array_ptr), Ptr{Float64}, svec(Any), 0, :(:ccall), :(A)), :(A)))</code></pre><p>The last <code>:(A)</code>, is an extra argument list inserted during lowering that informs the code generator which Julia level values need to be kept alive for the duration of this <a href="../../base/c/#ccall"><code>ccall</code></a>. We then take this information and represent it in an &quot;operand bundle&quot; at the IR level. An operand bundle is essentially a fake use that is attached to the call site. At the IR level, this looks like so:</p><pre><code class="language-llvm">call void inttoptr (i64 ... to void (double*)*)(double* %5) [ &quot;jl_roots&quot;(%jl_value_t addrspace(10)* %A) ]</code></pre><p>The GC root placement pass will treat the <code>jl_roots</code> operand bundle as if it were a regular operand. However, as a final step, after the GC roots are inserted, it will drop the operand bundle to avoid confusing instruction selection.</p><h3 id="Supporting-[pointer_from_objref](@ref)"><a class="docs-heading-anchor" href="#Supporting-[pointer_from_objref](@ref)">Supporting <a href="../../base/c/#Base.pointer_from_objref"><code>pointer_from_objref</code></a></a><a id="Supporting-[pointer_from_objref](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Supporting-[pointer_from_objref](@ref)" title="Permalink"></a></h3><p><a href="../../base/c/#Base.pointer_from_objref"><code>pointer_from_objref</code></a> is special because it requires the user to take explicit control of GC rooting. By our above invariants, this function is illegal, because it performs an address space cast from 10 to 0. However, it can be useful, in certain situations, so we provide a special intrinsic:</p><pre><code class="language-llvm">declared %jl_value_t *julia.pointer_from_objref(%jl_value_t addrspace(10)*)</code></pre><p>which is lowered to the corresponding address space cast after GC root lowering. Do note however that by using this intrinsic, the caller assumes all responsibility for making sure that the value in question is rooted. Further this intrinsic is not considered a use, so the GC root placement pass will not provide a GC root for the function. As a result, the external rooting must be arranged while the value is still tracked by the system. I.e. it is not valid to attempt to use the result of this operation to establish a global root - the optimizer may have already dropped the value.</p><h3 id="Keeping-values-alive-in-the-absence-of-uses"><a class="docs-heading-anchor" href="#Keeping-values-alive-in-the-absence-of-uses">Keeping values alive in the absence of uses</a><a id="Keeping-values-alive-in-the-absence-of-uses-1"></a><a class="docs-heading-anchor-permalink" href="#Keeping-values-alive-in-the-absence-of-uses" title="Permalink"></a></h3><p>In certain cases it is necessary to keep an object alive, even though there is no compiler-visible use of said object. This may be case for low level code that operates on the memory-representation of an object directly or code that needs to interface with C code. In order to allow this, we provide the following intrinsics at the LLVM level:</p><pre><code class="language-none">token @llvm.julia.gc_preserve_begin(...)
void @llvm.julia.gc_preserve_end(token)</code></pre><p>(The <code>llvm.</code> in the name is required in order to be able to use the <code>token</code> type). The semantics of these intrinsics are as follows: At any safepoint that is dominated by a <code>gc_preserve_begin</code> call, but that is not not dominated by a corresponding <code>gc_preserve_end</code> call (i.e. a call whose argument is the token returned by a <code>gc_preserve_begin</code> call), the values passed as arguments to that <code>gc_preserve_begin</code> will be kept live. Note that the <code>gc_preserve_begin</code> still counts as a regular use of those values, so the standard lifetime semantics will ensure that the values will be kept alive before entering the preserve region.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sysimg/">« System Image Building</a><a class="docs-footer-nextpage" href="../stdio/">printf() and stdio in the Julia runtime »</a><div class="flexbox-break"></div><p class="footer-message">📢📢📢 JuliaCN 2022 冬季见面会 报告<a href="https://cn.julialang.org/meetup-website/2022/">征集</a></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2023 十月 21 周六 14:15">2023 十月 21 周六</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.8.5版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
