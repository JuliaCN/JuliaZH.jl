<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Julia 的 AST · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/ast/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">一维和多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">标准数值类型</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/reflection/">反射 与 自我检查</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox" checked/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../init/">Julia 运行时的初始化</a></li><li class="is-active"><a class="tocitem" href>Julia 的 AST</a><ul class="internal"><li><a class="tocitem" href="#表面语法AST"><span>表面语法AST</span></a></li><li><a class="tocitem" href="#Lowered-form"><span>Lowered form</span></a></li></ul></li><li><a class="tocitem" href="../types/">More about types</a></li><li><a class="tocitem" href="../object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../functions/">Julia 函数</a></li><li><a class="tocitem" href="../cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../subarrays/">子数组</a></li><li><a class="tocitem" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../sysimg/">System Image Building</a></li><li><a class="tocitem" href="../pkgimg/">Package Images</a></li><li><a class="tocitem" href="../llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../boundscheck/">边界检查</a></li><li><a class="tocitem" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../require/">Module loading</a></li><li><a class="tocitem" href="../inference/">类型推导</a></li><li><a class="tocitem" href="../ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../build/linux/">Linux</a></li><li><a class="tocitem" href="../build/macos/">macOS</a></li><li><a class="tocitem" href="../build/windows/">Windows</a></li><li><a class="tocitem" href="../build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Documentation</a></li><li><a class="is-disabled">Documentation of Julia&#39;s Internals</a></li><li class="is-active"><a href>Julia 的 AST</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Julia 的 AST</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/devdocs-zh_cn/translate/#zh_CN/astmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Julia-的-AST"><a class="docs-heading-anchor" href="#Julia-的-AST">Julia 的 AST</a><a id="Julia-的-AST-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-的-AST" title="Permalink"></a></h1><p>Julia 有两种代码的表现形式。 第一种是解析器返回的表面语法 AST （例如 <a href="../../base/base/#Base.Meta.parse-Tuple{AbstractString, Int64}"><code>Meta.parse</code></a> 函数），由宏来操控。是代码编写时的结构化表示，由 <code>julia-parser.scm</code> 用字符流构造而成。 另一种则是底层形式，或者 IR（中间表示），这种形式在进行类型推导和代码生成的时候被使用。在这种底层形式中结点的类型相对更少，所有的宏都会被展开，所有的控制流会被转化成显式的分支和语句的序列。底层的形式由 <code>julia-syntax.scm</code> 构建。</p><p>首先，我们将关注AST，因为需要它来编写宏。</p><h2 id="表面语法AST"><a class="docs-heading-anchor" href="#表面语法AST">表面语法AST</a><a id="表面语法AST-1"></a><a class="docs-heading-anchor-permalink" href="#表面语法AST" title="Permalink"></a></h2><p>前端AST几乎由 <a href="../../base/base/#Core.Expr"><code>Expr</code></a> 和原子（例如 符号、数字）。 对于视觉上不同的语法形式，通常有不同的表达式头。 示例将在s-expression 语法中给出。 每个圆括号括着的列表都对应着一个 Expr，其中第一个元素是它的头部。 例如<code>(call f x)</code>对应于Julia中的 <code>Expr(:call，:f，:x)</code> 。</p><h3 id="调用"><a class="docs-heading-anchor" href="#调用">调用</a><a id="调用-1"></a><a class="docs-heading-anchor-permalink" href="#调用" title="Permalink"></a></h3><table><tr><th style="text-align: left">输入</th><th style="text-align: left">AST</th></tr><tr><td style="text-align: left"><code>f(x)</code></td><td style="text-align: left"><code>(call f x)</code></td></tr><tr><td style="text-align: left"><code>f(x, y=1, z=2)</code></td><td style="text-align: left"><code>(call f x (kw y 1) (kw z 2))</code></td></tr><tr><td style="text-align: left"><code>f(x; y=1)</code></td><td style="text-align: left"><code>(call f (parameters (kw y 1)) x)</code></td></tr><tr><td style="text-align: left"><code>f(x...)</code></td><td style="text-align: left"><code>(call f (... x))</code></td></tr></table><p><code>do</code> syntax:</p><pre><code class="language-julia">f(x) do a,b
    body
end</code></pre><p>parses as <code>(do (call f x) (-&gt; (tuple a b) (block body)))</code>.</p><h3 id="运算符"><a class="docs-heading-anchor" href="#运算符">运算符</a><a id="运算符-1"></a><a class="docs-heading-anchor-permalink" href="#运算符" title="Permalink"></a></h3><p>Most uses of operators are just function calls, so they are parsed with the head <code>call</code>. However some operators are special forms (not necessarily function calls), and in those cases the operator itself is the expression head. In julia-parser.scm these are referred to as &quot;syntactic operators&quot;. Some operators (<code>+</code> and <code>*</code>) use N-ary parsing; chained calls are parsed as a single N-argument call. Finally, chains of comparisons have their own special expression structure.</p><table><tr><th style="text-align: left">Input</th><th style="text-align: left">AST</th></tr><tr><td style="text-align: left"><code>x+y</code></td><td style="text-align: left"><code>(call + x y)</code></td></tr><tr><td style="text-align: left"><code>a+b+c+d</code></td><td style="text-align: left"><code>(call + a b c d)</code></td></tr><tr><td style="text-align: left"><code>2x</code></td><td style="text-align: left"><code>(call * 2 x)</code></td></tr><tr><td style="text-align: left"><code>a&amp;&amp;b</code></td><td style="text-align: left"><code>(&amp;&amp; a b)</code></td></tr><tr><td style="text-align: left"><code>x += 1</code></td><td style="text-align: left"><code>(+= x 1)</code></td></tr><tr><td style="text-align: left"><code>a ? 1 : 2</code></td><td style="text-align: left"><code>(if a 1 2)</code></td></tr><tr><td style="text-align: left"><code>a,b</code></td><td style="text-align: left"><code>(tuple a b)</code></td></tr><tr><td style="text-align: left"><code>a==b</code></td><td style="text-align: left"><code>(call == a b)</code></td></tr><tr><td style="text-align: left"><code>1&lt;i&lt;=n</code></td><td style="text-align: left"><code>(comparison 1 &lt; i &lt;= n)</code></td></tr><tr><td style="text-align: left"><code>a.b</code></td><td style="text-align: left"><code>(. a (quote b))</code></td></tr><tr><td style="text-align: left"><code>a.(b)</code></td><td style="text-align: left"><code>(. a (tuple b))</code></td></tr></table><h3 id="Bracketed-forms"><a class="docs-heading-anchor" href="#Bracketed-forms">Bracketed forms</a><a id="Bracketed-forms-1"></a><a class="docs-heading-anchor-permalink" href="#Bracketed-forms" title="Permalink"></a></h3><table><tr><th style="text-align: left">Input</th><th style="text-align: left">AST</th></tr><tr><td style="text-align: left"><code>a[i]</code></td><td style="text-align: left"><code>(ref a i)</code></td></tr><tr><td style="text-align: left"><code>t[i;j]</code></td><td style="text-align: left"><code>(typed_vcat t i j)</code></td></tr><tr><td style="text-align: left"><code>t[i j]</code></td><td style="text-align: left"><code>(typed_hcat t i j)</code></td></tr><tr><td style="text-align: left"><code>t[a b; c d]</code></td><td style="text-align: left"><code>(typed_vcat t (row a b) (row c d))</code></td></tr><tr><td style="text-align: left"><code>t[a b;;; c d]</code></td><td style="text-align: left"><code>(typed_ncat t 3 (row a b) (row c d))</code></td></tr><tr><td style="text-align: left"><code>a{b}</code></td><td style="text-align: left"><code>(curly a b)</code></td></tr><tr><td style="text-align: left"><code>a{b;c}</code></td><td style="text-align: left"><code>(curly a (parameters c) b)</code></td></tr><tr><td style="text-align: left"><code>[x]</code></td><td style="text-align: left"><code>(vect x)</code></td></tr><tr><td style="text-align: left"><code>[x,y]</code></td><td style="text-align: left"><code>(vect x y)</code></td></tr><tr><td style="text-align: left"><code>[x;y]</code></td><td style="text-align: left"><code>(vcat x y)</code></td></tr><tr><td style="text-align: left"><code>[x y]</code></td><td style="text-align: left"><code>(hcat x y)</code></td></tr><tr><td style="text-align: left"><code>[x y; z t]</code></td><td style="text-align: left"><code>(vcat (row x y) (row z t))</code></td></tr><tr><td style="text-align: left"><code>[x;y;; z;t;;;]</code></td><td style="text-align: left"><code>(ncat 3 (nrow 2 (nrow 1 x y) (nrow 1 z t)))</code></td></tr><tr><td style="text-align: left"><code>[x for y in z, a in b]</code></td><td style="text-align: left"><code>(comprehension (generator x (= y z) (= a b)))</code></td></tr><tr><td style="text-align: left"><code>T[x for y in z]</code></td><td style="text-align: left"><code>(typed_comprehension T (generator x (= y z)))</code></td></tr><tr><td style="text-align: left"><code>(a, b, c)</code></td><td style="text-align: left"><code>(tuple a b c)</code></td></tr><tr><td style="text-align: left"><code>(a; b; c)</code></td><td style="text-align: left"><code>(block a b c)</code></td></tr></table><h3 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h3><table><tr><th style="text-align: left">Input</th><th style="text-align: left">AST</th></tr><tr><td style="text-align: left"><code>@m x y</code></td><td style="text-align: left"><code>(macrocall @m (line) x y)</code></td></tr><tr><td style="text-align: left"><code>Base.@m x y</code></td><td style="text-align: left"><code>(macrocall (. Base (quote @m)) (line) x y)</code></td></tr><tr><td style="text-align: left"><code>@Base.m x y</code></td><td style="text-align: left"><code>(macrocall (. Base (quote @m)) (line) x y)</code></td></tr></table><h3 id="Strings"><a class="docs-heading-anchor" href="#Strings">Strings</a><a id="Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Strings" title="Permalink"></a></h3><table><tr><th style="text-align: left">Input</th><th style="text-align: left">AST</th></tr><tr><td style="text-align: left"><code>&quot;a&quot;</code></td><td style="text-align: left"><code>&quot;a&quot;</code></td></tr><tr><td style="text-align: left"><code>x&quot;y&quot;</code></td><td style="text-align: left"><code>(macrocall @x_str (line) &quot;y&quot;)</code></td></tr><tr><td style="text-align: left"><code>x&quot;y&quot;z</code></td><td style="text-align: left"><code>(macrocall @x_str (line) &quot;y&quot; &quot;z&quot;)</code></td></tr><tr><td style="text-align: left"><code>&quot;x = $x&quot;</code></td><td style="text-align: left"><code>(string &quot;x = &quot; x)</code></td></tr><tr><td style="text-align: left"><code>`a b c`</code></td><td style="text-align: left"><code>(macrocall @cmd (line) &quot;a b c&quot;)</code></td></tr></table><p>Doc string syntax:</p><pre><code class="language-julia">&quot;some docs&quot;
f(x) = x</code></pre><p>parses as <code>(macrocall (|.| Core &#39;@doc) (line) &quot;some docs&quot; (= (call f x) (block x)))</code>.</p><h3 id="Imports-and-such"><a class="docs-heading-anchor" href="#Imports-and-such">Imports and such</a><a id="Imports-and-such-1"></a><a class="docs-heading-anchor-permalink" href="#Imports-and-such" title="Permalink"></a></h3><table><tr><th style="text-align: left">Input</th><th style="text-align: left">AST</th></tr><tr><td style="text-align: left"><code>import a</code></td><td style="text-align: left"><code>(import (. a))</code></td></tr><tr><td style="text-align: left"><code>import a.b.c</code></td><td style="text-align: left"><code>(import (. a b c))</code></td></tr><tr><td style="text-align: left"><code>import ...a</code></td><td style="text-align: left"><code>(import (. . . . a))</code></td></tr><tr><td style="text-align: left"><code>import a.b, c.d</code></td><td style="text-align: left"><code>(import (. a b) (. c d))</code></td></tr><tr><td style="text-align: left"><code>import Base: x</code></td><td style="text-align: left"><code>(import (: (. Base) (. x)))</code></td></tr><tr><td style="text-align: left"><code>import Base: x, y</code></td><td style="text-align: left"><code>(import (: (. Base) (. x) (. y)))</code></td></tr><tr><td style="text-align: left"><code>export a, b</code></td><td style="text-align: left"><code>(export a b)</code></td></tr></table><p><code>using</code> has the same representation as <code>import</code>, but with expression head <code>:using</code> instead of <code>:import</code>.</p><h3 id="Numbers"><a class="docs-heading-anchor" href="#Numbers">Numbers</a><a id="Numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Numbers" title="Permalink"></a></h3><p>Julia supports more number types than many scheme implementations, so not all numbers are represented directly as scheme numbers in the AST.</p><table><tr><th style="text-align: left">Input</th><th style="text-align: left">AST</th></tr><tr><td style="text-align: left"><code>11111111111111111111</code></td><td style="text-align: left"><code>(macrocall @int128_str nothing &quot;11111111111111111111&quot;)</code></td></tr><tr><td style="text-align: left"><code>0xfffffffffffffffff</code></td><td style="text-align: left"><code>(macrocall @uint128_str nothing &quot;0xfffffffffffffffff&quot;)</code></td></tr><tr><td style="text-align: left"><code>1111...many digits...</code></td><td style="text-align: left"><code>(macrocall @big_str nothing &quot;1111....&quot;)</code></td></tr></table><h3 id="Block-forms"><a class="docs-heading-anchor" href="#Block-forms">Block forms</a><a id="Block-forms-1"></a><a class="docs-heading-anchor-permalink" href="#Block-forms" title="Permalink"></a></h3><p>A block of statements is parsed as <code>(block stmt1 stmt2 ...)</code>.</p><p>If statement:</p><pre><code class="language-julia">if a
    b
elseif c
    d
else
    e
end</code></pre><p>parses as:</p><pre><code class="language-none">(if a (block (line 2) b)
    (elseif (block (line 3) c) (block (line 4) d)
            (block (line 6 e))))</code></pre><p>A <code>while</code> loop parses as <code>(while condition body)</code>.</p><p>A <code>for</code> loop parses as <code>(for (= var iter) body)</code>. If there is more than one iteration specification, they are parsed as a block: <code>(for (block (= v1 iter1) (= v2 iter2)) body)</code>.</p><p><code>break</code> and <code>continue</code> are parsed as 0-argument expressions <code>(break)</code> and <code>(continue)</code>.</p><p><code>let</code> is parsed as <code>(let (= var val) body)</code> or <code>(let (block (= var1 val1) (= var2 val2) ...) body)</code>, like <code>for</code> loops.</p><p>A basic function definition is parsed as <code>(function (call f x) body)</code>. A more complex example:</p><pre><code class="language-julia">function f(x::T; k = 1) where T
    return x+1
end</code></pre><p>parses as:</p><pre><code class="language-none">(function (where (call f (parameters (kw k 1))
                       (:: x T))
                 T)
          (block (line 2) (return (call + x 1))))</code></pre><p>Type definition:</p><pre><code class="language-julia">mutable struct Foo{T&lt;:S}
    x::T
end</code></pre><p>parses as:</p><pre><code class="language-none">(struct true (curly Foo (&lt;: T S))
        (block (line 2) (:: x T)))</code></pre><p>The first argument is a boolean telling whether the type is mutable.</p><p><code>try</code> blocks parse as <code>(try try_block var catch_block finally_block)</code>. If no variable is present after <code>catch</code>, <code>var</code> is <code>#f</code>. If there is no <code>finally</code> clause, then the last argument is not present.</p><h3 id="Quote-expressions"><a class="docs-heading-anchor" href="#Quote-expressions">Quote expressions</a><a id="Quote-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Quote-expressions" title="Permalink"></a></h3><p>Julia source syntax forms for code quoting (<code>quote</code> and <code>:( )</code>) support interpolation with <code>$</code>. In Lisp terminology, this means they are actually &quot;backquote&quot; or &quot;quasiquote&quot; forms. Internally, there is also a need for code quoting without interpolation. In Julia&#39;s scheme code, non-interpolating quote is represented with the expression head <code>inert</code>.</p><p><code>inert</code> expressions are converted to Julia <code>QuoteNode</code> objects. These objects wrap a single value of any type, and when evaluated simply return that value.</p><p>A <code>quote</code> expression whose argument is an atom also gets converted to a <code>QuoteNode</code>.</p><h3 id="Line-numbers"><a class="docs-heading-anchor" href="#Line-numbers">Line numbers</a><a id="Line-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Line-numbers" title="Permalink"></a></h3><p>Source location information is represented as <code>(line line_num file_name)</code> where the third component is optional (and omitted when the current line number, but not file name, changes).</p><p>These expressions are represented as <code>LineNumberNode</code>s in Julia.</p><h3 id="Macros-2"><a class="docs-heading-anchor" href="#Macros-2">Macros</a><a class="docs-heading-anchor-permalink" href="#Macros-2" title="Permalink"></a></h3><p>Macro hygiene is represented through the expression head pair <code>escape</code> and <code>hygienic-scope</code>. The result of a macro expansion is automatically wrapped in <code>(hygienic-scope block module)</code>, to represent the result of the new scope. The user can insert <code>(escape block)</code> inside to interpolate code from the caller.</p><h2 id="Lowered-form"><a class="docs-heading-anchor" href="#Lowered-form">Lowered form</a><a id="Lowered-form-1"></a><a class="docs-heading-anchor-permalink" href="#Lowered-form" title="Permalink"></a></h2><p>Lowered form (IR) is more important to the compiler, since it is used for type inference, optimizations like inlining, and code generation. It is also less obvious to the human, since it results from a significant rearrangement of the input syntax.</p><p>In addition to <code>Symbol</code>s and some number types, the following data types exist in lowered form:</p><ul><li><p><code>Expr</code></p><p>Has a node type indicated by the <code>head</code> field, and an <code>args</code> field which is a <code>Vector{Any}</code> of subexpressions. While almost every part of a surface AST is represented by an <code>Expr</code>, the IR uses only a limited number of <code>Expr</code>s, mostly for calls and some top-level-only forms.</p></li><li><p><code>SlotNumber</code></p><p>Identifies arguments and local variables by consecutive numbering. It has an integer-valued <code>id</code> field giving the slot index. The types of these slots can be found in the <code>slottypes</code> field of their <code>CodeInfo</code> object. When a slot has different types at different uses and thus requires per-use type annotations, they are converted to temporary <code>Core.Compiler.TypedSlot</code> object. This object has an additional <code>typ</code> field as well as the <code>id</code> field. Note that <code>Core.Compiler.TypedSlot</code> only appears in an unoptimized lowered form that is scheduled for optimization, and it never appears elsewhere.</p></li><li><p><code>Argument</code></p><p>The same as <code>SlotNumber</code>, but appears only post-optimization. Indicates that the referenced slot is an argument of the enclosing function.</p></li><li><p><code>CodeInfo</code></p><p>Wraps the IR of a group of statements. Its <code>code</code> field is an array of expressions to execute.</p></li><li><p><code>GotoNode</code></p><p>Unconditional branch. The argument is the branch target, represented as an index in the code array to jump to.</p></li><li><p><code>GotoIfNot</code></p><p>Conditional branch. If the <code>cond</code> field evaluates to false, goes to the index identified by the <code>dest</code> field.</p></li><li><p><code>ReturnNode</code></p><p>Returns its argument (the <code>val</code> field) as the value of the enclosing function. If the <code>val</code> field is undefined, then this represents an unreachable statement.</p></li><li><p><code>QuoteNode</code></p><p>Wraps an arbitrary value to reference as data. For example, the function <code>f() = :a</code> contains a <code>QuoteNode</code> whose <code>value</code> field is the symbol <code>a</code>, in order to return the symbol itself instead of evaluating it.</p></li><li><p><code>GlobalRef</code></p><p>Refers to global variable <code>name</code> in module <code>mod</code>.</p></li><li><p><code>SSAValue</code></p><p>Refers to a consecutively-numbered (starting at 1) static single assignment (SSA) variable inserted by the compiler. The number (<code>id</code>) of an <code>SSAValue</code> is the code array index of the expression whose value it represents.</p></li><li><p><code>NewvarNode</code></p><p>Marks a point where a variable (slot) is created. This has the effect of resetting a variable to undefined.</p></li></ul><h3 id="Expr-types"><a class="docs-heading-anchor" href="#Expr-types"><code>Expr</code> types</a><a id="Expr-types-1"></a><a class="docs-heading-anchor-permalink" href="#Expr-types" title="Permalink"></a></h3><p>These symbols appear in the <code>head</code> field of <a href="../../base/base/#Core.Expr"><code>Expr</code></a>s in lowered form.</p><ul><li><p><code>call</code></p><p>Function call (dynamic dispatch). <code>args[1]</code> is the function to call, <code>args[2:end]</code> are the arguments.</p></li><li><p><code>invoke</code></p><p>Function call (static dispatch). <code>args[1]</code> is the MethodInstance to call, <code>args[2:end]</code> are the arguments (including the function that is being called, at <code>args[2]</code>).</p></li><li><p><code>static_parameter</code></p><p>Reference a static parameter by index.</p></li><li><p><code>=</code></p><p>Assignment. In the IR, the first argument is always a <code>SlotNumber</code> or a <code>GlobalRef</code>.</p></li><li><p><code>method</code></p><p>Adds a method to a generic function and assigns the result if necessary.</p><p>Has a 1-argument form and a 3-argument form. The 1-argument form arises from the syntax <code>function foo end</code>. In the 1-argument form, the argument is a symbol. If this symbol already names a function in the current scope, nothing happens. If the symbol is undefined, a new function is created and assigned to the identifier specified by the symbol. If the symbol is defined but names a non-function, an error is raised. The definition of &quot;names a function&quot; is that the binding is constant, and refers to an object of singleton type. The rationale for this is that an instance of a singleton type uniquely identifies the type to add the method to. When the type has fields, it wouldn&#39;t be clear whether the method was being added to the instance or its type.</p><p>The 3-argument form has the following arguments:</p><ul><li><p><code>args[1]</code></p><p>A function name, or <code>nothing</code> if unknown or unneeded. If a symbol, then the expression first behaves like the 1-argument form above. This argument is ignored from then on. It can be <code>nothing</code> when methods are added strictly by type, <code>(::T)(x) = x</code>, or when a method is being added to an existing function, <code>MyModule.f(x) = x</code>.</p></li><li><p><code>args[2]</code></p><p>A <code>SimpleVector</code> of argument type data. <code>args[2][1]</code> is a <code>SimpleVector</code> of the argument types, and <code>args[2][2]</code> is a <code>SimpleVector</code> of type variables corresponding to the method&#39;s static parameters.</p></li><li><p><code>args[3]</code></p><p>A <code>CodeInfo</code> of the method itself. For &quot;out of scope&quot; method definitions (adding a method to a function that also has methods defined in different scopes) this is an expression that evaluates to a <code>:lambda</code> expression.</p></li></ul></li><li><p><code>struct_type</code></p><p>A 7-argument expression that defines a new <code>struct</code>:</p><ul><li><p><code>args[1]</code></p><p>The name of the <code>struct</code></p></li><li><p><code>args[2]</code></p><p>A <code>call</code> expression that creates a <code>SimpleVector</code> specifying its parameters</p></li><li><p><code>args[3]</code></p><p>A <code>call</code> expression that creates a <code>SimpleVector</code> specifying its fieldnames</p></li><li><p><code>args[4]</code></p><p>A <code>Symbol</code>, <code>GlobalRef</code>, or <code>Expr</code> specifying the supertype (e.g., <code>:Integer</code>, <code>GlobalRef(Core, :Any)</code>, or <code>:(Core.apply_type(AbstractArray, T, N))</code>)</p></li><li><p><code>args[5]</code></p><p>A <code>call</code> expression that creates a <code>SimpleVector</code> specifying its fieldtypes</p></li><li><p><code>args[6]</code></p><p>A Bool, true if <code>mutable</code></p></li><li><p><code>args[7]</code></p><p>The number of arguments to initialize. This will be the number of fields, or the minimum number of fields called by an inner constructor&#39;s <code>new</code> statement.</p></li></ul></li><li><p><code>abstract_type</code></p><p>A 3-argument expression that defines a new abstract type. The arguments are the same as arguments 1, 2, and 4 of <code>struct_type</code> expressions.</p></li><li><p><code>primitive_type</code></p><p>A 4-argument expression that defines a new primitive type. Arguments 1, 2, and 4 are the same as <code>struct_type</code>. Argument 3 is the number of bits.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>struct_type</code>, <code>abstract_type</code>, and <code>primitive_type</code> were removed in Julia 1.5 and replaced by calls to new builtins.</p></div></div></li><li><p><code>global</code></p><p>Declares a global binding.</p></li><li><p><code>const</code></p><p>Declares a (global) variable as constant.</p></li><li><p><code>new</code></p><p>Allocates a new struct-like object. First argument is the type. The <a href="../../base/base/#new"><code>new</code></a> pseudo-function is lowered to this, and the type is always inserted by the compiler.  This is very much an internal-only feature, and does no checking. Evaluating arbitrary <code>new</code> expressions can easily segfault.</p></li><li><p><code>splatnew</code></p><p>Similar to <code>new</code>, except field values are passed as a single tuple. Works similarly to <code>splat(new)</code> if <code>new</code> were a first-class function, hence the name.</p></li><li><p><code>isdefined</code></p><p><code>Expr(:isdefined, :x)</code> returns a Bool indicating whether <code>x</code> has already been defined in the current scope.</p></li><li><p><code>the_exception</code></p><p>Yields the caught exception inside a <code>catch</code> block, as returned by <code>jl_current_exception()</code>.</p></li><li><p><code>enter</code></p><p>Enters an exception handler (<code>setjmp</code>). <code>args[1]</code> is the label of the catch block to jump to on error.  Yields a token which is consumed by <code>pop_exception</code>.</p></li><li><p><code>leave</code></p><p>Pop exception handlers. <code>args[1]</code> is the number of handlers to pop.</p></li><li><p><code>pop_exception</code></p><p>Pop the stack of current exceptions back to the state at the associated <code>enter</code> when leaving a catch block. <code>args[1]</code> contains the token from the associated <code>enter</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p><code>pop_exception</code> is new in Julia 1.1.</p></div></div></li><li><p><code>inbounds</code></p><p>Controls turning bounds checks on or off. A stack is maintained; if the first argument of this expression is true or false (<code>true</code> means bounds checks are disabled), it is pushed onto the stack. If the first argument is <code>:pop</code>, the stack is popped.</p></li><li><p><code>boundscheck</code></p><p>Has the value <code>false</code> if inlined into a section of code marked with <code>@inbounds</code>, otherwise has the value <code>true</code>.</p></li><li><p><code>loopinfo</code></p><p>Marks the end of the a loop. Contains metadata that is passed to <code>LowerSimdLoop</code> to either mark the inner loop of <code>@simd</code> expression, or to propagate information to LLVM loop passes.</p></li><li><p><code>copyast</code></p><p>Part of the implementation of quasi-quote. The argument is a surface syntax AST that is simply copied recursively and returned at run time.</p></li><li><p><code>meta</code></p><p>Metadata. <code>args[1]</code> is typically a symbol specifying the kind of metadata, and the rest of the arguments are free-form. The following kinds of metadata are commonly used:</p><ul><li><code>:inline</code> and <code>:noinline</code>: Inlining hints.</li></ul></li><li><p><code>foreigncall</code></p><p>Statically-computed container for <code>ccall</code> information. The fields are:</p><ul><li><p><code>args[1]</code> : name</p><p>The expression that&#39;ll be parsed for the foreign function.</p></li><li><p><code>args[2]::Type</code> : RT</p><p>The (literal) return type, computed statically when the containing method was defined.</p></li><li><p><code>args[3]::SimpleVector</code> (of Types) : AT</p><p>The (literal) vector of argument types, computed statically when the containing method was defined.</p></li><li><p><code>args[4]::Int</code> : nreq</p><p>The number of required arguments for a varargs function definition.</p></li><li><p><code>args[5]::QuoteNode{Symbol}</code> : calling convention</p><p>The calling convention for the call.</p></li><li><p><code>args[6:5+length(args[3])]</code> : arguments</p><p>The values for all the arguments (with types of each given in args[3]).</p></li><li><p><code>args[6+length(args[3])+1:end]</code> : gc-roots</p><p>The additional objects that may need to be gc-rooted for the duration of the call. See <a href="../llvm/#Working-with-LLVM">Working with LLVM</a> for where these are derived from and how they get handled.</p></li></ul></li><li><p><code>new_opaque_closure</code></p><p>Constructs a new opaque closure. The fields are:</p><ul><li><p><code>args[1]</code> : signature</p><p>The function signature of the opaque closure. Opaque closures don&#39;t participate in dispatch, but the input types can be restricted.</p></li><li><p><code>args[2]</code> : isva</p><p>Indicates whether the closure accepts varargs.</p></li><li><p><code>args[3]</code> : lb</p><p>Lower bound on the output type. (Defaults to <code>Union{}</code>)</p></li><li><p><code>args[4]</code> : ub</p><p>Upper bound on the output type. (Defaults to <code>Any</code>)</p></li><li><p><code>args[5]</code> : method</p><p>The actual method as an <code>opaque_closure_method</code> expression.</p></li><li><p><code>args[6:end]</code> : captures</p><p>The values captured by the opaque closure.</p></li></ul><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>Opaque closures were added in Julia 1.7</p></div></div></li></ul><h3 id="ast-lowered-method"><a class="docs-heading-anchor" href="#ast-lowered-method">Method</a><a id="ast-lowered-method-1"></a><a class="docs-heading-anchor-permalink" href="#ast-lowered-method" title="Permalink"></a></h3><p>A unique&#39;d container describing the shared metadata for a single method.</p><ul><li><p><code>name</code>, <code>module</code>, <code>file</code>, <code>line</code>, <code>sig</code></p><p>Metadata to uniquely identify the method for the computer and the human.</p></li><li><p><code>ambig</code></p><p>Cache of other methods that may be ambiguous with this one.</p></li><li><p><code>specializations</code></p><p>Cache of all MethodInstance ever created for this Method, used to ensure uniqueness. Uniqueness is required for efficiency, especially for incremental precompile and tracking of method invalidation.</p></li><li><p><code>source</code></p><p>The original source code (if available, usually compressed).</p></li><li><p><code>generator</code></p><p>A callable object which can be executed to get specialized source for a specific method signature.</p></li><li><p><code>roots</code></p><p>Pointers to non-AST things that have been interpolated into the AST, required by compression of the AST, type-inference, or the generation of native code.</p></li><li><p><code>nargs</code>, <code>isva</code>, <code>called</code>, <code>is_for_opaque_closure</code>,</p><p>Descriptive bit-fields for the source code of this Method.</p></li><li><p><code>primary_world</code></p><p>The world age that &quot;owns&quot; this Method.</p></li></ul><h3 id="MethodInstance"><a class="docs-heading-anchor" href="#MethodInstance">MethodInstance</a><a id="MethodInstance-1"></a><a class="docs-heading-anchor-permalink" href="#MethodInstance" title="Permalink"></a></h3><p>A unique&#39;d container describing a single callable signature for a Method. See especially <a href="../locks/#Proper-maintenance-and-care-of-multi-threading-locks">Proper maintenance and care of multi-threading locks</a> for important details on how to modify these fields safely.</p><ul><li><p><code>specTypes</code></p><p>The primary key for this MethodInstance. Uniqueness is guaranteed through a <code>def.specializations</code> lookup.</p></li><li><p><code>def</code></p><p>The <code>Method</code> that this function describes a specialization of. Or a <code>Module</code>, if this is a top-level Lambda expanded in Module, and which is not part of a Method.</p></li><li><p><code>sparam_vals</code></p><p>The values of the static parameters in <code>specTypes</code> indexed by <code>def.sparam_syms</code>. For the <code>MethodInstance</code> at <code>Method.unspecialized</code>, this is the empty <code>SimpleVector</code>. But for a runtime <code>MethodInstance</code> from the <code>MethodTable</code> cache, this will always be defined and indexable.</p></li><li><p><code>uninferred</code></p><p>The uncompressed source code for a toplevel thunk. Additionally, for a generated function, this is one of many places that the source code might be found.</p></li><li><p><code>backedges</code></p><p>We store the reverse-list of cache dependencies for efficient tracking of incremental reanalysis/recompilation work that may be needed after a new method definitions. This works by keeping a list of the other <code>MethodInstance</code> that have been inferred or optimized to contain a possible call to this <code>MethodInstance</code>. Those optimization results might be stored somewhere in the <code>cache</code>, or it might have been the result of something we didn&#39;t want to cache, such as constant propagation. Thus we merge all of those backedges to various cache entries here (there&#39;s almost always only the one applicable cache entry with a sentinel value for max_world anyways).</p></li><li><p><code>cache</code></p><p>Cache of <code>CodeInstance</code> objects that share this template instantiation.</p></li></ul><h3 id="CodeInstance"><a class="docs-heading-anchor" href="#CodeInstance">CodeInstance</a><a id="CodeInstance-1"></a><a class="docs-heading-anchor-permalink" href="#CodeInstance" title="Permalink"></a></h3><ul><li><p><code>def</code></p><p>The <code>MethodInstance</code> that this cache entry is derived from.</p></li></ul><ul><li><p><code>rettype</code>/<code>rettype_const</code></p><p>The inferred return type for the <code>specFunctionObject</code> field, which (in most cases) is also the computed return type for the function in general.</p></li><li><p><code>inferred</code></p><p>May contain a cache of the inferred source for this function, or it could be set to <code>nothing</code> to just indicate <code>rettype</code> is inferred.</p></li><li><p><code>ftpr</code></p><p>The generic jlcall entry point.</p></li><li><p><code>jlcall_api</code></p><p>The ABI to use when calling <code>fptr</code>. Some significant ones include:</p><ul><li>0 - Not compiled yet</li><li>1 - <code>JL_CALLABLE</code> <code>jl_value_t *(*)(jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)</code></li><li>2 - Constant (value stored in <code>rettype_const</code>)</li><li>3 - With Static-parameters forwarded <code>jl_value_t *(*)(jl_svec_t *sparams, jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)</code></li><li>4 - Run in interpreter <code>jl_value_t *(*)(jl_method_instance_t *meth, jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)</code></li></ul></li><li><p><code>min_world</code> / <code>max_world</code></p><p>The range of world ages for which this method instance is valid to be called. If max_world is the special token value <code>-1</code>, the value is not yet known. It may continue to be used until we encounter a backedge that requires us to reconsider.</p></li></ul><h3 id="CodeInfo"><a class="docs-heading-anchor" href="#CodeInfo">CodeInfo</a><a id="CodeInfo-1"></a><a class="docs-heading-anchor-permalink" href="#CodeInfo" title="Permalink"></a></h3><p>A (usually temporary) container for holding lowered source code.</p><ul><li><p><code>code</code></p><p>An <code>Any</code> array of statements</p></li><li><p><code>slotnames</code></p><p>An array of symbols giving names for each slot (argument or local variable).</p></li><li><p><code>slotflags</code></p><p>A <code>UInt8</code> array of slot properties, represented as bit flags:</p><ul><li>0x02 - assigned (only false if there are <em>no</em> assignment statements with this var on the left)</li><li>0x08 - used (if there is any read or write of the slot)</li><li>0x10 - statically assigned once</li><li>0x20 - might be used before assigned. This flag is only valid after type inference.</li></ul></li><li><p><code>ssavaluetypes</code></p><p>Either an array or an <code>Int</code>.</p><p>If an <code>Int</code>, it gives the number of compiler-inserted temporary locations in the function (the length of <code>code</code> array). If an array, specifies a type for each location.</p></li><li><p><code>ssaflags</code></p><p>Statement-level flags for each expression in the function. Many of these are reserved, but not yet implemented:</p><ul><li>0x01 &lt;&lt; 0 = statement is marked as <code>@inbounds</code></li><li>0x01 &lt;&lt; 1 = statement is marked as <code>@inline</code></li><li>0x01 &lt;&lt; 2 = statement is marked as <code>@noinline</code></li><li>0x01 &lt;&lt; 3 = statement is within a block that leads to <code>throw</code> call</li><li>0x01 &lt;&lt; 4 = statement may be removed if its result is unused, in particular it is thus be both pure and effect free</li><li>0x01 &lt;&lt; 5-6 = &lt;unused&gt;</li><li>0x01 &lt;&lt; 7 = &lt;reserved&gt; has out-of-band info</li></ul></li><li><p><code>linetable</code></p><p>An array of source location objects</p></li><li><p><code>codelocs</code></p><p>An array of integer indices into the <code>linetable</code>, giving the location associated with each statement.</p></li></ul><p>Optional Fields:</p><ul><li><p><code>slottypes</code></p><p>An array of types for the slots.</p></li><li><p><code>rettype</code></p><p>The inferred return type of the lowered form (IR). Default value is <code>Any</code>.</p></li><li><p><code>method_for_inference_limit_heuristics</code></p><p>The <code>method_for_inference_heuristics</code> will expand the given method&#39;s generator if necessary during inference.</p></li><li><p><code>parent</code></p><p>The <code>MethodInstance</code> that &quot;owns&quot; this object (if applicable).</p></li><li><p><code>edges</code></p><p>Forward edges to method instances that must be invalidated.</p></li><li><p><code>min_world</code>/<code>max_world</code></p><p>The range of world ages for which this code was valid at the time when it had been inferred.</p></li></ul><p>Boolean properties:</p><ul><li><p><code>inferred</code></p><p>Whether this has been produced by type inference.</p></li><li><p><code>inlineable</code></p><p>Whether this should be eligible for inlining.</p></li><li><p><code>propagate_inbounds</code></p><p>Whether this should propagate <code>@inbounds</code> when inlined for the purpose of eliding <code>@boundscheck</code> blocks.</p></li></ul><p><code>UInt8</code> settings:</p><ul><li><p><code>constprop</code></p><ul><li>0 = use heuristic</li><li>1 = aggressive</li><li>2 = none</li></ul></li><li><p><code>purity</code> Constructed from 5 bit flags:</p><ul><li>0x01 &lt;&lt; 0 = this method is guaranteed to return or terminate consistently (<code>:consistent</code>)</li><li>0x01 &lt;&lt; 1 = this method is free from externally semantically visible side effects (<code>:effect_free</code>)</li><li>0x01 &lt;&lt; 2 = this method is guaranteed to not throw an exception (<code>:nothrow</code>)</li><li>0x01 &lt;&lt; 3 = this method is guaranteed to terminate (<code>:terminates_globally</code>)</li><li>0x01 &lt;&lt; 4 = the syntactic control flow within this method is guaranteed to terminate (<code>:terminates_locally</code>)</li></ul><p>See the documentation of <code>Base.@assume_effects</code> for more details.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../init/">« Julia 运行时的初始化</a><a class="docs-footer-nextpage" href="../types/">More about types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2024 十二月 16 周一 10:06">2024 十二月 16 周一</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.10.7版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
