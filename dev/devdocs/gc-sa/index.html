<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Static analyzer annotations for GC correctness in C code · Julia 中文文档</title><meta name="title" content="Static analyzer annotations for GC correctness in C code · Julia 中文文档"/><meta property="og:title" content="Static analyzer annotations for GC correctness in C code · Julia 中文文档"/><meta property="twitter:title" content="Static analyzer annotations for GC correctness in C code · Julia 中文文档"/><meta name="description" content="Documentation for Julia 中文文档."/><meta property="og:description" content="Documentation for Julia 中文文档."/><meta property="twitter:description" content="Documentation for Julia 中文文档."/><meta property="og:url" content="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/gc-sa/"/><meta property="twitter:url" content="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/gc-sa/"/><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/gc-sa/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia 中文文档 logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">一维和多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">数值类型</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">任务</a></li><li><a class="tocitem" href="../../base/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/reflection/">反射与内省</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">标准库</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/ArgTools/">ArgTools</a></li><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibCURL/">LibCURL</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/NetworkOptions/">Network Options</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Tar/">Tar</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">开发者文档</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox" checked/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../types/">More about types</a></li><li><a class="tocitem" href="../object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../functions/">Julia 函数</a></li><li><a class="tocitem" href="../cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../subarrays/">子数组</a></li><li><a class="tocitem" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../sysimg/">System Image Building</a></li><li><a class="tocitem" href="../pkgimg/">Package Images</a></li><li><a class="tocitem" href="../llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../boundscheck/">边界检查</a></li><li><a class="tocitem" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../require/">Module loading</a></li><li><a class="tocitem" href="../inference/">类型推导</a></li><li><a class="tocitem" href="../ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li class="is-active"><a class="tocitem" href>Static analyzer annotations for GC correctness in C code</a><ul class="internal"><li><a class="tocitem" href="#Running-the-analysis"><span>Running the analysis</span></a></li><li><a class="tocitem" href="#General-Overview"><span>General Overview</span></a></li><li><a class="tocitem" href="#GC-Invariants"><span>GC Invariants</span></a></li><li><a class="tocitem" href="#Static-Analysis-Algorithm"><span>Static Analysis Algorithm</span></a></li><li><a class="tocitem" href="#The-analyzer-annotations"><span>The analyzer annotations</span></a></li><li><a class="tocitem" href="#Completeness-of-analysis"><span>Completeness of analysis</span></a></li></ul></li><li><a class="tocitem" href="../gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../build/linux/">Linux</a></li><li><a class="tocitem" href="../build/macos/">macOS</a></li><li><a class="tocitem" href="../build/windows/">Windows</a></li><li><a class="tocitem" href="../build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">开发者文档</a></li><li><a class="is-disabled">Documentation of Julia&#39;s Internals</a></li><li class="is-active"><a href>Static analyzer annotations for GC correctness in C code</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Static analyzer annotations for GC correctness in C code</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/zh_CN/doc/src/devdocs/gc-sa.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Static-analyzer-annotations-for-GC-correctness-in-C-code"><a class="docs-heading-anchor" href="#Static-analyzer-annotations-for-GC-correctness-in-C-code">Static analyzer annotations for GC correctness in C code</a><a id="Static-analyzer-annotations-for-GC-correctness-in-C-code-1"></a><a class="docs-heading-anchor-permalink" href="#Static-analyzer-annotations-for-GC-correctness-in-C-code" title="Permalink"></a></h1><h2 id="Running-the-analysis"><a class="docs-heading-anchor" href="#Running-the-analysis">Running the analysis</a><a id="Running-the-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-analysis" title="Permalink"></a></h2><p>The analyzer plugin that drives the analysis ships with julia. Its source code can be found in <code>src/clangsa</code>. Running it requires the clang dependency to be build. Set the <code>BUILD_LLVM_CLANG</code> variable in your Make.user in order to build an appropriate version of clang. You may also want to use the prebuilt binaries using the <code>USE_BINARYBUILDER_LLVM</code> options.</p><p>Alternatively (or if these do not suffice), try</p><pre><code class="language-sh hljs">make -C src install-analysis-deps</code></pre><p>from Julia&#39;s toplevel directory.</p><p>Afterwards, running the analysis over the source tree is as simple as running <code>make -C src analyzegc</code>.</p><h2 id="General-Overview"><a class="docs-heading-anchor" href="#General-Overview">General Overview</a><a id="General-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#General-Overview" title="Permalink"></a></h2><p>Since Julia&#39;s GC is precise, it needs to maintain correct rooting information for any value that may be referenced at any time GC may occur. These places are known as <code>safepoints</code> and in the function local context, we extend this designation to any function call that may recursively end up at a safepoint.</p><p>In generated code, this is taken care of automatically by the GC root placement pass (see the chapter on GC rooting in the LLVM codegen devdocs). However, in C code, we need to inform the runtime of any GC roots manually. This is done using the following macros:</p><pre><code class="nohighlight hljs">// The value assigned to any slot passed as an argument to these
// is rooted for the duration of this GC frame.
JL_GC_PUSH{1,...,6}(args...)
// The values assigned into the size `n` array `rts` are rooted
// for the duration of this GC frame.
JL_GC_PUSHARGS(rts, n)
// Pop a GC frame
JL_GC_POP</code></pre><p>If these macros are not used where they need to be, or they are used incorrectly, the result is silent memory corruption. As such it is very important that they are placed correctly in all applicable code.</p><p>As such, we employ static analysis (and in particular the clang static analyzer) to help ensure that these macros are used correctly. The remainder of this document gives an overview of this static analysis and describes the support needed in the julia code base to make things work.</p><h2 id="GC-Invariants"><a class="docs-heading-anchor" href="#GC-Invariants">GC Invariants</a><a id="GC-Invariants-1"></a><a class="docs-heading-anchor-permalink" href="#GC-Invariants" title="Permalink"></a></h2><p>There is two simple invariants correctness:</p><ul><li>All <code>GC_PUSH</code> calls need to be followed by an appropriate <code>GC_POP</code> (in practice we enforce this at the function level)</li><li>If a value was previously not rooted at any safepoint, it may no longer be referenced afterwards</li></ul><p>Of course the devil is in the details here. In particular to satisfy the second of the above conditions, we need to know:</p><ul><li>Which calls are safepoints and which are not</li><li>Which values are rooted at any given safepoint and which are not</li><li>When is a value referenced</li></ul><p>For the second point in particular, we need to know which memory locations will be considered rooting at runtime (i.e. values assigned to such locations are rooted). This includes locations explicitly designated as such by passing them to one of the <code>GC_PUSH</code> macros, globally rooted locations and values, as well as any location recursively reachable from one of those locations.</p><h2 id="Static-Analysis-Algorithm"><a class="docs-heading-anchor" href="#Static-Analysis-Algorithm">Static Analysis Algorithm</a><a id="Static-Analysis-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Static-Analysis-Algorithm" title="Permalink"></a></h2><p>The idea itself is very simple, although the implementation is quite a bit more complicated (mainly due to a large number of special cases and intricacies of C and C++). In essence, we keep track of all locations that are rooting, all values that are rootable and any expression (assignments, allocations, etc) affect the rootedness of any rootable values. Then, at any safepoint, we perform a &quot;symbolic GC&quot; and poison any values that are not rooted at said location. If these values are later referenced, we emit an error.</p><p>The clang static analyzer works by constructing a graph of states and exploring this graph for sources of errors. Several nodes in this graph are generated by the analyzer itself (e.g. for control flow), but the definitions above augment this graph with our own state.</p><p>The static analyzer is interprocedural and can analyze control flow across function boundaries. However, the static analyzer is not fully recursive and makes heuristic decisions about which calls to explore (additionally some calls are cross-translation unit and invisible to the analyzer). In our case, our definition of correctness requires total information. As such, we need to annotate the prototypes of all function calls with whatever information the analysis required, even if that information would otherwise be available by interprocedural static analysis.</p><p>Luckily however, we can still use this interprocedural analysis to ensure that the annotations we place on a given function are indeed correct given the implementation of said function.</p><h2 id="The-analyzer-annotations"><a class="docs-heading-anchor" href="#The-analyzer-annotations">The analyzer annotations</a><a id="The-analyzer-annotations-1"></a><a class="docs-heading-anchor-permalink" href="#The-analyzer-annotations" title="Permalink"></a></h2><p>These annotations are found in src/support/analyzer_annotations.h. The are only active when the analyzer is being used and expand either to nothing (for prototype annotations) or to no-ops (for function like annotations).</p><h3 id="JL_NOTSAFEPOINT"><a class="docs-heading-anchor" href="#JL_NOTSAFEPOINT"><code>JL_NOTSAFEPOINT</code></a><a id="JL_NOTSAFEPOINT-1"></a><a class="docs-heading-anchor-permalink" href="#JL_NOTSAFEPOINT" title="Permalink"></a></h3><p>This is perhaps the most common annotation, and should be placed on any function that is known not to possibly lead to reaching a GC safepoint. In general, it is only safe for such a function to perform arithmetic, memory accesses and calls to functions either annotated <code>JL_NOTSAFEPOINT</code> or otherwise known not to be safepoints (e.g. function in the C standard library, which are hardcoded as such in the analyzer)</p><p>It is valid to keep values unrooted across calls to any function annotated with this attribute:</p><p>Usage Example:</p><pre><code class="language-c hljs">void jl_get_one() JL_NOTSAFEPOINT {
  return 1;
}

jl_value_t *example() {
  jl_value_t *val = jl_alloc_whatever();
  // This is valid, even though `val` is unrooted, because
  // jl_get_one is not a safepoint
  jl_get_one();
  return val;
}</code></pre><h3 id="JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY"><a class="docs-heading-anchor" href="#JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY"><code>JL_MAYBE_UNROOTED</code>/<code>JL_ROOTS_TEMPORARILY</code></a><a id="JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY-1"></a><a class="docs-heading-anchor-permalink" href="#JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY" title="Permalink"></a></h3><p>When <code>JL_MAYBE_UNROOTED</code> is annotated as an argument on a function, indicates that said argument may be passed, even if it is not rooted. In the ordinary course of events, the julia ABI guarantees that callers root values before passing them to callees. However, some functions do not follow this ABI and allow values to be passed to them even though they are not rooted. Note however, that this does not automatically imply that said argument will be preserved. The <code>ROOTS_TEMPORARILY</code> annotation provides the stronger guarantee that, not only may the value be unrooted when passed, it will also be preserved across any internal safepoints by the callee.</p><p>Note that <code>JL_NOTSAFEPOINT</code> essentially implies <code>JL_MAYBE_UNROOTED</code>/<code>JL_ROOTS_TEMPORARILY</code>, because the rootedness of an argument is irrelevant if the function contains no safepoints.</p><p>One additional point to note is that these annotations apply on both the caller and the callee side. On the caller side, they lift rootedness restrictions that are normally required for julia ABI functions. On the callee side, they have the reverse effect of preventing these arguments from being considered implicitly rooted.</p><p>If either of these annotations is applied to the function as a whole, it applies to all arguments of the function. This should generally only be necessary for varargs functions.</p><p>Usage example:</p><pre><code class="language-c hljs">JL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);
jl_value_t *jl_alloc_error();

void example() {
  // The return value of the allocation is unrooted. This would normally
  // be an error, but is allowed because of the above annotation.
  jl_throw(jl_alloc_error());
}</code></pre><h3 id="JL_PROPAGATES_ROOT"><a class="docs-heading-anchor" href="#JL_PROPAGATES_ROOT"><code>JL_PROPAGATES_ROOT</code></a><a id="JL_PROPAGATES_ROOT-1"></a><a class="docs-heading-anchor-permalink" href="#JL_PROPAGATES_ROOT" title="Permalink"></a></h3><p>This annotation is commonly found on accessor functions that return one rootable object stored within another. When annotated on a function argument, it tells the analyzer that the root for that argument also applies to the value returned by the function.</p><p>Usage Example:</p><pre><code class="language-c hljs">jl_value_t *jl_svecref(jl_svec_t *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;

size_t example(jl_svec_t *svec) {
  jl_value_t *val = jl_svecref(svec, 1)
  // This is valid, because, as annotated by the PROPAGATES_ROOT annotation,
  // jl_svecref propagates the rooted-ness from `svec` to `val`
  jl_gc_safepoint();
  return jl_unbox_long(val);
}</code></pre><h3 id="JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT"><a class="docs-heading-anchor" href="#JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT"><code>JL_ROOTING_ARGUMENT</code>/<code>JL_ROOTED_ARGUMENT</code></a><a id="JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT-1"></a><a class="docs-heading-anchor-permalink" href="#JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT" title="Permalink"></a></h3><p>This is essentially the assignment counterpart to <code>JL_PROPAGATES_ROOT</code>. When assigning a value to a field of another value that is already rooted, the assigned value will inherit the root of the value it is assigned into.</p><p>Usage Example:</p><pre><code class="language-c hljs">void jl_svecset(void *t JL_ROOTING_ARGUMENT, size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT


size_t example(jl_svec_t *svec) {
  jl_value_t *val = jl_box_long(10000);
  jl_svecset(svec, val);
  // This is valid, because the annotations imply that the
  // jl_svecset propagates the rooted-ness from `svec` to `val`
  jl_gc_safepoint();
  return jl_unbox_long(val);
}</code></pre><h3 id="JL_GC_DISABLED"><a class="docs-heading-anchor" href="#JL_GC_DISABLED"><code>JL_GC_DISABLED</code></a><a id="JL_GC_DISABLED-1"></a><a class="docs-heading-anchor-permalink" href="#JL_GC_DISABLED" title="Permalink"></a></h3><p>This annotation implies that this function is only called with the GC runtime-disabled. Functions of this kind are most often encountered during startup and in the GC code itself. Note that this annotation is checked against the runtime enable/disable calls, so clang will know if you lie. This is not a good way to disable processing of a given function if the GC is not actually disabled (use <code>ifdef __clang_analyzer__</code> for that if you must).</p><p>Usage example:</p><pre><code class="language-c hljs">void jl_do_magic() JL_GC_DISABLED {
  // Wildly allocate here with no regard for roots
}

void example() {
  int en = jl_gc_enable(0);
  jl_do_magic();
  jl_gc_enable(en);
}</code></pre><h3 id="JL_REQUIRE_ROOTED_SLOT"><a class="docs-heading-anchor" href="#JL_REQUIRE_ROOTED_SLOT"><code>JL_REQUIRE_ROOTED_SLOT</code></a><a id="JL_REQUIRE_ROOTED_SLOT-1"></a><a class="docs-heading-anchor-permalink" href="#JL_REQUIRE_ROOTED_SLOT" title="Permalink"></a></h3><p>This annotation requires the caller to pass in a slot that is rooted (i.e. values assigned to this slot will be rooted).</p><p>Usage example:</p><pre><code class="language-c hljs">void jl_do_processing(jl_value_t **slot JL_REQUIRE_ROOTED_SLOT) {
  *slot = jl_box_long(1);
  // Ok, only, because the slot was annotated as rooting
  jl_gc_safepoint();
}

void example() {
  jl_value_t *slot = NULL;
  JL_GC_PUSH1(&amp;slot);
  jl_do_processing(&amp;slot);
  JL_GC_POP();
}</code></pre><h3 id="JL_GLOBALLY_ROOTED"><a class="docs-heading-anchor" href="#JL_GLOBALLY_ROOTED"><code>JL_GLOBALLY_ROOTED</code></a><a id="JL_GLOBALLY_ROOTED-1"></a><a class="docs-heading-anchor-permalink" href="#JL_GLOBALLY_ROOTED" title="Permalink"></a></h3><p>This annotation implies that a given value is always globally rooted. It can be applied to global variable declarations, in which case it will apply to the value of those variables (or values if the declaration if for an array), or to functions, in which case it will apply to the return value of such functions (e.g. for functions that always return some private, globally rooted value).</p><p>Usage example:</p><pre><code class="nohighlight hljs">extern JL_DLLEXPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;
jl_ast_context_t *jl_ast_ctx(fl_context_t *fl) JL_GLOBALLY_ROOTED;</code></pre><h3 id="JL_ALWAYS_LEAFTYPE"><a class="docs-heading-anchor" href="#JL_ALWAYS_LEAFTYPE"><code>JL_ALWAYS_LEAFTYPE</code></a><a id="JL_ALWAYS_LEAFTYPE-1"></a><a class="docs-heading-anchor-permalink" href="#JL_ALWAYS_LEAFTYPE" title="Permalink"></a></h3><p>This annotations is essentially equivalent to <code>JL_GLOBALLY_ROOTED</code>, except that is should only be used if those values are globally rooted by virtue of being a leaftype. The rooting of leaftypes is a bit complicated. They are generally rooted through <code>cache</code> field of the corresponding <code>TypeName</code>, which itself is rooted by the containing module (so they&#39;re rooted as long as the containing module is ok) and we can generally assume that leaftypes are rooted where they are used, but we may refine this property in the future, so the separate annotation helps split out the reason for being globally rooted.</p><p>The analyzer also automatically detects checks for leaftype-ness and will not complain about missing GC roots on these paths.</p><pre><code class="nohighlight hljs">JL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim) JL_ALWAYS_LEAFTYPE;</code></pre><h3 id="JL_GC_PROMISE_ROOTED"><a class="docs-heading-anchor" href="#JL_GC_PROMISE_ROOTED"><code>JL_GC_PROMISE_ROOTED</code></a><a id="JL_GC_PROMISE_ROOTED-1"></a><a class="docs-heading-anchor-permalink" href="#JL_GC_PROMISE_ROOTED" title="Permalink"></a></h3><p>This is a function-like annotation. Any value passed to this annotation will be considered rooted for the scope of the current function. It is designed as an escape hatch for analyzer inadequacy or complicated situations. However, it should be used sparingly, in favor of improving the analyzer itself.</p><pre><code class="nohighlight hljs">void example() {
  jl_value_t *val = jl_alloc_something();
  if (some_condition) {
    // We happen to know for complicated external reasons
    // that val is rooted under these conditions
    JL_GC_PROMISE_ROOTED(val);
  }
}</code></pre><h2 id="Completeness-of-analysis"><a class="docs-heading-anchor" href="#Completeness-of-analysis">Completeness of analysis</a><a id="Completeness-of-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Completeness-of-analysis" title="Permalink"></a></h2><p>The analyzer only looks at local information. In particular, e.g. in the <code>PROPAGATES_ROOT</code> case above, it assumes that such memory is only modified in ways it can see, not in any called functions (unless it happens to decide to consider them in its analysis) and not in any concurrently running threads. As such, it may miss a few problematic cases, though in practice such concurrent modification is fairly rare. Improving the analyzer to handle more such cases may be an interesting topic for future work.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../EscapeAnalysis/">« <code>EscapeAnalysis</code></a><a class="docs-footer-nextpage" href="../gc/">Garbage Collection in Julia »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>本文档在 <span class="colophon-date" title="2025 八月 15 周五 11:42">2025 八月 15 周五</span>用 <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> 1.10.2 版生成使用 1.10.10 版本的 Julia。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
