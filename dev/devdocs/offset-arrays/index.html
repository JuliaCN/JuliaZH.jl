<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Arrays with custom indices · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/offset-arrays/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-options/">命令行选项</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox" checked/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../types/">More about types</a></li><li><a class="tocitem" href="../object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../functions/">Julia 函数</a></li><li><a class="tocitem" href="../cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../subarrays/">子数组</a></li><li><a class="tocitem" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../sysimg/">System Image Building</a></li><li><a class="tocitem" href="../llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../boundscheck/">边界检查</a></li><li><a class="tocitem" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li class="is-active"><a class="tocitem" href>Arrays with custom indices</a><ul class="internal"><li><a class="tocitem" href="#Generalizing-existing-code"><span>Generalizing existing code</span></a></li><li><a class="tocitem" href="#Writing-custom-array-types-with-non-1-indexing"><span>Writing custom array types with non-1 indexing</span></a></li></ul></li><li><a class="tocitem" href="../require/">Module loading</a></li><li><a class="tocitem" href="../inference/">类型推导</a></li><li><a class="tocitem" href="../ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Documentation</a></li><li><a class="is-disabled">Documentation of Julia&#39;s Internals</a></li><li class="is-active"><a href>Arrays with custom indices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Arrays with custom indices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/devdocs-zh_cn/translate/#zh_CN/offset-arraysmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="man-custom-indices"><a class="docs-heading-anchor" href="#man-custom-indices">Arrays with custom indices</a><a id="man-custom-indices-1"></a><a class="docs-heading-anchor-permalink" href="#man-custom-indices" title="Permalink"></a></h1><p>Conventionally, Julia&#39;s arrays are indexed starting at 1, whereas some other languages start numbering at 0, and yet others (e.g., Fortran) allow you to specify arbitrary starting indices.  While there is much merit in picking a standard (i.e., 1 for Julia), there are some algorithms which simplify considerably if you can index outside the range <code>1:size(A,d)</code> (and not just <code>0:size(A,d)-1</code>, either). To facilitate such computations, Julia supports arrays with arbitrary indices.</p><p>The purpose of this page is to address the question, &quot;what do I have to do to support such arrays in my own code?&quot;  First, let&#39;s address the simplest case: if you know that your code will never need to handle arrays with unconventional indexing, hopefully the answer is &quot;nothing.&quot; Old code, on conventional arrays, should function essentially without alteration as long as it was using the exported interfaces of Julia. If you find it more convenient to just force your users to supply traditional arrays where indexing starts at one, you can add</p><pre><code class="language-julia">Base.require_one_based_indexing(arrays...)</code></pre><p>where <code>arrays...</code> is a list of the array objects that you wish to check for anything that violates 1-based indexing.</p><h2 id="Generalizing-existing-code"><a class="docs-heading-anchor" href="#Generalizing-existing-code">Generalizing existing code</a><a id="Generalizing-existing-code-1"></a><a class="docs-heading-anchor-permalink" href="#Generalizing-existing-code" title="Permalink"></a></h2><p>As an overview, the steps are:</p><ul><li>replace many uses of <code>size</code> with <code>axes</code></li><li>replace <code>1:length(A)</code> with <code>eachindex(A)</code>, or in some cases <code>LinearIndices(A)</code></li><li>replace explicit allocations like <code>Array{Int}(undef, size(B))</code> with <code>similar(Array{Int}, axes(B))</code></li></ul><p>These are described in more detail below.</p><h3 id="Things-to-watch-out-for"><a class="docs-heading-anchor" href="#Things-to-watch-out-for">Things to watch out for</a><a id="Things-to-watch-out-for-1"></a><a class="docs-heading-anchor-permalink" href="#Things-to-watch-out-for" title="Permalink"></a></h3><p>Because unconventional indexing breaks many people&#39;s assumptions that all arrays start indexing with 1, there is always the chance that using such arrays will trigger errors. The most frustrating bugs would be incorrect results or segfaults (total crashes of Julia). For example, consider the following function:</p><pre><code class="language-julia">function mycopy!(dest::AbstractVector, src::AbstractVector)
    length(dest) == length(src) || throw(DimensionMismatch(&quot;vectors must match&quot;))
    # OK, now we&#39;re safe to use @inbounds, right? (not anymore!)
    for i = 1:length(src)
        @inbounds dest[i] = src[i]
    end
    dest
end</code></pre><p>This code implicitly assumes that vectors are indexed from 1; if <code>dest</code> starts at a different index than <code>src</code>, there is a chance that this code would trigger a segfault. (If you do get segfaults, to help locate the cause try running julia with the option <code>--check-bounds=yes</code>.)</p><h3 id="Using-axes-for-bounds-checks-and-loop-iteration"><a class="docs-heading-anchor" href="#Using-axes-for-bounds-checks-and-loop-iteration">Using <code>axes</code> for bounds checks and loop iteration</a><a id="Using-axes-for-bounds-checks-and-loop-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Using-axes-for-bounds-checks-and-loop-iteration" title="Permalink"></a></h3><p><code>axes(A)</code> (reminiscent of <code>size(A)</code>) returns a tuple of <code>AbstractUnitRange{&lt;:Integer}</code> objects, specifying the range of valid indices along each dimension of <code>A</code>.  When <code>A</code> has unconventional indexing, the ranges may not start at 1.  If you just want the range for a particular dimension <code>d</code>, there is <code>axes(A, d)</code>.</p><p>Base implements a custom range type, <code>OneTo</code>, where <code>OneTo(n)</code> means the same thing as <code>1:n</code> but in a form that guarantees (via the type system) that the lower index is 1. For any new <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray</code></a> type, this is the default returned by <code>axes</code>, and it indicates that this array type uses &quot;conventional&quot; 1-based indexing.</p><p>For bounds checking, note that there are dedicated functions <code>checkbounds</code> and <code>checkindex</code> which can sometimes simplify such tests.</p><h3 id="Linear-indexing-(LinearIndices)"><a class="docs-heading-anchor" href="#Linear-indexing-(LinearIndices)">Linear indexing (<code>LinearIndices</code>)</a><a id="Linear-indexing-(LinearIndices)-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-indexing-(LinearIndices)" title="Permalink"></a></h3><p>Some algorithms are most conveniently (or efficiently) written in terms of a single linear index, <code>A[i]</code> even if <code>A</code> is multi-dimensional. Regardless of the array&#39;s native indices, linear indices always range from <code>1:length(A)</code>. However, this raises an ambiguity for one-dimensional arrays (a.k.a., <a href="../../base/arrays/#Base.AbstractVector"><code>AbstractVector</code></a>): does <code>v[i]</code> mean linear indexing , or Cartesian indexing with the array&#39;s native indices?</p><p>For this reason, your best option may be to iterate over the array with <code>eachindex(A)</code>, or, if you require the indices to be sequential integers, to get the index range by calling <code>LinearIndices(A)</code>. This will return <code>axes(A, 1)</code> if A is an AbstractVector, and the equivalent of <code>1:length(A)</code> otherwise.</p><p>By this definition, 1-dimensional arrays always use Cartesian indexing with the array&#39;s native indices. To help enforce this, it&#39;s worth noting that the index conversion functions will throw an error if shape indicates a 1-dimensional array with unconventional indexing (i.e., is a <code>Tuple{UnitRange}</code> rather than a tuple of <code>OneTo</code>). For arrays with conventional indexing, these functions continue to work the same as always.</p><p>Using <code>axes</code> and <code>LinearIndices</code>, here is one way you could rewrite <code>mycopy!</code>:</p><pre><code class="language-julia">function mycopy!(dest::AbstractVector, src::AbstractVector)
    axes(dest) == axes(src) || throw(DimensionMismatch(&quot;vectors must match&quot;))
    for i in LinearIndices(src)
        @inbounds dest[i] = src[i]
    end
    dest
end</code></pre><h3 id="Allocating-storage-using-generalizations-of-similar"><a class="docs-heading-anchor" href="#Allocating-storage-using-generalizations-of-similar">Allocating storage using generalizations of <code>similar</code></a><a id="Allocating-storage-using-generalizations-of-similar-1"></a><a class="docs-heading-anchor-permalink" href="#Allocating-storage-using-generalizations-of-similar" title="Permalink"></a></h3><p>Storage is often allocated with <code>Array{Int}(undef, dims)</code> or <code>similar(A, args...)</code>. When the result needs to match the indices of some other array, this may not always suffice. The generic replacement for such patterns is to use <code>similar(storagetype, shape)</code>.  <code>storagetype</code> indicates the kind of underlying &quot;conventional&quot; behavior you&#39;d like, e.g., <code>Array{Int}</code> or <code>BitArray</code> or even <code>dims-&gt;zeros(Float32, dims)</code> (which would allocate an all-zeros array). <code>shape</code> is a tuple of <a href="../../base/numbers/#Core.Integer"><code>Integer</code></a> or <code>AbstractUnitRange</code> values, specifying the indices that you want the result to use. Note that a convenient way of producing an all-zeros array that matches the indices of A is simply <code>zeros(A)</code>.</p><p>Let&#39;s walk through a couple of explicit examples. First, if <code>A</code> has conventional indices, then <code>similar(Array{Int}, axes(A))</code> would end up calling <code>Array{Int}(undef, size(A))</code>, and thus return an array.  If <code>A</code> is an <code>AbstractArray</code> type with unconventional indexing, then <code>similar(Array{Int}, axes(A))</code> should return something that &quot;behaves like&quot; an <code>Array{Int}</code> but with a shape (including indices) that matches <code>A</code>.  (The most obvious implementation is to allocate an <code>Array{Int}(undef, size(A))</code> and then &quot;wrap&quot; it in a type that shifts the indices.)</p><p>Note also that <code>similar(Array{Int}, (axes(A, 2),))</code> would allocate an <code>AbstractVector{Int}</code> (i.e., 1-dimensional array) that matches the indices of the columns of <code>A</code>.</p><h2 id="Writing-custom-array-types-with-non-1-indexing"><a class="docs-heading-anchor" href="#Writing-custom-array-types-with-non-1-indexing">Writing custom array types with non-1 indexing</a><a id="Writing-custom-array-types-with-non-1-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-custom-array-types-with-non-1-indexing" title="Permalink"></a></h2><p>Most of the methods you&#39;ll need to define are standard for any <code>AbstractArray</code> type, see <a href="../../manual/interfaces/#man-interface-array">Abstract Arrays</a>. This page focuses on the steps needed to define unconventional indexing.</p><h3 id="Custom-AbstractUnitRange-types"><a class="docs-heading-anchor" href="#Custom-AbstractUnitRange-types">Custom <code>AbstractUnitRange</code> types</a><a id="Custom-AbstractUnitRange-types-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-AbstractUnitRange-types" title="Permalink"></a></h3><p>If you&#39;re writing a non-1 indexed array type, you will want to specialize <code>axes</code> so it returns a <code>UnitRange</code>, or (perhaps better) a custom <code>AbstractUnitRange</code>.  The advantage of a custom type is that it &quot;signals&quot; the allocation type for functions like <code>similar</code>. If we&#39;re writing an array type for which indexing will start at 0, we likely want to begin by creating a new <code>AbstractUnitRange</code>, <code>ZeroRange</code>, where <code>ZeroRange(n)</code> is equivalent to <code>0:n-1</code>.</p><p>In general, you should probably <em>not</em> export <code>ZeroRange</code> from your package: there may be other packages that implement their own <code>ZeroRange</code>, and having multiple distinct <code>ZeroRange</code> types is (perhaps counterintuitively) an advantage: <code>ModuleA.ZeroRange</code> indicates that <code>similar</code> should create a <code>ModuleA.ZeroArray</code>, whereas <code>ModuleB.ZeroRange</code> indicates a <code>ModuleB.ZeroArray</code> type.  This design allows peaceful coexistence among many different custom array types.</p><p>Note that the Julia package <a href="https://github.com/JuliaArrays/CustomUnitRanges.jl">CustomUnitRanges.jl</a> can sometimes be used to avoid the need to write your own <code>ZeroRange</code> type.</p><h3 id="Specializing-axes"><a class="docs-heading-anchor" href="#Specializing-axes">Specializing <code>axes</code></a><a id="Specializing-axes-1"></a><a class="docs-heading-anchor-permalink" href="#Specializing-axes" title="Permalink"></a></h3><p>Once you have your <code>AbstractUnitRange</code> type, then specialize <code>axes</code>:</p><pre><code class="language-julia">Base.axes(A::ZeroArray) = map(n-&gt;ZeroRange(n), A.size)</code></pre><p>where here we imagine that <code>ZeroArray</code> has a field called <code>size</code> (there would be other ways to implement this).</p><p>In some cases, the fallback definition for <code>axes(A, d)</code>:</p><pre><code class="language-julia">axes(A::AbstractArray{T,N}, d) where {T,N} = d &lt;= N ? axes(A)[d] : OneTo(1)</code></pre><p>may not be what you want: you may need to specialize it to return something other than <code>OneTo(1)</code> when <code>d &gt; ndims(A)</code>.  Likewise, in <code>Base</code> there is a dedicated function <code>axes1</code> which is equivalent to <code>axes(A, 1)</code> but which avoids checking (at runtime) whether <code>ndims(A) &gt; 0</code>. (This is purely a performance optimization.)  It is defined as:</p><pre><code class="language-julia">axes1(A::AbstractArray{T,0}) where {T} = OneTo(1)
axes1(A::AbstractArray) = axes(A)[1]</code></pre><p>If the first of these (the zero-dimensional case) is problematic for your custom array type, be sure to specialize it appropriately.</p><h3 id="Specializing-similar"><a class="docs-heading-anchor" href="#Specializing-similar">Specializing <code>similar</code></a><a id="Specializing-similar-1"></a><a class="docs-heading-anchor-permalink" href="#Specializing-similar" title="Permalink"></a></h3><p>Given your custom <code>ZeroRange</code> type, then you should also add the following two specializations for <code>similar</code>:</p><pre><code class="language-julia">function Base.similar(A::AbstractArray, T::Type, shape::Tuple{ZeroRange,Vararg{ZeroRange}})
    # body
end

function Base.similar(f::Union{Function,DataType}, shape::Tuple{ZeroRange,Vararg{ZeroRange}})
    # body
end</code></pre><p>Both of these should allocate your custom array type.</p><h3 id="Specializing-reshape"><a class="docs-heading-anchor" href="#Specializing-reshape">Specializing <code>reshape</code></a><a id="Specializing-reshape-1"></a><a class="docs-heading-anchor-permalink" href="#Specializing-reshape" title="Permalink"></a></h3><p>Optionally, define a method</p><pre><code class="language-none">Base.reshape(A::AbstractArray, shape::Tuple{ZeroRange,Vararg{ZeroRange}}) = ...</code></pre><p>and you can <code>reshape</code> an array so that the result has custom indices.</p><h3 id="For-objects-that-mimic-AbstractArray-but-are-not-subtypes"><a class="docs-heading-anchor" href="#For-objects-that-mimic-AbstractArray-but-are-not-subtypes">For objects that mimic AbstractArray but are not subtypes</a><a id="For-objects-that-mimic-AbstractArray-but-are-not-subtypes-1"></a><a class="docs-heading-anchor-permalink" href="#For-objects-that-mimic-AbstractArray-but-are-not-subtypes" title="Permalink"></a></h3><p><code>has_offset_axes</code> depends on having <code>axes</code> defined for the objects you call it on. If there is some reason you don&#39;t have an <code>axes</code> method defined for your object, consider defining a method</p><pre><code class="language-julia">Base.has_offset_axes(obj::MyNon1IndexedArraylikeObject) = true</code></pre><p>This will allow code that assumes 1-based indexing to detect a problem and throw a helpful error, rather than returning incorrect results or segfaulting julia.</p><h3 id="Catching-errors"><a class="docs-heading-anchor" href="#Catching-errors">Catching errors</a><a id="Catching-errors-1"></a><a class="docs-heading-anchor-permalink" href="#Catching-errors" title="Permalink"></a></h3><p>If your new array type triggers errors in other code, one helpful debugging step can be to comment out <code>@boundscheck</code> in your <code>getindex</code> and <code>setindex!</code> implementation. This will ensure that every element access checks bounds. Or, restart julia with <code>--check-bounds=yes</code>.</p><p>In some cases it may also be helpful to temporarily disable <code>size</code> and <code>length</code> for your new array type, since code that makes incorrect assumptions frequently uses these functions.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../locks/">« Proper maintenance and care of multi-threading locks</a><a class="docs-footer-nextpage" href="../require/">Module loading »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2022 一月 4 周二 14:54">2022 一月 4 周二</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.7.1版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
