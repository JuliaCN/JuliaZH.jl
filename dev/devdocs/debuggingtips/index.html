<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>gdb 调试提示 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/debuggingtips/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-options/">命令行选项</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../types/">More about types</a></li><li><a class="tocitem" href="../object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../functions/">Julia 函数</a></li><li><a class="tocitem" href="../cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../subarrays/">子数组</a></li><li><a class="tocitem" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../sysimg/">System Image Building</a></li><li><a class="tocitem" href="../llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../boundscheck/">边界检查</a></li><li><a class="tocitem" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../require/">Module loading</a></li><li><a class="tocitem" href="../inference/">类型推导</a></li><li><a class="tocitem" href="../ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox" checked/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../backtraces/">报告和分析崩溃（段错误）</a></li><li class="is-active"><a class="tocitem" href>gdb 调试提示</a><ul class="internal"><li><a class="tocitem" href="#显示-Julia-变量"><span>显示 Julia 变量</span></a></li><li><a class="tocitem" href="#有用的用于检查的-Julia-变量"><span>有用的用于检查的 Julia 变量</span></a></li><li><a class="tocitem" href="#Useful-Julia-functions-for-Inspecting-those-variables"><span>Useful Julia functions for Inspecting those variables</span></a></li><li><a class="tocitem" href="#Inserting-breakpoints-for-inspection-from-gdb"><span>Inserting breakpoints for inspection from gdb</span></a></li><li><a class="tocitem" href="#Inserting-breakpoints-upon-certain-conditions"><span>Inserting breakpoints upon certain conditions</span></a></li><li><a class="tocitem" href="#Dealing-with-signals"><span>Dealing with signals</span></a></li><li><a class="tocitem" href="#Debugging-during-Julia&#39;s-build-process-(bootstrap)"><span>Debugging during Julia&#39;s build process (bootstrap)</span></a></li><li><a class="tocitem" href="#Debugging-precompilation-errors"><span>Debugging precompilation errors</span></a></li><li><a class="tocitem" href="#Mozilla&#39;s-Record-and-Replay-Framework-(rr)"><span>Mozilla&#39;s Record and Replay Framework (rr)</span></a></li></ul></li><li><a class="tocitem" href="../valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Documentation</a></li><li><a class="is-disabled">Developing/debugging Julia&#39;s C code</a></li><li class="is-active"><a href>gdb 调试提示</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>gdb 调试提示</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/devdocs-zh_cn/translate/#zh_CN/debuggingtipsmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="gdb-调试提示"><a class="docs-heading-anchor" href="#gdb-调试提示">gdb 调试提示</a><a id="gdb-调试提示-1"></a><a class="docs-heading-anchor-permalink" href="#gdb-调试提示" title="Permalink"></a></h1><h2 id="显示-Julia-变量"><a class="docs-heading-anchor" href="#显示-Julia-变量">显示 Julia 变量</a><a id="显示-Julia-变量-1"></a><a class="docs-heading-anchor-permalink" href="#显示-Julia-变量" title="Permalink"></a></h2><p>在 <code>gdb</code> 中, 任何 <code>jl_value_t*</code> 类型的变量 <code>obj</code> 的展示可以通过使用：</p><pre><code class="language-none">(gdb) call jl_(obj)</code></pre><p>这个对象会在 <code>julia</code> 会话中展示，而不是在 gdb 会话中。这是一种行之有效的方式来发现由 Julia 的 C 代码操控的对象的类型和值。</p><p>同样，如果你在调试一些 Julia 内部的东西 （比如 <code>compiler.jl</code> ），你可以通过使用这些来打印 <code>obj</code> ：</p><pre><code class="language-julia">ccall(:jl_, Cvoid, (Any,), obj)</code></pre><p>这是一种很好的方法，可以避免 Julia 的输出流初始化顺序引起的问题。</p><p>Julia的 flisp 解释器使用 <code>value_t</code> 对象；能够通过  <code>call fl_print(fl_ctx, ios_stdout, obj)</code> 来展示。</p><h2 id="有用的用于检查的-Julia-变量"><a class="docs-heading-anchor" href="#有用的用于检查的-Julia-变量">有用的用于检查的 Julia 变量</a><a id="有用的用于检查的-Julia-变量-1"></a><a class="docs-heading-anchor-permalink" href="#有用的用于检查的-Julia-变量" title="Permalink"></a></h2><p>While the addresses of many variables, like singletons, can be useful to print for many failures, there are a number of additional variables (see <code>julia.h</code> for a complete list) that are even more useful.</p><ul><li>(when in <code>jl_apply_generic</code>) <code>mfunc</code> and <code>jl_uncompress_ast(mfunc-&gt;def, mfunc-&gt;code)</code> :: for figuring out a bit about the call-stack</li><li><code>jl_lineno</code> and <code>jl_filename</code> :: for figuring out what line in a test to go start debugging from (or figure out how far into a file has been parsed)</li><li><code>$1</code> :: not really a variable, but still a useful shorthand for referring to the result of the last gdb command (such as <code>print</code>)</li><li><code>jl_options</code> :: sometimes useful, since it lists all of the command line options that were successfully parsed</li><li><code>jl_uv_stderr</code> :: because who doesn&#39;t like to be able to interact with stdio</li></ul><h2 id="Useful-Julia-functions-for-Inspecting-those-variables"><a class="docs-heading-anchor" href="#Useful-Julia-functions-for-Inspecting-those-variables">Useful Julia functions for Inspecting those variables</a><a id="Useful-Julia-functions-for-Inspecting-those-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-Julia-functions-for-Inspecting-those-variables" title="Permalink"></a></h2><ul><li><code>jl_gdblookup($rip)</code> :: For looking up the current function and line. (use <code>$eip</code> on i686 platforms)</li><li><code>jlbacktrace()</code> :: For dumping the current Julia backtrace stack to stderr. Only usable after <code>record_backtrace()</code> has been called.</li><li><code>jl_dump_llvm_value(Value*)</code> :: For invoking <code>Value-&gt;dump()</code> in gdb, where it doesn&#39;t work natively. For example, <code>f-&gt;linfo-&gt;functionObject</code>, <code>f-&gt;linfo-&gt;specFunctionObject</code>, and <code>to_function(f-&gt;linfo)</code>.</li><li><code>Type-&gt;dump()</code> :: only works in lldb. Note: add something like <code>;1</code> to prevent lldb from printing its prompt over the output</li><li><code>jl_eval_string(&quot;expr&quot;)</code> :: for invoking side-effects to modify the current state or to lookup symbols</li><li><code>jl_typeof(jl_value_t*)</code> :: for extracting the type tag of a Julia value (in gdb, call <code>macro define jl_typeof jl_typeof</code> first, or pick something short like <code>ty</code> for the first arg to define a shorthand)</li></ul><h2 id="Inserting-breakpoints-for-inspection-from-gdb"><a class="docs-heading-anchor" href="#Inserting-breakpoints-for-inspection-from-gdb">Inserting breakpoints for inspection from gdb</a><a id="Inserting-breakpoints-for-inspection-from-gdb-1"></a><a class="docs-heading-anchor-permalink" href="#Inserting-breakpoints-for-inspection-from-gdb" title="Permalink"></a></h2><p>In your <code>gdb</code> session, set a breakpoint in <code>jl_breakpoint</code> like so:</p><pre><code class="language-none">(gdb) break jl_breakpoint</code></pre><p>Then within your Julia code, insert a call to <code>jl_breakpoint</code> by adding</p><pre><code class="language-julia">ccall(:jl_breakpoint, Cvoid, (Any,), obj)</code></pre><p>where <code>obj</code> can be any variable or tuple you want to be accessible in the breakpoint.</p><p>It&#39;s particularly helpful to back up to the <code>jl_apply</code> frame, from which you can display the arguments to a function using, e.g.,</p><pre><code class="language-none">(gdb) call jl_(args[0])</code></pre><p>Another useful frame is <code>to_function(jl_method_instance_t *li, bool cstyle)</code>. The <code>jl_method_instance_t*</code> argument is a struct with a reference to the final AST sent into the compiler. However, the AST at this point will usually be compressed; to view the AST, call <code>jl_uncompress_ast</code> and then pass the result to <code>jl_</code>:</p><pre><code class="language-none">#2  0x00007ffff7928bf7 in to_function (li=0x2812060, cstyle=false) at codegen.cpp:584
584          abort();
(gdb) p jl_(jl_uncompress_ast(li, li-&gt;ast))</code></pre><h2 id="Inserting-breakpoints-upon-certain-conditions"><a class="docs-heading-anchor" href="#Inserting-breakpoints-upon-certain-conditions">Inserting breakpoints upon certain conditions</a><a id="Inserting-breakpoints-upon-certain-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Inserting-breakpoints-upon-certain-conditions" title="Permalink"></a></h2><h3 id="Loading-a-particular-file"><a class="docs-heading-anchor" href="#Loading-a-particular-file">Loading a particular file</a><a id="Loading-a-particular-file-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-a-particular-file" title="Permalink"></a></h3><p>Let&#39;s say the file is <code>sysimg.jl</code>:</p><pre><code class="language-none">(gdb) break jl_load if strcmp(fname, &quot;sysimg.jl&quot;)==0</code></pre><h3 id="Calling-a-particular-method"><a class="docs-heading-anchor" href="#Calling-a-particular-method">Calling a particular method</a><a id="Calling-a-particular-method-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-a-particular-method" title="Permalink"></a></h3><pre><code class="language-none">(gdb) break jl_apply_generic if strcmp((char*)(jl_symbol_name)(jl_gf_mtable(F)-&gt;name), &quot;method_to_break&quot;)==0</code></pre><p>Since this function is used for every call, you will make everything 1000x slower if you do this.</p><h2 id="Dealing-with-signals"><a class="docs-heading-anchor" href="#Dealing-with-signals">Dealing with signals</a><a id="Dealing-with-signals-1"></a><a class="docs-heading-anchor-permalink" href="#Dealing-with-signals" title="Permalink"></a></h2><p>Julia requires a few signal to function property. The profiler uses <code>SIGUSR2</code> for sampling and the garbage collector uses <code>SIGSEGV</code> for threads synchronization. If you are debugging some code that uses the profiler or multiple threads, you may want to let the debugger ignore these signals since they can be triggered very often during normal operations. The command to do this in GDB is (replace <code>SIGSEGV</code> with <code>SIGUSRS</code> or other signals you want to ignore):</p><pre><code class="language-none">(gdb) handle SIGSEGV noprint nostop pass</code></pre><p>The corresponding LLDB command is (after the process is started):</p><pre><code class="language-none">(lldb) pro hand -p true -s false -n false SIGSEGV</code></pre><p>If you are debugging a segfault with threaded code, you can set a breakpoint on <code>jl_critical_error</code> (<code>sigdie_handler</code> should also work on Linux and BSD) in order to only catch the actual segfault rather than the GC synchronization points.</p><h2 id="Debugging-during-Julia&#39;s-build-process-(bootstrap)"><a class="docs-heading-anchor" href="#Debugging-during-Julia&#39;s-build-process-(bootstrap)">Debugging during Julia&#39;s build process (bootstrap)</a><a id="Debugging-during-Julia&#39;s-build-process-(bootstrap)-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging-during-Julia&#39;s-build-process-(bootstrap)" title="Permalink"></a></h2><p>Errors that occur during <code>make</code> need special handling. Julia is built in two stages, constructing <code>sys0</code> and <code>sys.ji</code>. To see what commands are running at the time of failure, use <code>make VERBOSE=1</code>.</p><p>At the time of this writing, you can debug build errors during the <code>sys0</code> phase from the <code>base</code> directory using:</p><pre><code class="language-none">julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys0 sysimg.jl</code></pre><p>You might need to delete all the files in <code>usr/lib/julia/</code> to get this to work.</p><p>You can debug the <code>sys.ji</code> phase using:</p><pre><code class="language-none">julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys -J ../usr/lib/julia/sys0.ji sysimg.jl</code></pre><p>By default, any errors will cause Julia to exit, even under gdb. To catch an error &quot;in the act&quot;, set a breakpoint in <code>jl_error</code> (there are several other useful spots, for specific kinds of failures, including: <code>jl_too_few_args</code>, <code>jl_too_many_args</code>, and <code>jl_throw</code>).</p><p>Once an error is caught, a useful technique is to walk up the stack and examine the function by inspecting the related call to <code>jl_apply</code>. To take a real-world example:</p><pre><code class="language-none">Breakpoint 1, jl_throw (e=0x7ffdf42de400) at task.c:802
802 {
(gdb) p jl_(e)
ErrorException(&quot;auto_unbox: unable to determine argument type&quot;)
$2 = void
(gdb) bt 10
#0  jl_throw (e=0x7ffdf42de400) at task.c:802
#1  0x00007ffff65412fe in jl_error (str=0x7ffde56be000 &lt;_j_str267&gt; &quot;auto_unbox:
   unable to determine argument type&quot;)
   at builtins.c:39
#2  0x00007ffde56bd01a in julia_convert_16886 ()
#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281
...</code></pre><p>The most recent <code>jl_apply</code> is at frame #3, so we can go back there and look at the AST for the function <code>julia_convert_16886</code>. This is the uniqued name for some method of <code>convert</code>. <code>f</code> in this frame is a <code>jl_function_t*</code>, so we can look at the type signature, if any, from the <code>specTypes</code> field:</p><pre><code class="language-none">(gdb) f 3
#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281
1281            return f-&gt;fptr((jl_value_t*)f, args, nargs);
(gdb) p f-&gt;linfo-&gt;specTypes
$4 = (jl_tupletype_t *) 0x7ffdf39b1030
(gdb) p jl_( f-&gt;linfo-&gt;specTypes )
Tuple{Type{Float32}, Float64}           # &lt;-- type signature for julia_convert_16886</code></pre><p>Then, we can look at the AST for this function:</p><pre><code class="language-none">(gdb) p jl_( jl_uncompress_ast(f-&gt;linfo, f-&gt;linfo-&gt;ast) )
Expr(:lambda, Array{Any, 1}[:#s29, :x], Array{Any, 1}[Array{Any, 1}[], Array{Any, 1}[Array{Any, 1}[:#s29, :Any, 0], Array{Any, 1}[:x, :Any, 0]], Array{Any, 1}[], 0], Expr(:body,
Expr(:line, 90, :float.jl)::Any,
Expr(:return, Expr(:call, :box, :Float32, Expr(:call, :fptrunc, :Float32, :x)::Any)::Any)::Any)::Any)::Any</code></pre><p>Finally, and perhaps most usefully, we can force the function to be recompiled in order to step through the codegen process. To do this, clear the cached <code>functionObject</code> from the <code>jl_lamdbda_info_t*</code>:</p><pre><code class="language-none">(gdb) p f-&gt;linfo-&gt;functionObject
$8 = (void *) 0x1289d070
(gdb) set f-&gt;linfo-&gt;functionObject = NULL</code></pre><p>Then, set a breakpoint somewhere useful (e.g. <code>emit_function</code>, <code>emit_expr</code>, <code>emit_call</code>, etc.), and run codegen:</p><pre><code class="language-none">(gdb) p jl_compile(f)
... # your breakpoint here</code></pre><h2 id="Debugging-precompilation-errors"><a class="docs-heading-anchor" href="#Debugging-precompilation-errors">Debugging precompilation errors</a><a id="Debugging-precompilation-errors-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging-precompilation-errors" title="Permalink"></a></h2><p>Module precompilation spawns a separate Julia process to precompile each module. Setting a breakpoint or catching failures in a precompile worker requires attaching a debugger to the worker. The easiest approach is to set the debugger watch for new process launches matching a given name. For example:</p><pre><code class="language-none">(gdb) attach -w -n julia-debug</code></pre><p>or:</p><pre><code class="language-none">(lldb) process attach -w -n julia-debug</code></pre><p>Then run a script/command to start precompilation. As described earlier, use conditional breakpoints in the parent process to catch specific file-loading events and narrow the debugging window. (some operating systems may require alternative approaches, such as following each <code>fork</code> from the parent process)</p><h2 id="Mozilla&#39;s-Record-and-Replay-Framework-(rr)"><a class="docs-heading-anchor" href="#Mozilla&#39;s-Record-and-Replay-Framework-(rr)">Mozilla&#39;s Record and Replay Framework (rr)</a><a id="Mozilla&#39;s-Record-and-Replay-Framework-(rr)-1"></a><a class="docs-heading-anchor-permalink" href="#Mozilla&#39;s-Record-and-Replay-Framework-(rr)" title="Permalink"></a></h2><p>Julia now works out of the box with <a href="http://rr-project.org/">rr</a>, the lightweight recording and deterministic debugging framework from Mozilla. This allows you to replay the trace of an execution deterministically.  The replayed execution&#39;s address spaces, register contents, syscall data etc are exactly the same in every run.</p><p>A recent version of rr (3.1.0 or higher) is required.</p><h3 id="Reproducing-concurrency-bugs-with-rr"><a class="docs-heading-anchor" href="#Reproducing-concurrency-bugs-with-rr">Reproducing concurrency bugs with rr</a><a id="Reproducing-concurrency-bugs-with-rr-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducing-concurrency-bugs-with-rr" title="Permalink"></a></h3><p>rr simulates a single-threaded machine by default. In order to debug concurrent code you can use <code>rr record --chaos</code> which will cause rr to simulate between one to eight cores, chosen randomly. You might therefore want to set <code>JULIA_NUM_THREADS=8</code> and rerun your code under rr until you have caught your bug.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../backtraces/">« 报告和分析崩溃（段错误）</a><a class="docs-footer-nextpage" href="../valgrind/">在Julia中使用Valgrind »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2023 十月 22 周日 12:22">2023 十月 22 周日</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.8.5版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
