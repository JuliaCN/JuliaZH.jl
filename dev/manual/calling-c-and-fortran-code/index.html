<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>调用 C 和 Fortran 代码 · Julia 中文文档</title><meta name="title" content="调用 C 和 Fortran 代码 · Julia 中文文档"/><meta property="og:title" content="调用 C 和 Fortran 代码 · Julia 中文文档"/><meta property="twitter:title" content="调用 C 和 Fortran 代码 · Julia 中文文档"/><meta name="description" content="Documentation for Julia 中文文档."/><meta property="og:description" content="Documentation for Julia 中文文档."/><meta property="twitter:description" content="Documentation for Julia 中文文档."/><meta property="og:url" content="https://juliacn.github.io/JuliaZH.jl/latest/manual/calling-c-and-fortran-code/"/><meta property="twitter:url" content="https://juliacn.github.io/JuliaZH.jl/latest/manual/calling-c-and-fortran-code/"/><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/calling-c-and-fortran-code/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia 中文文档 logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">变量</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">一维和多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../multi-threading/">多线程</a></li><li><a class="tocitem" href="../distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li class="is-active"><a class="tocitem" href>调用 C 和 Fortran 代码</a><ul class="internal"><li><a class="tocitem" href="#创建和C兼容的Julia函数指针"><span>创建和C兼容的Julia函数指针</span></a></li><li><a class="tocitem" href="#mapping-c-types-to-julia"><span>将 C 类型映射到 Julia</span></a></li><li class="toplevel"><a class="tocitem" href="#将-C-函数映射到-Julia"><span>将 C 函数映射到 Julia</span></a></li><li><a class="tocitem" href="#C-包装器示例"><span>C 包装器示例</span></a></li><li><a class="tocitem" href="#Fortran-包装器示例"><span>Fortran 包装器示例</span></a></li><li><a class="tocitem" href="#垃圾回收安全"><span>垃圾回收安全</span></a></li><li><a class="tocitem" href="#Non-constant-Function-Specifications"><span>非常数函数规范</span></a></li><li><a class="tocitem" href="#间接调用"><span>间接调用</span></a></li><li><a class="tocitem" href="#cfunction-闭包"><span>cfunction 闭包</span></a></li><li><a class="tocitem" href="#关闭库"><span>关闭库</span></a></li><li><a class="tocitem" href="#Variadic-function-calls"><span>Variadic function calls</span></a></li><li><a class="tocitem" href="#ccall-interface"><span><code>ccall</code> interface</span></a></li><li><a class="tocitem" href="#calling-convention"><span>Calling Convention</span></a></li><li><a class="tocitem" href="#访问全局变量"><span>访问全局变量</span></a></li><li><a class="tocitem" href="#通过指针来访问数据"><span>通过指针来访问数据</span></a></li><li><a class="tocitem" href="#线程安全"><span>线程安全</span></a></li><li><a class="tocitem" href="#关于-Callbacks-的更多内容"><span>关于 Callbacks 的更多内容</span></a></li><li><a class="tocitem" href="#C"><span>C++</span></a></li></ul></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">标准数值类型</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/reflection/">反射 与 自我检查</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">标准库</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/ArgTools/">ArgTools</a></li><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibCURL/">LibCURL</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/NetworkOptions/">Network Options</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Tar/">Tar</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">开发者文档</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/pkgimg/">Package Images</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../../devdocs/gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../../devdocs/precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../../devdocs/probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../../devdocs/build/linux/">Linux</a></li><li><a class="tocitem" href="../../devdocs/build/macos/">macOS</a></li><li><a class="tocitem" href="../../devdocs/build/windows/">Windows</a></li><li><a class="tocitem" href="../../devdocs/build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../../devdocs/build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../../devdocs/build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>调用 C 和 Fortran 代码</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>调用 C 和 Fortran 代码</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/zh_CN/doc/src/manual/calling-c-and-fortran-code.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Calling-C-and-Fortran-Code"><a class="docs-heading-anchor" href="#Calling-C-and-Fortran-Code">调用 C 和 Fortran 代码</a><a id="Calling-C-and-Fortran-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-C-and-Fortran-Code" title="Permalink"></a></h1><p>在数值计算领域，尽管有很多用 C 语言或 Fortran 写的高质量且成熟的库都可以用 Julia 重写， 但为了便捷利用现有的 C 或 Fortran 代码，Julia 提供简洁且高效的调用方式。 Julia 的哲学是 <code>no boilerplate</code>： Julia 可以直接调用 C/Fortran 的函数，不需要任何&quot;胶水&quot;代码，代码生成或其它编译过程 —— 即使在交互式会话 (REPL/Jupyter notebook) 中使用也一样。 This is accomplished just by making an appropriate call with the <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> macro (or the less convenient <a href="../../base/c/#ccall"><code>ccall</code></a> syntax, see the <a href="#ccall-interface"><code>ccall</code> syntax section</a>).</p><p>被调用的代码必须是一个共享库（.so, .dylib, .dll）。大多数 C 和 Fortran 库都已经是以共享库的形式发布的，但在用 GCC 或 Clang 编译自己的代码时，需要添加 <code>-shared</code> 和 <code>-fPIC</code> 编译器选项。由于 Julia 的 JIT 生成的机器码跟原生 C 代码的调用是一样，所以在 Julia 里调用 C/Fortran 库的额外开销与直接从 C 里调用是一样的。<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><p>默认情况下，Fortran 编译器会<a href="https://en.wikipedia.org/wiki/Name_mangling#Fortran">进行名称修饰</a> （例如，将函数名转换为小写或大写，通常会添加下划线）， 要调用 Fortran 函数，传递的标识符必须与 Fortran 编译器名称修饰之后的一致。 此外，在调用 Fortran 函数时，<strong>所有</strong>输入必须以指针形式传递，并已在堆或栈上分配内存。 这不仅适用于通常是堆分配的数组及可变对象，而且适用于整数和浮点数等标量值， 尽管这些值通常是栈分配的，且在使用 C 或 Julia 调用约定时通常是通过寄存器传递的。</p><p>The syntax for <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> to generate a call to the library function is:</p><pre><code class="language-julia hljs">  @ccall library.function_name(argvalue1::argtype1, ...)::returntype
  @ccall function_name(argvalue1::argtype1, ...)::returntype
  @ccall $function_pointer(argvalue1::argtype1, ...)::returntype</code></pre><p>where <code>library</code> is a string constant or literal (but see <a href="#Non-constant-Function-Specifications">Non-constant Function Specifications</a> below). The library may be omitted, in which case the function name is resolved in the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia. The full path to the library may also be specified. Alternatively, <code>@ccall</code> may also be used to call a function pointer <code>$function_pointer</code>, such as one returned by <code>Libdl.dlsym</code>. The <code>argtype</code>s corresponds to the C-function signature and the <code>argvalue</code>s are the actual argument values to be passed to the function.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>请参阅下文了解如何 <a href="#mapping-c-types-to-julia">将 C 类型映射到 Julia 类型</a>。</p></div></div><p>作为一个完整但简单的例子，下面从大多数 Unix 派生系统上的标准 C 库中调用 <code>clock</code> 函数：</p><pre><code class="language-julia-repl hljs">julia&gt; t = @ccall clock()::Int32
2292761

julia&gt; typeof(t)
Int32</code></pre><p><code>clock</code> 不接受任何参数并返回一个 <a href="../../base/numbers/#Core.Int32"><code>Int32</code></a>。 要调用 <code>getenv</code> 函数来获取指向环境变量值的指针，可以这样调用：</p><pre><code class="language-julia-repl hljs">julia&gt; path = @ccall getenv(&quot;SHELL&quot;::Cstring)::Cstring
Cstring(@0x00007fff5fbffc45)

julia&gt; unsafe_string(path)
&quot;/bin/bash&quot;</code></pre><p>在实践中，尤其是在提供可重用功能时，通常会在 Julia 函数中包装 <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> 使用，这些函数设置参数，然后以 C 或 Fortran 函数指定的任何方式检查错误。 如果发生错误，它会作为普通的 Julia 异常抛出。 这一点尤其重要，因为 C 和 Fortran API 在它们指示错误条件的方式上是出了名的不一致。 例如，<code>getenv</code> C 库函数被包裹在下面的 Julia 函数中，它是 <a href="https://github.com/JuliaLang/julia/blob/master/base/env.jl"><code>env.jl</code></a> 实际定义的简化版本：</p><pre><code class="language-julia hljs">function getenv(var::AbstractString)
    val = @ccall getenv(var::Cstring)::Cstring
    if val == C_NULL
        error(&quot;getenv: undefined variable: &quot;, var)
    end
    return unsafe_string(val)
end</code></pre><p>C 函数 <code>getenv</code> 通过返回 <code>C_NULL</code> 的方式进行报错，但是其他 C 标准库函数也会通过不同的方式来报错，这包括返回 <code>-1, 0, 1</code> 以及其它特殊值。 此封装能够抛出异常信息，即是否调用者在尝试获取一个不存在的环境变量：</p><pre><code class="language-julia-repl hljs">julia&gt; getenv(&quot;SHELL&quot;)
&quot;/bin/bash&quot;

julia&gt; getenv(&quot;FOOBAR&quot;)
ERROR: getenv: undefined variable: FOOBAR</code></pre><p>这是一个稍微复杂的示例，用于发现本地计算机的主机名。</p><pre><code class="language-julia hljs">function gethostname()
    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN
    err = @ccall gethostname(hostname::Ptr{UInt8}, sizeof(hostname)::Csize_t)::Int32
    Base.systemerror(&quot;gethostname&quot;, err != 0)
    hostname[end] = 0 # ensure null-termination
    return GC.@preserve hostname unsafe_string(pointer(hostname))
end</code></pre><p>此示例首先分配一个字节数组。 然后它调用 C 库函数 <code>gethostname</code> 以使用主机名填充数组。 最后，它接受一个指向主机名缓冲区的指针，并将该指针转换为一个 Julia 字符串，假设它是一个以 null 结尾的 C 字符串。</p><p>C 库通常使用这种模式，要求调用者分配要传递给被调用者并填充的内存。 像这样从 Julia 分配内存通常是通过创建一个未初始化的数组并将指向其数据的指针传递给 C 函数来完成的。 这就是我们在这里不使用 <code>Cstring</code> 类型的原因：由于数组未初始化，它可能包含 null 字节。 作为 <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> 的一部分，转换为 <code>Cstring</code> 会检查包含的 null 字节，因此可能会引发类型转换错误。</p><p>用 <code>unsafe_string</code> 取消引用 <code>pointer(hostname)</code> 是一种不安全的操作，因为它需要访问为 <code>hostname</code> 分配的内存，而这些内存可能在同时被垃圾收集。 宏 <a href="../../base/base/#Base.GC.@preserve"><code>GC.@preserve</code></a> 防止这种情况发生，从而防止访问无效的内存位置。</p><p>Finally, here is an example of specifying a library via a path. We create a shared library with the following content</p><pre><code class="language-c hljs">#include &lt;stdio.h&gt;

void say_y(int y)
{
    printf(&quot;Hello from C: got y = %d.\n&quot;, y);
}</code></pre><p>and compile it with <code>gcc -fPIC -shared -o mylib.so mylib.c</code>. It can then be called by specifying the (absolute) path as the library name:</p><pre><code class="language-julia-repl hljs">julia&gt; @ccall &quot;./mylib.so&quot;.say_y(5::Cint)::Cvoid
Hello from C: got y = 5.</code></pre><h2 id="创建和C兼容的Julia函数指针"><a class="docs-heading-anchor" href="#创建和C兼容的Julia函数指针">创建和C兼容的Julia函数指针</a><a id="创建和C兼容的Julia函数指针-1"></a><a class="docs-heading-anchor-permalink" href="#创建和C兼容的Julia函数指针" title="Permalink"></a></h2><p>可以将Julia函数传递给接受函数指针参数的原生C函数。例如，要匹配满足下面的C原型：</p><pre><code class="language-c hljs">typedef returntype (*functiontype)(argumenttype, ...)</code></pre><p>宏 <a href="../../base/c/#Base.@cfunction"><code>@cfunction</code></a> 为调用 Julia 函数生成 C 兼容函数指针。 <a href="../../base/c/#Base.@cfunction"><code>@cfunction</code></a> 的参数是：</p><ol><li>一个Julia函数</li><li>函数的返回值类型</li><li>输入类型的元组，对应于函数签名</li></ol><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>与 <code>ccall</code> 一样，返回类型和输入类型必须是字面量常量。</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>目前，仅支持平台默认的C调用约定。这意味着，<code>@cfunction</code>生成的指针不能用于WINAPI要求在32位Windows上使用<code>stdcall</code>函数的调用中，但可以在WIN64上使用（其中<code>stdcall</code>与C调用约定统一）。</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Callback functions exposed via <code>@cfunction</code> should not throw errors, as that will return control to the Julia runtime unexpectedly and may leave the program in an undefined state.</p></div></div><p>A classic example is the standard C library <code>qsort</code> function, declared as:</p><pre><code class="language-c hljs">void qsort(void *base, size_t nitems, size_t size,
           int (*compare)(const void*, const void*));</code></pre><p><code>base</code> 参数是一个指向长度为 <code>nitems</code> 的数组的指针，每个元素都有 <code>size</code> 字节。 <code>compare</code> 是一个回调函数，它采用指向两个元素 <code>a</code> 和 <code>b</code> 的指针， 如果 <code>a</code> 出现在 <code>b</code> 之前/之后，则返回小于/大于零的整数（如果允许任何顺序，则返回零） 。</p><p>现在，假设我们在 Julia 中有一个 1 维数组 <code>A</code>，我们希望使用<code>qsort</code>函数（而不是 Julia 的内置<code>sort</code>函数）对其进行排序。 在我们考虑调用 <code>qsort</code> 并传递参数之前，我们需要编写一个比较函数：</p><pre><code class="language-julia-repl hljs">julia&gt; function mycompare(a, b)::Cint
           return (a &lt; b) ? -1 : ((a &gt; b) ? +1 : 0)
       end;</code></pre><p><code>qsort</code> 需要一个返回 C <code>int</code> 的比较函数，因此我们将返回类型注释为 <code>Cint</code>。</p><p>为了将此函数传递给 C，我们使用宏<code>@cfunction</code> 获取它的地址：</p><pre><code class="language-julia-repl hljs">julia&gt; mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));</code></pre><p><a href="../../base/c/#Base.@cfunction"><code>@cfunction</code></a> 需要三个参数: Julia函数 (<code>mycompare</code>), 返回值类型(<code>Cint</code>), 和一个输入参数类型的字面量元组, 此处是要排序的<code>Cdouble</code>(<a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>) 元素的数组.</p><p><code>qsort</code>的最终调用看起来是这样的：</p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.3, -2.7, 4.4, 3.1];

julia&gt; @ccall qsort(A::Ptr{Cdouble}, length(A)::Csize_t, sizeof(eltype(A))::Csize_t, mycompare_c::Ptr{Cvoid})::Cvoid

julia&gt; A
4-element Vector{Float64}:
 -2.7
  1.3
  3.1
  4.4</code></pre><p>如示例所示，原始 Julia 数组 <code>A</code> 现在已排序：<code>[-2.7, 1.3, 3.1, 4.4]</code>。 请注意，Julia <a href="#automatic-type-conversion">负责将数组转换为<code>Ptr{Cdouble}</code></a>)，计算元素类型的大小（以字节为单位），等等。</p><p>为了好玩，尝试在 <code>mycompare</code> 中插入一行 <code>println(&quot;mycompare($a, $b)&quot;)</code>，这将允许你查看 <code>qsort</code> 正在执行的比较（并验证它是否真的在调用你传递给它的 Julia 函数）。</p><h2 id="mapping-c-types-to-julia"><a class="docs-heading-anchor" href="#mapping-c-types-to-julia">将 C 类型映射到 Julia</a><a id="mapping-c-types-to-julia-1"></a><a class="docs-heading-anchor-permalink" href="#mapping-c-types-to-julia" title="Permalink"></a></h2><p>将声明的 C 类型与其在 Julia 中的声明完全匹配至关重要。 不一致会导致在一个系统上正常工作的代码在另一个系统上失败或产生不确定的结果。</p><p>请注意，在调用 C 函数的过程中没有任何地方使用 C 头文件：您有责任确保您的 Julia 类型和调用签名准确反映 C 头文件中的那些。<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></p><h3 id="automatic-type-conversion"><a class="docs-heading-anchor" href="#automatic-type-conversion">自动类型转换</a><a id="automatic-type-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#automatic-type-conversion" title="Permalink"></a></h3><p>Julia 会自动插入对 <a href="../../base/c/#Base.cconvert"><code>Base.cconvert</code></a> 函数的调用，以将每个参数转换为指定的类型。 例如，以下调用：</p><pre><code class="language-julia hljs">@ccall &quot;libfoo&quot;.foo(x::Int32, y::Float64)::Cvoid</code></pre><p>将表现得好像它是这样写的：</p><pre><code class="language-julia hljs">@ccall &quot;libfoo&quot;.foo(
    Base.unsafe_convert(Int32, Base.cconvert(Int32, x))::Int32,
    Base.unsafe_convert(Float64, Base.cconvert(Float64, y))::Float64
    )::Cvoid</code></pre><p><a href="../../base/c/#Base.cconvert"><code>Base.cconvert</code></a> 通常只调用 <a href="../../base/base/#Base.convert"><code>convert</code></a>，但可以定义为返回一个更适合传递给 C 的任意新对象。这应该用于执行 C 代码将访问的内存。 例如，这用于将对象（例如字符串）的 <code>Array</code> 转换为指针数组。</p><p><a href="../../base/c/#Base.unsafe_convert"><code>Base.unsafe_convert</code></a> 处理到 <a href="../../base/c/#Core.Ptr"><code>Ptr</code></a> 类型转换。 它被认为是不安全的，因为将对象转换为本地指针会隐藏垃圾收集器中的对象，导致它过早地被释放。</p><h3 id="类型对应"><a class="docs-heading-anchor" href="#类型对应">类型对应</a><a id="类型对应-1"></a><a class="docs-heading-anchor-permalink" href="#类型对应" title="Permalink"></a></h3><p>首先，让我们回顾一些相关的 Julia 类型术语：</p><table><tr><th style="text-align: left">语法 / 关键字</th><th style="text-align: left">例子</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><code>mutable struct</code></td><td style="text-align: left"><code>BitSet</code></td><td style="text-align: left"><code>Leaf Type</code>：包含 <code>type-tag</code> 的一组相关数据，由 Julia GC 管理，通过 <code>object-identity</code> 来定义。为了保证实例可以被构造，<code>Leaf Type</code> 必须是完整定义的，即不允许使用 <code>TypeVars</code>。</td></tr><tr><td style="text-align: left"><code>abstract type</code></td><td style="text-align: left"><code>Any</code>, <code>AbstractArray{T, N}</code>, <code>Complex{T}</code></td><td style="text-align: left"><code>Super Type</code>：用于描述一组类型，它不是 <code>Leaf-Type</code>，也无法被实例化。</td></tr><tr><td style="text-align: left"><code>T{A}</code></td><td style="text-align: left"><code>Vector{Int}</code></td><td style="text-align: left"><code>Type Parameter</code>：某种类型的一种具体化，通常用于分派或存储优化。</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>TypeVar</code>：<code>Type parameter</code> 声明中的 <code>T</code> 是一个 <code>TypeVar</code>，它是类型变量的简称。</td></tr><tr><td style="text-align: left"><code>primitive type</code></td><td style="text-align: left"><code>Int</code>, <code>Float64</code></td><td style="text-align: left"><code>Primitive Type</code>：一种没有成员变量的类型，但是它有大小。它是按值存储和定义的。</td></tr><tr><td style="text-align: left"><code>struct</code></td><td style="text-align: left"><code>Pair{Int, Int}</code></td><td style="text-align: left">&quot;Struct&quot; :: 所有字段都定义为常量的类型。 它是按值定义的，并且可以与类型标签一起存储。</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>ComplexF64</code> (<code>isbits</code>)</td><td style="text-align: left">&quot;Is-Bits&quot; :: 一个 <code>primitive type</code>，或者一个 <code>struct</code> 类型，其中所有字段都是其他 <code>isbits</code> 类型。 它是按值定义的，并且在没有类型标签的情况下存储。</td></tr><tr><td style="text-align: left"><code>struct ...; end</code></td><td style="text-align: left"><code>nothing</code></td><td style="text-align: left"><code>Singleton</code>：没有成员变量的 <code>Leaf Type</code> 或 <code>Struct</code>。</td></tr><tr><td style="text-align: left"><code>(...)</code> or <code>tuple(...)</code></td><td style="text-align: left"><code>(1, 2, 3)</code></td><td style="text-align: left">“元组” :: 类似于匿名结构类型或常量数组的不可变数据结构。 表示为数组或结构。</td></tr></table><h3 id="man-bits-types"><a class="docs-heading-anchor" href="#man-bits-types">Bits Types</a><a id="man-bits-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-bits-types" title="Permalink"></a></h3><p>有几种特殊类型需要注意，因为没有其他类型可以定义为具有相同的行为：</p><ul><li><p><code>Float32</code></p><p>和C语言中的 <code>float</code> 类型完全对应（以及Fortran中的 <code>REAL*4</code> ）</p></li><li><p><code>Float64</code></p><p>和C语言中的 <code>double</code> 类型完全对应（以及Fortran中的 <code>REAL*8</code> ）</p></li><li><p><code>ComplexF32</code></p><p>和C语言中的 <code>complex float</code> 类型完全对应（以及Fortran中的 <code>COMPLEX*8</code> ）</p></li><li><p><code>ComplexF64</code></p><p>和C语言中的 <code>complex double</code> 类型完全对应（以及Fortran中的 <code>COMPLEX*16</code> ）</p></li><li><p><code>Signed</code></p><p>和C语言中的 <code>signed</code> 类型标识完全对应（以及Fortran中的任意 <code>INTEGER</code> 类型） Julia中任何不是<a href="../../base/numbers/#Core.Signed"><code>Signed</code></a> 的子类型的类型，都会被认为是unsigned类型。</p></li></ul><ul><li><p><code>Ref{T}</code></p><p>和 <code>Ptr{T}</code> 行为相同，能通过Julia的GC管理其内存。</p></li></ul><ul><li><p><code>Array{T,N}</code></p><p>当数组作为 <code>Ptr{T}</code> 参数传递给 C 时，它不是重新解释转换：Julia 要求数组的元素类型与 <code>T</code> 匹配，并传递第一个元素的地址。</p><p>因此，如果一个 <code>Array</code> 中的数据格式不正确，它必须被显式地转换 ，通过类似 <code>trunc.(Int32, A)</code> 的函数。</p><p>若要将一个数组 <code>A</code> 以不同类型的指针传递，而<em>不提前转换数据</em>， （比如，将一个 <code>Float64</code> 数组传给一个处理原生字节的函数时），你 可以将这一参数声明为 <code>Ptr{Cvoid}</code> 。</p><p>如果一个元素类型为 <code>Ptr{T}</code> 的数组作为 <code>Ptr{Ptr{T}}</code> 类型的参数传递， <a href="../../base/c/#Base.cconvert"><code>Base.cconvert</code></a>  将会首先尝试进行 null-terminated copy（即直到下一个元素为null才停止复制），并将每一个元素使用其通过 <a href="../../base/c/#Base.cconvert"><code>Base.cconvert</code></a> 转换后的版本替换。 这允许，比如，将一个 <code>argv</code> 的指针数组，其类型为 <code>Vector{String}</code> ，传递给一个类型为 <code>Ptr{Ptr{Cchar}}</code> 的参数。</p></li></ul><p>在我们目前支持的所有系统上，基本的 C/C++ 值类型可以转换为 Julia 类型，如下所示。 每个 C 类型还有一个对应的同名 Julia 类型，以 C 为前缀。这在编写可移植代码时很有帮助（记住 C 中的 <code>int</code> 与 Julia 中的 <code>Int</code> 不同）。</p><p><strong>独立于系统的类型</strong></p><table><tr><th style="text-align: left">C 类型</th><th style="text-align: left">Fortran 类型</th><th style="text-align: left">标准 Julia 别名</th><th style="text-align: left">Julia 基本类型</th></tr><tr><td style="text-align: left"><code>unsigned char</code></td><td style="text-align: left"><code>CHARACTER</code></td><td style="text-align: left"><code>Cuchar</code></td><td style="text-align: left"><code>UInt8</code></td></tr><tr><td style="text-align: left"><code>bool</code> (_Bool in C99+)</td><td style="text-align: left"></td><td style="text-align: left"><code>Cuchar</code></td><td style="text-align: left"><code>UInt8</code></td></tr><tr><td style="text-align: left"><code>short</code></td><td style="text-align: left"><code>INTEGER*2</code>, <code>LOGICAL*2</code></td><td style="text-align: left"><code>Cshort</code></td><td style="text-align: left"><code>Int16</code></td></tr><tr><td style="text-align: left"><code>unsigned short</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cushort</code></td><td style="text-align: left"><code>UInt16</code></td></tr><tr><td style="text-align: left"><code>int</code>, <code>BOOL</code> (C, typical)</td><td style="text-align: left"><code>INTEGER*4</code>, <code>LOGICAL*4</code></td><td style="text-align: left"><code>Cint</code></td><td style="text-align: left"><code>Int32</code></td></tr><tr><td style="text-align: left"><code>unsigned int</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cuint</code></td><td style="text-align: left"><code>UInt32</code></td></tr><tr><td style="text-align: left"><code>long long</code></td><td style="text-align: left"><code>INTEGER*8</code>, <code>LOGICAL*8</code></td><td style="text-align: left"><code>Clonglong</code></td><td style="text-align: left"><code>Int64</code></td></tr><tr><td style="text-align: left"><code>unsigned long long</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Culonglong</code></td><td style="text-align: left"><code>UInt64</code></td></tr><tr><td style="text-align: left"><code>intmax_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cintmax_t</code></td><td style="text-align: left"><code>Int64</code></td></tr><tr><td style="text-align: left"><code>uintmax_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cuintmax_t</code></td><td style="text-align: left"><code>UInt64</code></td></tr><tr><td style="text-align: left"><code>float</code></td><td style="text-align: left"><code>REAL*4i</code></td><td style="text-align: left"><code>Cfloat</code></td><td style="text-align: left"><code>Float32</code></td></tr><tr><td style="text-align: left"><code>double</code></td><td style="text-align: left"><code>REAL*8</code></td><td style="text-align: left"><code>Cdouble</code></td><td style="text-align: left"><code>Float64</code></td></tr><tr><td style="text-align: left"><code>complex float</code></td><td style="text-align: left"><code>COMPLEX*8</code></td><td style="text-align: left"><code>ComplexF32</code></td><td style="text-align: left"><code>Complex{Float32}</code></td></tr><tr><td style="text-align: left"><code>complex double</code></td><td style="text-align: left"><code>COMPLEX*16</code></td><td style="text-align: left"><code>ComplexF64</code></td><td style="text-align: left"><code>Complex{Float64}</code></td></tr><tr><td style="text-align: left"><code>ptrdiff_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cptrdiff_t</code></td><td style="text-align: left"><code>Int</code></td></tr><tr><td style="text-align: left"><code>ssize_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cssize_t</code></td><td style="text-align: left"><code>Int</code></td></tr><tr><td style="text-align: left"><code>size_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Csize_t</code></td><td style="text-align: left"><code>UInt</code></td></tr><tr><td style="text-align: left"><code>void</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Cvoid</code></td></tr><tr><td style="text-align: left"><code>void</code> and <code>[[noreturn]]</code> or <code>_Noreturn</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Union{}</code></td></tr><tr><td style="text-align: left"><code>void*</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ptr{Cvoid}</code> (或类似的 <code>Ref{Cvoid}</code>)</td></tr><tr><td style="text-align: left"><code>T*</code> (where T represents an appropriately defined type)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ref{T}</code> （只有当 T 是 isbits 类型时，T 才可以安全地转变）</td></tr><tr><td style="text-align: left"><code>char*</code> (or <code>char[]</code>, e.g. a string)</td><td style="text-align: left"><code>CHARACTER*N</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cstring</code> if null-terminated, or <code>Ptr{UInt8}</code> if not</td></tr><tr><td style="text-align: left"><code>char**</code> (or <code>*char[]</code>)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ptr{Ptr{UInt8}}</code></td></tr><tr><td style="text-align: left"><code>jl_value_t*</code> (any Julia Type)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Any</code></td></tr><tr><td style="text-align: left"><code>jl_value_t* const*</code> (一个 Julia 值的引用）</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ref{Any}</code>（常量，因为转变需要写屏障，不可能正确插入）</td></tr><tr><td style="text-align: left"><code>va_arg</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">Not supported</td></tr><tr><td style="text-align: left"><code>...</code> (variadic function specification)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>T...</code>（其中 <code>T</code> 是上述类型之一，当使用 <code>ccall</code> 函数时）</td></tr><tr><td style="text-align: left"><code>...</code> (variadic function specification)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>; va_arg1::T、va_arg2::S 等</code>（仅支持<code>@ccall</code> 宏）</td></tr></table><p><a href="../../base/c/#Base.Cstring"><code>Cstring</code></a> 类型本质上是 <code>Ptr{UInt8}</code> 的同义词，但如果 Julia 字符串包含任何嵌入的 null 字符，则类型转换为 <code>Cstring</code> 会引发错误 （如果 C 例程将 null 视为终止符，则会导致字符串被静默截断）。 如果要将 <code>char*</code> 传递给不采用 null 终止的 C 例程（例如，因为传递的是显式字符串长度）， 或者如果确定 Julia 字符串不包含 null 并希望跳过检查，则可以使用 <code>Ptr{UInt8}</code> 作为参数类型。 <code>Cstring</code> 也可以用作 <a href="../../base/c/#ccall"><code>ccall</code></a> 返回类型，但在这种情况下，它显然不会引入任何额外的检查，只是为了提高调用的可读性。</p><p><strong>系统独立类型</strong></p><table><tr><th style="text-align: left">C 类型</th><th style="text-align: left">标准 Julia 别名</th><th style="text-align: left">Julia 基本类型</th></tr><tr><td style="text-align: left"><code>char</code></td><td style="text-align: left"><code>Cchar</code></td><td style="text-align: left"><code>Int8</code> (x86, x86_64), <code>UInt8</code> (powerpc, arm)</td></tr><tr><td style="text-align: left"><code>long</code></td><td style="text-align: left"><code>Clong</code></td><td style="text-align: left"><code>Int</code> (UNIX), <code>Int32</code> (Windows)</td></tr><tr><td style="text-align: left"><code>unsigned long</code></td><td style="text-align: left"><code>Culong</code></td><td style="text-align: left"><code>UInt</code> (UNIX), <code>UInt32</code> (Windows)</td></tr><tr><td style="text-align: left"><code>wchar_t</code></td><td style="text-align: left"><code>Cwchar_t</code></td><td style="text-align: left"><code>Int32</code> (UNIX), <code>UInt16</code> (Windows)</td></tr></table><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>调用 Fortran 时，所有输入都必须通过指向堆分配或堆栈分配值的指针传递，因此上述所有类型对应都应在其类型规范周围包含一个额外的 <code>Ptr{..}</code> 或 <code>Ref{..}</code> 包装器。</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>对于字符串参数 (<code>char*</code>)，Julia 类型应该是 <code>Cstring</code>（如果需要以 null 结尾的数据），否则为 <code>Ptr{Cchar}</code> 或 <code>Ptr{UInt8}</code>（这两种指针类型具有相同的效果）， 如上所述，而不是 <code>String</code>。 类似地，对于数组参数（<code>T[]</code> 或 <code>T*</code>），Julia 类型应该还是 <code>Ptr{T}</code>，而不是 <code>Vector{T}</code>。</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Julia 的 <code>Char</code> 类型是 32 位，这与所有平台上的宽字符类型（<code>wchar_t</code> 或 <code>wint_t</code>）不同。</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>Union{}</code> 的返回类型意味着函数不会返回，即 C++11 <code>[[noreturn]]</code> 或 C11 <code>_Noreturn</code>（例如 <code>jl_throw</code> 或 <code>longjmp</code>）。 不要将此用于不返回值（<code>void</code>）但返回的函数，对于这些函数，使用 <code>Cvoid</code>。</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>对于 <code>wchar_t*</code> 参数，Julia 类型应为 <a href="../../base/c/#Base.Cwstring"><code>Cwstring</code></a>（如果 C 例程需要以 null 结尾的字符串），否则为 <code>Ptr{Cwchar_t}</code>。 另请注意，Julia 中的 UTF-8 字符串数据在内部以 null 结尾，因此可以将其传递给需要以 null 结尾的数据的 C 函数，而无需进行复制 （但使用 <code>Cwstring</code> 类型将导致抛出错误，如果字符串本身包含 null 字符）。</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>可以在 Julia 中使用 <code>Ptr{Ptr{UInt8}}</code> 类型调用采用 <code>char**</code> 类型参数的 C 函数。 例如，以下形式的 C 函数：</p><pre><code class="language-c hljs">int main(int argc, char **argv);</code></pre><p>可以通过以下 Julia 代码调用：</p><pre><code class="language-julia hljs">argv = [ &quot;a.out&quot;, &quot;arg1&quot;, &quot;arg2&quot; ]
@ccall main(length(argv)::Int32, argv::Ptr{Ptr{UInt8}})::Int32</code></pre></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>对于采用 <code>character(len=*)</code> 类型的可变长度字符串的 Fortran 函数，字符串长度作为<em>隐藏参数</em>提供。 这些参数在列表中的类型和位置是特定于编译器的，编译器供应商通常默认使用 <code>Csize_t</code> 作为类型并将隐藏的参数附加到参数列表的末尾。 虽然此行为对于某些编译器 (GNU) 是固定的，但其他编译器<em>可选</em> 允许将隐藏参数直接放置在字符参数（Intel、PGI）之后。 例如，如下的 Fortran 子程序</p><pre><code class="language-fortran hljs">subroutine test(str1, str2)
character(len=*) :: str1,str2</code></pre><p>can be called via the following Julia code, where the lengths are appended</p><pre><code class="language-julia hljs">str1 = &quot;foo&quot;
str2 = &quot;bar&quot;
ccall(:test, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),
                    str1, str2, sizeof(str1), sizeof(str2))</code></pre></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Fortran 编译器还<em>可以</em>为指针、假定形状（<code>:</code>）和假定大小（<code>*</code>）数组添加其他隐藏参数。 这种行为可以通过使用 <code>ISO_C_BINDING</code> 并在子例程的定义中包含 <code>bind(c)</code> 来避免，强烈推荐用于可互操作的代码。 在这种情况下，将没有隐藏的参数，代价是一些语言特性（例如，只允许 <code>character(len=1)</code> 传递字符串）。</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>声明为返回 <code>Cvoid</code> 的 C 函数将在 Julia 中返回值 <code>nothing</code>。</p></div></div><h3 id="结构类型对应"><a class="docs-heading-anchor" href="#结构类型对应">结构类型对应</a><a id="结构类型对应-1"></a><a class="docs-heading-anchor-permalink" href="#结构类型对应" title="Permalink"></a></h3><p>复合类型，例如 C 中的<code>struct</code>或 Fortran90 中的<code>TYPE</code>（或 F77 的某些变体中的<code>STRUCTURE</code>/<code>RECORD</code>），可以通过创建具有相同字段布局的<code>struct</code>定义在 Julia 中进行镜像复制。</p><p>当递归使用时，<code>isbits</code> 类型被内联存储。 所有其他类型都存储为指向数据的指针。 在 C 中的另一个结构中镜像复制按值使用的结构时，不要尝试手动复制字段，因为这不会保留正确的字段对齐。 相反，建议声明一个 <code>isbits</code> 结构类型并使用它。 未命名的结构在翻译为 Julia 时是不可能的。</p><p>Julia不支持压缩结构和联合声明。</p><p>如果你事先地知道将具有最大大小（可能包括填充）的字段，则可以获得 <code>union</code> 的近似。 将你的字段转换为 Julia 时，将 Julia 字段声明为仅属于该类型。</p><p>参数数组可以用 <code>NTuple</code> 表示。例如，C 符号中的 struct 写成</p><pre><code class="language-c hljs">struct B {
    int A[3];
};

b_a_2 = B.A[2];</code></pre><p>可以用 Julia 写成</p><pre><code class="language-julia hljs">struct B
    A::NTuple{3, Cint}
end

b_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)</code></pre><p>不直接支持未知大小的数组（由<code>[]</code> 或<code>[0]</code> 指定的符合C99 的可变长度结构）。 通常处理这些的最好方法是直接处理字节偏移量。 例如，如果一个 C 库声明了一个正确的字符串类型并返回一个指向它的指针：</p><pre><code class="language-c hljs">struct String {
    int strlen;
    char data[];
};</code></pre><p>在 Julia 中，我们可以独立访问这些部分以制作该字符串的副本：</p><pre><code class="language-julia hljs">str = from_c::Ptr{Cvoid}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)</code></pre><h3 id="类型参数"><a class="docs-heading-anchor" href="#类型参数">类型参数</a><a id="类型参数-1"></a><a class="docs-heading-anchor-permalink" href="#类型参数" title="Permalink"></a></h3><p>当定义了方法时，<code>@ccall</code> 和 <code>@cfunction</code> 的类型参数被静态地评估。 因此，它们必须采用字面量元组的形式，而不是变量，并且不能引用局部变量。</p><p>这听起来像是一个奇怪的限制，但请记住，由于 C 不是像 Julia 那样的动态语言，它的函数只能接受具有静态已知的固定签名的参数类型。</p><p>然而，虽然必须静态地知道类型布局才能计算预期的 C ABI，但函数的静态参数被视为此静态环境的一部分。 函数的静态参数可以用作调用签名中的类型参数，只要它们不影响类型的布局即可。 例如，<code>f(x::T) where {T} = @ccall valid(x::Ptr{T})::Ptr{T}</code> 是有效的，因为 <code>Ptr</code> 始终是字大小的原始类型。 但是，<code>g(x::T) where {T} = @ccall notvalid(x::T)::T</code> 是无效的，因为 <code>T</code> 的类型布局不是静态已知的。</p><h3 id="SIMD-值"><a class="docs-heading-anchor" href="#SIMD-值">SIMD 值</a><a id="SIMD-值-1"></a><a class="docs-heading-anchor-permalink" href="#SIMD-值" title="Permalink"></a></h3><p>注意：此功能目前仅在 64 位 x86 和 AArch64 平台上实现。</p><p>如果 C/C++ 例程具有本机 SIMD 类型的参数或返回值，则相应的 Julia 类型是自然映射到 SIMD 类型的<code>VecElement</code> 的同构元组。 具体来说：</p><blockquote><ul><li>元组的大小必须与 SIMD 类型相同。 例如，一个表示 <code>__m128</code> 的元组</li></ul><p>在 x86 上必须有 16 字节的大小。</p><ul><li>元组的元素类型必须是 <code>VecElement{T}</code> 的一个实例，其中 <code>T</code> 是一个原始类型</li></ul><p>是 1、2、4 或 8 个字节。</p></blockquote><p>例如，考虑这个使用 AVX 内在函数的 C 例程：</p><pre><code class="language-c hljs">#include &lt;immintrin.h&gt;

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}</code></pre><p>以下 Julia 代码使用 <code>ccall</code> 调用 <code>dist</code>：</p><pre><code class="language-julia hljs">const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -&gt; VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -&gt; VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    @ccall &quot;libdist&quot;.dist(a::m256, b::m256)::m256
end

println(call_dist(a,b))</code></pre><p>主机必须具有必要的 SIMD 寄存器。 例如，上面的代码将无法在没有 AVX 支持的主机上运行。</p><h3 id="内存所有权"><a class="docs-heading-anchor" href="#内存所有权">内存所有权</a><a id="内存所有权-1"></a><a class="docs-heading-anchor-permalink" href="#内存所有权" title="Permalink"></a></h3><p><strong><code>malloc</code>/<code>free</code></strong></p><p>此类对象的内存分配和释放必须通过调用正在使用的库中的适当清理例程来处理，就像在任何 C 程序中一样。 不要尝试在 Julia 中使用 <a href="../../base/libc/#Base.Libc.free"><code>Libc.free</code></a> 释放从 C 库接收的对象，因为这可能会导致通过错误的库调用 <code>free</code> 函数并导致进程中止。 反过来（传递在 Julia 中分配的对象以供外部库释放）同样无效。</p><h3 id="何时使用-T、Ptr{T}-以及-Ref{T}"><a class="docs-heading-anchor" href="#何时使用-T、Ptr{T}-以及-Ref{T}">何时使用 <code>T</code>、<code>Ptr{T}</code> 以及 <code>Ref{T}</code></a><a id="何时使用-T、Ptr{T}-以及-Ref{T}-1"></a><a class="docs-heading-anchor-permalink" href="#何时使用-T、Ptr{T}-以及-Ref{T}" title="Permalink"></a></h3><p>在对外部C例程的Julia代码包装调用中，普通（非指针）数据应该在 <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> 中声明为<code>T</code>类型，因为它们是通过值传递的。 对于接受指针的C代码，<a href="../../base/c/#Core.Ref"><code>Ref{T}</code></a> 通常应用于输入参数的类型，允许通过对<a href="../../base/c/#Base.cconvert"><code>Base.cconvert</code></a> 的隐式调用使用指向Julia或C管理的内存的指针。 相反，被调用的C函数返回的指针应该声明为输出类型<a href="../../base/c/#Core.Ptr"><code>Ptr{T}</code></a>，这反映了指向的内存仅由C管理。 C结构中包含的指针应在相应的Julia结构类型中表示为<code>Ptr{T}</code>类型的字段，这些结构类型旨在模拟相应C结构的内部结构。</p><p>在 Julia 代码包装对外部 Fortran 例程的调用中，所有输入参数都应声明为<code>Ref{T}</code>类型，因为 Fortran 通过指向内存位置的指针传递所有变量。 Fortran 子程序的返回类型应该是 <code>Cvoid</code>，或者 Fortran 函数的返回类型应该是 <code>T</code>，返回类型是 <code>T</code>。</p><h1 id="将-C-函数映射到-Julia"><a class="docs-heading-anchor" href="#将-C-函数映射到-Julia">将 C 函数映射到 Julia</a><a id="将-C-函数映射到-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#将-C-函数映射到-Julia" title="Permalink"></a></h1><h3 id="@ccall-/-@cfunction-参数翻译指南"><a class="docs-heading-anchor" href="#@ccall-/-@cfunction-参数翻译指南"><code>@ccall</code> / <code>@cfunction</code> 参数翻译指南</a><a id="@ccall-/-@cfunction-参数翻译指南-1"></a><a class="docs-heading-anchor-permalink" href="#@ccall-/-@cfunction-参数翻译指南" title="Permalink"></a></h3><p>将 C 参数列表翻译为 Julia：</p><ul><li><p><code>T</code>，其中 <code>T</code> 取值为：<code>char</code>、<code>int</code>、<code>long</code>、<code>short</code>、<code>float</code>、<code>double</code>、<code>complex</code>、<code>enum</code> 或其等价的 <code>typedef</code> 类型</p><ul><li><code>T</code>，其中 <code>T</code> 是等价的 Julia Bits 类型（参见上表）</li><li>如果 <code>T</code> 是 <code>enum</code>，则参数类型应等价于 <code>Cint</code> 或 <code>Cuint</code></li><li>参数值将被复制（按值传递）</li></ul></li><li><p><code>struct T</code> （包括 struct 的 typedef）</p><ul><li><code>T</code>，其中 <code>T</code> 是 Julia 叶类型</li><li>参数值将被复制（按值传递）</li></ul></li><li><p><code>void*</code></p></li></ul><pre><code class="nohighlight hljs"> * 取决于如何使用此参数，首先将其翻译为所需的指针类型，然后使用此列表中的其余规则确定 Julia 等价项
 * 这个参数可以声明为 `Ptr{Cvoid}`，如果它真的只是一个未知的指针</code></pre><ul><li><p><code>jl_value_t*</code></p><ul><li><code>Any</code></li><li>参数值必须是有效的 Julia 对象</li></ul></li><li><p><code>jl_value_t* const*</code></p><ul><li><code>Ref{Any}</code></li><li>参数列表必须是有效的 Julia 对象（或 C_NULL）</li><li>不能用于输出参数，除非用户能够单独安排要GC保留的对象</li></ul></li><li><p><code>T*</code> </p><ul><li><code>Ref{T}</code>，其中 <code>T</code> 是与 <code>T</code> 对应的 Julia 类型</li><li>如果它是 <code>inlinealloc</code> 类型，则将复制参数值（包括 <code>isbits</code>，否则，值必须是有效的 Julia 对象）</li></ul></li><li><p><code>T (*)(...)</code> （例如，指向函数的指针）</p><ul><li><code>Ptr{Cvoid}</code>（您可能需要显式使用 <a href="../../base/c/#Base.@cfunction"><code>@cfunction</code></a> 来创建此指针）</li></ul></li><li><p><code>...</code> （例如，可变参数）</p><ul><li>[对于 <code>ccall</code>]：<code>T...</code>，其中 <code>T</code> 是所有剩余参数的单个 Julia 类型</li><li>[对于 <code>@ccall</code>]：<code>; va_arg1::T, va_arg2::S, etc</code>，其中 <code>T</code> 和 <code>S</code> 是 Julia 类型（即，使用 <code>;</code> 将常规参数与可变参数分开）</li><li>目前不支持 <code>@cfunction</code></li></ul></li><li><p><code>va_arg</code></p><ul><li><code>ccall</code> 或 <code>@cfunction</code> 不支持</li></ul></li></ul><h3 id="@ccall-/-@cfunction-返回类型翻译指南"><a class="docs-heading-anchor" href="#@ccall-/-@cfunction-返回类型翻译指南"><code>@ccall</code> / <code>@cfunction</code> 返回类型翻译指南</a><a id="@ccall-/-@cfunction-返回类型翻译指南-1"></a><a class="docs-heading-anchor-permalink" href="#@ccall-/-@cfunction-返回类型翻译指南" title="Permalink"></a></h3><p>将 C 返回类型翻译为 Julia：</p><ul><li><p><code>void</code></p><ul><li><code>Cvoid</code>（这将返回单例实例 <code>nothing::Cvoid</code>）</li></ul></li><li><p><code>T</code>，其中 <code>T</code> 是原始类型之一：<code>char</code>，<code>int</code>，<code>long</code>，<code>short</code>，<code>float</code>，<code>double</code>，<code>complex</code>，<code>enum</code> 或任何等效的 <code>typedef</code></p><ul><li><code>T</code>, 其中 <code>T</code> 是等效的 Julia Bits 类型（请参阅上表）</li><li>如果 <code>T</code> 是 <code>enum</code>，则参数类型应等效于 <code>Cint</code> 或 <code>Cuint</code></li><li>参数值将被复制（按值返回）</li></ul></li><li><p><code>struct T</code> （包括 typedef 到结构体）</p><ul><li><code>T</code>，其中 <code>T</code> 是 Julia 叶类型</li><li>参数值将被复制（按值返回）</li></ul></li><li><p><code>void*</code></p><pre><code class="nohighlight hljs">* 取决于如何使用此参数，首先将其翻译为所需的指针类型，然后使用此列表中的其余规则确定 Julia 等效项
* 如果它确实只是一个未知指针，则可以将此参数声明为 `Ptr{Cvoid}`</code></pre></li><li><p><code>jl_value_t*</code></p><ul><li><code>Any</code></li><li>参数值必须是有效的 Julia 对象</li></ul></li><li><p><code>jl_value_t**</code></p><ul><li><code>Ptr{Any}</code>（<code>Ref{Any}</code> 是无效的返回类型）</li></ul></li><li><p><code>T*</code></p><ul><li><p>如果内存已由 Julia 拥有，或者是 <code>isbits</code> 类型，并且已知为非空：</p><ul><li><code>Ref{T}</code>，其中 <code>T</code> 是对应于 <code>T</code> 的 Julia 类型</li><li>返回类型 <code>Ref{Any}</code> 无效，它应该是 <code>Any</code>（对应于 <code>jl_value_t*</code>）或 <code>Ptr{Any}</code>（对应于 <code>jl_value_t**</code>）</li><li>C <strong>不得</strong> 修改通过 <code>Ref{T}</code> 返回的内存，如果 <code>T</code> 是 <code>isbits</code> 类型</li></ul></li><li><p>如果内存由 C 拥有：</p><ul><li><code>Ptr{T}</code>，其中 <code>T</code> 是对应于 <code>T</code> 的 Julia 类型</li></ul></li></ul></li><li><p><code>T (*)(...)</code>（例如，指向函数的指针）</p><ul><li><code>Ptr{Cvoid}</code>，以便从 Julia 直接调用此函数，你需要将此作为 <a href="../../base/c/#ccall"><code>ccall</code></a> 的第一个参数传递。 请参阅 <a href="#间接调用">间接调用</a>。</li></ul></li></ul><h3 id="传递修改输入的指针"><a class="docs-heading-anchor" href="#传递修改输入的指针">传递修改输入的指针</a><a id="传递修改输入的指针-1"></a><a class="docs-heading-anchor-permalink" href="#传递修改输入的指针" title="Permalink"></a></h3><p>因为 C 不支持多个返回值，所以 C 函数通常会使用指向函数将修改的数据的指针。 要在 <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> 中完成此操作，你需要首先将值封装在适当类型的 <a href="../../base/c/#Core.Ref"><code>Ref{T}</code></a> 中。 当你将这个 <code>Ref</code> 对象作为参数传递时，Julia 会自动传递一个指向封装数据的 C 指针：</p><pre><code class="language-julia hljs">width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
@ccall foo(width::Ref{Cint}, range::Ref{Cfloat})::Cvoid</code></pre><p>返回时，可以通过<code>width[]</code>和<code>range[]</code>检索<code>width</code>和<code>range</code>的内容（如果它们被<code>foo</code>改变的话）； 也就是说，它们就像零维数组。</p><h2 id="C-包装器示例"><a class="docs-heading-anchor" href="#C-包装器示例">C 包装器示例</a><a id="C-包装器示例-1"></a><a class="docs-heading-anchor-permalink" href="#C-包装器示例" title="Permalink"></a></h2><p>让我们从一个返回 <code>Ptr</code> 类型的 C 包装器的简单示例开始：</p><pre><code class="language-julia hljs">mutable struct gsl_permutation
end

# The corresponding C signature is
#     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = @ccall &quot;libgsl&quot;.gsl_permutation_alloc(n::Csize_t)::Ptr{gsl_permutation}
    if output_ptr == C_NULL # Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end</code></pre><p><a href="https://www.gnu.org/software/gsl/">GNU 科学图书馆</a>（这里假设可以通过 <code>:libgsl</code> 访问） 定义了一个不透明的指针，<code>gsl_permutation *</code>，作为 C 函数<code>gsl_permutation_alloc</code> 的返回类型。 由于用户代码永远不必查看 <code>gsl_permutation</code> 结构内部，相应的 Julia 包装器只需要一个新的类型声明 <code>gsl_permutation</code> 它没有内部字段，其唯一目的是放置在 <code>Ptr</code>类型的类型参数中。 <a href="../../base/c/#ccall"><code>ccall</code></a> 的返回类型声明为 <code>Ptr{gsl_permutation}</code>，因为 <code>output_ptr</code> 分配和指向的内存由 C 控制。</p><p>输入 <code>n</code> 是按值传递的，因此函数的输入签名被简单地声明为 <code>::Csize_t</code>，不需要任何 <code>Ref</code> 或 <code>Ptr</code>。 （如果包装器改为调用 Fortran 函数，则相应的函数输入签名将改为 <code>::Ref{Csize_t}</code>，因为 Fortran 变量是通过指针传递的。） 此外，<code>n</code> 可以是任何可转换的类型 到一个 <code>Csize_t</code> 整数； <a href="../../base/c/#ccall"><code>ccall</code></a> 隐式调用 <a href="../../base/c/#Base.cconvert"><code>Base.cconvert(Csize_t, n)</code></a>。</p><p>这是包装相应析构函数的第二个示例：</p><pre><code class="language-julia hljs"># The corresponding C signature is
#     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ptr{gsl_permutation})
    @ccall &quot;libgsl&quot;.gsl_permutation_free(p::Ptr{gsl_permutation})::Cvoid
end</code></pre><p>这是传递 Julia 数组的第三个示例：</p><pre><code class="language-julia hljs"># The corresponding C signature is
#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
#                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax &lt; nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)
    errorcode = @ccall &quot;libgsl&quot;.gsl_sf_bessel_Jn_array(
                    nmin::Cint, nmax::Cint, x::Cdouble, result_array::Ref{Cdouble})::Cint
    if errorcode != 0
        error(&quot;GSL error code $errorcode&quot;)
    end
    return result_array
end</code></pre><p>包装的 C 函数返回一个整数错误代码； Bessel J 函数的实际评估结果填充 Julia 数组 <code>result_array</code>。 这个变量被声明为一个 <code>Ref{Cdouble}</code>，因为它的内存是由 Julia 分配和管理的。 对 <a href="../../base/c/#Base.cconvert"><code>Base.cconvert(Ref{Cdouble}, result_array)</code></a> 的隐式调用将指向 Julia 数组数据结构的 Julia 指针解包为 C 可以理解的形式。</p><h2 id="Fortran-包装器示例"><a class="docs-heading-anchor" href="#Fortran-包装器示例">Fortran 包装器示例</a><a id="Fortran-包装器示例-1"></a><a class="docs-heading-anchor-permalink" href="#Fortran-包装器示例" title="Permalink"></a></h2><p>以下示例利用 <code>ccall</code> 调用通用 Fortran 库 (libBLAS) 中的函数来计算点积。 请注意，这里的参数映射与上面的有点不同，因为我们需要从 Julia 映射到 Fortran。 在每个参数类型上，我们指定 <code>Ref</code> 或 <code>Ptr</code>。 此修改约定可能特定于你的 Fortran 编译器和操作系统，并且可能未记录在案。 但是，将每个包装在一个 <code>Ref</code>（或 <code>Ptr</code>，等效地）中是 Fortran 编译器实现的一个常见要求：</p><pre><code class="language-julia hljs">function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = @ccall &quot;libLAPACK&quot;.ddot(
        n::Ref{Int32}, DX::Ptr{Float64}, incx::Ref{Int32}, DY::Ptr{Float64}, incy::Ref{Int32})::Float64
    return product
end</code></pre><h2 id="垃圾回收安全"><a class="docs-heading-anchor" href="#垃圾回收安全">垃圾回收安全</a><a id="垃圾回收安全-1"></a><a class="docs-heading-anchor-permalink" href="#垃圾回收安全" title="Permalink"></a></h2><p>将数据传递给 <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> 时，最好避免使用 <a href="../../base/c/#Base.pointer"><code>pointer</code></a> 函数。 而是定义一个 <a href="../../base/c/#Base.cconvert"><code>Base.cconvert</code></a> 方法并将变量直接传递给 <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a>。 <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> 自动安排它的所有参数都将从垃圾收集中保留，直到调用返回。 如果 C API 将存储对 Julia 分配的内存的引用，则在 <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> 返回后，你必须确保该对象对垃圾收集器保持可见。 建议的方法是创建一个类型为 <code>Array{Ref,1}</code> 的全局变量来保存这些值，直到 C 库通知你它已完成使用它们。</p><p>每当你创建了一个指向 Julia 数据的指针时，你必须确保原始数据存在，直到你完成使用该指针。 Julia 中的许多方法，例如 <a href="../../base/c/#Base.unsafe_load"><code>unsafe_load</code></a> 和 <a href="../../base/strings/#Core.String-Tuple{AbstractString}"><code>String</code></a> 复制数据而不是获取缓冲区的所有权，因此可以安全地释放（或更改）原始数而不影响 Julia。 一个值得注意的例外是 <a href="../../base/c/#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T}}, Type{Array{T, N}}}, Ptr{T}, Tuple{Vararg{Int64, N}}}} where {T, N}"><code>unsafe_wrap</code></a>，出于性能原因，它共享（或可以被告知拥有）底层缓冲区。</p><p>垃圾收集器不保证任何终结顺序。 也就是说，如果 <code>a</code> 包含对 <code>b</code> 的引用，并且 <code>a</code> 和 <code>b</code> 都需要进行垃圾回收，则不能保证 <code>b</code> 会在 <code>a</code> 之后完成。 如果 <code>a</code> 的正确终结取决于 <code>b</code> 是否有效，则必须以其他方式处理。</p><h2 id="Non-constant-Function-Specifications"><a class="docs-heading-anchor" href="#Non-constant-Function-Specifications">非常数函数规范</a><a id="Non-constant-Function-Specifications-1"></a><a class="docs-heading-anchor-permalink" href="#Non-constant-Function-Specifications" title="Permalink"></a></h2><p>在某些情况下，所需库的确切名称或路径是事先未知的，必须在运行时计算。 为了处理这种情况，规范的库组件可以是一个函数调用，例如 <code>find_blas().dgemm</code>。 调用表达式将在执行 <code>ccall</code> 本身时执行。 但是，假设库位置一旦确定就不会改变，因此调用的结果可以被缓存和重用。 因此，表达式执行的次数是未指定的，多次调用返回不同的值会导致未指定的行为。</p><p>如果需要更大的灵活性，可以通过 <a href="../../base/base/#Base.MainInclude.eval"><code>eval</code></a> 分段使用计算值作为函数名称，如下所示：</p><pre><code class="language-julia hljs">@eval @ccall &quot;lib&quot;.$(string(&quot;a&quot;, &quot;b&quot;))()::Cint</code></pre><p>此表达式使用 <code>string</code> 构造一个名称，然后将此名称替换为一个新的 <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> 表达式，然后对其进行评估。 请记住，<code>eval</code> 仅在顶层运行，因此在此表达式中局部变量将不可用（除非它们的值被替换为 <code>$</code>）。 出于这个原因，<code>eval</code> 通常仅用于形成顶级定义，例如在包装包含许多类似函数的库时。 可以为 <a href="../../base/c/#Base.@cfunction"><code>@cfunction</code></a> 构造一个类似的示例。</p><p>但是，这样做也会很慢并且会泄漏内存，因此你通常应该避免这种情况，而是继续阅读。 下一节讨论如何使用间接调用来有效地实现类似的效果。</p><h2 id="间接调用"><a class="docs-heading-anchor" href="#间接调用">间接调用</a><a id="间接调用-1"></a><a class="docs-heading-anchor-permalink" href="#间接调用" title="Permalink"></a></h2><p><a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> 的第一个参数也可以是在运行时计算的表达式。 在这种情况下，表达式的计算结果必须为 <code>Ptr</code>，它将用作要调用的本地函数的地址。 当第一个 <a href="../../base/c/#Base.@ccall"><code>@ccall</code></a> 参数包含对非常量（例如局部变量、函数参数或非常量全局变量）的引用时，会发生此行为。</p><p>例如，你可以通过 <code>dlsym</code> 查找函数，然后将其缓存在该会话的共享引用中。 例如：</p><pre><code class="language-julia hljs">macro dlsym(lib, func)
    z = Ref{Ptr{Cvoid}}(C_NULL)
    quote
        let zlocal = $z[]
            if zlocal == C_NULL
                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}
                $z[] = zlocal
            end
            zlocal
        end
    end
end

mylibvar = Libdl.dlopen(&quot;mylib&quot;)
@ccall $(@dlsym(mylibvar, &quot;myfunc&quot;))()::Cvoid</code></pre><h2 id="cfunction-闭包"><a class="docs-heading-anchor" href="#cfunction-闭包">cfunction 闭包</a><a id="cfunction-闭包-1"></a><a class="docs-heading-anchor-permalink" href="#cfunction-闭包" title="Permalink"></a></h2><p><a href="../../base/c/#Base.@cfunction"><code>@cfunction</code></a> 的第一个参数可以用 <code>$</code> 标记，在这种情况下，返回值将改为结束参数的 <code>struct CFunction</code>。 你必须确保此返回对象保持活动状态，直到完成对它的所有使用。 当这个引用被删除和 atexit 时，cfunction 指针处的内容和代码将通过 <a href="../../base/base/#Base.finalizer"><code>finalizer</code></a> 删除。 这通常不是必需的，因为此功能在 C 中不存在，但对于处理不提供单独的闭包环境参数的设计不良的 API 很有用。</p><pre><code class="language-julia hljs">function qsort(a::Vector{T}, cmp) where T
    isbits(T) || throw(ArgumentError(&quot;this method can only qsort isbits arrays&quot;))
    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})
    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}
    # (and protected against finalization) by the ccall
    @ccall qsort(a::Ptr{T}, length(a)::Csize_t, Base.elsize(a)::Csize_t, callback::Ptr{Cvoid})
    # We could instead use:
    #    GC.@preserve callback begin
    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))
    #    end
    # if we needed to use it outside of a `ccall`
    return a
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>闭包 <a href="../../base/c/#Base.@cfunction"><code>@cfunction</code></a> 依赖于 LLVM Trampolines，并非在所有平台（例如 ARM 和 PowerPC）上都可用。</p></div></div><h2 id="关闭库"><a class="docs-heading-anchor" href="#关闭库">关闭库</a><a id="关闭库-1"></a><a class="docs-heading-anchor-permalink" href="#关闭库" title="Permalink"></a></h2><p>关闭（卸载）库以便重新加载有时很有用。 例如，在开发与 Julia 一起使用的 C 代码时，可能需要编译、从 Julia 调用 C 代码，然后关闭库、进行编辑、重新编译并加载新的更改。 可以重新启动 Julia 或使用 <code>Libdl</code> 函数来显式管理库，例如：</p><pre><code class="language-julia hljs">lib = Libdl.dlopen(&quot;./my_lib.so&quot;) # Open the library explicitly.
sym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.
@ccall $sym(...) # Use the pointer `sym` instead of the library.symbol tuple.
Libdl.dlclose(lib) # Close the library explicitly.</code></pre><p>Note that when using <code>@ccall</code> with the input (e.g., <code>@ccall &quot;./my_lib.so&quot;.my_fcn(...)::Cvoid</code>), the library is opened implicitly and it may not be explicitly closed.</p><h2 id="Variadic-function-calls"><a class="docs-heading-anchor" href="#Variadic-function-calls">Variadic function calls</a><a id="Variadic-function-calls-1"></a><a class="docs-heading-anchor-permalink" href="#Variadic-function-calls" title="Permalink"></a></h2><p>To call variadic C functions a <code>semicolon</code> can be used in the argument list to separate required arguments from variadic arguments. An example with the <code>printf</code> function is given below:</p><pre><code class="language-julia-repl hljs">julia&gt; @ccall printf(&quot;%s = %d\n&quot;::Cstring ; &quot;foo&quot;::Cstring, foo::Cint)::Cint
foo = 3
8</code></pre><h2 id="ccall-interface"><a class="docs-heading-anchor" href="#ccall-interface"><code>ccall</code> interface</a><a id="ccall-interface-1"></a><a class="docs-heading-anchor-permalink" href="#ccall-interface" title="Permalink"></a></h2><p>There is another alternative interface to <code>@ccall</code>. This interface is slightly less convenient but it does allow one to specify a <a href="#calling-convention">calling convention</a>.</p><p>The arguments to <a href="../../base/c/#ccall"><code>ccall</code></a> are:</p><ol><li><p>A <code>(:function, &quot;library&quot;)</code> pair (most common),</p><p>OR</p><p>a <code>:function</code> name symbol or <code>&quot;function&quot;</code> name string (for symbols in the current process or libc),</p><p>OR</p><p>a function pointer (for example, from <code>dlsym</code>).</p></li><li><p>The function&#39;s return type</p></li><li><p>A tuple of input types, corresponding to the function signature. One common mistake is forgetting that a 1-tuple of argument types must be written with a trailing comma.</p></li><li><p>The actual argument values to be passed to the function, if any; each is a separate parameter.</p></li></ol><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>(:function, &quot;library&quot;)</code> pair, return type, and input types must be literal constants (i.e., they can&#39;t be variables, but see <a href="#Non-constant-Function-Specifications">Non-constant Function Specifications</a>).</p><p>The remaining parameters are evaluated at compile-time, when the containing method is defined.</p></div></div><p>A table of translations between the macro and function interfaces is given below.</p><table><tr><th style="text-align: right"><code>@ccall</code></th><th style="text-align: right"><code>ccall</code></th></tr><tr><td style="text-align: right"><code>@ccall clock()::Int32</code></td><td style="text-align: right"><code>ccall(:clock, Int32, ())</code></td></tr><tr><td style="text-align: right"><code>@ccall f(a::Cint)::Cint</code></td><td style="text-align: right"><code>ccall(:a, Cint, (Cint,), a)</code></td></tr><tr><td style="text-align: right"><code>@ccall &quot;mylib&quot;.f(a::Cint, b::Cdouble)::Cvoid</code></td><td style="text-align: right"><code>ccall((:f, &quot;mylib&quot;), Cvoid, (Cint, Cdouble), (a, b))</code></td></tr><tr><td style="text-align: right"><code>@ccall $fptr.f()::Cvoid</code></td><td style="text-align: right"><code>ccall(fptr, f, Cvoid, ())</code></td></tr><tr><td style="text-align: right"><code>@ccall printf(&quot;%s = %d\n&quot;::Cstring ; &quot;foo&quot;::Cstring, foo::Cint)::Cint</code></td><td style="text-align: right"><code>&lt;unavailable&gt;</code></td></tr><tr><td style="text-align: right"><code>@ccall printf(&quot;%s = %d\n&quot;::Cstring ; &quot;2 + 2&quot;::Cstring, &quot;5&quot;::Cstring)::Cint</code></td><td style="text-align: right"><code>ccall(:printf, Cint, (Cstring, Cstring...), &quot;%s = %s\n&quot;, &quot;2 + 2&quot;, &quot;5&quot;)</code></td></tr><tr><td style="text-align: right"><code>&lt;unavailable&gt;</code></td><td style="text-align: right"><code>ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))</code></td></tr></table><h2 id="calling-convention"><a class="docs-heading-anchor" href="#calling-convention">Calling Convention</a><a id="calling-convention-1"></a><a class="docs-heading-anchor-permalink" href="#calling-convention" title="Permalink"></a></h2><p>The second argument to <code>ccall</code> (immediately preceding return type) can optionally be a calling convention specifier (the <code>@ccall</code> macro currently does not support giving a calling convention). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: <code>stdcall</code>, <code>cdecl</code>, <code>fastcall</code>, and <code>thiscall</code> (no-op on 64-bit Windows). For example (from <code>base/libc.jl</code>) we see the same <code>gethostname</code><code>ccall</code> as above, but with the correct signature for Windows:</p><pre><code class="language-julia hljs">hn = Vector{UInt8}(undef, 256)
err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))</code></pre><p>请参阅 <a href="https://llvm.org/docs/LangRef.html#calling-conventions">LLVM Language Reference</a> 来获得更多信息。</p><p>还有一个额外的特殊调用约定 <a href="../../base/c/#Core.Intrinsics.llvmcall"><code>llvmcall</code></a>，它允许直接插入对 LLVM 内部函数的调用。 这在针对不常见的平台（例如 GPGPU）时特别有用。 例如，对于<a href="https://llvm.org/docs/NVPTXUsage.html">CUDA</a>，我们需要能够读取线程索引：</p><pre><code class="language-julia hljs">ccall(&quot;llvm.nvvm.read.ptx.sreg.tid.x&quot;, llvmcall, Int32, ())</code></pre><p>与任何 <code>ccall</code> 一样，参数签名必须完全正确。另外，请注意，与<code>Core.Intrinsics</code>开放的等效Julia函数不同，没有兼容层级可以确保内在函数有意义并在当前目标上工作。</p><h2 id="访问全局变量"><a class="docs-heading-anchor" href="#访问全局变量">访问全局变量</a><a id="访问全局变量-1"></a><a class="docs-heading-anchor-permalink" href="#访问全局变量" title="Permalink"></a></h2><p>可以使用 <a href="../../base/c/#Core.Intrinsics.cglobal"><code>cglobal</code></a> 函数按名称访问本地库导出的全局变量。 <a href="../../base/c/#Core.Intrinsics.cglobal"><code>cglobal</code></a> 的参数与 <a href="../../base/c/#ccall"><code>ccall</code></a> 使用相同的符号规范，以及描述存储在变量中的值的类型：</p><pre><code class="language-julia-repl hljs">julia&gt; cglobal((:errno, :libc), Int32)
Ptr{Int32} @0x00007f418d0816b8</code></pre><p>结果是一个给出值地址的指针。 可以使用 <a href="../../base/c/#Base.unsafe_load"><code>unsafe_load</code></a> 和 <a href="../../base/c/#Base.unsafe_store!"><code>unsafe_store!</code></a> 通过这个指针来操作该值。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>在名为“libc”的库中可能找不到此 <code>errno</code> 符号，因为这是系统编译器的实现细节。 通常标准库符号应该只通过名称访问，允许编译器填写正确的符号。 然而，这个例子中显示的 <code>errno</code> 符号在大多数编译器中都是特殊的，所以这里看到的值可能不是你所期望或想要的。 在任何支持多线程的系统上用 C 编译等效代码通常实际上会调用不同的函数（通过宏预处理器重载），并且可能给出与此处打印的遗留值不同的结果。</p></div></div><h2 id="通过指针来访问数据"><a class="docs-heading-anchor" href="#通过指针来访问数据">通过指针来访问数据</a><a id="通过指针来访问数据-1"></a><a class="docs-heading-anchor-permalink" href="#通过指针来访问数据" title="Permalink"></a></h2><p>以下方法被描述为“不安全”，因为错误的指针或类型声明会导致 Julia 突然终止。</p><p>给定一个 <code>Ptr{T}</code>，通常可以使用 <code>unsafe_load(ptr, [index])</code> 将 <code>T</code> 类型的内容从引用的内存复制到 Julia 对象中。 index 参数是可选的（默认为 1），并遵循基于 1 的索引的 Julia 惯例。 此函数类似于 <a href="../../base/collections/#Base.getindex"><code>getindex</code></a> 和 <a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a> 的行为（例如<code>[]</code> 访问语法）。</p><p>返回值将是一个初始化为包含引用内存内容副本的新对象。 引用的内存可以安全地释放或释放。</p><p>如果 <code>T</code> 是 <code>Any</code>，则假定内存包含对 Julia 对象的引用（<code>jl_value_t*</code>），结果将是对该对象的引用，并且不会复制该对象。 在这种情况下，你必须小心确保对象始终对垃圾收集器可见（指针不计数，但新引用计数）以确保内存不会过早释放。 请注意，如果对象最初不是由 Julia 分配的，则新对象将永远不会被 Julia 的垃圾收集器终结。 如果 <code>Ptr</code> 本身实际上是一个 <code>jl_value_t*</code>，它可以通过 <a href="../../base/c/#Base.unsafe_pointer_to_objref"><code>unsafe_pointer_to_objref(ptr)</code></a> 转换回 Julia 对象引用。 （Julia 值 <code>v</code> 可以通过调用 <a href="../../base/c/#Base.pointer_from_objref"><code>pointer_from_objref(v)</code></a> 转换为 <code>jl_value_t*</code> 指针，如 <code>Ptr{Cvoid}</code>。）</p><p>可以使用 <a href="../../base/c/#Base.unsafe_store!"><code>unsafe_store!(ptr, value, [index])</code></a> 执行反向操作（将数据写入 <code>Ptr{T}</code>）。 目前，这仅支持原始类型或其他无指针（<code>isbits</code>）不可变结构类型。</p><p>任何引发错误的操作目前可能尚未实现，应作为错误发布，以便解决。</p><p>如果感兴趣的指针是纯数据数组（原始类型或不可变结构），则函数 <a href="../../base/c/#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T}}, Type{Array{T, N}}}, Ptr{T}, Tuple{Vararg{Int64, N}}}} where {T, N}"><code>unsafe_wrap(Array, ptr,dims, own = false)</code></a> 可能更有用。 如果 Julia 应该“获得”底层缓冲区的所有权并在返回的 <code>Array</code> 对象最终确定时调用 <code>free(ptr)</code>，则最后一个参数应该为 true。 如果省略了 <code>own</code> 参数或为 false，则调用者必须确保缓冲区一直存在，直到所有访问完成。</p><p>Julia 中 <code>Ptr</code> 类型的算术（例如使用 <code>+</code>）与 C 的指针算术的行为不同。 将整数添加到 Julia 中的 <code>Ptr</code> 总是将指针移动一定数量的 <em>bytes</em>，而不是元素。 这样，通过指针运算获得的地址值不依赖于指针的元素类型。</p><h2 id="线程安全"><a class="docs-heading-anchor" href="#线程安全">线程安全</a><a id="线程安全-1"></a><a class="docs-heading-anchor-permalink" href="#线程安全" title="Permalink"></a></h2><p>一些 C 库从不同的线程执行它们的回调，并且由于 Julia 不是线程安全的，因此你需要采取一些额外的预防措施。 特别是，你需要设置一个两层系统：C 回调应该只 <em>安排</em>（通过 Julia 的事件循环）执行“真实”回调。 为此，创建一个 <a href="../../base/base/#Base.AsyncCondition"><code>AsyncCondition</code></a> 对象并在其上创建 <a href="../../base/parallel/#Base.wait"><code>wait</code></a>：</p><pre><code class="language-julia hljs">cond = Base.AsyncCondition()
wait(cond)</code></pre><p>传递给 C 的回调应该只通过 <a href="../../base/c/#ccall"><code>ccall</code></a> 将 <code>cond.handle</code> 作为参数传递给 <code>:uv_async_send</code> 并调用，注意避免任何内存分配操作或与 Julia 运行时的其他交互。</p><p>注意，事件可能会合并，因此对 <code>uv_async_send</code> 的多个调用可能会导致对该条件的单个唤醒通知。</p><h2 id="关于-Callbacks-的更多内容"><a class="docs-heading-anchor" href="#关于-Callbacks-的更多内容">关于 Callbacks 的更多内容</a><a id="关于-Callbacks-的更多内容-1"></a><a class="docs-heading-anchor-permalink" href="#关于-Callbacks-的更多内容" title="Permalink"></a></h2><p>关于如何传递 callback 到 C 库的更多细节，请参考此<a href="https://julialang.org/blog/2013/05/callback">博客</a>。</p><h2 id="C"><a class="docs-heading-anchor" href="#C">C++</a><a id="C-1"></a><a class="docs-heading-anchor-permalink" href="#C" title="Permalink"></a></h2><p>如需封装C++库的工具，即用C++写封装/胶水代码，请参考<a href="https://github.com/JuliaInterop/CxxWrap.jl">CxxWrap</a>。</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. The point above is that the cost of actually doing foreign function call is about the same as doing a call in either native language.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>The <a href="https://github.com/ihnorton/Clang.jl">Clang package</a> can be used to auto-generate Julia code from a C header file.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../running-external-programs/">« 运行外部程序</a><a class="docs-footer-nextpage" href="../handling-operating-system-variation/">处理操作系统差异 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>本文档在 <span class="colophon-date" title="2024 十二月 26 周四 08:52">2024 十二月 26 周四</span>用 <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> 1.8.0 版生成使用 1.10.7 版本的 Julia。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
