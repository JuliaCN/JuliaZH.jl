<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>运行外部程序 · Julia 中文文档</title><meta name="title" content="运行外部程序 · Julia 中文文档"/><meta property="og:title" content="运行外部程序 · Julia 中文文档"/><meta property="twitter:title" content="运行外部程序 · Julia 中文文档"/><meta name="description" content="Documentation for Julia 中文文档."/><meta property="og:description" content="Documentation for Julia 中文文档."/><meta property="twitter:description" content="Documentation for Julia 中文文档."/><meta property="og:url" content="https://juliacn.github.io/JuliaZH.jl/latest/manual/running-external-programs/"/><meta property="twitter:url" content="https://juliacn.github.io/JuliaZH.jl/latest/manual/running-external-programs/"/><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/running-external-programs/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia 中文文档 logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">变量</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">一维和多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../multi-threading/">多线程</a></li><li><a class="tocitem" href="../distributed-computing/">多进程和分布式计算</a></li><li class="is-active"><a class="tocitem" href>运行外部程序</a><ul class="internal"><li><a class="tocitem" href="#command-interpolation"><span>插值</span></a></li><li><a class="tocitem" href="#引用"><span>引用</span></a></li><li><a class="tocitem" href="#管道"><span>管道</span></a></li><li><a class="tocitem" href="#Cmd对象"><span><code>Cmd</code>对象</span></a></li></ul></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">标准数值类型</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/reflection/">反射 与 自我检查</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">标准库</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/ArgTools/">ArgTools</a></li><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibCURL/">LibCURL</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/NetworkOptions/">Network Options</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Tar/">Tar</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">开发者文档</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/pkgimg/">Package Images</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../../devdocs/gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../../devdocs/precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../../devdocs/probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../../devdocs/build/linux/">Linux</a></li><li><a class="tocitem" href="../../devdocs/build/macos/">macOS</a></li><li><a class="tocitem" href="../../devdocs/build/windows/">Windows</a></li><li><a class="tocitem" href="../../devdocs/build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../../devdocs/build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../../devdocs/build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>运行外部程序</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>运行外部程序</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/zh_CN/doc/src/manual/running-external-programs.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Running-External-Programs"><a class="docs-heading-anchor" href="#Running-External-Programs">运行外部程序</a><a id="Running-External-Programs-1"></a><a class="docs-heading-anchor-permalink" href="#Running-External-Programs" title="Permalink"></a></h1><p>Julia 中命令的反引号记法借鉴于 shell、Perl 和 Ruby。然而，在 Julia 中编写</p><pre><code class="language-julia-repl hljs">julia&gt; `echo hello`
`echo hello`</code></pre><p>在多个方面上与 shell、Perl 和 Ruby 中的行为有所不同：</p><ul><li>反引号创建一个 <a href="../../base/base/#Base.Cmd"><code>Cmd</code></a> 对象来表示命令，而不是立即运行命令。 你可以使用此对象将命令通过管道连接到其它命令、<a href="../../base/base/#Base.run"><code>run</code></a> 它以及对它进行 <a href="../../base/io-network/#Base.read"><code>read</code></a> 或 <a href="../../base/io-network/#Base.write"><code>write</code></a>。</li><li>在命令运行时，Julia 不会捕获命令的输出结果，除非你对它专门安排。相反，在默认情况下，命令的输出会被定向到 <a href="../../base/io-network/#Base.stdout"><code>stdout</code></a>，因为它将使用 <code>libc</code> 的 <code>system</code> 调用。</li><li>命令从不会在 shell 中运行。相反地，Julia 会直接解析命令语法，适当地插入变量并像 shell 那样拆分单词，同时遵从 shell 的引用语法。命令会作为 <code>julia</code> 的直接子进程运行，使用 <code>fork</code> 和 <code>exec</code> 调用。</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>下面假设在 Linux 或 MacOS 上使用 Posix 环境。 在 Windows 上，许多类似的命令，例如 <code>echo</code> 和 <code>dir</code>，不是外部程序，而是内置在 shell <code>cmd.exe</code> 本身中。 运行这些命令的一种选择是调用 <code>cmd.exe</code>，例如 <code>cmd /C echo hello</code>。 或者，Julia 可以在 Posix 环境中运行，例如 Cygwin。</p></div></div><p>这是运行外部程序的简单示例：</p><pre><code class="language-julia-repl hljs">julia&gt; mycommand = `echo hello`
`echo hello`

julia&gt; typeof(mycommand)
Cmd

julia&gt; run(mycommand);
hello</code></pre><p><code>hello</code> 是 <code>echo</code> 命令的输出，发送到 <a href="../../base/io-network/#Base.stdout"><code>stdout</code></a>。 如果外部命令无法成功运行，则 run 方法会抛出 <a href="../../base/base/#Base.ProcessFailedException"><code>ProcessFailedException</code></a>。</p><p>如果要读取外部命令的输出，可以使用 <a href="../../base/io-network/#Base.read"><code>read</code></a> 或 <a href="../../base/io-network/#Base.readchomp"><code>readchomp</code></a> 代替：</p><pre><code class="language-julia-repl hljs">julia&gt; read(`echo hello`, String)
&quot;hello\n&quot;

julia&gt; readchomp(`echo hello`)
&quot;hello&quot;</code></pre><p>更一般地，你可以使用 <a href="../../base/io-network/#Base.open"><code>open</code></a> 来读取或写入外部命令。</p><pre><code class="language-julia-repl hljs">julia&gt; open(`less`, &quot;w&quot;, stdout) do io
           for i = 1:3
               println(io, i)
           end
       end
1
2
3</code></pre><p>命令中的程序名称和各个参数可以访问和迭代，这就好像命令也是一个字符串数组：</p><pre><code class="language-julia-repl hljs">julia&gt; collect(`echo &quot;foo bar&quot;`)
2-element Vector{String}:
 &quot;echo&quot;
 &quot;foo bar&quot;

julia&gt; `echo &quot;foo bar&quot;`[2]
&quot;foo bar&quot;</code></pre><h2 id="command-interpolation"><a class="docs-heading-anchor" href="#command-interpolation">插值</a><a id="command-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#command-interpolation" title="Permalink"></a></h2><p>假设你想要做的事情更复杂，并使用以变量 <code>file</code> 表示的文件名作为命令的参数。那你可以像在字符串字面量中那样使用 <code>$</code> 进行插值：</p><pre><code class="language-julia-repl hljs">julia&gt; file = &quot;/etc/passwd&quot;
&quot;/etc/passwd&quot;

julia&gt; `sort $file`
`sort /etc/passwd`</code></pre><p>通过 shell 运行外部程序的一个常见陷阱是，如果文件名中包含 shell 中的特殊字符，那么可能会导致不希望出现的行为。例如，假设我们想要对其内容进行排序的文件是 <code>/Volumes/External HD/data.csv</code>，而不是 <code>/etc/passwd</code>。让我们来试试：</p><pre><code class="language-julia-repl hljs">julia&gt; file = &quot;/Volumes/External HD/data.csv&quot;
&quot;/Volumes/External HD/data.csv&quot;

julia&gt; `sort $file`
`sort &#39;/Volumes/External HD/data.csv&#39;`</code></pre><p>文件名是如何被引用的？Julia 知道 <code>file</code> 是作为单个参数插入的，因此它替你引用了此单词。事实上，这不太准确：<code>file</code> 的值始终不会被 shell 解释，因此并不需要实际引用；插入引号只是为了展现给用户。就算你把值作为 shell 单词的一部分插入，这也可以工作：</p><pre><code class="language-julia-repl hljs">julia&gt; path = &quot;/Volumes/External HD&quot;
&quot;/Volumes/External HD&quot;

julia&gt; name = &quot;data&quot;
&quot;data&quot;

julia&gt; ext = &quot;csv&quot;
&quot;csv&quot;

julia&gt; `sort $path/$name.$ext`
`sort &#39;/Volumes/External HD/data.csv&#39;`</code></pre><p>如你所见，<code>path</code> 变量中的空格被恰当地转义了。但是，如果你<em>想</em>插入多个单词怎么办？在此情况下，只需使用数组（或其它可迭代容器）：</p><pre><code class="language-julia-repl hljs">julia&gt; files = [&quot;/etc/passwd&quot;,&quot;/Volumes/External HD/data.csv&quot;]
2-element Vector{String}:
 &quot;/etc/passwd&quot;
 &quot;/Volumes/External HD/data.csv&quot;

julia&gt; `grep foo $files`
`grep foo /etc/passwd &#39;/Volumes/External HD/data.csv&#39;`</code></pre><p>如果将数组作为 shell 单词的一部分插入，Julia 将模拟 shell 的 <code>{a,b,c}</code> 参数生成：</p><pre><code class="language-julia-repl hljs">julia&gt; names = [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
3-element Vector{String}:
 &quot;foo&quot;
 &quot;bar&quot;
 &quot;baz&quot;

julia&gt; `grep xylophone $names.txt`
`grep xylophone foo.txt bar.txt baz.txt`</code></pre><p>此外，若在同一单词中插入多个数组，则将模拟 shell 的笛卡尔积生成行为：</p><pre><code class="language-julia-repl hljs">julia&gt; names = [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
3-element Vector{String}:
 &quot;foo&quot;
 &quot;bar&quot;
 &quot;baz&quot;

julia&gt; exts = [&quot;aux&quot;,&quot;log&quot;]
2-element Vector{String}:
 &quot;aux&quot;
 &quot;log&quot;

julia&gt; `rm -f $names.$exts`
`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`</code></pre><p>因为可以插入字面量数组，所以你可以使用此生成功能，而无需先创建临时数组对象：</p><pre><code class="language-julia-repl hljs">julia&gt; `rm -rf $[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;,&quot;qux&quot;].$[&quot;aux&quot;,&quot;log&quot;,&quot;pdf&quot;]`
`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`</code></pre><h2 id="引用"><a class="docs-heading-anchor" href="#引用">引用</a><a id="引用-1"></a><a class="docs-heading-anchor-permalink" href="#引用" title="Permalink"></a></h2><p>不可避免地，我们会想要编写不那么简单的命令，且有必要使用引号。下面是 shell 提示符下单行 Perl 程序的简单示例：</p><pre><code class="nohighlight hljs">sh$ perl -le &#39;$|=1; for (0..3) { print }&#39;
0
1
2
3</code></pre><p>该 Perl 表达式需要使用单引号有两个原因：一是为了避免空格将表达式分解为多个 shell 单词，二是为了在使用像 <code>$|</code>（是的，这在 Perl 中是变量名）这样的 Perl 变量时避免发生插值。在其它情况下，你可能想要使用双引号来<em>真的</em>进行插值：</p><pre><code class="nohighlight hljs">sh$ first=&quot;A&quot;
sh$ second=&quot;B&quot;
sh$ perl -le &#39;$|=1; print for @ARGV&#39; &quot;1: $first&quot; &quot;2: $second&quot;
1: A
2: B</code></pre><p>总之，Julia 反引号语法是经过精心设计的，因此你可以只是将 shell 命令剪切并粘贴到反引号中，接着它们将会工作：转义、引用和插值行为与 shell 相同。唯一的不同是，插值是集成的并且知道在 Julia 的概念中什么是单个字符串值、什么是多个值的容器。让我们在 Julia 中尝试上面的两个例子：</p><pre><code class="language-julia-repl hljs">julia&gt; A = `perl -le &#39;$|=1; for (0..3) { print }&#39;`
`perl -le &#39;$|=1; for (0..3) { print }&#39;`

julia&gt; run(A);
0
1
2
3

julia&gt; first = &quot;A&quot;; second = &quot;B&quot;;

julia&gt; B = `perl -le &#39;print for @ARGV&#39; &quot;1: $first&quot; &quot;2: $second&quot;`
`perl -le &#39;print for @ARGV&#39; &#39;1: A&#39; &#39;2: B&#39;`

julia&gt; run(B);
1: A
2: B</code></pre><p>结果是相同的，且 Julia 的插值行为模仿了 shell 的并对其做了一些改进，因为 Julia 支持头等的可迭代对象，但大多数 shell 通过使用空格分隔字符串来实现这一点，而这又引入了歧义。在尝试将 shell 命令移植到 Julia 中时，请先试着剪切并粘贴它。因为 Julia 会在运行命令前向你显示命令，所以你可以在不造成任何破坏的前提下轻松并安全地检查命令的解释。</p><h2 id="管道"><a class="docs-heading-anchor" href="#管道">管道</a><a id="管道-1"></a><a class="docs-heading-anchor-permalink" href="#管道" title="Permalink"></a></h2><p>Shell 元字符，如 <code>|</code>、<code>&amp;</code> 和 <code>&gt;</code>，在 Julia 的反引号中需被引用（或转义）：</p><pre><code class="language-julia-repl hljs">julia&gt; run(`echo hello &#39;|&#39; sort`);
hello | sort

julia&gt; run(`echo hello \| sort`);
hello | sort</code></pre><p>此表达式调用 <code>echo</code> 命令并以三个单词作为其参数：<code>hello</code>、<code>|</code> 和 <code>sort</code>。结果是只打印了一行：<code>hello | sort</code>。那么，如何构造管道呢？为此，请使用 <a href="../../base/base/#Base.pipeline-Tuple{Any, Any, Any, Vararg{Any}}"><code>pipeline</code></a>，而不是在反引号内使用 <code>&#39;|&#39;</code>：</p><pre><code class="language-julia-repl hljs">julia&gt; run(pipeline(`echo hello`, `sort`));
hello</code></pre><p>这将 <code>echo</code> 命令的输出传输到 <code>sort</code> 命令中。当然，这不是很有趣，因为只有一行要排序，但是我们的当然可以做更多、更有趣的事：</p><pre><code class="language-julia-repl hljs">julia&gt; run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))
210
211
212
213
214</code></pre><p>这将打印在 UNIX 系统上最高的五个用户 ID。<code>cut</code>、<code>sort</code> 和 <code>tail</code> 命令都是当前 <code>julia</code> 进程的直接子进程，这中间没有 shell 进程的干预。Julia 自己负责设置管道和连接文件描述符，而这通常由 shell 完成。因为 Julia 自己做了这些事，所以它能更好的控制并做 shell 做不到的一些事情。</p><p>Julia 可以并行地运行多个命令：</p><pre><code class="language-julia-repl hljs">julia&gt; run(`echo hello` &amp; `echo world`);
world
hello</code></pre><p>这里的输出顺序是不确定的，因为两个 <code>echo</code> 进程几乎同时启动，并且争着先写入 <a href="../../base/io-network/#Base.stdout"><code>stdout</code></a> 描述符和 <code>julia</code> 父进程。Julia 允许你将这两个进程的输出通过管道传输到另一个程序：</p><pre><code class="language-julia-repl hljs">julia&gt; run(pipeline(`echo world` &amp; `echo hello`, `sort`));
hello
world</code></pre><p>在 UNIX 管道方面，这里发生的是，一个 UNIX 管道对象由两个 <code>echo</code> 进程创建和写入，管道的另一端由 <code>sort</code> 命令读取。</p><p>IO 重定向可以通过向 <code>pipeline</code> 函数传递关键字参数 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 来实现：</p><pre><code class="language-julia hljs">pipeline(`do_work`, stdout=pipeline(`sort`, &quot;out.txt&quot;), stderr=&quot;errs.txt&quot;)</code></pre><h3 id="避免管道中的死锁"><a class="docs-heading-anchor" href="#避免管道中的死锁">避免管道中的死锁</a><a id="避免管道中的死锁-1"></a><a class="docs-heading-anchor-permalink" href="#避免管道中的死锁" title="Permalink"></a></h3><p>在单个进程中读取和写入管道的两端时，避免强制内核缓冲所有数据是很重要的。</p><p>例如，在读取命令的所有输出时，请调用 <code>read(out, String)</code>，而非 <code>wait(process)</code>，因为前者会积极地消耗由该进程写入的所有数据，而后者在等待读取者连接时会尝试将数据存储内核的缓冲区中。</p><p>另一个常见的解决方案是将读取者和写入者分离到单独的 <a href="../../base/parallel/#Core.Task"><code>Task</code></a> 中：</p><pre><code class="language-julia hljs">writer = @async write(process, &quot;data&quot;)
reader = @async do_compute(read(process, String))
wait(writer)
fetch(reader)</code></pre><p>（通常，reader 不是一个单独的任务，因为无论如何我们都会立即 <code>fetch</code> 它）。</p><h3 id="复杂示例"><a class="docs-heading-anchor" href="#复杂示例">复杂示例</a><a id="复杂示例-1"></a><a class="docs-heading-anchor-permalink" href="#复杂示例" title="Permalink"></a></h3><p>高级编程语言、头等的命令抽象以及进程间管道的自动设置，三者组合起来非常强大。为了更好地理解可被轻松创建的复杂管道，这里有一些更复杂的例子，以避免对单行 Perl 程序的滥用。</p><pre><code class="language-julia-repl hljs">julia&gt; prefixer(prefix, sleep) = `perl -nle &#39;$|=1; print &quot;&#39;$prefix&#39; &quot;, $_; sleep &#39;$sleep&#39;;&#39;`;

julia&gt; run(pipeline(`perl -le &#39;$|=1; for(0..5){ print; sleep 1 }&#39;`, prefixer(&quot;A&quot;,2) &amp; prefixer(&quot;B&quot;,2)));
B 0
A 1
B 2
A 3
B 4
A 5</code></pre><p>这是一个经典的例子，一个生产者为两个并发的消费者提供内容：一个 <code>perl</code> 进程生成从数字 0 到 5 的行，而两个并行进程则使用该输出，一个行首加字母「A」，另一个行首加字母「B」。哪个进程使用第一行是不确定的，但是一旦赢得了竞争，这些行会先后被其中一个进程及另一个进程交替使用。（在 Perl 中设置 <code>$|=1</code> 会导致每个 print 语句刷新 <a href="../../base/io-network/#Base.stdout"><code>stdout</code></a> 句柄，这是本例工作所必需的。此外，所有输出将被缓存并一次性打印到管道中，以便只由一个消费者进程读取。）</p><p>这是一个更加复杂的多阶段生产者——消费者示例：</p><pre><code class="language-julia-repl hljs">julia&gt; run(pipeline(`perl -le &#39;$|=1; for(0..5){ print; sleep 1 }&#39;`,
           prefixer(&quot;X&quot;,3) &amp; prefixer(&quot;Y&quot;,3) &amp; prefixer(&quot;Z&quot;,3),
           prefixer(&quot;A&quot;,2) &amp; prefixer(&quot;B&quot;,2)));
A X 0
B Y 1
A Z 2
B X 3
A Y 4
B Z 5</code></pre><p>此示例与前一个类似，不同之处在于本例中的消费者有两个阶段，并且阶段间有不同的延迟，因此它们使用不同数量的并行 worker 来维持饱和的吞吐量。</p><p>我们强烈建议你尝试所有这些例子，以便了解它们的工作原理。</p><h2 id="Cmd对象"><a class="docs-heading-anchor" href="#Cmd对象"><code>Cmd</code>对象</a><a id="Cmd对象-1"></a><a class="docs-heading-anchor-permalink" href="#Cmd对象" title="Permalink"></a></h2><p>反引号语法创建一个 <a href="../../base/base/#Base.Cmd"><code>Cmd</code></a> 类型的对象。 此类对象也可以直接从现有的 <code>Cmd</code> 或参数列表构造：</p><pre><code class="language-julia hljs">run(Cmd(`pwd`, dir=&quot;..&quot;))
run(Cmd([&quot;pwd&quot;], detach=true, ignorestatus=true))</code></pre><p>这允许你通过关键字参数指定 <code>Cmd</code> 的执行环境的几个方面。 例如，<code>dir</code> 关键字提供对 <code>Cmd</code> 工作目录的控制：</p><pre><code class="language-julia-repl hljs">julia&gt; run(Cmd(`pwd`, dir=&quot;/&quot;));
/</code></pre><p>并且 <code>env</code> 关键字允许您设置执行环境变量：</p><pre><code class="language-julia-repl hljs">julia&gt; run(Cmd(`sh -c &quot;echo foo \$HOWLONG&quot;`, env=(&quot;HOWLONG&quot; =&gt; &quot;ever!&quot;,)));
foo ever!</code></pre><p>有关其它关键字参数，请参阅 <a href="../../base/base/#Base.Cmd"><code>Cmd</code></a>。 <a href="../../base/base/#Base.setenv"><code>setenv</code></a> 和 <a href="../../base/base/#Base.addenv"><code>addenv</code></a> 命令分别提供了另一种替换或添加到 <code>Cmd</code> 执行环境变量的方法：</p><pre><code class="language-julia-repl hljs">julia&gt; run(setenv(`sh -c &quot;echo foo \$HOWLONG&quot;`, (&quot;HOWLONG&quot; =&gt; &quot;ever!&quot;,)));
foo ever!

julia&gt; run(addenv(`sh -c &quot;echo foo \$HOWLONG&quot;`, &quot;HOWLONG&quot; =&gt; &quot;ever!&quot;));
foo ever!</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../distributed-computing/">« 多进程和分布式计算</a><a class="docs-footer-nextpage" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>本文档在 <span class="colophon-date" title="2024 十二月 22 周日 18:40">2024 十二月 22 周日</span>用 <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> 1.8.0 版生成使用 1.10.7 版本的 Julia。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
