<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>模块 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/modules/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">变量</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li class="is-active"><a class="tocitem" href>模块</a><ul class="internal"><li><a class="tocitem" href="#namespace-management"><span>Namespace management</span></a></li><li><a class="tocitem" href="#Submodules-and-relative-paths"><span>Submodules and relative paths</span></a></li></ul></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../asynchronous-programming/">Asynchronous Programming</a></li><li><a class="tocitem" href="../multi-threading/">多线程</a></li><li><a class="tocitem" href="../distributed-computing/">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../command-line-options/">命令行选项</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>模块</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>模块</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/modulesmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="modules"><a class="docs-heading-anchor" href="#modules">模块</a><a id="modules-1"></a><a class="docs-heading-anchor-permalink" href="#modules" title="Permalink"></a></h1><p>Julia 中的模块有助于将代码组织成连贯的部分。 它们在语法上以 <code>module Name ... end</code> 界定，并具有以下特点：</p><ol><li><p>Modules are separate namespaces, each introducing a new global scope. This is useful, because it allows the same name to be used for different functions or global variables without conflict, as long as they are in separate modules.</p></li><li><p>Modules have facilities for detailed namespace management: each defines a set of names it <code>export</code>s, and can import names from other modules with <code>using</code> and <code>import</code> (we explain these below).</p></li><li><p>Modules can be precompiled for faster loading, and contain code for runtime initialization.</p></li></ol><p>Typically, in larger Julia packages you will see module code organized into files, eg</p><pre><code class="language-julia">module SomeModule

# export, using, import statements are usually here; we discuss these below

include(&quot;file1.jl&quot;)
include(&quot;file2.jl&quot;)

end</code></pre><p>Files and file names are mostly unrelated to modules; modules are associated only with module expressions. One can have multiple files per module, and multiple modules per file. <code>include</code> behaves as if the contents of the source file were evaluated in the global scope of the including module. In this chapter, we use short and simplified examples, so we won&#39;t use <code>include</code>.</p><p>The recommended style is not to indent the body of the module, since that would typically lead to whole files being indented. Also, it is common to use <code>UpperCamelCase</code> for module names (just like types), and use the plural form if applicable, especially if the module contains a similarly named identifier, to avoid name clashes. For example,</p><pre><code class="language-julia">module FastThings

struct FastThing
    ...
end

end</code></pre><h2 id="namespace-management"><a class="docs-heading-anchor" href="#namespace-management">Namespace management</a><a id="namespace-management-1"></a><a class="docs-heading-anchor-permalink" href="#namespace-management" title="Permalink"></a></h2><p>Namespace management refers to the facilities the language offers for making names in a module available in other modules. We discuss the related concepts and functionality below in detail.</p><h3 id="Qualified-names"><a class="docs-heading-anchor" href="#Qualified-names">Qualified names</a><a id="Qualified-names-1"></a><a class="docs-heading-anchor-permalink" href="#Qualified-names" title="Permalink"></a></h3><p>Names for functions, variables and types in the global scope like <code>sin</code>, <code>ARGS</code>, and <code>UnitRange</code> always belong to a module, called the <em>parent module</em>, which can be found interactively with <a href="../../base/base/#Base.parentmodule"><code>parentmodule</code></a>, for example</p><pre><code class="language-julia-repl">julia&gt; parentmodule(UnitRange)
Base</code></pre><p>One can also refer to these names outside their parent module by prefixing them with their module, eg <code>Base.UnitRange</code>. This is called a <em>qualified name</em>. The parent module may be accessible using a chain of submodules like <code>Base.Math.sin</code>, where <code>Base.Math</code> is called the <em>module path</em>. Due to syntactic ambiguities, qualifying a name that contains only symbols, such as an operator, requires inserting a colon, e.g. <code>Base.:+</code>. A small number of operators additionally require parentheses, e.g. <code>Base.:(==)</code>.</p><p>If a name is qualified, then it is always <em>accessible</em>, and in case of a function, it can also have methods added to it by using the qualified name as the function name.</p><p>Within a module, a variable name can be “reserved” without assigning to it by declaring it as <code>global x</code>. This prevents name conflicts for globals initialized after load time. The syntax <code>M.x = y</code> does not work to assign a global in another module; global assignment is always module-local.</p><h3 id="Export-lists"><a class="docs-heading-anchor" href="#Export-lists">Export lists</a><a id="Export-lists-1"></a><a class="docs-heading-anchor-permalink" href="#Export-lists" title="Permalink"></a></h3><p>Names (referring to functions, types, global variables, and constants) can be added to the <em>export list</em> of a module with <code>export</code>. Typically, they are at or near the top of the module definition so that readers of the source code can find them easily, as in</p><pre><code class="language-julia">module NiceStuff

export nice, DOG

struct Dog end      # singleton type, not exported

const DOG = Dog()   # named instance, exported

nice(x) = &quot;nice $x&quot; # function, exported

end</code></pre><p>but this is just a style suggestion — a module can have multiple <code>export</code> statements in arbitrary locations.</p><p>It is common to export names which form part of the API (application programming interface). In the above code, the export list suggests that users should use <code>nice</code> and <code>DOG</code>. However, since qualified names always make identifiers accessible, this is just an option for organizing APIs: unlike other languages, Julia has no facilities for truly hiding module internals.</p><p>Also, some modules don&#39;t export names at all. This is usually done if they use common words, such as <code>derivative</code>, in their API, which could easily clash with the export lists of other modules. We will see how to manage name clashes below.</p><h3 id="Standalone-using-and-import"><a class="docs-heading-anchor" href="#Standalone-using-and-import">Standalone <code>using</code> and <code>import</code></a><a id="Standalone-using-and-import-1"></a><a class="docs-heading-anchor-permalink" href="#Standalone-using-and-import" title="Permalink"></a></h3><p>Possibly the most common way of loading a module is <code>using ModuleName</code>. This <a href="../code-loading/#code-loading">loads</a> the code associated with <code>ModuleName</code>, and brings</p><ol><li><p>the module name</p></li><li><p>and the elements of the export list into the surrounding global namespace.</p></li></ol><p>Technically, the statement <code>using ModuleName</code> means that a module called <code>ModuleName</code> will be available for resolving names as needed. When a global variable is encountered that has no definition in the current module, the system will search for it among variables exported by <code>ModuleName</code> and use it if it is found there. This means that all uses of that global within the current module will resolve to the definition of that variable in <code>ModuleName</code>.</p><p>To continue with our example,</p><pre><code class="language-julia">using NiceStuff</code></pre><p>would load the above code, making <code>NiceStuff</code> (the module name), <code>DOG</code> and <code>nice</code> available. <code>Dog</code> is not on the export list, but it can be accessed if the name is qualified with the module path (which here is just the module name) as <code>NiceStuff.Dog</code>.</p><p>Importantly, <strong><code>using ModuleName</code> is the only form for which export lists matter at all</strong>.</p><p>In contrast,</p><pre><code class="language-julia">import NiceStuff</code></pre><p>brings <em>only</em> the module name into scope. Users would need to use <code>NiceStuff.DOG</code>, <code>NiceStuff.Dog</code>, and <code>NiceStuff.nice</code> to access its contents. Usually, <code>import ModuleName</code> is used in contexts when the user wants to keep the namespace clean. As we will see in the next section <code>import NiceStuff</code> is equivalent to <code>using NiceStuff: NiceStuff</code>.</p><p>You can combine multiple <code>using</code> and <code>import</code> statements of the same kind in a comma-separated expression, e.g.</p><pre><code class="language-julia">using LinearAlgebra, Statistics</code></pre><h3 id="using-and-import-with-specific-identifiers,-and-adding-methods"><a class="docs-heading-anchor" href="#using-and-import-with-specific-identifiers,-and-adding-methods"><code>using</code> and <code>import</code> with specific identifiers, and adding methods</a><a id="using-and-import-with-specific-identifiers,-and-adding-methods-1"></a><a class="docs-heading-anchor-permalink" href="#using-and-import-with-specific-identifiers,-and-adding-methods" title="Permalink"></a></h3><p>When <code>using ModuleName:</code> or <code>import ModuleName:</code> is followed by a comma-separated list of names, the module is loaded, but <em>only those specific names are brought into the namespace</em> by the statement. For example,</p><pre><code class="language-julia">using NiceStuff: nice, DOG</code></pre><p>will import the names <code>nice</code> and <code>DOG</code>.</p><p>Importantly, the module name <code>NiceStuff</code> will <em>not</em> be in the namespace. If you want to make it accessible, you have to list it explicitly, as</p><pre><code class="language-julia">using NiceStuff: nice, DOG, NiceStuff</code></pre><p>Julia has two forms for seemingly the same thing because only <code>import ModuleName: f</code> allows adding methods to <code>f</code> <em>without a module path</em>. That is to say, the following example will give an error:</p><pre><code class="language-julia">using NiceStuff: nice
struct Cat end
nice(::Cat) = &quot;nice 😸&quot;</code></pre><p>This error prevents accidentally adding methods to functions in other modules that you only intended to use.</p><p>There are two ways to deal with this. You can always qualify function names with a module path:</p><pre><code class="language-julia">using NiceStuff
struct Cat end
NiceStuff.nice(::Cat) = &quot;nice 😸&quot;</code></pre><p>Alternatively, you can <code>import</code> the specific function name:</p><pre><code class="language-julia">import NiceStuff: nice
struct Cat end
nice(::Cat) = &quot;nice 😸&quot;</code></pre><p>Which one you choose is a matter of style. The first form makes it clear that you are adding a method to a function in another module (remember, that the imports and the method defintion may be in separate files), while the second one is shorter, which is especially convenient if you are defining multiple methods.</p><p>一旦一个变量通过 <code>using</code> 或 <code>import</code> 引入，当前模块就不能创建同名的变量了。而且导入的变量是只读的，给全局变量赋值只能影响到由当前模块拥有的变量，否则会报错。</p><h3 id="Renaming-with-as"><a class="docs-heading-anchor" href="#Renaming-with-as">Renaming with <code>as</code></a><a id="Renaming-with-as-1"></a><a class="docs-heading-anchor-permalink" href="#Renaming-with-as" title="Permalink"></a></h3><p>An identifier brought into scope by <code>import</code> or <code>using</code> can be renamed with the keyword <code>as</code>. This is useful for working around name conflicts as well as for shortening names. For example, <code>Base</code> exports the function name <code>read</code>, but the CSV.jl package also provides <code>CSV.read</code>. If we are going to invoke CSV reading many times, it would be convenient to drop the <code>CSV.</code> qualifier. But then it is ambiguous whether we are referring to <code>Base.read</code> or <code>CSV.read</code>:</p><pre><code class="language-julia">julia&gt; read;

julia&gt; import CSV: read
WARNING: ignoring conflicting import of CSV.read into Main</code></pre><p>Renaming provides a solution:</p><pre><code class="language-julia">julia&gt; import CSV: read as rd</code></pre><p>Imported packages themselves can also be renamed:</p><pre><code class="language-julia">import BenchmarkTools as BT</code></pre><p><code>as</code> works with <code>using</code> only when a single identifier is brought into scope. For example <code>using CSV: read as rd</code> works, but <code>using CSV as C</code> does not, since it operates on all of the exported names in <code>CSV</code>.</p><h3 id="Mixing-multiple-using-and-import-statements"><a class="docs-heading-anchor" href="#Mixing-multiple-using-and-import-statements">Mixing multiple <code>using</code> and <code>import</code> statements</a><a id="Mixing-multiple-using-and-import-statements-1"></a><a class="docs-heading-anchor-permalink" href="#Mixing-multiple-using-and-import-statements" title="Permalink"></a></h3><p>When multiple <code>using</code> or <code>import</code> statements of any of the forms above are used, their effect is combined in the order they appear. For example,</p><pre><code class="language-julia">using NiceStuff         # exported names and the module name
import NiceStuff: nice  # allows adding methods to unqualified functions</code></pre><p>would bring all the exported names of <code>NiceStuff</code> and the module name itself into scope, and also allow adding methods to <code>nice</code> without prefixing it with a module name.</p><h3 id="Handling-name-conflicts"><a class="docs-heading-anchor" href="#Handling-name-conflicts">Handling name conflicts</a><a id="Handling-name-conflicts-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-name-conflicts" title="Permalink"></a></h3><p>Consider the situation where two (or more) packages export the same name, as in</p><pre><code class="language-julia">module A
export f
f() = 1
end

module B
export f
f() = 2
end</code></pre><p>The statement <code>using A, B</code> works, but when you try to call <code>f</code>, you get a warning</p><pre><code class="language-julia">WARNING: both B and A export &quot;f&quot;; uses of it in module Main must be qualified
ERROR: LoadError: UndefVarError: f not defined</code></pre><p>Here, Julia cannot decide which <code>f</code> you are referring to, so you have to make a choice. The following solutions are commonly used:</p><ol><li><p>Simply proceed with qualified names like <code>A.f</code> and <code>B.f</code>. This makes the context clear to the reader of your code, especially if <code>f</code> just happens to coincide but has different meaning in various packages. For example, <code>degree</code> has various uses in mathematics, the natural sciences, and in everyday life, and these meanings should be kept separate.</p></li><li><p>Use the <code>as</code> keyword above to rename one or both identifiers, eg</p><pre><code class="language-julia">using A: f as f
using B: f as g</code></pre><p>would make <code>B.f</code> available as <code>g</code>. Here, we are assuming that you did not use <code>using A</code> before, which would have brought <code>f</code> into the namespace.</p></li><li><p>When the names in question <em>do</em> share a meaning, it is common for one module to import it from another, or have a lightweight “base” package with the sole function of defining an interface like this, which can be used by other packages. It is conventional to have such package names end in <code>...Base</code> (which has nothing to do with Julia&#39;s <code>Base</code> module).</p></li></ol><h3 id="默认顶层定义以及裸模块"><a class="docs-heading-anchor" href="#默认顶层定义以及裸模块">默认顶层定义以及裸模块</a><a id="默认顶层定义以及裸模块-1"></a><a class="docs-heading-anchor-permalink" href="#默认顶层定义以及裸模块" title="Permalink"></a></h3><p>Modules automatically contain <code>using Core</code>, <code>using Base</code>, and definitions of the <a href="../../base/base/#Base.MainInclude.eval"><code>eval</code></a> and <a href="../../base/base/#Base.MainInclude.include"><code>include</code></a> functions, which evaluate expressions/files within the global scope of that module.</p><p>If these default definitions are not wanted, modules can be defined using the keyword <a href="../../base/base/#baremodule"><code>baremodule</code></a> instead (note: <code>Core</code> is still imported). In terms of <code>baremodule</code>, a standard <code>module</code> looks like this:</p><pre><code class="language-none">baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
include(p) = Base.include(Mod, p)

...

end</code></pre><h3 id="标准模块"><a class="docs-heading-anchor" href="#标准模块">标准模块</a><a id="标准模块-1"></a><a class="docs-heading-anchor-permalink" href="#标准模块" title="Permalink"></a></h3><p>有三个重要的标准模块：</p><ul><li><a href="../../base/base/#Core"><code>Core</code></a> 包含了语言“内置”的所有功能。</li><li><a href="../../base/base/#Base"><code>Base</code></a> 包含了绝大多数情况下都会用到的基本功能。</li><li><a href="manual/@ref"><code>Main</code></a> 是顶层模块，当 julia 启动时，也是当前模块。</li></ul><div class="admonition is-info"><header class="admonition-header">Standard library modules</header><div class="admonition-body"><p>By default Julia ships with some standard library modules. These behave like regular Julia packages except that you don&#39;t need to install them explicitly. For example, if you wanted to perform some unit testing, you could load the <code>Test</code> standard library as follows:</p><pre><code class="language-julia">using Test</code></pre></div></div><h2 id="Submodules-and-relative-paths"><a class="docs-heading-anchor" href="#Submodules-and-relative-paths">Submodules and relative paths</a><a id="Submodules-and-relative-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Submodules-and-relative-paths" title="Permalink"></a></h2><p>Modules can contain <em>submodules</em>, nesting the same syntax <code>module ... end</code>. They can be used to introduce separate namespaces, which can be helpful for organizing complex codebases. Note that each <code>module</code> introduces its own <a href="../variables-and-scoping/#scope-of-variables">scope</a>, so submodules do not automatically “inherit” names from their parent.</p><p>It is recommended that submodules refer to other modules within the enclosing parent module (including the latter) using <em>relative module qualifiers</em> in <code>using</code> and <code>import</code> statements. A relative module qualifier starts with a period (<code>.</code>), which corresponds to the current module, and each successive <code>.</code> leads to the parent of the current module. This should be followed by modules if necessary, and eventually the actual name to access, all separated by <code>.</code>s.</p><p>Consider the following example, where the submodule <code>SubA</code> defines a function, which is then extended in its “sibling” module:</p><pre><code class="language-julia">module ParentModule

module SubA
export add_D  # exported interface
const D = 3
add_D(x) = x + D
end

using .SubA  # brings `add_D` into the namespace

export add_D # export it from ParentModule too

module SubB
import ..SubA: add_D # relative path for a “sibling” module
struct Infinity end
add_D(x::Infinity) = x
end

end</code></pre><p>You may see code in packages, which, in a similar situation, uses</p><pre><code class="language-julia">import ParentModule.SubA: add_D</code></pre><p>However, this operates through <a href="../code-loading/#code-loading">code loading</a>, and thus only works if <code>ParentModule</code> is in a package. It is better to use relative paths.</p><p>Note that the order of definitions also matters if you are evaluating values. Consider</p><pre><code class="language-julia">module TestPackage

export x, y

x = 0

module Sub
using ..TestPackage
z = y # ERROR: UndefVarError: y not defined
end

y = 1

end</code></pre><p>where <code>Sub</code> is trying to use <code>TestPackage.y</code> before it was defined, so it does not have a value.</p><p>For similar reasons, you cannot use a cyclic ordering:</p><pre><code class="language-julia">module A

module B
using ..C # ERROR: UndefVarError: C not defined
end

module C
using ..B
end

end</code></pre><h3 id="模块初始化和预编译"><a class="docs-heading-anchor" href="#模块初始化和预编译">模块初始化和预编译</a><a id="模块初始化和预编译-1"></a><a class="docs-heading-anchor-permalink" href="#模块初始化和预编译" title="Permalink"></a></h3><p>因为执行模块中的所有语句通常需要编译大量代码，大型模块可能需要几秒钟才能加载。Julia 会创建模块的预编译缓存以减少这个时间。</p><p>当用 <code>import</code> 或 <code>using</code> 加载一个模块时，模块增量预编译文件会自动创建并使用。这会让模块在第一次加载时自动编译。 另外，你也可以手工调用 <a href="../../base/base/#Base.compilecache"><code>Base.compilecache(modulename)</code></a>，产生的缓存文件会放在 <code>DEPOT_PATH[1]/compiled/</code> 目录下。 之后，当该模块的任何一个依赖发生变更时，该模块会在 <code>using</code> 或 <code>import</code> 时自动重新编译； 模块的依赖指的是：任何它导入的模块、Julia 自身、include 的文件或由 <a href="../../base/base/#Base.include_dependency"><code>include_dependency(path)</code></a> 显式声明的依赖。</p><p>For file dependencies, a change is determined by examining whether the modification time (<code>mtime</code>) of each file loaded by <code>include</code> or added explicitly by <code>include_dependency</code> is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can&#39;t copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in <code>require</code> matches the path that had created the precompile file. It also takes into account the set of dependencies already loaded into the current process and won&#39;t recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache.</p><p>If you know that a module is <em>not</em> safe to precompile (for example, for one of the reasons described below), you should put <code>__precompile__(false)</code> in the module file (typically placed at the top). This will cause <code>Base.compilecache</code> to throw an error, and will cause <code>using</code> / <code>import</code> to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</p><p>在开发模块的时候，你可能需要了解一些与增量编译相关的固有行为。例如，外部状态不会被保留。为了解决这个问题，需要显式分离运行时与编译期的部分。Julia 允许你定义一个 <code>__init__()</code> 函数来执行任何需要在运行时发生的初始化。在编译期（<code>--output-*</code>），此函数将不会被调用。你可以假设在代码的生存周期中，此函数只会被运行一次。当然，如果有必要，你也可以手动调用它，但在默认的情况下，请假定此函数是为了处理与本机状态相关的信息，注意这些信息不需要，更不应该存入预编译镜像。此函数会在模块被导入到当前进程之后被调用，这包括在一个增量编译中导入该模块的时候（<code>--output-incremental=yes</code>），但在完整编译时该函数不会被调用。</p><p>特别的，如果你在模块里定义了一个名为 <code>__init__()</code> 的函数，那么 Julia 在加载这个模块之后会在第一次运行时（runtime）立刻调用这个函数（例如，通过 <code>import</code>，<code>using</code>，或者 <code>require</code> 加载时），也就是说 <code>__init__</code> 只会在模块中所有其它命令都执行完以后被调用一次。因为这个函数将在模块完全载入后被调用，任何子模块或者已经载入的模块都将在当前模块调用 <code>__init__</code> <strong>之前</strong> 调用自己的 <code>__init__</code> 函数。</p><p><code>__init__</code>的典型用法有二，一是用于调用外部 C 库的运行时初始化函数，二是用于初始化涉及到外部库所返回的指针的全局常量。例如，假设我们正在调用一个 C 库 <code>libfoo</code>，它要求我们在运行时调用<code>foo_init()</code> 这个初始化函数。假设我们还想定义一个全局常量 <code>foo_data_ptr</code>，它保存 <code>libfoo</code> 所定义的 <code>void *foo_data()</code> 函数的返回值——必须在运行时（而非编译时）初始化这个常量，因为指针地址不是固定的。可以通过在模块中定义 <code>__init__</code> 函数来完成这个操作。</p><pre><code class="language-julia">const foo_data_ptr = Ref{Ptr{Cvoid}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Cvoid, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())
    nothing
end</code></pre><p>注意，在像 <code>__init__</code> 这样的函数里定义一个全局变量是完全可以的，这是动态语言的优点之一。但是把全局作用域的值定义成常量，可以让编译器能确定该值的类型，并且能让编译器生成更好的优化过的代码。显然，你的模块（Module）中，任何其他依赖于 <code>foo_data_ptr</code> 的全局量也必须在 <code>__init__</code> 中被初始化。</p><p>Constants involving most Julia objects that are not produced by <a href="../../base/c/#ccall"><code>ccall</code></a> do not need to be placed in <code>__init__</code>: their definitions can be precompiled and loaded from the cached module image. This includes complicated heap-allocated objects like arrays. However, any routine that returns a raw pointer value must be called at runtime for precompilation to work (<a href="../../base/c/#Core.Ptr"><code>Ptr</code></a> objects will turn into null pointers unless they are hidden inside an <a href="../../base/base/#Base.isbits"><code>isbits</code></a> object). This includes the return values of the Julia functions <a href="../../base/c/#Base.@cfunction"><code>@cfunction</code></a> and <a href="../../base/c/#Base.pointer"><code>pointer</code></a>.</p><p>字典和集合类型，或者通常任何依赖于 <code>hash(key)</code> 方法的类型，都是比较棘手的情况。 通常当键是数字、字符串、符号、范围、<code>Expr</code> 或这些类型的组合（通过数组、元组、集合、映射对等）时，可以安全地预编译它们。但是，对于一些其它的键类型，例如 <code>Function</code> 或 <code>DataType</code>、以及还没有定义散列方法的通用用户定义类型，回退（fallback）的散列（<code>hash</code>）方法依赖于对象的内存地址（通过 <code>objectid</code>），因此可能会在每次运行时发生变化。 如果您有这些关键类型中的一种，或者您不确定，为了安全起见，您可以在您的 <code>__init__</code> 函数中初始化这个字典。或者，您可以使用 <a href="../../base/collections/#Base.IdDict"><code>IdDict</code></a> 字典类型，它是由预编译专门处理的，因此在编译时初始化是安全的。</p><p>当使用预编译时，我们必须要清楚地区分代码的编译阶段和运行阶段。在此模式下，我们会更清楚发现 Julia 的编译器可以执行任何 Julia 代码，而不是一个用于生成编译后代码的独立的解释器。</p><p>其它已知的潜在失败场景包括：</p><ol><li><p>全局计数器，例如：为了试图唯一的标识对象。考虑以下代码片段：</p><pre><code class="language-julia">mutable struct UniquedById
    myid::Int
    let counter = 0
        UniquedById() = new(counter += 1)
    end
end</code></pre><p>尽管这段代码的目标是给每个实例赋一个唯一的 ID，但计数器的值会在代码编译结束时被记录。任何对此增量编译模块的后续使用，计数器都将从同一个值开始计数。</p><p>注意 <code>objectid</code> （工作原理是取内存指针的 hash）也有类似的问题，请查阅下面关于 <code>Dict</code> 的用法。</p><p>一种解决方案是用宏捕捉 <a href="../../base/base/#Base.@__MODULE__"><code>@__MODULE__</code></a>，并将它与目前的 <code>counter</code> 值一起保存。然而，更好的方案是对代码进行重新设计，不要依赖这种全局状态变量。</p></li><li><p>像 <code>Dict</code> 和 <code>Set</code> 这种关联集合需要在 <code>__init__</code> 中 re-hash。Julia 在未来很可能会提供一个机制来注册初始化函数。</p></li><li><p>依赖编译期的副作用会在加载时蔓延。例子包括：更改其它 Julia 模块里的数组或变量，操作文件或设备的句柄，保存指向其它系统资源（包括内存）的指针。</p></li><li><p>无意中从其它模块中“拷贝”了全局状态：通过直接引用的方式而不是通过查找的方式。例如，在全局作用域下：</p><pre><code class="language-julia">#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#
# instead use accessor functions:
getstdout() = Base.stdout #= best option =#
# or move the assignment into the runtime:
__init__() = global mystdout = Base.stdout #= also works =#</code></pre></li></ol><p>此处为预编译中的操作附加了若干限制，以帮助用户避免其他误操作：</p><ol><li>调用 <a href="../../base/base/#Base.MainInclude.eval"><code>eval</code></a> 来在另一个模块中引发副作用。当增量预编译被标记时，该操作同时会导致抛出一个警告。</li><li>当 <code>__init__()</code> 已经开始执行后，在局部作用域中声明 <code>global const</code>（见 issue #12010，计划为此情况添加一个错误提示）</li><li>在增量预编译时替换模块是一个运行时错误。</li></ol><p>一些其他需要注意的点：</p><ol><li>在源代码文件本身被修改之后，不会执行代码重载或缓存失效化处理（包括由 <code>Pkg.update</code> 执行的修改，此外在 <code>Pkg.rm</code> 执行后也没有清理操作）</li><li>变形数组的内存共享特性会被预编译忽略（每个数组样貌都会获得一个拷贝）</li><li>文件系统在编译期间和运行期间被假设为不变的，比如使用 <a href="../../base/base/#Base.@__FILE__"><code>@__FILE__</code></a>/<code>source_path()</code> 在运行期间寻找资源、或使用 BinDeps 宏 <code>@checked_lib</code>。有时这是不可避免的。但是可能的话，在编译期将资源复制到模块里面是个好做法，这样在运行期间，就不需要去寻找它们了。</li><li><code>WeakRef</code> 对象和完成器目前在序列化器中无法被恰当地处理（在接下来的发行版中将修复）。</li><li>通常，最好避免去捕捉内部元数据对象的引用，如 <code>Method</code>、<code>MethodInstance</code>、<code>TypeMapLevel</code>、<code>TypeMapEntry</code> 及这些对象的字段，因为这会迷惑序列化器，且可能会引发你不想要的结果。此操作不足以成为一个错误，但你需做好准备：系统会尝试拷贝一部分，然后创建其余部分的单个独立实例。</li></ol><p>在开发模块时，关闭增量预编译可能会有所帮助。命令行标记 <code>--compiled-modules={yes|no}</code> 可以让你切换预编译的开启和关闭。当 Julia 附加 <code>--compiled-modules=no</code> 启动，在载入模块和模块依赖时，编译缓存中的序列化模块会被忽略。<code>Base.compilecache</code> 仍可以被手动调用。此命令行标记的状态会被传递给 <code>Pkg.build</code>，禁止其在安装、更新、显式构建包时触发自动预编译。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interfaces/">« 接口</a><a class="docs-footer-nextpage" href="../documentation/">文档 »</a><div class="flexbox-break"></div><p class="footer-message">📢📢📢Julia中文社区现已加入“开源软件供应链点亮计划”，如果你想改善Julia中文文档的翻译，那就赶快来 <a href="https://summer.iscas.ac.cn/#/org/prodetail/210370191">报名</a> 吧！</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2021 八月 13 周五 15:24">2021 八月 13 周五</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.6.2版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
