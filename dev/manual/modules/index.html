<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>æ¨¡å— Â· Juliaä¸­æ–‡æ–‡æ¡£</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/modules/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Juliaä¸­æ–‡æ–‡æ¡£ logo"/></a><div class="docs-package-name"><span class="docs-autofit">Juliaä¸­æ–‡æ–‡æ¡£</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">ä¸»é¡µ</a></li><li><span class="tocitem">æ‰‹å†Œ</span><ul><li><a class="tocitem" href="../getting-started/">å…¥é—¨</a></li><li><a class="tocitem" href="../variables/">å˜é‡</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">æ•´æ•°å’Œæµ®ç‚¹æ•°</a></li><li><a class="tocitem" href="../mathematical-operations/">æ•°å­¦è¿ç®—å’Œåˆç­‰å‡½æ•°</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">å¤æ•°å’Œæœ‰ç†æ•°</a></li><li><a class="tocitem" href="../strings/">å­—ç¬¦ä¸²</a></li><li><a class="tocitem" href="../functions/">å‡½æ•°</a></li><li><a class="tocitem" href="../control-flow/">æµç¨‹æ§åˆ¶</a></li><li><a class="tocitem" href="../variables-and-scoping/">å˜é‡ä½œç”¨åŸŸ</a></li><li><a class="tocitem" href="../types/">ç±»å‹</a></li><li><a class="tocitem" href="../methods/">æ–¹æ³•</a></li><li><a class="tocitem" href="../constructors/">æ„é€ å‡½æ•°</a></li><li><a class="tocitem" href="../conversion-and-promotion/">ç±»å‹è½¬æ¢å’Œç±»å‹æå‡</a></li><li><a class="tocitem" href="../interfaces/">æ¥å£</a></li><li class="is-active"><a class="tocitem" href>æ¨¡å—</a><ul class="internal"><li><a class="tocitem" href="#namespace-management"><span>Namespace management</span></a></li><li><a class="tocitem" href="#Submodules-and-relative-paths"><span>Submodules and relative paths</span></a></li></ul></li><li><a class="tocitem" href="../documentation/">æ–‡æ¡£</a></li><li><a class="tocitem" href="../metaprogramming/">å…ƒç¼–ç¨‹</a></li><li><a class="tocitem" href="../arrays/">å¤šç»´æ•°ç»„</a></li><li><a class="tocitem" href="../missing/">ç¼ºå¤±å€¼</a></li><li><a class="tocitem" href="../networking-and-streams/">ç½‘ç»œå’Œæµ</a></li><li><a class="tocitem" href="../parallel-computing/">å¹¶è¡Œè®¡ç®—</a></li><li><a class="tocitem" href="../asynchronous-programming/">Asynchronous Programming</a></li><li><a class="tocitem" href="../multi-threading/">å¤šçº¿ç¨‹</a></li><li><a class="tocitem" href="../distributed-computing/">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../running-external-programs/">è¿è¡Œå¤–éƒ¨ç¨‹åº</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">è°ƒç”¨ C å’Œ Fortran ä»£ç </a></li><li><a class="tocitem" href="../handling-operating-system-variation/">å¤„ç†æ“ä½œç³»ç»Ÿå·®å¼‚</a></li><li><a class="tocitem" href="../environment-variables/">ç¯å¢ƒå˜é‡</a></li><li><a class="tocitem" href="../embedding/">åµŒå…¥ Julia</a></li><li><a class="tocitem" href="../code-loading/">ä»£ç åŠ è½½</a></li><li><a class="tocitem" href="../profile/">æ€§èƒ½åˆ†æ</a></li><li><a class="tocitem" href="../stacktraces/">æ ˆè·Ÿè¸ª</a></li><li><a class="tocitem" href="../performance-tips/">æ€§èƒ½å»ºè®®</a></li><li><a class="tocitem" href="../workflow-tips/">å·¥ä½œæµç¨‹å»ºè®®</a></li><li><a class="tocitem" href="../style-guide/">ä»£ç é£æ ¼æŒ‡å—</a></li><li><a class="tocitem" href="../faq/">å¸¸è§é—®é¢˜</a></li><li><a class="tocitem" href="../noteworthy-differences/">ä¸å…¶ä»–è¯­è¨€çš„æ˜¾è‘—å·®å¼‚</a></li><li><a class="tocitem" href="../unicode-input/">Unicode è¾“å…¥è¡¨</a></li><li><a class="tocitem" href="../command-line-options/">å‘½ä»¤è¡Œé€‰é¡¹</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">åŸºæœ¬åŠŸèƒ½</a></li><li><a class="tocitem" href="../../base/collections/">é›†åˆå’Œæ•°æ®ç»“æ„</a></li><li><a class="tocitem" href="../../base/math/">æ•°å­¦ç›¸å…³</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">å­—ç¬¦ä¸²</a></li><li><a class="tocitem" href="../../base/arrays/">æ•°ç»„</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">å¸¸é‡</a></li><li><a class="tocitem" href="../../base/file/">æ–‡ä»¶ç³»ç»Ÿ</a></li><li><a class="tocitem" href="../../base/io-network/">I/O ä¸ç½‘ç»œ</a></li><li><a class="tocitem" href="../../base/punctuation/">è¿ç®—ç¬¦ä¸è®°å·</a></li><li><a class="tocitem" href="../../base/sort/">æ’åºåŠç›¸å…³å‡½æ•°</a></li><li><a class="tocitem" href="../../base/iterators/">è¿­ä»£ç›¸å…³</a></li><li><a class="tocitem" href="../../base/c/">C æ¥å£</a></li><li><a class="tocitem" href="../../base/libc/">C æ ‡å‡†åº“</a></li><li><a class="tocitem" href="../../base/stacktraces/">å †æ ˆè·Ÿè¸ª</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD æ”¯æŒ</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">æ—¥æœŸ</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">åˆ†éš”ç¬¦æ–‡ä»¶</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">æ–‡ä»¶ç›¸å…³äº‹ä»¶</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">åŠ¨æ€é“¾æ¥å™¨</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">æ—¥å¿—è®°å½•</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">å†…å­˜æ˜ å°„ I/O</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">æ€§èƒ½åˆ†æ</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">éšæœºæ•°</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">åºåˆ—åŒ–</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">å…±äº«æ•°ç»„</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">å¥—æ¥å­—</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">ç¨€ç–æ•°ç»„</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">ç»Ÿè®¡</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">å•å…ƒæµ‹è¯•</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">åå°„ ä¸ è‡ªæˆ‘æ£€æŸ¥</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia è¿è¡Œæ—¶çš„åˆå§‹åŒ–</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia çš„ AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia ä»£ç çš„ eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">æœ¬æœºä»£ç ç”Ÿæˆè¿‡ç¨‹çš„é«˜çº§æ¦‚è¿°</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia å‡½æ•°</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">ç¬›å¡å°”</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">å­æ•°ç»„</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">è¾¹ç•Œæ£€æŸ¥</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">ç±»å‹æ¨å¯¼</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">æŠ¥å‘Šå’Œåˆ†æå´©æºƒï¼ˆæ®µé”™è¯¯ï¼‰</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb è°ƒè¯•æç¤º</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">åœ¨Juliaä¸­ä½¿ç”¨Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">æ‰‹å†Œ</a></li><li class="is-active"><a href>æ¨¡å—</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>æ¨¡å—</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/modulesmd" title=" å®Œå–„ Transifex ä¸Šçš„ç¿»è¯‘"><span class="docs-icon fab">ï‚¬</span><span class="docs-label is-hidden-touch"> å®Œå–„ Transifex ä¸Šçš„ç¿»è¯‘</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="è®¾ç½®"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="modules"><a class="docs-heading-anchor" href="#modules">æ¨¡å—</a><a id="modules-1"></a><a class="docs-heading-anchor-permalink" href="#modules" title="Permalink"></a></h1><p>Julia ä¸­çš„æ¨¡å—æœ‰åŠ©äºå°†ä»£ç ç»„ç»‡æˆè¿è´¯çš„éƒ¨åˆ†ã€‚ å®ƒä»¬åœ¨è¯­æ³•ä¸Šä»¥ <code>module Name ... end</code> ç•Œå®šï¼Œå¹¶å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š</p><ol><li><p>Modules are separate namespaces, each introducing a new global scope. This is useful, because it allows the same name to be used for different functions or global variables without conflict, as long as they are in separate modules.</p></li><li><p>Modules have facilities for detailed namespace management: each defines a set of names it <code>export</code>s, and can import names from other modules with <code>using</code> and <code>import</code> (we explain these below).</p></li><li><p>Modules can be precompiled for faster loading, and contain code for runtime initialization.</p></li></ol><p>Typically, in larger Julia packages you will see module code organized into files, eg</p><pre><code class="language-julia">module SomeModule

# export, using, import statements are usually here; we discuss these below

include(&quot;file1.jl&quot;)
include(&quot;file2.jl&quot;)

end</code></pre><p>Files and file names are mostly unrelated to modules; modules are associated only with module expressions. One can have multiple files per module, and multiple modules per file. <code>include</code> behaves as if the contents of the source file were evaluated in the global scope of the including module. In this chapter, we use short and simplified examples, so we won&#39;t use <code>include</code>.</p><p>The recommended style is not to indent the body of the module, since that would typically lead to whole files being indented. Also, it is common to use <code>UpperCamelCase</code> for module names (just like types), and use the plural form if applicable, especially if the module contains a similarly named identifier, to avoid name clashes. For example,</p><pre><code class="language-julia">module FastThings

struct FastThing
    ...
end

end</code></pre><h2 id="namespace-management"><a class="docs-heading-anchor" href="#namespace-management">Namespace management</a><a id="namespace-management-1"></a><a class="docs-heading-anchor-permalink" href="#namespace-management" title="Permalink"></a></h2><p>Namespace management refers to the facilities the language offers for making names in a module available in other modules. We discuss the related concepts and functionality below in detail.</p><h3 id="Qualified-names"><a class="docs-heading-anchor" href="#Qualified-names">Qualified names</a><a id="Qualified-names-1"></a><a class="docs-heading-anchor-permalink" href="#Qualified-names" title="Permalink"></a></h3><p>Names for functions, variables and types in the global scope like <code>sin</code>, <code>ARGS</code>, and <code>UnitRange</code> always belong to a module, called the <em>parent module</em>, which can be found interactively with <a href="../../base/base/#Base.parentmodule"><code>parentmodule</code></a>, for example</p><pre><code class="language-julia-repl">julia&gt; parentmodule(UnitRange)
Base</code></pre><p>One can also refer to these names outside their parent module by prefixing them with their module, eg <code>Base.UnitRange</code>. This is called a <em>qualified name</em>. The parent module may be accessible using a chain of submodules like <code>Base.Math.sin</code>, where <code>Base.Math</code> is called the <em>module path</em>. Due to syntactic ambiguities, qualifying a name that contains only symbols, such as an operator, requires inserting a colon, e.g. <code>Base.:+</code>. A small number of operators additionally require parentheses, e.g. <code>Base.:(==)</code>.</p><p>If a name is qualified, then it is always <em>accessible</em>, and in case of a function, it can also have methods added to it by using the qualified name as the function name.</p><p>Within a module, a variable name can be â€œreservedâ€ without assigning to it by declaring it as <code>global x</code>. This prevents name conflicts for globals initialized after load time. The syntax <code>M.x = y</code> does not work to assign a global in another module; global assignment is always module-local.</p><h3 id="Export-lists"><a class="docs-heading-anchor" href="#Export-lists">Export lists</a><a id="Export-lists-1"></a><a class="docs-heading-anchor-permalink" href="#Export-lists" title="Permalink"></a></h3><p>Names (referring to functions, types, global variables, and constants) can be added to the <em>export list</em> of a module with <code>export</code>. Typically, they are at or near the top of the module definition so that readers of the source code can find them easily, as in</p><pre><code class="language-julia">module NiceStuff

export nice, DOG

struct Dog end      # singleton type, not exported

const DOG = Dog()   # named instance, exported

nice(x) = &quot;nice $x&quot; # function, exported

end</code></pre><p>but this is just a style suggestion â€” a module can have multiple <code>export</code> statements in arbitrary locations.</p><p>It is common to export names which form part of the API (application programming interface). In the above code, the export list suggests that users should use <code>nice</code> and <code>DOG</code>. However, since qualified names always make identifiers accessible, this is just an option for organizing APIs: unlike other languages, Julia has no facilities for truly hiding module internals.</p><p>Also, some modules don&#39;t export names at all. This is usually done if they use common words, such as <code>derivative</code>, in their API, which could easily clash with the export lists of other modules. We will see how to manage name clashes below.</p><h3 id="Standalone-using-and-import"><a class="docs-heading-anchor" href="#Standalone-using-and-import">Standalone <code>using</code> and <code>import</code></a><a id="Standalone-using-and-import-1"></a><a class="docs-heading-anchor-permalink" href="#Standalone-using-and-import" title="Permalink"></a></h3><p>Possibly the most common way of loading a module is <code>using ModuleName</code>. This <a href="../code-loading/#code-loading">loads</a> the code associated with <code>ModuleName</code>, and brings</p><ol><li><p>the module name</p></li><li><p>and the elements of the export list into the surrounding global namespace.</p></li></ol><p>Technically, the statement <code>using ModuleName</code> means that a module called <code>ModuleName</code> will be available for resolving names as needed. When a global variable is encountered that has no definition in the current module, the system will search for it among variables exported by <code>ModuleName</code> and use it if it is found there. This means that all uses of that global within the current module will resolve to the definition of that variable in <code>ModuleName</code>.</p><p>To continue with our example,</p><pre><code class="language-julia">using NiceStuff</code></pre><p>would load the above code, making <code>NiceStuff</code> (the module name), <code>DOG</code> and <code>nice</code> available. <code>Dog</code> is not on the export list, but it can be accessed if the name is qualified with the module path (which here is just the module name) as <code>NiceStuff.Dog</code>.</p><p>Importantly, <strong><code>using ModuleName</code> is the only form for which export lists matter at all</strong>.</p><p>In contrast,</p><pre><code class="language-julia">import NiceStuff</code></pre><p>brings <em>only</em> the module name into scope. Users would need to use <code>NiceStuff.DOG</code>, <code>NiceStuff.Dog</code>, and <code>NiceStuff.nice</code> to access its contents. Usually, <code>import ModuleName</code> is used in contexts when the user wants to keep the namespace clean. As we will see in the next section <code>import NiceStuff</code> is equivalent to <code>using NiceStuff: NiceStuff</code>.</p><p>You can combine multiple <code>using</code> and <code>import</code> statements of the same kind in a comma-separated expression, e.g.</p><pre><code class="language-julia">using LinearAlgebra, Statistics</code></pre><h3 id="using-and-import-with-specific-identifiers,-and-adding-methods"><a class="docs-heading-anchor" href="#using-and-import-with-specific-identifiers,-and-adding-methods"><code>using</code> and <code>import</code> with specific identifiers, and adding methods</a><a id="using-and-import-with-specific-identifiers,-and-adding-methods-1"></a><a class="docs-heading-anchor-permalink" href="#using-and-import-with-specific-identifiers,-and-adding-methods" title="Permalink"></a></h3><p>When <code>using ModuleName:</code> or <code>import ModuleName:</code> is followed by a comma-separated list of names, the module is loaded, but <em>only those specific names are brought into the namespace</em> by the statement. For example,</p><pre><code class="language-julia">using NiceStuff: nice, DOG</code></pre><p>will import the names <code>nice</code> and <code>DOG</code>.</p><p>Importantly, the module name <code>NiceStuff</code> will <em>not</em> be in the namespace. If you want to make it accessible, you have to list it explicitly, as</p><pre><code class="language-julia">using NiceStuff: nice, DOG, NiceStuff</code></pre><p>Julia has two forms for seemingly the same thing because only <code>import ModuleName: f</code> allows adding methods to <code>f</code> <em>without a module path</em>. That is to say, the following example will give an error:</p><pre><code class="language-julia">using NiceStuff: nice
struct Cat end
nice(::Cat) = &quot;nice ğŸ˜¸&quot;</code></pre><p>This error prevents accidentally adding methods to functions in other modules that you only intended to use.</p><p>There are two ways to deal with this. You can always qualify function names with a module path:</p><pre><code class="language-julia">using NiceStuff
struct Cat end
NiceStuff.nice(::Cat) = &quot;nice ğŸ˜¸&quot;</code></pre><p>Alternatively, you can <code>import</code> the specific function name:</p><pre><code class="language-julia">import NiceStuff: nice
struct Cat end
nice(::Cat) = &quot;nice ğŸ˜¸&quot;</code></pre><p>Which one you choose is a matter of style. The first form makes it clear that you are adding a method to a function in another module (remember, that the imports and the method defintion may be in separate files), while the second one is shorter, which is especially convenient if you are defining multiple methods.</p><p>ä¸€æ—¦ä¸€ä¸ªå˜é‡é€šè¿‡ <code>using</code> æˆ– <code>import</code> å¼•å…¥ï¼Œå½“å‰æ¨¡å—å°±ä¸èƒ½åˆ›å»ºåŒåçš„å˜é‡äº†ã€‚è€Œä¸”å¯¼å…¥çš„å˜é‡æ˜¯åªè¯»çš„ï¼Œç»™å…¨å±€å˜é‡èµ‹å€¼åªèƒ½å½±å“åˆ°ç”±å½“å‰æ¨¡å—æ‹¥æœ‰çš„å˜é‡ï¼Œå¦åˆ™ä¼šæŠ¥é”™ã€‚</p><h3 id="Renaming-with-as"><a class="docs-heading-anchor" href="#Renaming-with-as">Renaming with <code>as</code></a><a id="Renaming-with-as-1"></a><a class="docs-heading-anchor-permalink" href="#Renaming-with-as" title="Permalink"></a></h3><p>An identifier brought into scope by <code>import</code> or <code>using</code> can be renamed with the keyword <code>as</code>. This is useful for working around name conflicts as well as for shortening names. For example, <code>Base</code> exports the function name <code>read</code>, but the CSV.jl package also provides <code>CSV.read</code>. If we are going to invoke CSV reading many times, it would be convenient to drop the <code>CSV.</code> qualifier. But then it is ambiguous whether we are referring to <code>Base.read</code> or <code>CSV.read</code>:</p><pre><code class="language-julia">julia&gt; read;

julia&gt; import CSV: read
WARNING: ignoring conflicting import of CSV.read into Main</code></pre><p>Renaming provides a solution:</p><pre><code class="language-julia">julia&gt; import CSV: read as rd</code></pre><p>Imported packages themselves can also be renamed:</p><pre><code class="language-julia">import BenchmarkTools as BT</code></pre><p><code>as</code> works with <code>using</code> only when a single identifier is brought into scope. For example <code>using CSV: read as rd</code> works, but <code>using CSV as C</code> does not, since it operates on all of the exported names in <code>CSV</code>.</p><h3 id="Mixing-multiple-using-and-import-statements"><a class="docs-heading-anchor" href="#Mixing-multiple-using-and-import-statements">Mixing multiple <code>using</code> and <code>import</code> statements</a><a id="Mixing-multiple-using-and-import-statements-1"></a><a class="docs-heading-anchor-permalink" href="#Mixing-multiple-using-and-import-statements" title="Permalink"></a></h3><p>When multiple <code>using</code> or <code>import</code> statements of any of the forms above are used, their effect is combined in the order they appear. For example,</p><pre><code class="language-julia">using NiceStuff         # exported names and the module name
import NiceStuff: nice  # allows adding methods to unqualified functions</code></pre><p>would bring all the exported names of <code>NiceStuff</code> and the module name itself into scope, and also allow adding methods to <code>nice</code> without prefixing it with a module name.</p><h3 id="Handling-name-conflicts"><a class="docs-heading-anchor" href="#Handling-name-conflicts">Handling name conflicts</a><a id="Handling-name-conflicts-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-name-conflicts" title="Permalink"></a></h3><p>Consider the situation where two (or more) packages export the same name, as in</p><pre><code class="language-julia">module A
export f
f() = 1
end

module B
export f
f() = 2
end</code></pre><p>The statement <code>using A, B</code> works, but when you try to call <code>f</code>, you get a warning</p><pre><code class="language-julia">WARNING: both B and A export &quot;f&quot;; uses of it in module Main must be qualified
ERROR: LoadError: UndefVarError: f not defined</code></pre><p>Here, Julia cannot decide which <code>f</code> you are referring to, so you have to make a choice. The following solutions are commonly used:</p><ol><li><p>Simply proceed with qualified names like <code>A.f</code> and <code>B.f</code>. This makes the context clear to the reader of your code, especially if <code>f</code> just happens to coincide but has different meaning in various packages. For example, <code>degree</code> has various uses in mathematics, the natural sciences, and in everyday life, and these meanings should be kept separate.</p></li><li><p>Use the <code>as</code> keyword above to rename one or both identifiers, eg</p><pre><code class="language-julia">using A: f as f
using B: f as g</code></pre><p>would make <code>B.f</code> available as <code>g</code>. Here, we are assuming that you did not use <code>using A</code> before, which would have brought <code>f</code> into the namespace.</p></li><li><p>When the names in question <em>do</em> share a meaning, it is common for one module to import it from another, or have a lightweight â€œbaseâ€ package with the sole function of defining an interface like this, which can be used by other packages. It is conventional to have such package names end in <code>...Base</code> (which has nothing to do with Julia&#39;s <code>Base</code> module).</p></li></ol><h3 id="é»˜è®¤é¡¶å±‚å®šä¹‰ä»¥åŠè£¸æ¨¡å—"><a class="docs-heading-anchor" href="#é»˜è®¤é¡¶å±‚å®šä¹‰ä»¥åŠè£¸æ¨¡å—">é»˜è®¤é¡¶å±‚å®šä¹‰ä»¥åŠè£¸æ¨¡å—</a><a id="é»˜è®¤é¡¶å±‚å®šä¹‰ä»¥åŠè£¸æ¨¡å—-1"></a><a class="docs-heading-anchor-permalink" href="#é»˜è®¤é¡¶å±‚å®šä¹‰ä»¥åŠè£¸æ¨¡å—" title="Permalink"></a></h3><p>Modules automatically contain <code>using Core</code>, <code>using Base</code>, and definitions of the <a href="../../base/base/#Base.MainInclude.eval"><code>eval</code></a> and <a href="../../base/base/#Base.MainInclude.include"><code>include</code></a> functions, which evaluate expressions/files within the global scope of that module.</p><p>If these default definitions are not wanted, modules can be defined using the keyword <a href="../../base/base/#baremodule"><code>baremodule</code></a> instead (note: <code>Core</code> is still imported). In terms of <code>baremodule</code>, a standard <code>module</code> looks like this:</p><pre><code class="language-none">baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
include(p) = Base.include(Mod, p)

...

end</code></pre><h3 id="æ ‡å‡†æ¨¡å—"><a class="docs-heading-anchor" href="#æ ‡å‡†æ¨¡å—">æ ‡å‡†æ¨¡å—</a><a id="æ ‡å‡†æ¨¡å—-1"></a><a class="docs-heading-anchor-permalink" href="#æ ‡å‡†æ¨¡å—" title="Permalink"></a></h3><p>æœ‰ä¸‰ä¸ªé‡è¦çš„æ ‡å‡†æ¨¡å—ï¼š</p><ul><li><a href="../../base/base/#Core"><code>Core</code></a> åŒ…å«äº†è¯­è¨€â€œå†…ç½®â€çš„æ‰€æœ‰åŠŸèƒ½ã€‚</li><li><a href="../../base/base/#Base"><code>Base</code></a> åŒ…å«äº†ç»å¤§å¤šæ•°æƒ…å†µä¸‹éƒ½ä¼šç”¨åˆ°çš„åŸºæœ¬åŠŸèƒ½ã€‚</li><li><a href="manual/@ref"><code>Main</code></a> æ˜¯é¡¶å±‚æ¨¡å—ï¼Œå½“ julia å¯åŠ¨æ—¶ï¼Œä¹Ÿæ˜¯å½“å‰æ¨¡å—ã€‚</li></ul><div class="admonition is-info"><header class="admonition-header">Standard library modules</header><div class="admonition-body"><p>By default Julia ships with some standard library modules. These behave like regular Julia packages except that you don&#39;t need to install them explicitly. For example, if you wanted to perform some unit testing, you could load the <code>Test</code> standard library as follows:</p><pre><code class="language-julia">using Test</code></pre></div></div><h2 id="Submodules-and-relative-paths"><a class="docs-heading-anchor" href="#Submodules-and-relative-paths">Submodules and relative paths</a><a id="Submodules-and-relative-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Submodules-and-relative-paths" title="Permalink"></a></h2><p>Modules can contain <em>submodules</em>, nesting the same syntax <code>module ... end</code>. They can be used to introduce separate namespaces, which can be helpful for organizing complex codebases. Note that each <code>module</code> introduces its own <a href="../variables-and-scoping/#scope-of-variables">scope</a>, so submodules do not automatically â€œinheritâ€ names from their parent.</p><p>It is recommended that submodules refer to other modules within the enclosing parent module (including the latter) using <em>relative module qualifiers</em> in <code>using</code> and <code>import</code> statements. A relative module qualifier starts with a period (<code>.</code>), which corresponds to the current module, and each successive <code>.</code> leads to the parent of the current module. This should be followed by modules if necessary, and eventually the actual name to access, all separated by <code>.</code>s.</p><p>Consider the following example, where the submodule <code>SubA</code> defines a function, which is then extended in its â€œsiblingâ€ module:</p><pre><code class="language-julia">module ParentModule

module SubA
export add_D  # exported interface
const D = 3
add_D(x) = x + D
end

using .SubA  # brings `add_D` into the namespace

export add_D # export it from ParentModule too

module SubB
import ..SubA: add_D # relative path for a â€œsiblingâ€ module
struct Infinity end
add_D(x::Infinity) = x
end

end</code></pre><p>You may see code in packages, which, in a similar situation, uses</p><pre><code class="language-julia">import ParentModule.SubA: add_D</code></pre><p>However, this operates through <a href="../code-loading/#code-loading">code loading</a>, and thus only works if <code>ParentModule</code> is in a package. It is better to use relative paths.</p><p>Note that the order of definitions also matters if you are evaluating values. Consider</p><pre><code class="language-julia">module TestPackage

export x, y

x = 0

module Sub
using ..TestPackage
z = y # ERROR: UndefVarError: y not defined
end

y = 1

end</code></pre><p>where <code>Sub</code> is trying to use <code>TestPackage.y</code> before it was defined, so it does not have a value.</p><p>For similar reasons, you cannot use a cyclic ordering:</p><pre><code class="language-julia">module A

module B
using ..C # ERROR: UndefVarError: C not defined
end

module C
using ..B
end

end</code></pre><h3 id="æ¨¡å—åˆå§‹åŒ–å’Œé¢„ç¼–è¯‘"><a class="docs-heading-anchor" href="#æ¨¡å—åˆå§‹åŒ–å’Œé¢„ç¼–è¯‘">æ¨¡å—åˆå§‹åŒ–å’Œé¢„ç¼–è¯‘</a><a id="æ¨¡å—åˆå§‹åŒ–å’Œé¢„ç¼–è¯‘-1"></a><a class="docs-heading-anchor-permalink" href="#æ¨¡å—åˆå§‹åŒ–å’Œé¢„ç¼–è¯‘" title="Permalink"></a></h3><p>å› ä¸ºæ‰§è¡Œæ¨¡å—ä¸­çš„æ‰€æœ‰è¯­å¥é€šå¸¸éœ€è¦ç¼–è¯‘å¤§é‡ä»£ç ï¼Œå¤§å‹æ¨¡å—å¯èƒ½éœ€è¦å‡ ç§’é’Ÿæ‰èƒ½åŠ è½½ã€‚Julia ä¼šåˆ›å»ºæ¨¡å—çš„é¢„ç¼–è¯‘ç¼“å­˜ä»¥å‡å°‘è¿™ä¸ªæ—¶é—´ã€‚</p><p>å½“ç”¨ <code>import</code> æˆ– <code>using</code> åŠ è½½ä¸€ä¸ªæ¨¡å—æ—¶ï¼Œæ¨¡å—å¢é‡é¢„ç¼–è¯‘æ–‡ä»¶ä¼šè‡ªåŠ¨åˆ›å»ºå¹¶ä½¿ç”¨ã€‚è¿™ä¼šè®©æ¨¡å—åœ¨ç¬¬ä¸€æ¬¡åŠ è½½æ—¶è‡ªåŠ¨ç¼–è¯‘ã€‚ å¦å¤–ï¼Œä½ ä¹Ÿå¯ä»¥æ‰‹å·¥è°ƒç”¨ <a href="../../base/base/#Base.compilecache"><code>Base.compilecache(modulename)</code></a>ï¼Œäº§ç”Ÿçš„ç¼“å­˜æ–‡ä»¶ä¼šæ”¾åœ¨ <code>DEPOT_PATH[1]/compiled/</code> ç›®å½•ä¸‹ã€‚ ä¹‹åï¼Œå½“è¯¥æ¨¡å—çš„ä»»ä½•ä¸€ä¸ªä¾èµ–å‘ç”Ÿå˜æ›´æ—¶ï¼Œè¯¥æ¨¡å—ä¼šåœ¨ <code>using</code> æˆ– <code>import</code> æ—¶è‡ªåŠ¨é‡æ–°ç¼–è¯‘ï¼› æ¨¡å—çš„ä¾èµ–æŒ‡çš„æ˜¯ï¼šä»»ä½•å®ƒå¯¼å…¥çš„æ¨¡å—ã€Julia è‡ªèº«ã€include çš„æ–‡ä»¶æˆ–ç”± <a href="../../base/base/#Base.include_dependency"><code>include_dependency(path)</code></a> æ˜¾å¼å£°æ˜çš„ä¾èµ–ã€‚</p><p>For file dependencies, a change is determined by examining whether the modification time (<code>mtime</code>) of each file loaded by <code>include</code> or added explicitly by <code>include_dependency</code> is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can&#39;t copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in <code>require</code> matches the path that had created the precompile file. It also takes into account the set of dependencies already loaded into the current process and won&#39;t recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache.</p><p>If you know that a module is <em>not</em> safe to precompile (for example, for one of the reasons described below), you should put <code>__precompile__(false)</code> in the module file (typically placed at the top). This will cause <code>Base.compilecache</code> to throw an error, and will cause <code>using</code> / <code>import</code> to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</p><p>åœ¨å¼€å‘æ¨¡å—çš„æ—¶å€™ï¼Œä½ å¯èƒ½éœ€è¦äº†è§£ä¸€äº›ä¸å¢é‡ç¼–è¯‘ç›¸å…³çš„å›ºæœ‰è¡Œä¸ºã€‚ä¾‹å¦‚ï¼Œå¤–éƒ¨çŠ¶æ€ä¸ä¼šè¢«ä¿ç•™ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦æ˜¾å¼åˆ†ç¦»è¿è¡Œæ—¶ä¸ç¼–è¯‘æœŸçš„éƒ¨åˆ†ã€‚Julia å…è®¸ä½ å®šä¹‰ä¸€ä¸ª <code>__init__()</code> å‡½æ•°æ¥æ‰§è¡Œä»»ä½•éœ€è¦åœ¨è¿è¡Œæ—¶å‘ç”Ÿçš„åˆå§‹åŒ–ã€‚åœ¨ç¼–è¯‘æœŸï¼ˆ<code>--output-*</code>ï¼‰ï¼Œæ­¤å‡½æ•°å°†ä¸ä¼šè¢«è°ƒç”¨ã€‚ä½ å¯ä»¥å‡è®¾åœ¨ä»£ç çš„ç”Ÿå­˜å‘¨æœŸä¸­ï¼Œæ­¤å‡½æ•°åªä¼šè¢«è¿è¡Œä¸€æ¬¡ã€‚å½“ç„¶ï¼Œå¦‚æœæœ‰å¿…è¦ï¼Œä½ ä¹Ÿå¯ä»¥æ‰‹åŠ¨è°ƒç”¨å®ƒï¼Œä½†åœ¨é»˜è®¤çš„æƒ…å†µä¸‹ï¼Œè¯·å‡å®šæ­¤å‡½æ•°æ˜¯ä¸ºäº†å¤„ç†ä¸æœ¬æœºçŠ¶æ€ç›¸å…³çš„ä¿¡æ¯ï¼Œæ³¨æ„è¿™äº›ä¿¡æ¯ä¸éœ€è¦ï¼Œæ›´ä¸åº”è¯¥å­˜å…¥é¢„ç¼–è¯‘é•œåƒã€‚æ­¤å‡½æ•°ä¼šåœ¨æ¨¡å—è¢«å¯¼å…¥åˆ°å½“å‰è¿›ç¨‹ä¹‹åè¢«è°ƒç”¨ï¼Œè¿™åŒ…æ‹¬åœ¨ä¸€ä¸ªå¢é‡ç¼–è¯‘ä¸­å¯¼å…¥è¯¥æ¨¡å—çš„æ—¶å€™ï¼ˆ<code>--output-incremental=yes</code>ï¼‰ï¼Œä½†åœ¨å®Œæ•´ç¼–è¯‘æ—¶è¯¥å‡½æ•°ä¸ä¼šè¢«è°ƒç”¨ã€‚</p><p>ç‰¹åˆ«çš„ï¼Œå¦‚æœä½ åœ¨æ¨¡å—é‡Œå®šä¹‰äº†ä¸€ä¸ªåä¸º <code>__init__()</code> çš„å‡½æ•°ï¼Œé‚£ä¹ˆ Julia åœ¨åŠ è½½è¿™ä¸ªæ¨¡å—ä¹‹åä¼šåœ¨ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶ï¼ˆruntimeï¼‰ç«‹åˆ»è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡ <code>import</code>ï¼Œ<code>using</code>ï¼Œæˆ–è€… <code>require</code> åŠ è½½æ—¶ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´ <code>__init__</code> åªä¼šåœ¨æ¨¡å—ä¸­æ‰€æœ‰å…¶å®ƒå‘½ä»¤éƒ½æ‰§è¡Œå®Œä»¥åè¢«è°ƒç”¨ä¸€æ¬¡ã€‚å› ä¸ºè¿™ä¸ªå‡½æ•°å°†åœ¨æ¨¡å—å®Œå…¨è½½å…¥åè¢«è°ƒç”¨ï¼Œä»»ä½•å­æ¨¡å—æˆ–è€…å·²ç»è½½å…¥çš„æ¨¡å—éƒ½å°†åœ¨å½“å‰æ¨¡å—è°ƒç”¨ <code>__init__</code> <strong>ä¹‹å‰</strong> è°ƒç”¨è‡ªå·±çš„ <code>__init__</code> å‡½æ•°ã€‚</p><p><code>__init__</code>çš„å…¸å‹ç”¨æ³•æœ‰äºŒï¼Œä¸€æ˜¯ç”¨äºè°ƒç”¨å¤–éƒ¨ C åº“çš„è¿è¡Œæ—¶åˆå§‹åŒ–å‡½æ•°ï¼ŒäºŒæ˜¯ç”¨äºåˆå§‹åŒ–æ¶‰åŠåˆ°å¤–éƒ¨åº“æ‰€è¿”å›çš„æŒ‡é’ˆçš„å…¨å±€å¸¸é‡ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æ­£åœ¨è°ƒç”¨ä¸€ä¸ª C åº“ <code>libfoo</code>ï¼Œå®ƒè¦æ±‚æˆ‘ä»¬åœ¨è¿è¡Œæ—¶è°ƒç”¨<code>foo_init()</code> è¿™ä¸ªåˆå§‹åŒ–å‡½æ•°ã€‚å‡è®¾æˆ‘ä»¬è¿˜æƒ³å®šä¹‰ä¸€ä¸ªå…¨å±€å¸¸é‡ <code>foo_data_ptr</code>ï¼Œå®ƒä¿å­˜ <code>libfoo</code> æ‰€å®šä¹‰çš„ <code>void *foo_data()</code> å‡½æ•°çš„è¿”å›å€¼â€”â€”å¿…é¡»åœ¨è¿è¡Œæ—¶ï¼ˆè€Œéç¼–è¯‘æ—¶ï¼‰åˆå§‹åŒ–è¿™ä¸ªå¸¸é‡ï¼Œå› ä¸ºæŒ‡é’ˆåœ°å€ä¸æ˜¯å›ºå®šçš„ã€‚å¯ä»¥é€šè¿‡åœ¨æ¨¡å—ä¸­å®šä¹‰ <code>__init__</code> å‡½æ•°æ¥å®Œæˆè¿™ä¸ªæ“ä½œã€‚</p><pre><code class="language-julia">const foo_data_ptr = Ref{Ptr{Cvoid}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Cvoid, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())
    nothing
end</code></pre><p>æ³¨æ„ï¼Œåœ¨åƒ <code>__init__</code> è¿™æ ·çš„å‡½æ•°é‡Œå®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡æ˜¯å®Œå…¨å¯ä»¥çš„ï¼Œè¿™æ˜¯åŠ¨æ€è¯­è¨€çš„ä¼˜ç‚¹ä¹‹ä¸€ã€‚ä½†æ˜¯æŠŠå…¨å±€ä½œç”¨åŸŸçš„å€¼å®šä¹‰æˆå¸¸é‡ï¼Œå¯ä»¥è®©ç¼–è¯‘å™¨èƒ½ç¡®å®šè¯¥å€¼çš„ç±»å‹ï¼Œå¹¶ä¸”èƒ½è®©ç¼–è¯‘å™¨ç”Ÿæˆæ›´å¥½çš„ä¼˜åŒ–è¿‡çš„ä»£ç ã€‚æ˜¾ç„¶ï¼Œä½ çš„æ¨¡å—ï¼ˆModuleï¼‰ä¸­ï¼Œä»»ä½•å…¶ä»–ä¾èµ–äº <code>foo_data_ptr</code> çš„å…¨å±€é‡ä¹Ÿå¿…é¡»åœ¨ <code>__init__</code> ä¸­è¢«åˆå§‹åŒ–ã€‚</p><p>Constants involving most Julia objects that are not produced by <a href="../../base/c/#ccall"><code>ccall</code></a> do not need to be placed in <code>__init__</code>: their definitions can be precompiled and loaded from the cached module image. This includes complicated heap-allocated objects like arrays. However, any routine that returns a raw pointer value must be called at runtime for precompilation to work (<a href="../../base/c/#Core.Ptr"><code>Ptr</code></a> objects will turn into null pointers unless they are hidden inside an <a href="../../base/base/#Base.isbits"><code>isbits</code></a> object). This includes the return values of the Julia functions <a href="../../base/c/#Base.@cfunction"><code>@cfunction</code></a> and <a href="../../base/c/#Base.pointer"><code>pointer</code></a>.</p><p>å­—å…¸å’Œé›†åˆç±»å‹ï¼Œæˆ–è€…é€šå¸¸ä»»ä½•ä¾èµ–äº <code>hash(key)</code> æ–¹æ³•çš„ç±»å‹ï¼Œéƒ½æ˜¯æ¯”è¾ƒæ£˜æ‰‹çš„æƒ…å†µã€‚ é€šå¸¸å½“é”®æ˜¯æ•°å­—ã€å­—ç¬¦ä¸²ã€ç¬¦å·ã€èŒƒå›´ã€<code>Expr</code> æˆ–è¿™äº›ç±»å‹çš„ç»„åˆï¼ˆé€šè¿‡æ•°ç»„ã€å…ƒç»„ã€é›†åˆã€æ˜ å°„å¯¹ç­‰ï¼‰æ—¶ï¼Œå¯ä»¥å®‰å…¨åœ°é¢„ç¼–è¯‘å®ƒä»¬ã€‚ä½†æ˜¯ï¼Œå¯¹äºä¸€äº›å…¶å®ƒçš„é”®ç±»å‹ï¼Œä¾‹å¦‚ <code>Function</code> æˆ– <code>DataType</code>ã€ä»¥åŠè¿˜æ²¡æœ‰å®šä¹‰æ•£åˆ—æ–¹æ³•çš„é€šç”¨ç”¨æˆ·å®šä¹‰ç±»å‹ï¼Œå›é€€ï¼ˆfallbackï¼‰çš„æ•£åˆ—ï¼ˆ<code>hash</code>ï¼‰æ–¹æ³•ä¾èµ–äºå¯¹è±¡çš„å†…å­˜åœ°å€ï¼ˆé€šè¿‡ <code>objectid</code>ï¼‰ï¼Œå› æ­¤å¯èƒ½ä¼šåœ¨æ¯æ¬¡è¿è¡Œæ—¶å‘ç”Ÿå˜åŒ–ã€‚ å¦‚æœæ‚¨æœ‰è¿™äº›å…³é”®ç±»å‹ä¸­çš„ä¸€ç§ï¼Œæˆ–è€…æ‚¨ä¸ç¡®å®šï¼Œä¸ºäº†å®‰å…¨èµ·è§ï¼Œæ‚¨å¯ä»¥åœ¨æ‚¨çš„ <code>__init__</code> å‡½æ•°ä¸­åˆå§‹åŒ–è¿™ä¸ªå­—å…¸ã€‚æˆ–è€…ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ <a href="../../base/collections/#Base.IdDict"><code>IdDict</code></a> å­—å…¸ç±»å‹ï¼Œå®ƒæ˜¯ç”±é¢„ç¼–è¯‘ä¸“é—¨å¤„ç†çš„ï¼Œå› æ­¤åœ¨ç¼–è¯‘æ—¶åˆå§‹åŒ–æ˜¯å®‰å…¨çš„ã€‚</p><p>å½“ä½¿ç”¨é¢„ç¼–è¯‘æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»è¦æ¸…æ¥šåœ°åŒºåˆ†ä»£ç çš„ç¼–è¯‘é˜¶æ®µå’Œè¿è¡Œé˜¶æ®µã€‚åœ¨æ­¤æ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬ä¼šæ›´æ¸…æ¥šå‘ç° Julia çš„ç¼–è¯‘å™¨å¯ä»¥æ‰§è¡Œä»»ä½• Julia ä»£ç ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç”¨äºç”Ÿæˆç¼–è¯‘åä»£ç çš„ç‹¬ç«‹çš„è§£é‡Šå™¨ã€‚</p><p>å…¶å®ƒå·²çŸ¥çš„æ½œåœ¨å¤±è´¥åœºæ™¯åŒ…æ‹¬ï¼š</p><ol><li><p>å…¨å±€è®¡æ•°å™¨ï¼Œä¾‹å¦‚ï¼šä¸ºäº†è¯•å›¾å”¯ä¸€çš„æ ‡è¯†å¯¹è±¡ã€‚è€ƒè™‘ä»¥ä¸‹ä»£ç ç‰‡æ®µï¼š</p><pre><code class="language-julia">mutable struct UniquedById
    myid::Int
    let counter = 0
        UniquedById() = new(counter += 1)
    end
end</code></pre><p>å°½ç®¡è¿™æ®µä»£ç çš„ç›®æ ‡æ˜¯ç»™æ¯ä¸ªå®ä¾‹èµ‹ä¸€ä¸ªå”¯ä¸€çš„ IDï¼Œä½†è®¡æ•°å™¨çš„å€¼ä¼šåœ¨ä»£ç ç¼–è¯‘ç»“æŸæ—¶è¢«è®°å½•ã€‚ä»»ä½•å¯¹æ­¤å¢é‡ç¼–è¯‘æ¨¡å—çš„åç»­ä½¿ç”¨ï¼Œè®¡æ•°å™¨éƒ½å°†ä»åŒä¸€ä¸ªå€¼å¼€å§‹è®¡æ•°ã€‚</p><p>æ³¨æ„ <code>objectid</code> ï¼ˆå·¥ä½œåŸç†æ˜¯å–å†…å­˜æŒ‡é’ˆçš„ hashï¼‰ä¹Ÿæœ‰ç±»ä¼¼çš„é—®é¢˜ï¼Œè¯·æŸ¥é˜…ä¸‹é¢å…³äº <code>Dict</code> çš„ç”¨æ³•ã€‚</p><p>ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯ç”¨å®æ•æ‰ <a href="../../base/base/#Base.@__MODULE__"><code>@__MODULE__</code></a>ï¼Œå¹¶å°†å®ƒä¸ç›®å‰çš„ <code>counter</code> å€¼ä¸€èµ·ä¿å­˜ã€‚ç„¶è€Œï¼Œæ›´å¥½çš„æ–¹æ¡ˆæ˜¯å¯¹ä»£ç è¿›è¡Œé‡æ–°è®¾è®¡ï¼Œä¸è¦ä¾èµ–è¿™ç§å…¨å±€çŠ¶æ€å˜é‡ã€‚</p></li><li><p>åƒ <code>Dict</code> å’Œ <code>Set</code> è¿™ç§å…³è”é›†åˆéœ€è¦åœ¨ <code>__init__</code> ä¸­ re-hashã€‚Julia åœ¨æœªæ¥å¾ˆå¯èƒ½ä¼šæä¾›ä¸€ä¸ªæœºåˆ¶æ¥æ³¨å†Œåˆå§‹åŒ–å‡½æ•°ã€‚</p></li><li><p>ä¾èµ–ç¼–è¯‘æœŸçš„å‰¯ä½œç”¨ä¼šåœ¨åŠ è½½æ—¶è”“å»¶ã€‚ä¾‹å­åŒ…æ‹¬ï¼šæ›´æ”¹å…¶å®ƒ Julia æ¨¡å—é‡Œçš„æ•°ç»„æˆ–å˜é‡ï¼Œæ“ä½œæ–‡ä»¶æˆ–è®¾å¤‡çš„å¥æŸ„ï¼Œä¿å­˜æŒ‡å‘å…¶å®ƒç³»ç»Ÿèµ„æºï¼ˆåŒ…æ‹¬å†…å­˜ï¼‰çš„æŒ‡é’ˆã€‚</p></li><li><p>æ— æ„ä¸­ä»å…¶å®ƒæ¨¡å—ä¸­â€œæ‹·è´â€äº†å…¨å±€çŠ¶æ€ï¼šé€šè¿‡ç›´æ¥å¼•ç”¨çš„æ–¹å¼è€Œä¸æ˜¯é€šè¿‡æŸ¥æ‰¾çš„æ–¹å¼ã€‚ä¾‹å¦‚ï¼Œåœ¨å…¨å±€ä½œç”¨åŸŸä¸‹ï¼š</p><pre><code class="language-julia">#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#
# instead use accessor functions:
getstdout() = Base.stdout #= best option =#
# or move the assignment into the runtime:
__init__() = global mystdout = Base.stdout #= also works =#</code></pre></li></ol><p>æ­¤å¤„ä¸ºé¢„ç¼–è¯‘ä¸­çš„æ“ä½œé™„åŠ äº†è‹¥å¹²é™åˆ¶ï¼Œä»¥å¸®åŠ©ç”¨æˆ·é¿å…å…¶ä»–è¯¯æ“ä½œï¼š</p><ol><li>è°ƒç”¨ <a href="../../base/base/#Base.MainInclude.eval"><code>eval</code></a> æ¥åœ¨å¦ä¸€ä¸ªæ¨¡å—ä¸­å¼•å‘å‰¯ä½œç”¨ã€‚å½“å¢é‡é¢„ç¼–è¯‘è¢«æ ‡è®°æ—¶ï¼Œè¯¥æ“ä½œåŒæ—¶ä¼šå¯¼è‡´æŠ›å‡ºä¸€ä¸ªè­¦å‘Šã€‚</li><li>å½“ <code>__init__()</code> å·²ç»å¼€å§‹æ‰§è¡Œåï¼Œåœ¨å±€éƒ¨ä½œç”¨åŸŸä¸­å£°æ˜ <code>global const</code>ï¼ˆè§ issue #12010ï¼Œè®¡åˆ’ä¸ºæ­¤æƒ…å†µæ·»åŠ ä¸€ä¸ªé”™è¯¯æç¤ºï¼‰</li><li>åœ¨å¢é‡é¢„ç¼–è¯‘æ—¶æ›¿æ¢æ¨¡å—æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚</li></ol><p>ä¸€äº›å…¶ä»–éœ€è¦æ³¨æ„çš„ç‚¹ï¼š</p><ol><li>åœ¨æºä»£ç æ–‡ä»¶æœ¬èº«è¢«ä¿®æ”¹ä¹‹åï¼Œä¸ä¼šæ‰§è¡Œä»£ç é‡è½½æˆ–ç¼“å­˜å¤±æ•ˆåŒ–å¤„ç†ï¼ˆåŒ…æ‹¬ç”± <code>Pkg.update</code> æ‰§è¡Œçš„ä¿®æ”¹ï¼Œæ­¤å¤–åœ¨ <code>Pkg.rm</code> æ‰§è¡Œåä¹Ÿæ²¡æœ‰æ¸…ç†æ“ä½œï¼‰</li><li>å˜å½¢æ•°ç»„çš„å†…å­˜å…±äº«ç‰¹æ€§ä¼šè¢«é¢„ç¼–è¯‘å¿½ç•¥ï¼ˆæ¯ä¸ªæ•°ç»„æ ·è²Œéƒ½ä¼šè·å¾—ä¸€ä¸ªæ‹·è´ï¼‰</li><li>æ–‡ä»¶ç³»ç»Ÿåœ¨ç¼–è¯‘æœŸé—´å’Œè¿è¡ŒæœŸé—´è¢«å‡è®¾ä¸ºä¸å˜çš„ï¼Œæ¯”å¦‚ä½¿ç”¨ <a href="../../base/base/#Base.@__FILE__"><code>@__FILE__</code></a>/<code>source_path()</code> åœ¨è¿è¡ŒæœŸé—´å¯»æ‰¾èµ„æºã€æˆ–ä½¿ç”¨ BinDeps å® <code>@checked_lib</code>ã€‚æœ‰æ—¶è¿™æ˜¯ä¸å¯é¿å…çš„ã€‚ä½†æ˜¯å¯èƒ½çš„è¯ï¼Œåœ¨ç¼–è¯‘æœŸå°†èµ„æºå¤åˆ¶åˆ°æ¨¡å—é‡Œé¢æ˜¯ä¸ªå¥½åšæ³•ï¼Œè¿™æ ·åœ¨è¿è¡ŒæœŸé—´ï¼Œå°±ä¸éœ€è¦å»å¯»æ‰¾å®ƒä»¬äº†ã€‚</li><li><code>WeakRef</code> å¯¹è±¡å’Œå®Œæˆå™¨ç›®å‰åœ¨åºåˆ—åŒ–å™¨ä¸­æ— æ³•è¢«æ°å½“åœ°å¤„ç†ï¼ˆåœ¨æ¥ä¸‹æ¥çš„å‘è¡Œç‰ˆä¸­å°†ä¿®å¤ï¼‰ã€‚</li><li>é€šå¸¸ï¼Œæœ€å¥½é¿å…å»æ•æ‰å†…éƒ¨å…ƒæ•°æ®å¯¹è±¡çš„å¼•ç”¨ï¼Œå¦‚ <code>Method</code>ã€<code>MethodInstance</code>ã€<code>TypeMapLevel</code>ã€<code>TypeMapEntry</code> åŠè¿™äº›å¯¹è±¡çš„å­—æ®µï¼Œå› ä¸ºè¿™ä¼šè¿·æƒ‘åºåˆ—åŒ–å™¨ï¼Œä¸”å¯èƒ½ä¼šå¼•å‘ä½ ä¸æƒ³è¦çš„ç»“æœã€‚æ­¤æ“ä½œä¸è¶³ä»¥æˆä¸ºä¸€ä¸ªé”™è¯¯ï¼Œä½†ä½ éœ€åšå¥½å‡†å¤‡ï¼šç³»ç»Ÿä¼šå°è¯•æ‹·è´ä¸€éƒ¨åˆ†ï¼Œç„¶ååˆ›å»ºå…¶ä½™éƒ¨åˆ†çš„å•ä¸ªç‹¬ç«‹å®ä¾‹ã€‚</li></ol><p>åœ¨å¼€å‘æ¨¡å—æ—¶ï¼Œå…³é—­å¢é‡é¢„ç¼–è¯‘å¯èƒ½ä¼šæœ‰æ‰€å¸®åŠ©ã€‚å‘½ä»¤è¡Œæ ‡è®° <code>--compiled-modules={yes|no}</code> å¯ä»¥è®©ä½ åˆ‡æ¢é¢„ç¼–è¯‘çš„å¼€å¯å’Œå…³é—­ã€‚å½“ Julia é™„åŠ  <code>--compiled-modules=no</code> å¯åŠ¨ï¼Œåœ¨è½½å…¥æ¨¡å—å’Œæ¨¡å—ä¾èµ–æ—¶ï¼Œç¼–è¯‘ç¼“å­˜ä¸­çš„åºåˆ—åŒ–æ¨¡å—ä¼šè¢«å¿½ç•¥ã€‚<code>Base.compilecache</code> ä»å¯ä»¥è¢«æ‰‹åŠ¨è°ƒç”¨ã€‚æ­¤å‘½ä»¤è¡Œæ ‡è®°çš„çŠ¶æ€ä¼šè¢«ä¼ é€’ç»™ <code>Pkg.build</code>ï¼Œç¦æ­¢å…¶åœ¨å®‰è£…ã€æ›´æ–°ã€æ˜¾å¼æ„å»ºåŒ…æ—¶è§¦å‘è‡ªåŠ¨é¢„ç¼–è¯‘ã€‚</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interfaces/">Â« æ¥å£</a><a class="docs-footer-nextpage" href="../documentation/">æ–‡æ¡£ Â»</a><div class="flexbox-break"></div><p class="footer-message">ğŸ“¢ğŸ“¢ğŸ“¢Juliaä¸­æ–‡ç¤¾åŒºç°å·²åŠ å…¥â€œå¼€æºè½¯ä»¶ä¾›åº”é“¾ç‚¹äº®è®¡åˆ’â€ï¼Œå¦‚æœä½ æƒ³æ”¹å–„Juliaä¸­æ–‡æ–‡æ¡£çš„ç¿»è¯‘ï¼Œé‚£å°±èµ¶å¿«æ¥ <a href="https://summer.iscas.ac.cn/#/org/prodetail/210370191">æŠ¥å</a> å§ï¼</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">è®¾ç½®</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">é€‰æ‹©ä¸»é¢˜</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>æœ¬æ–‡æ¡£åœ¨<span class="colophon-date" title="2021 å…«æœˆ 13 å‘¨äº” 15:24">2021 å…«æœˆ 13 å‘¨äº”</span>ç”±<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>ä½¿ç”¨1.6.2ç‰ˆæœ¬çš„Juliaç”Ÿæˆã€‚</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
