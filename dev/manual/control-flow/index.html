<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>流程控制 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/control-flow/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">变量</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li class="is-active"><a class="tocitem" href>流程控制</a><ul class="internal"><li><a class="tocitem" href="#man-compound-expressions"><span>复合表达式</span></a></li><li><a class="tocitem" href="#man-conditional-evaluation"><span>条件表达式</span></a></li><li><a class="tocitem" href="#短路求值"><span>短路求值</span></a></li><li><a class="tocitem" href="#man-loops"><span>重复执行：循环</span></a></li><li><a class="tocitem" href="#异常处理"><span>异常处理</span></a></li><li><a class="tocitem" href="#man-tasks"><span> Tasks 任务（或协程）</span></a></li></ul></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../multi-threading/">多线程</a></li><li><a class="tocitem" href="../distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../command-line-options/">命令行选项</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>流程控制</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>流程控制</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/control-flowmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="流程控制"><a class="docs-heading-anchor" href="#流程控制">流程控制</a><a id="流程控制-1"></a><a class="docs-heading-anchor-permalink" href="#流程控制" title="Permalink"></a></h1><p>Julia 提供了大量的流程控制构件：</p><ul><li><a href="#man-compound-expressions">复合表达式</a>：<code>begin</code> 和 <code>;</code>。</li><li><a href="#man-conditional-evaluation">条件表达式</a>：<code>if</code>-<code>elseif</code>-<code>else</code> 和 <code>?:</code> (三元运算符)。</li><li><a href="#短路求值">短路求值</a>：逻辑运算符 <code>&amp;&amp;</code>（与）和 <code>||</code>（或），以及链式比较。</li><li><a href="#man-loops">重复执行：循环</a>：<code>while</code> 和 <code>for</code>。</li><li><a href="#异常处理">异常处理</a>：<code>try</code>-<code>catch</code>、<a href="../../base/base/#Base.error"><code>error</code></a> 和 <a href="../../base/base/#Core.throw"><code>throw</code></a>。</li><li><a href="#man-tasks"><code>Task</code>（协程）</a>：<a href="../../base/parallel/#Base.yieldto"><code>yieldto</code></a>。</li></ul><p>前五个流程控制机制是高级编程语言的标准。<a href="../../base/parallel/#Core.Task"><code>Task</code></a> 不是那么的标准：它提供了非局部的流程控制，这使得在暂时挂起的计算任务之间进行切换成为可能。这是一个功能强大的构件：Julia 中的异常处理和协同多任务都是通过 <code>Task</code> 实现的。虽然日常编程并不需要直接使用 <code>Task</code>，但某些问题用 <code>Task</code> 处理会更加简单。</p><h2 id="man-compound-expressions"><a class="docs-heading-anchor" href="#man-compound-expressions">复合表达式</a><a id="man-compound-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#man-compound-expressions" title="Permalink"></a></h2><p>有时一个表达式能够有序地计算若干子表达式，并返回最后一个子表达式的值作为它的值是很方便的。Julia 有两个组件来完成这个： <code>begin</code> 代码块 和 <code>;</code> 链。这两个复合表达式组件的值都是最后一个子表达式的值。下面是一个 <code>begin</code> 代码块的例子：</p><pre><code class="language-julia-repl">julia&gt; z = begin
           x = 1
           y = 2
           x + y
       end
3</code></pre><p>因为这些是非常简短的表达式，它们可以简单地被放到一行里，这也是 <code>;</code> 链的由来：</p><pre><code class="language-julia-repl">julia&gt; z = (x = 1; y = 2; x + y)
3</code></pre><p>这个语法在定义简洁的单行函数的时候特别有用，参见<a href="manual/@id man-functions">函数</a>。尽管很典型，但是并不要求 <code>begin</code> 代码块是多行的，或者 <code>;</code> 链是单行的：</p><pre><code class="language-julia-repl">julia&gt; begin x = 1; y = 2; x + y end
3

julia&gt; (x = 1;
        y = 2;
        x + y)
3</code></pre><h2 id="man-conditional-evaluation"><a class="docs-heading-anchor" href="#man-conditional-evaluation">条件表达式</a><a id="man-conditional-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#man-conditional-evaluation" title="Permalink"></a></h2><p>条件表达式（Conditional evaluation）可以根据布尔表达式的值，让部分代码被执行或者不被执行。下面是对 <code>if</code>-<code>elseif</code>-<code>else</code> 条件语法的分析：</p><pre><code class="language-julia">if x &lt; y
    println(&quot;x is less than y&quot;)
elseif x &gt; y
    println(&quot;x is greater than y&quot;)
else
    println(&quot;x is equal to y&quot;)
end</code></pre><p>如果表达式 <code>x &lt; y</code> 是 <code>true</code>，那么对应的代码块会被执行；否则判断条件表达式 <code>x &gt; y</code>，如果它是 <code>true</code>，则执行对应的代码块；如果没有表达式是 true，则执行 <code>else</code> 代码块。下面是一个例子：</p><pre><code class="language-julia-repl">julia&gt; function test(x, y)
           if x &lt; y
               println(&quot;x is less than y&quot;)
           elseif x &gt; y
               println(&quot;x is greater than y&quot;)
           else
               println(&quot;x is equal to y&quot;)
           end
       end
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y</code></pre><p><code>elseif</code> 和 <code>else</code> 代码块是可选的，并且可以使用任意多个 <code>elseif</code> 代码块。 <code>if</code>-<code>elseif</code>-<code>else</code> 组件中的第一个条件表达式为 <code>true</code> 时，其他条件表达式才会被执行，当对应的代码块被执行后，其余的表达式或者代码块将不会被执行。</p><p><code>if</code> 代码块是&quot;有渗漏的&quot;，也就是说它们不会引入局部作用域。这意味着在 <code>if</code> 语句中新定义的变量依然可以在 <code>if</code> 代码块之后使用，尽管这些变量没有在 <code>if</code> 语句之前定义过。所以，我们可以将上面的 <code>test</code> 函数定义为</p><pre><code class="language-julia-repl">julia&gt; function test(x,y)
           if x &lt; y
               relation = &quot;less than&quot;
           elseif x == y
               relation = &quot;equal to&quot;
           else
               relation = &quot;greater than&quot;
           end
           println(&quot;x is &quot;, relation, &quot; y.&quot;)
       end
test (generic function with 1 method)

julia&gt; test(2, 1)
x is greater than y.</code></pre><p>变量 <code>relation</code> 是在 <code>if</code> 代码块内部声明的，但可以在外部使用。然而，在利用这种行为的时候，要保证变量在所有的分支下都进行了定义。对上述函数做如下修改会导致运行时错误</p><pre><code class="language-julia-repl">julia&gt; function test(x,y)
           if x &lt; y
               relation = &quot;less than&quot;
           elseif x == y
               relation = &quot;equal to&quot;
           end
           println(&quot;x is &quot;, relation, &quot; y.&quot;)
       end
test (generic function with 1 method)

julia&gt; test(1,2)
x is less than y.

julia&gt; test(2,1)
ERROR: UndefVarError: relation not defined
Stacktrace:
 [1] test(::Int64, ::Int64) at ./none:7</code></pre><p><code>if</code> 代码块也会返回一个值，这可能对于一些从其他语言转过来的用户来说不是很直观。 这个返回值就是被执行的分支中最后一个被执行的语句的返回值。 所以</p><pre><code class="language-julia-repl">julia&gt; x = 3
3

julia&gt; if x &gt; 0
           &quot;positive!&quot;
       else
           &quot;negative...&quot;
       end
&quot;positive!&quot;</code></pre><p>需要注意的是，在 Julia 中，经常会用短路求值来表示非常短的条件表达式（单行），这会在下一节中介绍。</p><p>与 C, MATLAB, Perl, Python，以及 Ruby 不同，但跟 Java，还有一些别的严谨的类型语言类似：一个条件表达式的值如果不是 <code>true</code> 或者 <code>false</code> 的话，会返回错误：</p><pre><code class="language-julia-repl">julia&gt; if 1
           println(&quot;true&quot;)
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context</code></pre><p>这个错误是说，条件判断结果的类型：<a href="../../base/numbers/#Core.Int64"><code>Int64</code></a> 是错的，而不是期望的 <a href="../../base/numbers/#Core.Bool"><code>Bool</code></a>。</p><p>所谓的 &quot;三元运算符&quot;, <code>?:</code>，很类似 <code>if</code>-<code>elseif</code>-<code>else</code> 语法，它用于选择性获取单个表达式的值，而不是选择性执行大段的代码块。它因在很多语言中是唯一一个有三个操作数的运算符而得名：</p><pre><code class="language-julia">a ? b : c</code></pre><p>在 <code>?</code> 之前的表达式 <code>a</code>, 是一个条件表达式，如果条件 <code>a</code> 是 <code>true</code>，三元运算符计算在 <code>:</code> 之前的表达式 <code>b</code>；如果条件 <code>a</code> 是 <code>false</code>，则执行 <code>:</code> 后面的表达式 <code>c</code>。注意，<code>?</code> 和 <code>:</code> 旁边的空格是强制的，像 <code>a?b:c</code> 这种表达式不是一个有效的三元表达式（但在<code>?</code> 和 <code>:</code> 之后的换行是允许的）。</p><p>理解这种行为的最简单方式是看一个实际的例子。在前一个例子中，虽然在三个分支中都有调用 <code>println</code>，但实质上是选择打印哪一个字符串。在这种情况下，我们可以用三元运算符更紧凑地改写。为了简明，我们先尝试只有两个分支的版本：</p><pre><code class="language-julia-repl">julia&gt; x = 1; y = 2;

julia&gt; println(x &lt; y ? &quot;less than&quot; : &quot;not less than&quot;)
less than

julia&gt; x = 1; y = 0;

julia&gt; println(x &lt; y ? &quot;less than&quot; : &quot;not less than&quot;)
not less than</code></pre><p>如果表达式 <code>x &lt; y</code> 为真，整个三元运算符会执行字符串 <code>&quot;less than&quot;</code>，否则执行字符串 <code>&quot;not less than&quot;</code>。原本的三个分支的例子需要链式嵌套使用三元运算符：</p><pre><code class="language-julia-repl">julia&gt; test(x, y) = println(x &lt; y ? &quot;x is less than y&quot;    :
                            x &gt; y ? &quot;x is greater than y&quot; : &quot;x is equal to y&quot;)
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y</code></pre><p>为了方便链式传值，运算符从右到左连接到一起。</p><p>重要地是，与 <code>if</code>-<code>elseif</code>-<code>else</code> 类似，<code>:</code> 之前和之后的表达式只有在条件表达式为 <code>true</code> 或者 <code>false</code> 时才会被相应地执行：</p><pre><code class="language-julia-repl">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; 1 &lt; 2 ? v(&quot;yes&quot;) : v(&quot;no&quot;)
yes
&quot;yes&quot;

julia&gt; 1 &gt; 2 ? v(&quot;yes&quot;) : v(&quot;no&quot;)
no
&quot;no&quot;</code></pre><h2 id="短路求值"><a class="docs-heading-anchor" href="#短路求值">短路求值</a><a id="短路求值-1"></a><a class="docs-heading-anchor-permalink" href="#短路求值" title="Permalink"></a></h2><p>Julia 中的 <code>&amp;&amp;</code> 和 <code>||</code> 运算符分别对应于逻辑“与”和“或”操作，并通常都这样使用。 但是，它们具有 <em>逻辑短路</em> 的特殊性质：不一定评估其第二个参数，下面会详细介绍。 （也有按位 <code>&amp;</code> 和 <code>|</code> 运算符可用作逻辑“与”和“或”的<em>无</em>短路行为，但要注意 <code>&amp;</code> 和 <code>|</code> 的评估时的优先级高于 <code>&amp;&amp;</code> 和 <code>||</code> 。）</p><p>短路求值与条件求值非常相似。 这种行为在大多数具有 <code>&amp;&amp;</code> 和 <code>||</code> 布尔运算符的命令式编程语言中都可以找到：在一系列由这些运算符连接的布尔表达式中，为了得到整个链的最终布尔值，仅仅只有最小数量的表达式被计算。 一些语言（如 Python）将它们称为<code>and</code>（<code>&amp;&amp;</code>）和<code>or</code>（<code>||</code>）。 更准确地说，这意味着：</p><ul><li>在表达式 <code>a &amp;&amp; b</code> 中，子表达式 <code>b</code> 仅当 <code>a</code> 为 <code>true</code> 的时候才会被执行。</li><li>在表达式 <code>a || b</code> 中，子表达式 <code>b</code> 仅在 <code>a</code> 为 <code>false</code> 的时候才会被执行。</li></ul><p>这里的原因是：如果 <code>a</code> 是 <code>false</code>，那么无论 <code>b</code> 的值是多少，<code>a &amp;&amp; b</code> 一定是 <code>false</code>。同理，如果 <code>a</code> 是 <code>true</code>，那么无论 <code>b</code> 的值是多少，<code>a || b</code> 的值一定是 true。<code>&amp;&amp;</code> 和 <code>||</code> 都依赖于右边，但是 <code>&amp;&amp;</code> 比 <code>||</code> 有更高的优先级。我们可以简单地测试一下这个行为：</p><pre><code class="language-julia-repl">julia&gt; t(x) = (println(x); true)
t (generic function with 1 method)

julia&gt; f(x) = (println(x); false)
f (generic function with 1 method)

julia&gt; t(1) &amp;&amp; t(2)
1
2
true

julia&gt; t(1) &amp;&amp; f(2)
1
2
false

julia&gt; f(1) &amp;&amp; t(2)
1
false

julia&gt; f(1) &amp;&amp; f(2)
1
false

julia&gt; t(1) || t(2)
1
true

julia&gt; t(1) || f(2)
1
true

julia&gt; f(1) || t(2)
1
2
true

julia&gt; f(1) || f(2)
1
2
false</code></pre><p>你可以用同样的方式测试不同 <code>&amp;&amp;</code> 和 <code>||</code> 运算符的组合条件下的关联和优先级。</p><p>这种行为在 Julia 中经常被用来作为简短 <code>if</code> 语句的替代。 可以用 <code>&lt;cond&gt; &amp;&amp; &lt;statement&gt;</code> (可读为: &lt;cond&gt; <em>and then</em> &lt;statement&gt;)来替换 <code>if &lt;cond&gt; &lt;statement&gt; end</code>。 类似的， 可以用 <code>&lt;cond&gt; || &lt;statement&gt;</code> (可读为: &lt;cond&gt; <em>or else</em> &lt;statement&gt;)来替换 <code>if ! &lt;cond&gt; &lt;statement&gt; end</code>.</p><p>例如，可以像这样定义递归阶乘：</p><pre><code class="language-julia-repl">julia&gt; function fact(n::Int)
           n &gt;= 0 || error(&quot;n must be non-negative&quot;)
           n == 0 &amp;&amp; return 1
           n * fact(n-1)
       end
fact (generic function with 1 method)

julia&gt; fact(5)
120

julia&gt; fact(0)
1

julia&gt; fact(-1)
ERROR: n must be non-negative
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fact(::Int64) at ./none:2
 [3] top-level scope</code></pre><p><strong>无</strong>短路求值的布尔运算可以用位布尔运算符来完成，见<a href="../mathematical-operations/#数学运算和初等函数">数学运算和初等函数</a>：<code>&amp;</code> 和 <code>|</code>。这些是普通的函数，同时也刚好支持中缀运算符语法，但总是会计算它们的所有参数：</p><pre><code class="language-julia-repl">julia&gt; f(1) &amp; t(2)
1
2
false

julia&gt; t(1) | t(2)
1
2
true</code></pre><p>与 <code>if</code>, <code>elseif</code> 或者三元运算符中的条件表达式相同，<code>&amp;&amp;</code> 或者 <code>||</code> 的操作数必须是布尔值（<code>true</code> 或者 <code>false</code>）。在链式嵌套的条件表达式中， 除最后一项外，使用非布尔值会导致错误：</p><pre><code class="language-julia-repl">julia&gt; 1 &amp;&amp; true
ERROR: TypeError: non-boolean (Int64) used in boolean context</code></pre><p>但在链的末尾允许使用任意类型的表达式，此表达式会根据前面的条件被执行并返回：</p><pre><code class="language-julia-repl">julia&gt; true &amp;&amp; (x = (1, 2, 3))
(1, 2, 3)

julia&gt; false &amp;&amp; (x = (1, 2, 3))
false</code></pre><h2 id="man-loops"><a class="docs-heading-anchor" href="#man-loops">重复执行：循环</a><a id="man-loops-1"></a><a class="docs-heading-anchor-permalink" href="#man-loops" title="Permalink"></a></h2><p>有两个用于重复执行表达式的组件：<code>while</code> 循环和 <code>for</code> 循环。下面是一个 <code>while</code> 循环的例子：</p><pre><code class="language-julia-repl">julia&gt; i = 1;

julia&gt; while i &lt;= 5
           println(i)
           global i += 1
       end
1
2
3
4
5</code></pre><p><code>while</code> 循环会执行条件表达式（例子中为 <code>i &lt;= 5</code>），只要它为 <code>true</code>，就一直执行<code>while</code> 循环的主体部分。当 <code>while</code> 循环第一次执行时，如果条件表达式为 <code>false</code>，那么主体代码就一次也不会被执行。</p><p><code>for</code> 循环使得常见的重复执行代码写起来更容易。 像之前 <code>while</code> 循环中用到的向上和向下计数是可以用 <code>for</code> 循环更简明地表达：</p><pre><code class="language-julia-repl">julia&gt; for i = 1:5
           println(i)
       end
1
2
3
4
5</code></pre><p>这里的 <code>1:5</code> 是一个范围对象，代表数字 1, 2, 3, 4, 5 的序列。<code>for</code> 循环在这些值之中迭代，对每一个变量 <code>i</code> 进行赋值。<code>for</code> 循环与之前 <code>while</code> 循环的一个非常重要区别是作用域，即变量的可见性。如果变量 <code>i</code> 没有在另一个作用域里引入，在 <code>for</code> 循环内，它就只在 <code>for</code> 循环内部可见，在外部和后面均不可见。你需要一个新的交互式会话实例或者一个新的变量名来测试这个特性：</p><pre><code class="language-julia-repl">julia&gt; for j = 1:5
           println(j)
       end
1
2
3
4
5

julia&gt; j
ERROR: UndefVarError: j not defined</code></pre><p>参见<a href="../variables-and-scoping/#scope-of-variables">变量作用域</a>中对变量作用域的详细解释以及它在 Julia 中是如何工作的。</p><p>一般来说，<code>for</code> 循环组件可以用于迭代任一个容器。在这种情况下，相比 <code>=</code>，另外的（但完全相同）关键字 <code>in</code> 或者 <code>∈</code> 则更常用，因为它使得代码更清晰：</p><pre><code class="language-julia-repl">julia&gt; for i in [1,4,0]
           println(i)
       end
1
4
0

julia&gt; for s ∈ [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
           println(s)
       end
foo
bar
baz</code></pre><p>在手册后面的章节中会介绍和讨论各种不同的迭代容器（比如，<a href="../arrays/#man-multi-dim-arrays">多维数组</a>）。</p><p>为了方便，我们可能会在测试条件不成立之前终止一个 <code>while</code> 循环，或者在访问到迭代对象的结尾之前停止一个 <code>for</code> 循环，这可以用关键字 <code>break</code> 来完成：</p><pre><code class="language-julia-repl">julia&gt; i = 1;

julia&gt; while true
           println(i)
           if i &gt;= 5
               break
           end
           global i += 1
       end
1
2
3
4
5

julia&gt; for j = 1:1000
           println(j)
           if j &gt;= 5
               break
           end
       end
1
2
3
4
5</code></pre><p>没有关键字 <code>break</code> 的话，上面的 <code>while</code> 循环永远不会自己结束，而 <code>for</code> 循环会迭代到 1000，这些循环都可以使用 <code>break</code> 来提前结束。</p><p>在某些场景下，需要直接结束此次迭代，并立刻进入下次迭代，<code>continue</code> 关键字可以用来完成此功能：</p><pre><code class="language-julia-repl">julia&gt; for i = 1:10
           if i % 3 != 0
               continue
           end
           println(i)
       end
3
6
9</code></pre><p>这是一个有点做作的例子，因为我们可以通过否定这个条件，把 <code>println</code> 调用放到 <code>if</code> 代码块里来更简洁的实现同样的功能。在实际应用中，在 <code>continue</code> 后面还会有更多的代码要运行，并且调用 <code>continue</code> 的地方可能会有多个。</p><p>多个嵌套的 <code>for</code> 循环可以合并到一个外部循环，可以用来创建其迭代对象的笛卡尔积：</p><pre><code class="language-julia-repl">julia&gt; for i = 1:2, j = 3:4
           println((i, j))
       end
(1, 3)
(1, 4)
(2, 3)
(2, 4)</code></pre><p>有了这个语法，迭代变量依然可以正常使用循环变量来进行索引，例如 <code>for i = 1:n, j = 1:i</code> 是合法的，但是在一个循环里面使用 <code>break</code> 语句则会跳出整个嵌套循环，不仅仅是内层循环。每次内层循环运行的时候，变量（<code>i</code> 和 <code>j</code>）会被赋值为他们当前的迭代变量值。所以对 <code>i</code> 的赋值对于接下来的迭代是不可见的：</p><pre><code class="language-julia-repl">julia&gt; for i = 1:2, j = 3:4
           println((i, j))
           i = 0
       end
(1, 3)
(1, 4)
(2, 3)
(2, 4)</code></pre><p>如果这个例子给每个变量一个关键字 <code>for</code> 来重写，那么输出会不一样：第二个和第四个变量包含 <code>0</code>。</p><p>可以使用 <a href="../../base/iterators/#Base.Iterators.zip"><code>zip</code></a> 在单个 <code>for</code> 循环中同时迭代多个容器：</p><pre><code class="language-julia-repl">julia&gt; for (j, k) in zip([1 2 3], [4 5 6 7])
           println((j,k))
       end
(1, 4)
(2, 5)
(3, 6)</code></pre><p>使用 <a href="../../base/iterators/#Base.Iterators.zip"><code>zip</code></a> 将创建一个迭代器，它是一个包含传递给它的容器的子迭代器的元组。 <code>zip</code> 迭代器将按顺序迭代所有子迭代器，在 <code>for</code> 循环的第 <span>$i$</span> 次迭代中选择每个子迭代器的第 <span>$i$</span> 个元素。 一旦任何子迭代器用完，<code>for</code> 循环就会停止。</p><h2 id="异常处理"><a class="docs-heading-anchor" href="#异常处理">异常处理</a><a id="异常处理-1"></a><a class="docs-heading-anchor-permalink" href="#异常处理" title="Permalink"></a></h2><p>当一个意外条件发生时，一个函数可能无法向调用者返回一个合理的值。在这种情况下，最好让意外条件终止程序并打印出调试的错误信息，或者根据程序员预先提供的异常处理代码来采取恰当的措施。</p><h3 id="内置的-Exception"><a class="docs-heading-anchor" href="#内置的-Exception">内置的 <code>Exception</code></a><a id="内置的-Exception-1"></a><a class="docs-heading-anchor-permalink" href="#内置的-Exception" title="Permalink"></a></h3><p>当一个意外的情况发生时，会抛出 <code>Exception</code>。下面列出的内置 <code>Exception</code> 都会中断正常的控制流程。</p><table><tr><th style="text-align: left"><code>Exception</code></th></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.ArgumentError"><code>ArgumentError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.BoundsError"><code>BoundsError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.CompositeException"><code>CompositeException</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.DimensionMismatch"><code>DimensionMismatch</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.DivideError"><code>DivideError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.DomainError"><code>DomainError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.EOFError"><code>EOFError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.ErrorException"><code>ErrorException</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.InexactError"><code>InexactError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.InitError"><code>InitError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.InterruptException"><code>InterruptException</code></a></td></tr><tr><td style="text-align: left"><code>InvalidStateException</code></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.KeyError"><code>KeyError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.LoadError"><code>LoadError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.OutOfMemoryError"><code>OutOfMemoryError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.ReadOnlyMemoryError"><code>ReadOnlyMemoryError</code></a></td></tr><tr><td style="text-align: left"><a href="../../stdlib/Distributed/#Distributed.RemoteException"><code>RemoteException</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.MethodError"><code>MethodError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.OverflowError"><code>OverflowError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.Meta.ParseError"><code>Meta.ParseError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.SystemError"><code>SystemError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.TypeError"><code>TypeError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.UndefRefError"><code>UndefRefError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Core.UndefVarError"><code>UndefVarError</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.StringIndexError"><code>StringIndexError</code></a></td></tr></table><p>例如，当输入参数为负实数时，<a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt</code></a> 函数会抛出一个 <a href="../../base/base/#Core.DomainError"><code>DomainError</code></a> ：</p><pre><code class="language-julia-repl">julia&gt; sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]</code></pre><p>你可能需要根据下面的方式来定义你自己的异常：</p><pre><code class="language-julia-repl">julia&gt; struct MyCustomException &lt;: Exception end</code></pre><h3 id="[throw](@ref)-函数"><a class="docs-heading-anchor" href="#[throw](@ref)-函数"><a href="../../base/base/#Core.throw"><code>throw</code></a> 函数</a><a id="[throw](@ref)-函数-1"></a><a class="docs-heading-anchor-permalink" href="#[throw](@ref)-函数" title="Permalink"></a></h3><p>我们可以用 <a href="../../base/base/#Core.throw"><code>throw</code></a> 显式地创建异常。例如，若一个函数只对非负数有定义，当输入参数是负数的时候，可以用 <a href="../../base/base/#Core.throw"><code>throw</code></a> 抛出一个 <a href="../../base/base/#Core.DomainError"><code>DomainError</code></a>。</p><pre><code class="language-julia-repl">julia&gt; f(x) = x&gt;=0 ? exp(-x) : throw(DomainError(x, &quot;argument must be nonnegative&quot;))
f (generic function with 1 method)

julia&gt; f(1)
0.36787944117144233

julia&gt; f(-1)
ERROR: DomainError with -1:
argument must be nonnegative
Stacktrace:
 [1] f(::Int64) at ./none:1</code></pre><p>注意 <a href="../../base/base/#Core.DomainError"><code>DomainError</code></a> 后面不接括号的话不是一个异常，而是一个异常类型。我们需要调用它来获得一个 <code>Exception</code> 对象：</p><pre><code class="language-julia-repl">julia&gt; typeof(DomainError(nothing)) &lt;: Exception
true

julia&gt; typeof(DomainError) &lt;: Exception
false</code></pre><p>另外，一些异常类型会接受一个或多个参数来进行错误报告：</p><pre><code class="language-julia-repl">julia&gt; throw(UndefVarError(:x))
ERROR: UndefVarError: x not defined</code></pre><p>我们可以仿照 <a href="../../base/base/#Core.UndefVarError"><code>UndefVarError</code></a> 的写法，用自定义异常类型来轻松实现这个机制：</p><pre><code class="language-julia-repl">julia&gt; struct MyUndefVarError &lt;: Exception
           var::Symbol
       end

julia&gt; Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, &quot; not defined&quot;)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>错误信息的第一个单词最好用小写。例如：</p><p><code>size(A) == size(B) || throw(DimensionMismatch(&quot;size of A not equal to size of B&quot;))</code></p><p>就比</p><p><code>size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))</code>.</p><p>更好。</p><p>但是，有时保留大写首字母是有意义的，例如函数的参数就是大写字母时：</p><p><code>size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))</code>.</p></div></div><h3 id="错误"><a class="docs-heading-anchor" href="#错误">错误</a><a id="错误-1"></a><a class="docs-heading-anchor-permalink" href="#错误" title="Permalink"></a></h3><p>我们可以用 <a href="../../base/base/#Base.error"><code>error</code></a> 函数生成一个 <a href="../../base/base/#Core.ErrorException"><code>ErrorException</code></a> 来中断正常的控制流程。</p><p>假设我们希望在计算负数的平方根时让程序立即停止执行。为了实现它，我们可以定义一个挑剔的 <a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt</code></a> 函数，当它的参数是负数时，产生一个错误：</p><pre><code class="language-julia-repl">julia&gt; fussy_sqrt(x) = x &gt;= 0 ? sqrt(x) : error(&quot;negative x not allowed&quot;)
fussy_sqrt (generic function with 1 method)

julia&gt; fussy_sqrt(2)
1.4142135623730951

julia&gt; fussy_sqrt(-1)
ERROR: negative x not allowed
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fussy_sqrt(::Int64) at ./none:1
 [3] top-level scope</code></pre><p>如果另一个函数调用 <code>fussy_sqrt</code> 和一个负数, 它会立马返回， 在交互会话中显示错误信息，而不会继续执行调用的函数：</p><pre><code class="language-julia-repl">julia&gt; function verbose_fussy_sqrt(x)
           println(&quot;before fussy_sqrt&quot;)
           r = fussy_sqrt(x)
           println(&quot;after fussy_sqrt&quot;)
           return r
       end
verbose_fussy_sqrt (generic function with 1 method)

julia&gt; verbose_fussy_sqrt(2)
before fussy_sqrt
after fussy_sqrt
1.4142135623730951

julia&gt; verbose_fussy_sqrt(-1)
before fussy_sqrt
ERROR: negative x not allowed
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fussy_sqrt at ./none:1 [inlined]
 [3] verbose_fussy_sqrt(::Int64) at ./none:3
 [4] top-level scope</code></pre><h3 id="try/catch-语句"><a class="docs-heading-anchor" href="#try/catch-语句"><code>try/catch</code> 语句</a><a id="try/catch-语句-1"></a><a class="docs-heading-anchor-permalink" href="#try/catch-语句" title="Permalink"></a></h3><p>通过 <code>try / catch</code> 语句，可以测试 Exception 并 优雅处理可能会破坏应用程序的事情。 例如， 在下面的代码中，平方根函数会引发异常。 通过 在其周围放置 <code>try / catch</code> 块可以缓解。 您可以选择如何 处理此异常，无论是记录它，返回占位符值还是 就像下面仅打印一句话。 要注意的是 在决定如何处理异常时，使用<code>try / catch</code> 块 比使用条件分支处理要慢得多。 以下是使用<code>try / catch</code> 块处理异常的更多示例：</p><pre><code class="language-julia-repl">julia&gt; try
sqrt(&quot;ten&quot;)
catch e
println(&quot;You should have entered a numeric value&quot;)
end
You should have entered a numeric value</code></pre><p><code>try/catch</code> 语句允许保存 <code>Exception</code> 到一个变量中。在下面这个做作的例子中，如果 <code>x</code> 是可索引的，则计算 <code>x</code> 的第二项的平方根，否则就假设 <code>x</code> 是一个实数，并返回它的平方根：</p><pre><code class="language-julia-repl">julia&gt; sqrt_second(x) = try
           sqrt(x[2])
       catch y
           if isa(y, DomainError)
               sqrt(complex(x[2], 0))
           elseif isa(y, BoundsError)
               sqrt(x)
           end
       end
sqrt_second (generic function with 1 method)

julia&gt; sqrt_second([1 4])
2.0

julia&gt; sqrt_second([1 -4])
0.0 + 2.0im

julia&gt; sqrt_second(9)
3.0

julia&gt; sqrt_second(-9)
ERROR: DomainError with -9.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]</code></pre><p>注意 <code>catch</code> 后面的字符会被一直认为是异常的名字，所以在写 <code>try/catch</code> 单行表达式时，需要特别小心。下面的代码<strong>不会</strong>在错误的情况下返回 <code>x</code> 的值：</p><pre><code class="language-julia">try bad() catch x end</code></pre><p>正确的做法是在 <code>catch</code> 后添加一个分号或者直接换行：</p><pre><code class="language-julia">try bad() catch; x end

try bad()
catch
    x
end</code></pre><p><code>try/catch</code> 结构的强大之处在于能够立即将深度嵌套的计算展开到调用函数堆栈中的更高级别。 在某些情况下，没有发生错误，但需要能够展开堆栈并将值传递到更高级别。 Julia 提供了 <a href="../../base/base/#Base.rethrow"><code>rethrow</code></a>、<a href="../../base/base/#Base.backtrace"><code>backtrace</code></a>、<a href="../../base/base/#Base.catch_backtrace"><code>catch_backtrace</code></a> 和 <a href="../../base/base/#Base.current_exceptions"><code>current_exceptions</code></a> 函数来进行更高级的错误处理。</p><h3 id="finally-子句"><a class="docs-heading-anchor" href="#finally-子句"><code>finally</code> 子句</a><a id="finally-子句-1"></a><a class="docs-heading-anchor-permalink" href="#finally-子句" title="Permalink"></a></h3><p>在进行状态改变或者使用类似文件的资源的编程时，经常需要在代码结束的时候进行必要的清理工作（比如关闭文件）。由于异常会使得部分代码块在正常结束之前退出，所以可能会让上述工作变得复杂。<code>finally</code> 关键字提供了一种方式，无论代码块是如何退出的，都能够让代码块在退出时运行某段代码。</p><p>这里是一个确保一个打开的文件被关闭的例子：</p><pre><code class="language-julia">f = open(&quot;file&quot;)
try
    # operate on file f
finally
    close(f)
end</code></pre><p>当控制流离开 <code>try</code> 代码块（例如，遇到 <code>return</code>，或者正常结束），<code>close(f)</code> 就会被执行。如果 <code>try</code> 代码块由于异常退出，这个异常会继续传递。<code>catch</code> 代码块可以和 <code>try</code> 还有 <code>finally</code> 配合使用。这时 <code>finally</code> 代码块会在 <code>catch</code> 处理错误之后才运行。</p><h2 id="man-tasks"><a class="docs-heading-anchor" href="#man-tasks"> Tasks 任务（或协程）</a><a id="man-tasks-1"></a><a class="docs-heading-anchor-permalink" href="#man-tasks" title="Permalink"></a></h2><p><code>Task</code> 是一种允许计算以更灵活的方式被中断或者恢复的流程控制特性。 我们提及它只是为了说明的完整性；详细的介绍参见：<a href="../asynchronous-programming/#man-asynchronous">异步编程</a>。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions/">« 函数</a><a class="docs-footer-nextpage" href="../variables-and-scoping/">变量作用域 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2022 一月 4 周二 14:54">2022 一月 4 周二</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.7.1版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
