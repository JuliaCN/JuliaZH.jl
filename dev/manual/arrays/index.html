<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>一维和多维数组 · Julia 中文文档</title><meta name="title" content="一维和多维数组 · Julia 中文文档"/><meta property="og:title" content="一维和多维数组 · Julia 中文文档"/><meta property="twitter:title" content="一维和多维数组 · Julia 中文文档"/><meta name="description" content="Documentation for Julia 中文文档."/><meta property="og:description" content="Documentation for Julia 中文文档."/><meta property="twitter:description" content="Documentation for Julia 中文文档."/><meta property="og:url" content="https://juliacn.github.io/JuliaZH.jl/latest/manual/arrays/"/><meta property="twitter:url" content="https://juliacn.github.io/JuliaZH.jl/latest/manual/arrays/"/><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/arrays/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia 中文文档 logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">变量</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li class="is-active"><a class="tocitem" href>一维和多维数组</a><ul class="internal"><li><a class="tocitem" href="#基本函数"><span>基本函数</span></a></li><li><a class="tocitem" href="#构造和初始化"><span>构造和初始化</span></a></li><li><a class="tocitem" href="#man-array-literals"><span>数组常量</span></a></li><li><a class="tocitem" href="#man-comprehensions"><span>数组推导</span></a></li><li><a class="tocitem" href="#生成器表达式"><span>生成器表达式</span></a></li><li><a class="tocitem" href="#man-array-indexing"><span>索引</span></a></li><li><a class="tocitem" href="#man-indexed-assignment"><span>索引赋值</span></a></li><li><a class="tocitem" href="#man-supported-index-types"><span>支持的索引类型</span></a></li><li><a class="tocitem" href="#Iteration"><span>迭代</span></a></li><li><a class="tocitem" href="#Array-traits"><span>Array traits</span></a></li><li><a class="tocitem" href="#man-array-and-vectorized-operators-and-functions"><span>数组和向量化的算子与函数</span></a></li><li><a class="tocitem" href="#Broadcasting"><span>广播</span></a></li><li><a class="tocitem" href="#实现"><span>实现</span></a></li></ul></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../multi-threading/">多线程</a></li><li><a class="tocitem" href="../distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">标准数值类型</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/reflection/">反射 与 自我检查</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">标准库</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/ArgTools/">ArgTools</a></li><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibCURL/">LibCURL</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/NetworkOptions/">Network Options</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Tar/">Tar</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">开发者文档</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/pkgimg/">Package Images</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../../devdocs/gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../../devdocs/precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../../devdocs/probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../../devdocs/build/linux/">Linux</a></li><li><a class="tocitem" href="../../devdocs/build/macos/">macOS</a></li><li><a class="tocitem" href="../../devdocs/build/windows/">Windows</a></li><li><a class="tocitem" href="../../devdocs/build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../../devdocs/build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../../devdocs/build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>一维和多维数组</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>一维和多维数组</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/zh_CN/doc/src/manual/arrays.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-multi-dim-arrays"><a class="docs-heading-anchor" href="#man-multi-dim-arrays">一维和多维数组</a><a id="man-multi-dim-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#man-multi-dim-arrays" title="Permalink"></a></h1><p>与大多数科学计算语言一样，Julia 提供原生的数组实现。大多数科学计算语言非常重视其数组实现，而牺牲了其他容器。Julia 没有以任何特殊方式处理数组。 就像和其它用 Julia 写的代码一样，Julia 的数组库几乎完全是用 Julia 自身实现的，并且由编译器保证其性能。 因此，也可以通过继承 <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray</code></a> 来定义自定义数组类型。 有关实现自定义数组类型的更多详细信息，请参阅 <a href="../interfaces/#man-interface-array">AbstractArray 接口的手册部分</a>。</p><p>数组是存储在多维网格中对象的集合。允许使用零维数组，请参见[常见问题]（@ref faq-array-0dim）。 在最一般的情况下， 数组中的对象可能是 <a href="../../base/base/#Core.Any"><code>Any</code></a> 类型。 对于大多数计算上的需求，数组中对象的类型应该更加具体，例如 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> 或 <a href="../../base/numbers/#Core.Int32"><code>Int32</code></a>。</p><p>一般来说，与许多其他科学计算语言不同，Julia 不希望为了性能而以向量化的方式编写程序。 Julia 的编译器使用类型推断，并为标量数组索引生成优化的代码，从而能够令用户方便地编写可读性良好的程序，而不牺牲性能，并且时常会减少内存使用。</p><p>在 Julia 中，所有函数的参数都是 <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing">非复制的方式进行传递</a>的（比如说，通过指针传递）。一些科学计算语言用传值的方式传递数组，尽管这样做可以防止数组在被调函数中被意外地篡改，但这也会导致不必要的数组拷贝。作为 Julia 的一个惯例，以一个 <code>!</code> 结尾的函数名它会对自己的一个或者多个参数的值进行修改或者销毁（例如，请比较 <a href="../../base/sort/#Base.sort"><code>sort</code></a> 和 <a href="../../base/sort/#Base.sort!"><code>sort!</code></a>）。被调函数必须进行显式拷贝，以确保它们不会无意中修改输入参数。很多不以<code>!</code>结尾的函数在实现的时候，都会先进行显式拷贝，然后调用一个以 <code>!</code> 结尾的同名函数，最后返回之前拷贝的副本。</p><h2 id="基本函数"><a class="docs-heading-anchor" href="#基本函数">基本函数</a><a id="基本函数-1"></a><a class="docs-heading-anchor-permalink" href="#基本函数" title="Permalink"></a></h2><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><a href="../../base/collections/#Base.eltype"><code>eltype(A)</code></a></td><td style="text-align: left"><code>A</code> 中元素的类型</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.length-Tuple{AbstractArray}"><code>length(A)</code></a></td><td style="text-align: left"><code>A</code> 中元素的数量</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.ndims"><code>ndims(A)</code></a></td><td style="text-align: left"><code>A</code> 的维数</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.size"><code>size(A)</code></a></td><td style="text-align: left">一个包含 <code>A</code> 各个维度上元素数量的元组</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.size"><code>size(A,n)</code></a></td><td style="text-align: left"><code>A</code> 第 <code>n</code> 维中的元素数量</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.axes-Tuple{Any}"><code>axes(A)</code></a></td><td style="text-align: left">一个包含 <code>A</code> 有效索引的元组</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.axes-Tuple{Any}"><code>axes(A,n)</code></a></td><td style="text-align: left">第 <code>n</code> 维有效索引的范围</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.eachindex"><code>eachindex(A)</code></a></td><td style="text-align: left">一个访问 <code>A</code> 中每一个位置的高效迭代器</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.stride"><code>stride(A,k)</code></a></td><td style="text-align: left">在第 <code>k</code> 维上的间隔（stride）（相邻元素间的线性索引距离）</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.strides"><code>strides(A)</code></a></td><td style="text-align: left">包含每一维上的间隔（stride）的元组</td></tr></table><h2 id="构造和初始化"><a class="docs-heading-anchor" href="#构造和初始化">构造和初始化</a><a id="构造和初始化-1"></a><a class="docs-heading-anchor-permalink" href="#构造和初始化" title="Permalink"></a></h2><p>Julia 提供了许多用于构造和初始化数组的函数。在下列函数中，参数 <code>dims ...</code> 可以是一个元组 tuple 来表示维数，也可以是一个可变长度的整数值作为维数。大部分函数的第一个参数都表示数组的元素类型 <code>T</code> 。如果类型 <code>T</code> 被省略，那么将默认为 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>。</p><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Core.Array"><code>Array{T}(undef, dims...)</code></a></td><td style="text-align: left">一个没有初始化的密集 <a href="../../base/arrays/#Core.Array"><code>Array</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.zeros"><code>zeros(T, dims...)</code></a></td><td style="text-align: left">一个全零 <code>Array</code></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.ones"><code>ones(T, dims...)</code></a></td><td style="text-align: left">一个元素均为 1 的 <code>Array</code></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.trues"><code>trues(dims...)</code></a></td><td style="text-align: left">一个每个元素都为 <code>true</code> 的 <a href="../../base/arrays/#Base.BitArray"><code>BitArray</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.falses"><code>falses(dims...)</code></a></td><td style="text-align: left">一个每个元素都为 <code>false</code> 的 <code>BitArray</code></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.reshape"><code>reshape(A, dims...)</code></a></td><td style="text-align: left">一个包含跟 <code>A</code> 相同数据但维数不同的数组</td></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.copy"><code>copy(A)</code></a></td><td style="text-align: left">拷贝 <code>A</code></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.deepcopy"><code>deepcopy(A)</code></a></td><td style="text-align: left">深拷贝，即拷贝 <code>A</code>，并递归地拷贝其元素</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.similar"><code>similar(A, T, dims...)</code></a></td><td style="text-align: left">一个与<code>A</code>具有相同类型（这里指的是密集，稀疏等）的未初始化数组，但具有指定的元素类型和维数。第二个和第三个参数都是可选的，如果省略则默认为元素类型和 <code>A</code> 的维数。</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.reinterpret"><code>reinterpret(T, A)</code></a></td><td style="text-align: left">与 <code>A</code> 具有相同二进制数据的数组，但元素类型为 <code>T</code></td></tr><tr><td style="text-align: left"><a href="../../stdlib/Random/#Base.rand"><code>rand(T, dims...)</code></a></td><td style="text-align: left">一个随机 <code>Array</code>，其元素值是 iid <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> 和均匀分布值的。 对于浮点类型 <code>T</code>，数值位于半开放区间 <span>$[0, 1)$</span> 内。</td></tr><tr><td style="text-align: left"><a href="../../stdlib/Random/#Base.randn"><code>randn(T, dims...)</code></a></td><td style="text-align: left">一个随机 <code>Array</code>，元素为标准正态分布，服从独立同分布</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.Matrix"><code>Matrix{T}(I, m, n)</code></a></td><td style="text-align: left"><code>m</code> 行 <code>n</code> 列的单位矩阵 （需要先执行 <code>using LinearAlgebra</code> 来才能使用 <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.I"><code>I</code></a>）</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.range"><code>range(start, stop, n)</code></a></td><td style="text-align: left">从 <code>start</code> 到 <code>stop</code> 的带有 <code>n</code> 个线性间隔元素的范围</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.fill!"><code>fill!(A, x)</code></a></td><td style="text-align: left">用值 <code>x</code> 填充数组 <code>A</code></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.fill"><code>fill(x, dims...)</code></a></td><td style="text-align: left">一个由 <code>x</code> 填充的 <code>Array</code>。特别的，<code>fill(x)</code> 构造了一个包含 <code>x</code> 的零维 <code>Array</code>。</td></tr></table><p>要查看各种方法，我们可以将不同维数传递给这些构造函数，请考虑以下示例：</p><pre><code class="language-julia-repl hljs">julia&gt; zeros(Int8, 2, 3)
2×3 Matrix{Int8}:
 0  0  0
 0  0  0

julia&gt; zeros(Int8, (2, 3))
2×3 Matrix{Int8}:
 0  0  0
 0  0  0

julia&gt; zeros((2, 3))
2×3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>此处, <code>(2, 3)</code> 是一个元组 <a href="../../base/base/#Core.Tuple"><code>Tuple</code></a> 并且第一个参数——元素类型是可选的, 默认值为 <code>Float64</code>.</p><h2 id="man-array-literals"><a class="docs-heading-anchor" href="#man-array-literals">数组常量</a><a id="man-array-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-literals" title="Permalink"></a></h2><p>数组也可以直接用方括号来构造; 语法 <code>[A, B, C, ...]</code> 创建一个一维数组(即一个向量)，该一维数组的元素用逗号分隔。 所创建的数组中元素的类型(<a href="../../base/collections/#Base.eltype"><code>eltype</code></a>) 自动由括号内参数的类型确定。如果所有参数类型都相同，则该类型称为数组的 <code>eltype</code>。 如果所有元素都有相同的<a href="../conversion-and-promotion/#conversion-and-promotion">promotion type</a>，那么个元素都由<a href="../../base/base/#Base.convert"><code>convert</code></a>转换成该类型并且该类型为数组的 <code>eltype</code>。 否则, 生成一个可以包含任意类型的异构数组—— <code>Vector{Any}</code> ;该构造方法包含字符 <code>[]</code>，此时构造过程无参数给出。 <a href="#man-array-typed-literal">Array literal can be typed</a> with the syntax <code>T[A, B, C, ...]</code> where <code>T</code> is a type.</p><pre><code class="language-julia-repl hljs">julia&gt; [1,2,3] # 元素类型为 Int 的向量
3-element Vector{Int64}:
 1
 2
 3

julia&gt; promote(1, 2.3, 4//5) # Int, Float64 以及 Rational 类型放在一起则会提升到 Float64
(1.0, 2.3, 0.8)

julia&gt; [1, 2.3, 4//5] # 从而它就是这个矩阵的元素类型
3-element Vector{Float64}:
 1.0
 2.3
 0.8

julia&gt; Float32[1, 2.3, 4//5] # Specify element type manually
3-element Vector{Float32}:
 1.0
 2.3
 0.8

julia&gt; []
Any[]</code></pre><h3 id="man-array-concatenation"><a class="docs-heading-anchor" href="#man-array-concatenation">数组拼接</a><a id="man-array-concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-concatenation" title="Permalink"></a></h3><p>如果方括号里的参数不是由逗号分隔，而是由单个分号(<code>;</code>) 或者换行符分隔，那么每一个参数就不再解析为一个单独的数组元素，而是纵向拼接起来。  </p><pre><code class="language-julia-repl hljs">julia&gt; [1:2, 4:5] # 这里有一个逗号，因此并不会发生矩阵的拼接。这里居然的元素本身就是这些 range
2-element Vector{UnitRange{Int64}}:
 1:2
 4:5

julia&gt; [1:2; 4:5]
4-element Vector{Int64}:
 1
 2
 4
 5

julia&gt; [1:2
        4:5
        6]
5-element Vector{Int64}:
 1
 2
 4
 5
 6</code></pre><p>类似的，如果这些参数是被制表符、空格符或者两个分号所分隔，那么它们的内容就<em>横向拼接</em>在一起。</p><pre><code class="language-julia-repl hljs">julia&gt; [1:2  4:5  7:8]
2×3 Matrix{Int64}:
 1  4  7
 2  5  8

julia&gt; [[1,2]  [4,5]  [7,8]]
2×3 Matrix{Int64}:
 1  4  7
 2  5  8

julia&gt; [1 2 3] # 数字可以被横向拼接
1×3 Matrix{Int64}:
 1  2  3

julia&gt; [1;; 2;; 3;; 4]
1×4 Matrix{Int64}:
 1  2  3  4</code></pre><p>单个分号（或换行符）和空格（或制表符）可以被结合起来使用进行横向或者纵向的拼接。</p><pre><code class="language-julia-repl hljs">julia&gt; [1 2
        3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; [zeros(Int, 2, 2) [1; 2]
        [3 4]            5]
3×3 Matrix{Int64}:
 0  0  1
 0  0  2
 3  4  5

julia&gt; [[1 1]; 2 3; [4 4]]
3×2 Matrix{Int64}:
 1  1
 2  3
 4  4</code></pre><p>Spaces (and tabs) have a higher precedence than semicolons, performing any horizontal concatenations first and then concatenating the result. Using double semicolons for the horizontal concatenation, on the other hand, performs any vertical concatenations before horizontally concatenating the result.</p><pre><code class="language-julia-repl hljs">julia&gt; [zeros(Int, 2, 2) ; [3 4] ;; [1; 2] ; 5]
3×3 Matrix{Int64}:
 0  0  1
 0  0  2
 3  4  5

julia&gt; [1:2; 4;; 1; 3:4]
3×2 Matrix{Int64}:
 1  1
 2  3
 4  4</code></pre><p>Just as <code>;</code> and <code>;;</code> concatenate in the first and second dimension, using more semicolons extends this same general scheme. The number of semicolons in the separator specifies the particular dimension, so <code>;;;</code> concatenates in the third dimension, <code>;;;;</code> in the 4th, and so on. Fewer semicolons take precedence, so the lower dimensions are generally concatenated first.</p><pre><code class="language-julia-repl hljs">julia&gt; [1; 2;; 3; 4;; 5; 6;;;
        7; 8;; 9; 10;; 11; 12]
2×3×2 Array{Int64, 3}:
[:, :, 1] =
 1  3  5
 2  4  6

[:, :, 2] =
 7   9  11
 8  10  12</code></pre><p>Like before, spaces (and tabs) for horizontal concatenation have a higher precedence than any number of semicolons. Thus, higher-dimensional arrays can also be written by specifying their rows first, with their elements textually arranged in a manner similar to their layout:</p><pre><code class="language-julia-repl hljs">julia&gt; [1 3 5
        2 4 6;;;
        7 9 11
        8 10 12]
2×3×2 Array{Int64, 3}:
[:, :, 1] =
 1  3  5
 2  4  6

[:, :, 2] =
 7   9  11
 8  10  12

julia&gt; [1 2;;; 3 4;;;; 5 6;;; 7 8]
1×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  2

[:, :, 2, 1] =
 3  4

[:, :, 1, 2] =
 5  6

[:, :, 2, 2] =
 7  8

julia&gt; [[1 2;;; 3 4];;;; [5 6];;; [7 8]]
1×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  2

[:, :, 2, 1] =
 3  4

[:, :, 1, 2] =
 5  6

[:, :, 2, 2] =
 7  8</code></pre><p>Although they both mean concatenation in the second dimension, spaces (or tabs) and <code>;;</code> cannot appear in the same array expression unless the double semicolon is simply serving as a &quot;line continuation&quot; character. This allows a single horizontal concatenation to span multiple lines (without the line break being interpreted as a vertical concatenation).</p><pre><code class="language-julia-repl hljs">julia&gt; [1 2 ;;
       3 4]
1×4 Matrix{Int64}:
 1  2  3  4</code></pre><p>Terminating semicolons may also be used to add trailing length 1 dimensions.</p><pre><code class="language-julia-repl hljs">julia&gt; [1;;]
1×1 Matrix{Int64}:
 1

julia&gt; [2; 3;;;]
2×1×1 Array{Int64, 3}:
[:, :, 1] =
 2
 3</code></pre><p>空格（和制表符）的优先级高于分号，首先执行任何纵向拼接，然后拼接结果。 另一方面，使用双分号进行水平连接时，先纵向拼接再横向拼接。</p><table><tr><th style="text-align: left">Syntax</th><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="../../base/arrays/#Base.cat"><code>cat</code></a></td><td style="text-align: left">concatenate input arrays along dimension(s) <code>k</code></td></tr><tr><td style="text-align: left"><code>[A; B; C; ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.vcat"><code>vcat</code></a></td><td style="text-align: left">shorthand for <code>cat(A...; dims=1)</code></td></tr><tr><td style="text-align: left"><code>[A B C ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.hcat"><code>hcat</code></a></td><td style="text-align: left">shorthand for <code>cat(A...; dims=2)</code></td></tr><tr><td style="text-align: left"><code>[A B; C D; ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a></td><td style="text-align: left">simultaneous vertical and horizontal concatenation</td></tr><tr><td style="text-align: left"><code>[A; C;; B; D;;; ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.hvncat"><code>hvncat</code></a></td><td style="text-align: left">simultaneous n-dimensional concatenation, where number of semicolons indicate the dimension to concatenate</td></tr></table><h3 id="man-array-typed-literal"><a class="docs-heading-anchor" href="#man-array-typed-literal">Typed array literals</a><a id="man-array-typed-literal-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-typed-literal" title="Permalink"></a></h3><p>正如 <code>;</code> 和 <code>;;</code> 在第一维和第二维中拼接一样，使用更多的分号扩展了相同的通用方案。 分隔符中的分号数指定了特定的维度，因此<code>;;;</code> 在第三个维度中拼接，<code>;;;;</code> 在第四个维度中，依此类推。 较少的分号优先级高，因此较低的维度通常首先拼接。</p><pre><code class="language-julia-repl hljs">julia&gt; [1; 2;; 3; 4;; 5; 6;;;
        7; 8;; 9; 10;; 11; 12]
2×3×2 Array{Int64, 3}:
[:, :, 1] =
 1  3  5
 2  4  6

[:, :, 2] =
 7   9  11
 8  10  12</code></pre><p>像之前一样，用于水平拼接的空格（和制表符）的优先级高于任何数量的分号。 因此，高维数组也可以通过首先指定它们的行来编写，它们的元素以类似于它们的布局的方式进行文本排列：</p><pre><code class="language-julia-repl hljs">julia&gt; [1 3 5
        2 4 6;;;
        7 9 11
        8 10 12]
2×3×2 Array{Int64, 3}:
[:, :, 1] =
 1  3  5
 2  4  6

[:, :, 2] =
 7   9  11
 8  10  12

julia&gt; [1 2;;; 3 4;;;; 5 6;;; 7 8]
1×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  2

[:, :, 2, 1] =
 3  4

[:, :, 1, 2] =
 5  6

[:, :, 2, 2] =
 7  8

julia&gt; [[1 2;;; 3 4];;;; [5 6];;; [7 8]]
1×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  2

[:, :, 2, 1] =
 3  4

[:, :, 1, 2] =
 5  6

[:, :, 2, 2] =
 7  8</code></pre><p>尽管它们都表示第二维中的连接，但空格（或制表符）和 <code>;;</code> 不能出现在同一个数组表达式中，除非双分号只是作为“行继续”字符。 这允许单个水平拼接跨越多行（不会将换行符解释为垂直拼接）。</p><pre><code class="language-julia-repl hljs">julia&gt; [1 2 ;;
       3 4]
1×4 Matrix{Int64}:
 1  2  3  4</code></pre><p>终止分号也可用于在最后添加 1 个长度为1的维度。</p><pre><code class="language-julia-repl hljs">julia&gt; [1;;]
1×1 Matrix{Int64}:
 1

julia&gt; [2; 3;;;]
2×1×1 Array{Int64, 3}:
[:, :, 1] =
 2
 3</code></pre><p>更一般地，可以通过<a href="../../base/arrays/#Base.cat"><code>cat</code></a> 函数来实现数组元素的拼接功能。 以下这些的语法为这些函数的简写形式，它们本身也是非常方便使用的：</p><table><tr><th style="text-align: left">语法</th><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="../../base/arrays/#Base.cat"><code>cat</code></a></td><td style="text-align: left">沿着 s 的第 <code>k</code> 维拼接数组</td></tr><tr><td style="text-align: left"><code>[A; B; C; ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.vcat"><code>vcat</code></a></td><td style="text-align: left">`cat(A...; dims=1) 的简写</td></tr><tr><td style="text-align: left"><code>[A B C ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.hcat"><code>hcat</code></a></td><td style="text-align: left">`cat(A...; dims=2) 的简写</td></tr><tr><td style="text-align: left"><code>[A B; C D; ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a></td><td style="text-align: left">同时沿垂直和水平方向拼接</td></tr><tr><td style="text-align: left"><code>[A; C;; B; D;;; ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.hvncat"><code>hvncat</code></a></td><td style="text-align: left">同时进行 n 维拼接，其中分号的数量表示拼接所在的维度</td></tr></table><h3 id="指定类型的数组字面量"><a class="docs-heading-anchor" href="#指定类型的数组字面量">指定类型的数组字面量</a><a id="指定类型的数组字面量-1"></a><a class="docs-heading-anchor-permalink" href="#指定类型的数组字面量" title="Permalink"></a></h3><p>可以用 <code>T[A, B, C, ...]</code> 的方式声明一个元素为某种特定类型的数组。该方法定义一个元素类型为 <code>T</code> 的一维数组并且初始化元素为 <code>A</code>, <code>B</code>, <code>C</code>, ....。比如，<code>Any[x, y, z]</code> 会构建一个异构数组，该数组可以包含任意类型的元素。</p><p>类似的，拼接也可以用类型为前缀来指定结果的元素类型。</p><pre><code class="language-julia-repl hljs">julia&gt; [[1 2] [3 4]]
1×4 Matrix{Int64}:
 1  2  3  4

julia&gt; Int8[[1 2] [3 4]]
1×4 Matrix{Int8}:
 1  2  3  4</code></pre><h2 id="man-comprehensions"><a class="docs-heading-anchor" href="#man-comprehensions">数组推导</a><a id="man-comprehensions-1"></a><a class="docs-heading-anchor-permalink" href="#man-comprehensions" title="Permalink"></a></h2><p>（数组）推导提供了构造数组的通用且强大的方法。其语法类似于数学中的集合构造的写法：</p><pre><code class="nohighlight hljs">A = [ F(x, y, ...) for x=rx, y=ry, ... ]</code></pre><p>这种形式的含义是 <code>F(x,y,...)</code> 取其给定列表中变量 <code>x</code>，<code>y</code> 等的每个值进行计算。值可以指定为任何可迭代对象，但通常是 <code>1:n</code> 或 <code>2:(n-1)</code> 之类的范围，或者像 <code>[1.2, 3.4, 5.7]</code> 这样的显式数组值。结果是一个 N 维密集数组，将变量范围 <code>rx</code>，<code>ry</code> 等的维数拼接起来得到其维数，并且每次 <code>F(x,y,...)</code> 计算返回一个标量。</p><p>下面的示例计算当前元素和沿一维网格其左，右相邻元素的加权平均值：</p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia&gt; [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511</code></pre><p>生成的数组的类型取决于参与计算元素的类型，就像<a href="#man-array-literals">数组字面量</a>一样。为了显式地控制类型，可以在数组推导之前指定类型。例如，我们可以要求推导的结果为单精度类型：</p><pre><code class="language-julia hljs">Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]</code></pre><h2 id="生成器表达式"><a class="docs-heading-anchor" href="#生成器表达式">生成器表达式</a><a id="生成器表达式-1"></a><a class="docs-heading-anchor-permalink" href="#生成器表达式" title="Permalink"></a></h2><p>也可以在没有方括号的情况下编写（数组）推导，从而产生称为生成器的对象。可以迭代此对象以按需生成值，而不是预先分配数组并存储它们（请参阅 <a href="#Iteration">迭代</a>）。例如，以下表达式在不分配内存的情况下对一个序列进行求和：</p><pre><code class="language-julia-repl hljs">julia&gt; sum(1/n^2 for n=1:1000)
1.6439345666815615</code></pre><p>在参数列表中使用具有多个维度的生成器表达式时，需要使用括号将生成器与后续参数分开：</p><pre><code class="language-julia-repl hljs">julia&gt; map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification</code></pre><p><code>for</code> 后面所有逗号分隔的表达式都被解释为范围。 添加括号让我们可以向 <a href="../../base/collections/#Base.map"><code>map</code></a> 中添加第三个参数：</p><pre><code class="language-julia-repl hljs">julia&gt; map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Matrix{Tuple{Float64, Int64}}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)</code></pre><p>生成器是通过内部函数实现。 与本语言中别处使用的内部函数一样，封闭作用域中的变量可以在内部函数中被「捕获」。例如，<code>sum(p[i] - q[i] for i=1:n)</code> 从封闭作用域中捕获三个变量 <code>p</code>、<code>q</code> 和 <code>n</code>。但是变量捕获可能会带来性能挑战；请参阅 <a href="../performance-tips/#man-performance-tips">性能提示</a>。</p><p>通过编写多个 <code>for</code> 关键字，生成器和推导中的范围可以取决于之前的范围：</p><pre><code class="language-julia-repl hljs">julia&gt; [(i, j) for i=1:3 for j=1:i]
6-element Vector{Tuple{Int64, Int64}}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)</code></pre><p>在这些情况下，结果都是一维的。</p><p>可以使用 <code>if</code> 关键字过滤生成的值：</p><pre><code class="language-julia-repl hljs">julia&gt; [(i, j) for i=1:3 for j=1:i if i+j == 4]
2-element Vector{Tuple{Int64, Int64}}:
 (2, 2)
 (3, 1)</code></pre><h2 id="man-array-indexing"><a class="docs-heading-anchor" href="#man-array-indexing">索引</a><a id="man-array-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-indexing" title="Permalink"></a></h2><p>索引 n 维数组 <code>A</code> 的一般语法是：</p><pre><code class="nohighlight hljs">X = A[I_1, I_2, ..., I_n]</code></pre><p>其中每个 <code>I_k</code> 可以是标量整数，整数数组或任何其他<a href="#man-supported-index-types">支持的索引类型</a>。这包括 <a href="../../base/arrays/#Base.Colon"><code>Colon</code></a> (<code>:</code>) 来选择整个维度中的所有索引，形式为 <code>a:c</code> 或 <code>a:b:c</code> 的范围来选择连续或跨步的子区间，以及布尔数组以选择索引为 <code>true</code> 的元素。</p><p>如果所有索引都是标量，则结果 <code>X</code> 是数组 <code>A</code> 中的单个元素。否则，<code>X</code> 是一个数组，其维数与所有索引的维数之和相同。</p><p>如果所有索引 <code>I_k</code> 都是向量，则 <code>X</code> 的形状将是 <code>(length(I_1), length(I_2), ..., length(I_n))</code>，其中，<code>X</code> 中位于 <code>i_1, i_2, ..., i_n</code> 处的元素为 <code>A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]</code>。</p><p>例如：</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; A[1, 2, 1, 1] # 全部为标量索引
3

julia&gt; A[[1, 2], [1], [1, 2], [1]] # 全部为向量索引
2×1×2×1 Array{Int64, 4}:
[:, :, 1, 1] =
 1
 2

[:, :, 2, 1] =
 5
 6

julia&gt; A[[1, 2], [1], [1, 2], 1] # 标量与向量索引的混合使用
2×1×2 Array{Int64, 3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 5
 6</code></pre><p>请注意最后两种情况下得到的数组大小为何是不同的。</p><p>如果 <code>I_1</code> 是二维矩阵，则 <code>X</code> 是 <code>n+1</code> 维数组，其形状为 <code>(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))</code>。矩阵会添加一个维度。</p><p>例如：</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2));

julia&gt; A[[1 2; 1 2]]
2×2 Matrix{Int64}:
 1  2
 1  2

julia&gt; A[[1 2; 1 2], 1, 2, 1]
2×2 Matrix{Int64}:
 5  6
 5  6</code></pre><p>位于 <code>i_1, i_2, i_3, ..., i_{n+1}</code> 处的元素值是 <code>A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]</code>。所有使用标量索引的维度都将被丢弃，例如，假设 <code>J</code> 是索引数组，那么 <code>A[2，J，3]</code> 的结果是一个大小为 <code>size(J)</code> 的数组、其第 j 个元素由 <code>A[2, J[j], 3]</code> 填充。</p><p>作为此语法的特殊部分，<code>end</code> 关键字可用于表示索引括号内每个维度的最后一个索引，由索引的最内层数组的大小决定。没有 <code>end</code> 关键字的索引语法相当于调用<a href="../../base/collections/#Base.getindex"><code>getindex</code></a>：</p><pre><code class="nohighlight hljs">X = getindex(A, I_1, I_2, ..., I_n)</code></pre><p>例如：</p><pre><code class="language-julia-repl hljs">julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[2:3, 2:end-1]
2×2 Matrix{Int64}:
 6  10
 7  11

julia&gt; x[1, [2 3; 4 1]]
2×2 Matrix{Int64}:
  5  9
 13  1</code></pre><h2 id="man-indexed-assignment"><a class="docs-heading-anchor" href="#man-indexed-assignment">索引赋值</a><a id="man-indexed-assignment-1"></a><a class="docs-heading-anchor-permalink" href="#man-indexed-assignment" title="Permalink"></a></h2><p>在 n 维数组 <code>A</code> 中赋值的一般语法是：</p><pre><code class="nohighlight hljs">A[I_1, I_2, ..., I_n] = X</code></pre><p>其中每个 <code>I_k</code> 可以是标量整数，整数数组或任何其他<a href="#man-supported-index-types">支持的索引类型</a>。这包括 <a href="../../base/arrays/#Base.Colon"><code>Colon</code></a> (<code>:</code>) 来选择整个维度中的所有索引，形式为 <code>a:c</code> 或 <code>a:b:c</code> 的范围来选择连续或跨步的子区间，以及布尔数组以选择索引为 <code>true</code> 的元素。</p><p>如果所有 <code>I_k</code> 都为整数，则数组 <code>A</code> 中 <code>I_1, I_2, ..., I_n</code> 位置的值将被 <code>X</code> 的值覆盖，必要时将 <a href="../../base/base/#Base.convert"><code>convert</code></a> 为数组 <code>A</code> 的 <a href="../../base/collections/#Base.eltype"><code>eltype</code></a>。</p><p>如果索引 <code>I_k</code> 本身就是一个数组，那么右侧的 <code>X</code> 也必须是一个与索引 <code>A[I_1, I_2, ..., I_n]</code> 的结果具有相同形状的数组或是具有相同数量元素的向量。 <code>A</code> 的位置 <code>I_1[i_1], I_2[i_2], ..., I_n[i_n]</code> 中的值被值 <code>X[I_1, I_2, ..., I_n]</code> 覆盖，如果必要也会进行类型转换。 元素分配运算符 <code>.=</code> 可以用于沿着所选区域 <a href="#Broadcasting">广播</a> <code>X</code>：</p><pre><code class="nohighlight hljs">A[I_1, I_2, ..., I_n] .= X</code></pre><p>就像在<a href="#man-array-indexing">索引</a>中一样，<code>end</code>关键字可用于表示索引括号中每个维度的最后一个索引，由被赋值的数组大小决定。 没有<code>end</code>关键字的索引赋值语法相当于调用<a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a>：</p><pre><code class="nohighlight hljs">setindex!(A, X, I_1, I_2, ..., I_n)</code></pre><p>例如：</p><pre><code class="language-julia-repl hljs">julia&gt; x = collect(reshape(1:9, 3, 3))
3×3 Matrix{Int64}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; x[3, 3] = -9;

julia&gt; x[1:2, 1:2] = [-1 -4; -2 -5];

julia&gt; x
3×3 Matrix{Int64}:
 -1  -4   7
 -2  -5   8
  3   6  -9</code></pre><h2 id="man-supported-index-types"><a class="docs-heading-anchor" href="#man-supported-index-types">支持的索引类型</a><a id="man-supported-index-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-supported-index-types" title="Permalink"></a></h2><p>在表达式 <code>A[I_1, I_2, ..., I_n]</code> 中，每个 <code>I_k</code> 可以是标量索引，标量索引数组，或者用 <a href="../../base/arrays/#Base.to_indices"><code>to_indices</code></a> 转换成的表示标量索引数组的对象：</p><ol><li>标量索引。默认情况下，这包括：<ul><li>非布尔的整数</li><li><a href="../../base/arrays/#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex{N}</code></a> 用来表达多个维度的信息（详见下文），其内部实际为 N个整数组成的元组。</li></ul></li><li>标量索引数组。这包括：<ul><li>整数向量和多维整数数组</li><li>像 <code>[]</code> 这样的空数组，它不选择任何元素。e.g. <code>A[[]]</code> (not to be confused with <code>A[]</code>)</li><li>如 <code>a:c</code> 或 <code>a:b:c</code> 的范围，从 <code>a</code> 到 <code>c</code>（包括）选择连续或间隔的部分元素</li><li>任何自定义标量索引数组，它是 <code>AbstractArray</code> 的子类型</li><li><code>CartesianIndex{N}</code> 数组（详见下文）</li></ul></li><li>一个表示标量索引数组的对象，可以通过<a href="../../base/arrays/#Base.to_indices"><code>to_indices</code></a>转换为这样的对象。 默认情况下，这包括：<ul><li><a href="../../base/arrays/#Base.Colon"><code>Colon()</code></a> (<code>:</code>)，表示整个维度内或整个数组中的所有索引</li><li>布尔数组，选择其中值为 <code>true</code> 的索引对应的元素（更多细节见下文）</li></ul></li></ol><p>一些例子：</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:2:18), (3, 3))
3×3 Matrix{Int64}:
 1   7  13
 3   9  15
 5  11  17

julia&gt; A[4]
7

julia&gt; A[[2, 5, 8]]
3-element Vector{Int64}:
  3
  9
 15

julia&gt; A[[1 4; 3 8]]
2×2 Matrix{Int64}:
 1   7
 5  15

julia&gt; A[[]]
Int64[]

julia&gt; A[1:2:5]
3-element Vector{Int64}:
 1
 5
 9

julia&gt; A[2, :]
3-element Vector{Int64}:
  3
  9
 15

julia&gt; A[:, 3]
3-element Vector{Int64}:
 13
 15
 17

julia&gt; A[:, 3:3]
3×1 Matrix{Int64}:
 13
 15
 17</code></pre><h3 id="笛卡尔索引"><a class="docs-heading-anchor" href="#笛卡尔索引">笛卡尔索引</a><a id="笛卡尔索引-1"></a><a class="docs-heading-anchor-permalink" href="#笛卡尔索引" title="Permalink"></a></h3><p>特殊的 <code>CartesianIndex{N}</code> 对象表示一个标量索引，其行为类似于张成多个维度的 <code>N</code> 维整数元组。例如：</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(1:32, 4, 4, 2);

julia&gt; A[3, 2, 1]
7

julia&gt; A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true</code></pre><p>单独来看的话，这看起来很平凡：<code>CartesianIndex</code> 单纯只是将多个整数捆绑在一起作为一个对象来表示一个多维下标。当与其他取下标方式和生成 <code>CartesianIndex</code> 的迭代器进行工作的时候，它才真正能展现出它的简洁与高效。关于这个你可以参考 <a href="#Iteration">迭代器</a> 这一部分，你也可以参考 <a href="https://julialang.org/blog/2016/02/iteration">关于多维算法和迭代器的介绍</a> 这篇博客来了解更进阶的用法。</p><p>元素类型为 <code>CartesianIndex{N}</code>  的矩阵也是支持的。每一个元素都单独表示一个 <code>N</code> 维空间的 索引下标，作为一个整体这样一个矩阵则表示一些 <code>N</code> 维空间的点的坐标，因此这种形式有时 也称为逐点索引。例如：你可以通过它来访问上面所定义的三维矩阵  <code>A</code> 的第一页 (第三维指标为1）的对角线元素：</p><pre><code class="language-julia-repl hljs">julia&gt; page = A[:, :, 1]
4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; page[[CartesianIndex(1, 1),
             CartesianIndex(2, 2),
             CartesianIndex(3, 3),
             CartesianIndex(4, 4)]]
4-element Vector{Int64}:
  1
  6
 11
 16</code></pre><p>这可以通过 <a href="../functions/#man-vectorized">dot broadcasting</a> 以及普通整数索引（而不是把从 <code>A</code> 中提取第一“页”作为单独的步骤）更加简单地表达。它甚至可以与 <code>:</code> 结合使用，同时从两个页面中提取两个对角线：</p><pre><code class="language-julia-repl hljs">julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]
4-element Vector{Int64}:
  1
  6
 11
 16

julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]
4×2 Matrix{Int64}:
  1  17
  6  22
 11  27
 16  32</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>CartesianIndex</code> 和 <code>CartesianIndex</code> 数组与用来表示维度的最后一个索引的 <code>end</code> 关键字不兼容。 不要在可能包含<code>CartesianIndex</code>或其数组的索引表达式中使用<code>end</code>。</p></div></div><h3 id="逻辑索引"><a class="docs-heading-anchor" href="#逻辑索引">逻辑索引</a><a id="逻辑索引-1"></a><a class="docs-heading-anchor-permalink" href="#逻辑索引" title="Permalink"></a></h3><p>通常被称为逻辑索引或带有逻辑掩码的索引，通过布尔数组进行索引选择其值为<code>true</code>的索引处的元素。 通过布尔向量<code>B</code>进行索引实际上与通过<a href="../../base/arrays/#Base.findall-Tuple{Any}"><code>findall(B)</code></a>返回的整数向量进行索引相同。 类似地，通过<code>N</code>维布尔数组进行索引与通过其值为<code>true</code>的<code>CartesianIndex{N}</code>的向量进行索引实际上是相同的。 一个逻辑索引必须是一个与它所索引的维度长度相同的向量，或者它必须是唯一提供的索引并且匹配它所索引到的数组的大小和维度。 通常直接使用布尔数组作为索引更有效，而不是调用 <a href="../../base/arrays/#Base.findall-Tuple{Any}"><code>findall</code></a>。</p><pre><code class="language-julia-repl hljs">julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[[false, true, true, false], :]
2×4 Matrix{Int64}:
 2  6  10  14
 3  7  11  15

julia&gt; mask = map(ispow2, x)
4×4 Matrix{Bool}:
 1  0  0  0
 1  0  0  0
 0  0  0  0
 1  1  0  1

julia&gt; x[mask]
5-element Vector{Int64}:
  1
  2
  4
  8
 16</code></pre><h3 id="索引数"><a class="docs-heading-anchor" href="#索引数">索引数</a><a id="索引数-1"></a><a class="docs-heading-anchor-permalink" href="#索引数" title="Permalink"></a></h3><h4 id="笛卡尔索引-2"><a class="docs-heading-anchor" href="#笛卡尔索引-2">笛卡尔索引</a><a class="docs-heading-anchor-permalink" href="#笛卡尔索引-2" title="Permalink"></a></h4><p>通常，为一个N维数组元素使用索引的方式是使用N个数字作为索引，每一个索引值确定一个具体的维度。例如，一个三维数组<code>A = rand(4, 3, 2)</code>, <code>A[2, 3, 1]</code> 将选择的第二行第三列第一“页”中的元素。这种方式通常也被成为笛卡尔索引。</p><h4 id="线性索引"><a class="docs-heading-anchor" href="#线性索引">线性索引</a><a id="线性索引-1"></a><a class="docs-heading-anchor-permalink" href="#线性索引" title="Permalink"></a></h4><p>当恰好提供了一个索引<code>i</code>时，该索引不再表示数组特定维度中的位置。 相反，它使用线性遍历整个数组的列主迭代顺序选择第 <code>i</code> 个元素。 这称为<em>线性索引</em>。 它本质上将数组视为使用 <a href="../../base/arrays/#Base.vec"><code>vec</code></a> 将其重新整形为一维向量。</p><pre><code class="language-julia-repl hljs">julia&gt; A = [2 6; 4 7; 3 1]
3×2 Matrix{Int64}:
 2  6
 4  7
 3  1

julia&gt; A[5]
7

julia&gt; vec(A)[5]
7</code></pre><p>数组 <code>A</code> 中的线性索引可以转换为 <code>CartesianIndex</code> 以使用 <code>CartesianIndices(A)[i]</code> 进行笛卡尔索引（参见 <a href="../../base/arrays/#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a>），一组 <code>N</code> 维笛卡尔索引可以通过<code>LinearIndices(A)[i_1, i_2, ..., i_N]</code> 转换为线性索引（参见<a href="../../base/arrays/#Base.LinearIndices"><code>LinearIndices</code></a>）。</p><pre><code class="language-julia-repl hljs">julia&gt; CartesianIndices(A)[5]
CartesianIndex(2, 2)

julia&gt; LinearIndices(A)[2, 2]
5</code></pre><p>需要注意的是，这些转换的性能存在很大的不对称性。 将线性索引转换为一组笛卡尔索引需要做除法取余数，而相反的转换只是相乘和相加。在现代处理器中，整数除法比乘法慢 10-50 倍。 虽然一些数组——比如 <a href="../../base/arrays/#Core.Array"><code>Array</code></a> 本身——是使用线性内存块实现的，并在它们的实现中直接使用线性索引，但其他数组——比如 <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.Diagonal"><code>Diagonal</code></a>——需要完整的笛卡尔索引集进行查找 （请参阅 <a href="../../base/arrays/#Base.IndexStyle"><code>IndexStyle</code></a> 以仔细推敲）。 （译者注：OffsetArrays.jl是Julia的一个包，支持矩阵的下标不从1开始）。</p><div class="admonition is-category-warnings"><header class="admonition-header">Warnings</header><div class="admonition-body"><p>When iterating over all the indices for an array, it is better to iterate over <a href="../../base/arrays/#Base.eachindex"><code>eachindex(A)</code></a> instead of <code>1:length(A)</code>. Not only will this be faster in cases where <code>A</code> is <code>IndexCartesian</code>, but it will also support arrays with custom indexing, such as <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays</a>. If only the values are needed, then is better to just iterate the array directly, i.e. <code>for a in A</code>.</p></div></div><h4 id="Omitted-and-extra-indices"><a class="docs-heading-anchor" href="#Omitted-and-extra-indices">省略和额外的索引</a><a id="Omitted-and-extra-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Omitted-and-extra-indices" title="Permalink"></a></h4><p>除了线性索引，在某些情况下， <code>N</code> 维数组的可能少于或多余  <code>N</code> 。</p><p>如果未索引的剩余维度的长度均为 1，则可以省略索引。 换句话说，只有当那些省略的索引对于索引表达式只有一个可能的值时，才可以省略剩余索引。 例如，一个大小为<code>(3, 4, 2, 1)</code>的四维数组可能只用三个索引进行索引，因为被跳过的维度（第四维）的长度为 1。 请注意，线性索引优先级高于此规则。</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(1:24, 3, 4, 2, 1)
3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64:
[:, :, 1, 1] =
 1  4  7  10
 2  5  8  11
 3  6  9  12

[:, :, 2, 1] =
 13  16  19  22
 14  17  20  23
 15  18  21  24

julia&gt; A[1, 3, 2] # Omits the fourth dimension (length 1)
19

julia&gt; A[1, 3] # Attempts to omit dimensions 3 &amp; 4 (lengths 2 and 1)
ERROR: BoundsError: attempt to access 3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64 at index [1, 3]

julia&gt; A[19] # Linear indexing
19</code></pre><p>当用<code>A[]</code> 省略<em>全部</em> 索引时，这种语义提供了一种简单的习惯用法来检索数组中的唯一元素，同时确保只有一个元素。</p><p>类似地，如果超出数组维数的所有索引都是<code>1</code>（或更一般地说是<code>axes(A, d)</code>的第一个也是唯一的元素，其中<code>d</code>是特定的维数），可以使用超过<code>N</code>维的索引。这允许向量像一列矩阵一样被索引，例如：</p><pre><code class="language-julia-repl hljs">julia&gt; A = [8,6,7]
3-element Vector{Int64}:
 8
 6
 7

julia&gt; A[2,1]
6</code></pre><h2 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">迭代</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h2><p>迭代整个数组的推荐方法是</p><pre><code class="language-julia hljs">for a in A
    # Do something with the element a
end

for i in eachindex(A)
    # Do something with i and/or A[i]
end</code></pre><p>当你需要每个元素的值而不是索引时，使用第一个构造。 在第二个构造中，如果 <code>A</code> 是具有快速线性索引的数组类型，<code>i</code> 将是 <code>Int</code>; 否则，它将是一个 <code>CartesianIndex</code>：</p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(4, 3);

julia&gt; B = view(A, 1:3, 2:3);

julia&gt; for i in eachindex(B)
           @show i
       end
i = CartesianIndex(1, 1)
i = CartesianIndex(2, 1)
i = CartesianIndex(3, 1)
i = CartesianIndex(1, 2)
i = CartesianIndex(2, 2)
i = CartesianIndex(3, 2)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In contrast with <code>for i = 1:length(A)</code>, iterating with <a href="../../base/arrays/#Base.eachindex"><code>eachindex</code></a> provides an efficient way to iterate over any array type. Besides, this also supports generic arrays with custom indexing such as <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays</a>.</p></div></div><h2 id="Array-traits"><a class="docs-heading-anchor" href="#Array-traits">Array traits</a><a id="Array-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Array-traits" title="Permalink"></a></h2><p>如果你编写一个自定义的 <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray</code></a> 类型，你可以用以下代码指定它使用快速线性索引</p><pre><code class="language-julia hljs">Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</code></pre><p>此设置将导致 <code>myArray</code> 上的 <code>eachindex</code> 迭代使用整数。如果未指定此特征，则使用默认值 <code>IndexCartesian()</code>。</p><h2 id="man-array-and-vectorized-operators-and-functions"><a class="docs-heading-anchor" href="#man-array-and-vectorized-operators-and-functions">数组和向量化的算子与函数</a><a id="man-array-and-vectorized-operators-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#man-array-and-vectorized-operators-and-functions" title="Permalink"></a></h2><p>以下运算符支持对数组操作</p><ol><li>一元运算符 – <code>-</code>, <code>+</code></li><li>二元运算符 – <code>-</code>, <code>+</code>, <code>*</code>, <code>/</code>, <code>\</code>, <code>^</code></li><li>比较操作符 – <code>==</code>, <code>!=</code>, <code>≈</code> (<a href="../../base/math/#Base.isapprox"><code>isapprox</code></a>), <code>≉</code></li></ol><p>另外，为了便于数学上和其他运算的向量化，Julia <a href="../functions/#man-vectorized">提供了点语法（dot syntax）</a> <code>f.(args...)</code>，例如，<code>sin.(x)</code> 或 <code>min.(x,y)</code>，用于数组或数组和标量的混合上的按元素运算（<a href="#Broadcasting">广播</a>运算）；当与其他点调用（dot call）结合使用时，它们的额外优点是能「融合」到单个循环中，例如，<code>sin.(cos.(x))</code>。</p><p>此外，<em>每个</em>二元运算符支持相应的<a href="../mathematical-operations/#man-dot-operators">点操作版本</a>，可以应用于此类<a href="../functions/#man-vectorized">融合 broadcasting 操作</a>的数组（以及数组和标量的组合），例如 <code>z .== sin.(x .* y)</code>。</p><p>请注意，类似 <code>==</code> 的比较运算在作用于整个数组时，得到一个布尔结果。使用像 <code>.==</code> 这样的点运算符进行按元素的比较。（对于像 <code>&lt;</code> 这样的比较操作，<em>只有</em>按元素运算的版本 <code>.&lt;</code> 适用于数组。）</p><p>还要注意 <code>max.(a,b)</code> 和 <a href="../../base/collections/#Base.maximum"><code>maximum(a)</code></a> 之间的区别，<code>max.(a,b)</code> 对 <code>a</code> 和 <code>b</code> 的每个元素 <a href="../../base/arrays/#Base.Broadcast.broadcast"><code>broadcast</code></a>s <a href="../../base/math/#Base.max"><code>max</code></a>，<a href="../../base/collections/#Base.maximum"><code>maximum(a)</code></a> 寻找在 <code>a</code> 中的最大值。<code>min.(a,b)</code> 和 <code>minimum(a)</code> 也有同样的关系。</p><h2 id="Broadcasting"><a class="docs-heading-anchor" href="#Broadcasting">广播</a><a id="Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting" title="Permalink"></a></h2><p>有时需要在不同尺寸的数组上执行元素对元素的操作，例如将矩阵的每一列加一个向量。一种低效的方法是将向量复制成矩阵的大小：</p><pre><code class="language-julia-repl hljs">julia&gt; a = rand(2, 1); A = rand(2, 3);

julia&gt; repeat(a, 1, 3) + A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846</code></pre><p>当维度较大的时候，这种方法将会十分浪费，所以 Julia 提供了广播 <a href="../../base/arrays/#Base.Broadcast.broadcast"><code>broadcast</code></a>，它将会将参数中低维度的参数扩展，使得其与其他维度匹配，且不会使用额外的内存，并将所给的函数逐元素地应用。</p><pre><code class="language-julia-repl hljs">julia&gt; broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia&gt; b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia&gt; broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631</code></pre><p><a href="../mathematical-operations/#man-dot-operators">点运算符</a> 如<code>.+</code> 和<code>.*</code> 等价于<code>broadcast</code> 调用（除了它们结合使用，<a href="#man-array-and-vectorized-operators-and-functions">如上所述</a>）。 还有一个 <a href="../../base/arrays/#Base.Broadcast.broadcast!"><code>broadcast!</code></a> 函数来指定一个明确的方式（也可以通过<code>.=</code> 赋值以融合方式访问）。 事实上，<code>f.(args...)</code> 等价于<code>broadcast(f, args...)</code>，提供了一种方便的语法来广播任何函数(<a href="../functions/#man-vectorized">dot syntax</a>)。 嵌套的“点运算符调用”<code>f.(...)</code>（包括对<code>.+</code> 等的调用）<a href="../mathematical-operations/#man-dot-operators">自动融合</a> 到单个<code>broadcast</code> 调用中。</p><p>此外，<a href="../../base/arrays/#Base.Broadcast.broadcast"><code>broadcast</code></a> 不限于数组（参见函数文档）； 它还处理标量、元组和其它容器。 默认情况下，只有一些参数类型被认为是标量，包括（但不限于）<code>Number</code>s、<code>String</code>s、<code>Symbol</code>s、<code>Type</code>s、<code>Function</code>s 和一些常见的单例，如 <code>missing</code> 和<code>nothing</code>。 所有其他参数都被迭代或逐个索引。</p><pre><code class="language-julia-repl hljs">julia&gt; convert.(Float32, [1, 2])
2-element Vector{Float32}:
 1.0
 2.0

julia&gt; ceil.(UInt8, [1.2 3.4; 5.6 6.7])
2×2 Matrix{UInt8}:
 0x02  0x04
 0x06  0x07

julia&gt; string.(1:3, &quot;. &quot;, [&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;])
3-element Vector{String}:
 &quot;1. First&quot;
 &quot;2. Second&quot;
 &quot;3. Third&quot;</code></pre><p>有时，你希望一个通常参与广播的容器（如数组）受到“保护”，使其免受广播迭代其所有元素的行为的影响。 通过将其放置在另一个容器中（如单个元素 <a href="../../base/base/#Core.Tuple"><code>Tuple</code></a>），广播会将其视为单个值。</p><pre><code class="language-julia-repl hljs">julia&gt; ([1, 2, 3], [4, 5, 6]) .+ ([1, 2, 3],)
([2, 4, 6], [5, 7, 9])

julia&gt; ([1, 2, 3], [4, 5, 6]) .+ tuple([1, 2, 3])
([2, 4, 6], [5, 7, 9])</code></pre><h2 id="实现"><a class="docs-heading-anchor" href="#实现">实现</a><a id="实现-1"></a><a class="docs-heading-anchor-permalink" href="#实现" title="Permalink"></a></h2><p>Julia 中的基本数组类型是抽象类型 <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray{T,N}</code></a>。它通过维数 <code>N</code> 和元素类型 <code>T</code> 进行参数化。<a href="../../base/arrays/#Base.AbstractVector"><code>AbstractVector</code></a> 和 <a href="../../base/arrays/#Base.AbstractMatrix"><code>AbstractMatrix</code></a> 是一维和二维情况下的别名。<code>AbstractArray</code> 对象的操作是使用更高级别的运算符和函数定义的，其方式独立于底层存储。这些操作可以正确地被用于任何特定数组实现的回退操作。</p><p><code>AbstractArray</code> 类型包括任何类似数组的东西，它的实现可能与传统数组完全不同。例如，元素可能根据请求计算而不是存储。然而，任何具体的 <code>AbstractArray{T,N}</code> 类型通常应该至少实现 <a href="../../base/arrays/#Base.size"><code>size(A)</code></a>（返回一个 <code>Int</code> 元组），<a href="../../base/arrays/#Base.getindex-Tuple{Type, Vararg{Any}}"><code>getindex(A,i)</code></a> 和 <a href="../../base/collections/#Base.getindex"><code>getindex(A,i1,...,iN)</code></a>;可变数组也应该实现 <a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a>。建议这些操作具有常数时间复杂度，否则某些数组函数可能会出乎意料的慢。具体类型通常还应该提供一个 <a href="../../base/arrays/#Base.similar"><code>similar(A,T=eltype(A),dims=size(A))</code></a> 方法，用于为 <a href="../../base/base/#Base.copy"><code>copy</code></a> 和其他不合适的操作。无论 <code>AbstractArray{T,N}</code> 在内部如何表示，<code>T</code> 都是由 <em>整数</em> 索引（<code>A[1, ..., 1]</code>，当 <code>A</code> 非空） 返回的对象类型并且 <code>N</code> 应该是 <a href="../../base/arrays/#Base.size"><code>size</code></a> 返回的元组的长度。有关自定义 <code>AbstractArray</code> 实现的更多详细信息，请参阅 <a href="../interfaces/#man-interface-array">接口章节中的数组接口指南</a>。</p><p><code>DenseArray</code> 是 <code>AbstractArray</code> 的抽象子类型，旨在包括元素以列优先顺序连续存储的所有数组（请参阅 <a href="../performance-tips/#man-performance-column-major">性能提示中的附加说明</a>）。 <a href="../../base/arrays/#Core.Array"><code>Array</code></a> 类型是<code>DenseArray</code> 的一个特定实例； <a href="../../base/arrays/#Base.Vector"><code>Vector</code></a> 和 <a href="../../base/arrays/#Base.Matrix"><code>Matrix</code></a> 是一维和二维情况的别名。 除了所有<code>AbstractArray</code>s所需的操作之外，很少有专门为<code>Array</code>实现的操作；大部分数组库都是以泛型方式实现的，允许所有自定义数组的行为类似。</p><p><code>SubArray</code> 是 <code>AbstractArray</code> 的特例，它通过与原始数组共享内存而不是复制它来执行索引。 使用<a href="../../base/arrays/#Base.view"><code>view</code></a> 函数创建 <code>SubArray</code>，它的调用方式与<a href="../../base/collections/#Base.getindex"><code>getindex</code></a> 相同（作用于数组和一系列索引参数）。 <a href="../../base/arrays/#Base.view"><code>view</code></a> 的结果看起来与 <a href="../../base/collections/#Base.getindex"><code>getindex</code></a> 的结果相同，只是数据保持不变。 <a href="../../base/arrays/#Base.view"><code>view</code></a> 将输入索引向量存储在 <code>SubArray</code> 对象中，该对象稍后可用于间接索引原始数组。 通过将  <a href="../../base/arrays/#Base.@views"><code>@views</code></a> 宏放在表达式或代码块之前，该表达式中的任何 <code>array [...]</code> 切片将被转换为创建一个 <code>SubArray</code> 视图。</p><p><a href="../../base/arrays/#Base.BitArray"><code>BitArray</code></a> 是节省空间“压缩”的布尔数组，每个比特（bit）存储一个布尔值。 它们可以类似于 <code>Array{Bool}</code> 数组（每个字节（byte）存储一个布尔值），并且可以分别通过 <code>Array(bitarray)</code> 和 <code>BitArray(array)</code> 相互转换。</p><p>如果数组存储在内存中，其元素之间具有明确定义的间距（步长），则该数组是“等步长的”的。 通过简单地传递其 <a href="../../base/c/#Base.pointer"><code>pointer</code></a> 和每个维度的步长，可以将有支持元素类型的等步长数组传递给外部（非 Julia）库，如 BLAS 或 LAPACK。 <a href="../../base/arrays/#Base.stride"><code>stride(A, d)</code></a> 是元素之间沿维度 <code>d</code> 的距离。 例如，<code>rand(5,7,2)</code> 返回的内置 <code>Array</code> 的元素按列优先顺序连续排列。 这意味着第一个维度的步长——同一列中元素之间的间距——是<code>1</code>：</p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(5, 7, 2);

julia&gt; stride(A, 1)
1</code></pre><p>第二个维度的步长是同一行中元素之间的间距，跳过与单列（<code>5</code>）中的元素一样多的元素。 类似地，在两个“页面”（在第三维中）之间跳转需要跳过 <code>5*7 == 35</code> 元素。 这个数组的 <a href="../../base/arrays/#Base.strides"><code>strides</code></a> 是这三个数字组成的元组：</p><pre><code class="language-julia-repl hljs">julia&gt; strides(A)
(1, 5, 35)</code></pre><p>在这种特殊情况下，在<em>内存</em>中跳过的元素数与跳过的<em>线性索引</em>数相匹配。 这仅适用于像 <code>Array</code>（和其他 <code>DenseArray</code> 子类型）这样的连续数组，通常情况下并非如此。 具有范围索引的视图是 <em>非连续</em> 等步长数组的一个很好的例子； 考虑<code>V = @view A[1:3:4, 2:2:6, 2:-1:1]</code>。 这个视图 <code>V</code> 与 <code>A</code> 引用了相同的内存，但它跳过并重新排列了它的一些元素。 <code>V</code> 的第一维的步幅是 <code>3</code>，因为我们只从原始数组中选择每第三行：</p><pre><code class="language-julia-repl hljs">julia&gt; V = @view A[1:3:4, 2:2:6, 2:-1:1];

julia&gt; stride(V, 1)
3</code></pre><p>这个视图类似于从我们原来的<code>A</code>中每隔一列选择一列——因此当在第二维的索引之间移动时，它需要跳过相当于两个五元素列的内容：</p><pre><code class="language-julia-repl hljs">julia&gt; stride(V, 2)
10</code></pre><p>第三维很有趣因为它的顺序颠倒了! 因此从第一 &quot;页&quot; 到第二页它必须在内存中到 <em>backwards</em>，所以它在这一维的 strides 是负的!</p><pre><code class="language-julia-repl hljs">julia&gt; stride(V, 3)
-35</code></pre><p>这意味着<code>V</code> 的<code>pointer</code> 实际上指向<code>A</code> 的内存块的中间，并且它在内存中指向元素是同时向后和向前的。 有关定义你自己的跨距数组的更多详细信息，请参阅 <a href="../interfaces/#man-interface-strided-arrays">等步长数组的接口指南</a>。 <a href="../../base/arrays/#Base.StridedVector"><code>StridedVector</code></a> 和 <a href="../../base/arrays/#Base.StridedMatrix"><code>StridedMatrix</code></a> 被认为是等步长数组的内置数组类型的方便别名，允许它们仅使用指针和步幅，来分派选择调用调整和优化后的 BLAS 和 LAPACK 函数。</p><p>需要强调的是 strides 是关于内存而不是索引中的偏移。如果你在找在线性（单索引）索引和笛卡尔（多索引）索引间切换的方法，见 <a href="../../base/arrays/#Base.LinearIndices"><code>LinearIndices</code></a> 和 <a href="../../base/arrays/#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a>.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><em>iid</em>，独立同分布</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../metaprogramming/">« 元编程</a><a class="docs-footer-nextpage" href="../missing/">缺失值 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>本文档在 <span class="colophon-date" title="2024 十二月 26 周四 08:52">2024 十二月 26 周四</span>用 <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> 1.8.0 版生成使用 1.10.7 版本的 Julia。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
