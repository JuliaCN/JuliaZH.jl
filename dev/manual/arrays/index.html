<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>多维数组 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/arrays/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li class="is-active"><a class="tocitem" href>多维数组</a><ul class="internal"><li><a class="tocitem" href="#基本函数-1"><span>基本函数</span></a></li><li><a class="tocitem" href="#构造和初始化-1"><span>构造和初始化</span></a></li><li><a class="tocitem" href="#man-array-literals-1"><span>Array literals</span></a></li><li><a class="tocitem" href="#man-comprehensions-1"><span>Comprehensions</span></a></li><li><a class="tocitem" href="#生成器表达式-1"><span>生成器表达式</span></a></li><li><a class="tocitem" href="#man-array-indexing-1"><span>索引</span></a></li><li><a class="tocitem" href="#man-indexed-assignment-1"><span>Indexed Assignment</span></a></li><li><a class="tocitem" href="#man-supported-index-types-1"><span>支持的索引类型</span></a></li><li><a class="tocitem" href="#迭代-1"><span>迭代</span></a></li><li><a class="tocitem" href="#Array-traits-1"><span>Array traits</span></a></li><li><a class="tocitem" href="#数组、向量化操作符及函数-1"><span>数组、向量化操作符及函数</span></a></li><li><a class="tocitem" href="#广播-1"><span>广播</span></a></li><li><a class="tocitem" href="#实现-1"><span>实现</span></a></li></ul></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">分布式计算</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">交互式组件</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>多维数组</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>多维数组</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/arraysmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="man-multi-dim-arrays-1"><a class="docs-heading-anchor" href="#man-multi-dim-arrays-1">多维数组</a><a class="docs-heading-anchor-permalink" href="#man-multi-dim-arrays-1" title="Permalink"></a></h1><p>与大多数技术计算语言一样，Julia 提供原生的数组实现。 大多数技术计算语言非常重视其数组实现，但需要付出使用其它容器的代价。Julia 用同样的方式来处理数组。就像和其它用 Julia 写的代码一样，Julia 的数组库几乎完全是用 Julia 自身实现的，它的性能源自编译器。这样一来，用户就可以通过继承 <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray</code></a> 的方式来创建自定义数组类型。 实现自定义数组类型的更多详细信息，请参阅<a href="../interfaces/#man-interface-array-1">manual section on the AbstractArray interface</a>。</p><p>数组是存储在多维网格中对象的集合。在最一般的情况下， 数组中的对象可能是 <a href="../../base/base/#Core.Any"><code>Any</code></a> 类型。 对于大多数计算上的需求，数组中对象的类型应该更加具体，例如 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> 或 <a href="../../base/numbers/#Core.Int32"><code>Int32</code></a>。</p><p>一般来说，与许多其他科学计算语言不同，Julia 不希望为了性能而以向量化的方式编写程序。Julia 的编译器使用类型推断，并为标量数组索引生成优化的代码，从而能够令用户方便地编写可读性良好的程序，而不牺牲性能，并且时常会减少内存使用。</p><p>在 Julia 中，所有函数的参数都是 <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing">passed by sharing</a>。一些科学计算语言用传值的方式传递数组，尽管这样做可以防止数组在被调函数中被意外地篡改，但这也会导致不必要的数组拷贝。通常，以一个 <code>!</code> 结尾的函数名表示它会对自己的一个或者多个参数的值进行修改或者销毁（例如，请比较 <a href="../../base/sort/#Base.sort"><code>sort</code></a> 和 <a href="../../base/sort/#Base.sort!"><code>sort!</code></a>）。被调函数必须进行显式拷贝，以确保它们不会无意中修改输入参数。很多 “non-mutating” 函数在实现的时候，都会先进行显式拷贝，然后调用一个以 <code>!</code> 结尾的同名函数，最后返回之前拷贝的副本。</p><h2 id="基本函数-1"><a class="docs-heading-anchor" href="#基本函数-1">基本函数</a><a class="docs-heading-anchor-permalink" href="#基本函数-1" title="Permalink"></a></h2><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><a href="../../base/collections/#Base.eltype"><code>eltype(A)</code></a></td><td style="text-align: left"><code>A</code> 中元素的类型</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.length-Tuple{AbstractArray}"><code>length(A)</code></a></td><td style="text-align: left"><code>A</code> 中元素的数量</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.ndims"><code>ndims(A)</code></a></td><td style="text-align: left"><code>A</code> 的维数</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.size"><code>size(A)</code></a></td><td style="text-align: left">一个包含 <code>A</code> 各个维度上元素数量的元组</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.size"><code>size(A,n)</code></a></td><td style="text-align: left"><code>A</code> 第 <code>n</code> 维中的元素数量</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.axes-Tuple{Any}"><code>axes(A)</code></a></td><td style="text-align: left">一个包含 <code>A</code> 有效索引的元组</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.axes-Tuple{Any}"><code>axes(A,n)</code></a></td><td style="text-align: left">第 <code>n</code> 维有效索引的范围</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.eachindex"><code>eachindex(A)</code></a></td><td style="text-align: left">一个访问 <code>A</code> 中每一个位置的高效迭代器</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.stride"><code>stride(A,k)</code></a></td><td style="text-align: left">在第 <code>k</code> 维上的间隔（stride）（相邻元素间的线性索引距离）</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.strides"><code>strides(A)</code></a></td><td style="text-align: left">包含每一维上的间隔（stride）的元组</td></tr></table><h2 id="构造和初始化-1"><a class="docs-heading-anchor" href="#构造和初始化-1">构造和初始化</a><a class="docs-heading-anchor-permalink" href="#构造和初始化-1" title="Permalink"></a></h2><p>Julia 提供了许多用于构造和初始化数组的函数。在下列函数中，参数 <code>dims ...</code> 可以是一个包含维数大小的元组，也可以表示用任意个参数传递的一系列维数大小值。大部分函数的第一个参数都表示数组的元素类型 <code>T</code> 。如果类型 <code>T</code> 被省略，那么将默认为 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>。</p><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Core.Array"><code>Array{T}(undef, dims...)</code></a></td><td style="text-align: left">一个没有初始化的密集 <a href="../../base/arrays/#Core.Array"><code>Array</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.zeros"><code>zeros(T, dims...)</code></a></td><td style="text-align: left">一个全零 <code>Array</code></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.ones"><code>ones(T, dims...)</code></a></td><td style="text-align: left">一个元素均为 1 的 <code>Array</code></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.trues"><code>trues(dims...)</code></a></td><td style="text-align: left">一个每个元素都为 <code>true</code> 的 <a href="../../base/arrays/#Base.BitArray"><code>BitArray</code></a></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.falses"><code>falses(dims...)</code></a></td><td style="text-align: left">一个每个元素都为 <code>false</code> 的 <code>BitArray</code></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.reshape"><code>reshape(A, dims...)</code></a></td><td style="text-align: left">一个包含跟 <code>A</code> 相同数据但维数不同的数组</td></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.copy"><code>copy(A)</code></a></td><td style="text-align: left">拷贝 <code>A</code></td></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.deepcopy"><code>deepcopy(A)</code></a></td><td style="text-align: left">深拷贝，即拷贝 <code>A</code>，并递归地拷贝其元素</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.similar"><code>similar(A, T, dims...)</code></a></td><td style="text-align: left">一个与<code>A</code>具有相同类型（这里指的是密集，稀疏等）的未初始化数组，但具有指定的元素类型和维数。第二个和第三个参数都是可选的，如果省略则默认为元素类型和 <code>A</code> 的维数。</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.reinterpret"><code>reinterpret(T, A)</code></a></td><td style="text-align: left">与 <code>A</code> 具有相同二进制数据的数组，但元素类型为 <code>T</code></td></tr><tr><td style="text-align: left"><a href="../../stdlib/Random/#Base.rand"><code>rand(T, dims...)</code></a></td><td style="text-align: left">一个随机 <code>Array</code>，元素值是 <span>$[0, 1)$</span> 半开区间中的均匀分布且服从一阶独立同分布 <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></td></tr><tr><td style="text-align: left"><a href="../../stdlib/Random/#Base.randn"><code>randn(T, dims...)</code></a></td><td style="text-align: left">一个随机 <code>Array</code>，元素为标准正态分布，服从独立同分布</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.Matrix"><code>Matrix{T}(I, m, n)</code></a></td><td style="text-align: left"><code>m</code>-by-<code>n</code> identity matrix (requires <code>using LinearAlgebra</code>)</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.range"><code>range(start, stop=stop, length=n)</code></a></td><td style="text-align: left">从 <code>start</code> 到 <code>stop</code> 的带有 <code>n</code> 个线性间隔元素的范围</td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.fill!"><code>fill!(A, x)</code></a></td><td style="text-align: left">用值 <code>x</code> 填充数组 <code>A</code></td></tr><tr><td style="text-align: left"><a href="../../base/arrays/#Base.fill"><code>fill(x, dims...)</code></a></td><td style="text-align: left">一个被值 <code>x</code> 填充的 <code>Array</code></td></tr></table><p>To see the various ways we can pass dimensions to these functions, consider the following examples:</p><pre><code class="language-julia-repl">julia&gt; zeros(Int8, 2, 3)
2×3 Array{Int8,2}:
 0  0  0
 0  0  0

julia&gt; zeros(Int8, (2, 3))
2×3 Array{Int8,2}:
 0  0  0
 0  0  0

julia&gt; zeros((2, 3))
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>Here, <code>(2, 3)</code> is a <a href="../../base/base/#Core.Tuple"><code>Tuple</code></a> and the first argument — the element type — is optional, defaulting to <code>Float64</code>.</p><h2 id="man-array-literals-1"><a class="docs-heading-anchor" href="#man-array-literals-1">Array literals</a><a class="docs-heading-anchor-permalink" href="#man-array-literals-1" title="Permalink"></a></h2><p>Arrays can also be directly constructed with square braces; the syntax <code>[A, B, C, ...]</code> creates a one dimensional array (i.e., a vector) containing the comma-separated arguments as its elements. The element type (<a href="../../base/collections/#Base.eltype"><code>eltype</code></a>) of the resulting array is automatically determined by the types of the arguments inside the braces. If all the arguments are the same type, then that is its <code>eltype</code>. If they all have a common <a href="../conversion-and-promotion/#conversion-and-promotion-1">promotion type</a> then they get converted to that type using <a href="../../base/base/#Base.convert"><code>convert</code></a> and that type is the array&#39;s <code>eltype</code>. Otherwise, a heterogeneous array that can hold anything — a <code>Vector{Any}</code> — is constructed; this includes the literal <code>[]</code> where no arguments are given.</p><pre><code class="language-julia-repl">julia&gt; [1,2,3] # An array of `Int`s
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; promote(1, 2.3, 4//5) # This combination of Int, Float64 and Rational promotes to Float64
(1.0, 2.3, 0.8)

julia&gt; [1, 2.3, 4//5] # Thus that&#39;s the element type of this Array
3-element Array{Float64,1}:
 1.0
 2.3
 0.8

julia&gt; []
0-element Array{Any,1}</code></pre><h3 id="man-array-concatenation-1"><a class="docs-heading-anchor" href="#man-array-concatenation-1">Concatenation</a><a class="docs-heading-anchor-permalink" href="#man-array-concatenation-1" title="Permalink"></a></h3><p>If the arguments inside the square brackets are separated by semicolons (<code>;</code>) or newlines instead of commas, then their contents are <em>vertically concatenated</em> together instead of the arguments being used as elements themselves.</p><pre><code class="language-julia-repl">julia&gt; [1:2, 4:5] # Has a comma, so no concatenation occurs. The ranges are themselves the elements
2-element Array{UnitRange{Int64},1}:
 1:2
 4:5

julia&gt; [1:2; 4:5]
4-element Array{Int64,1}:
 1
 2
 4
 5

julia&gt; [1:2; 4:5]
4-element Array{Int64,1}:
 1
 2
 4
 5

julia&gt; [1:2
        4:5
        6]
5-element Array{Int64,1}:
 1
 2
 4
 5
 6</code></pre><p>Similarly, if the arguments are separated by tabs or spaces, then their contents are <em>horizontally concatenated</em> together.</p><pre><code class="language-julia-repl">julia&gt; [1:2  4:5  7:8]
2×3 Array{Int64,2}:
 1  4  7
 2  5  8

julia&gt; [[1,2]  [4,5]  [7,8]]
2×3 Array{Int64,2}:
 1  4  7
 2  5  8

julia&gt; [1 2 3] # Numbers can also be horizontally concatenated
1×3 Array{Int64,2}:
 1  2  3</code></pre><p>Using semicolons (or newlines) and spaces (or tabs) can be combined to concatenate both horizontally and vertically at the same time.</p><pre><code class="language-julia-repl">julia&gt; [1 2
        3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; [zeros(Int, 2, 2) [1; 2]
        [3 4]            5]
3×3 Array{Int64,2}:
 0  0  1
 0  0  2
 3  4  5</code></pre><p>More generally, concatenation can be accomplished through the <a href="../../base/arrays/#Base.cat"><code>cat</code></a> function. These syntaxes are shorthands for function calls that themselves are convenience functions:</p><table><tr><th style="text-align: left">语法</th><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="../../base/arrays/#Base.cat"><code>cat</code></a></td><td style="text-align: left">沿着 s 的第 <code>k</code> 维拼接数组</td></tr><tr><td style="text-align: left"><code>[A; B; C; ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.vcat"><code>vcat</code></a></td><td style="text-align: left">shorthand for `cat(A...; dims=1)</td></tr><tr><td style="text-align: left"><code>[A B C ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.hcat"><code>hcat</code></a></td><td style="text-align: left">shorthand for `cat(A...; dims=2)</td></tr><tr><td style="text-align: left"><code>[A B; C D; ...]</code></td><td style="text-align: left"><a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a></td><td style="text-align: left">simultaneous vertical and horizontal concatenation</td></tr></table><h3 id="Typed-array-literals-1"><a class="docs-heading-anchor" href="#Typed-array-literals-1">Typed array literals</a><a class="docs-heading-anchor-permalink" href="#Typed-array-literals-1" title="Permalink"></a></h3><p>可以用 <code>T[A, B, C, ...]</code> 的方式声明一个元素为某种特定类型的数组。该方法定义一个元素类型为 <code>T</code> 的一维数组并且初始化元素为 <code>A</code>, <code>B</code>, <code>C</code>, ....。比如，<code>Any[x, y, z]</code> 会构建一个异构数组，该数组可以包含任意类型的元素。</p><p>类似的，拼接也可以用类型为前缀来指定结果的元素类型。</p><pre><code class="language-julia-repl">julia&gt; [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4</code></pre><h2 id="man-comprehensions-1"><a class="docs-heading-anchor" href="#man-comprehensions-1">Comprehensions</a><a class="docs-heading-anchor-permalink" href="#man-comprehensions-1" title="Permalink"></a></h2><p>（数组）推导提供了构造数组的通用且强大的方法。其语法类似于数学中的集合构造的写法：</p><pre><code class="language-none">A = [ F(x,y,...) for x=rx, y=ry, ... ]</code></pre><p>这种形式的含义是 <code>F(x,y,...)</code> 取其给定列表中变量 <code>x</code>，<code>y</code> 等的每个值进行计算。值可以指定为任何可迭代对象，但通常是 <code>1:n</code> 或 <code>2:(n-1)</code> 之类的范围，或者像 <code>[1.2, 3.4, 5.7]</code> 这样的显式数组值。结果是一个 N 维密集数组，其维数是变量范围 <code>rx</code>，<code>ry</code> 等的维数串联。每次 <code>F(x,y,...)</code> 计算返回一个标量。</p><p>下面的示例计算当前元素和沿一维网格其左，右相邻元素的加权平均值：</p><pre><code class="language-julia-repl">julia&gt; x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia&gt; [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511</code></pre><p>The resulting array type depends on the types of the computed elements just like <a href="#man-array-literals-1">array literals</a> do. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:</p><pre><code class="language-julia">Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]</code></pre><h2 id="生成器表达式-1"><a class="docs-heading-anchor" href="#生成器表达式-1">生成器表达式</a><a class="docs-heading-anchor-permalink" href="#生成器表达式-1" title="Permalink"></a></h2><p>也可以在没有方括号的情况下编写（数组）推导，从而产生称为生成器的对象。可以迭代此对象以按需生成值，而不是预先分配数组并存储它们（请参阅 <a href="#迭代-1">迭代</a>）。例如，以下表达式在不分配内存的情况下对一个序列进行求和：</p><pre><code class="language-julia-repl">julia&gt; sum(1/n^2 for n=1:1000)
1.6439345666815615</code></pre><p>在参数列表中使用具有多个维度的生成器表达式时，需要使用括号将生成器与后续参数分开：</p><pre><code class="language-julia-repl">julia&gt; map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification</code></pre><p><code>for</code> 后面所有逗号分隔的表达式都被解释为范围。 添加括号让我们可以向 <a href="../../base/collections/#Base.map"><code>map</code></a> 中添加第三个参数：</p><pre><code class="language-julia-repl">julia&gt; map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)</code></pre><p>Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be &quot;captured&quot; in the inner function.  For example, <code>sum(p[i] - q[i] for i=1:n)</code> captures the three variables <code>p</code>, <code>q</code> and <code>n</code> from the enclosing scope. Captured variables can present performance challenges; see <a href="../performance-tips/#man-performance-captured-1">performance tips</a>.</p><p>通过编写多个 <code>for</code> 关键字，生成器和推导中的范围可以取决于之前的范围：</p><pre><code class="language-julia-repl">julia&gt; [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)</code></pre><p>在这些情况下，结果都是一维的。</p><p>可以使用 <code>if</code> 关键字过滤生成的值：</p><pre><code class="language-julia-repl">julia&gt; [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)</code></pre><h2 id="man-array-indexing-1"><a class="docs-heading-anchor" href="#man-array-indexing-1">索引</a><a class="docs-heading-anchor-permalink" href="#man-array-indexing-1" title="Permalink"></a></h2><p>索引 n 维数组 <code>A</code> 的一般语法是：</p><pre><code class="language-none">X = A[I_1, I_2, ..., I_n]</code></pre><p>其中每个 <code>I_k</code> 可以是标量整数，整数数组或任何其他<a href="#man-supported-index-types-1">支持的索引类型</a>。这包括 <a href="../../base/arrays/#Base.Colon"><code>Colon</code></a> (<code>:</code>) 来选择整个维度中的所有索引，形式为 <code>a:c</code> 或 <code>a:b:c</code> 的范围来选择连续或跨步的子区间，以及布尔数组以选择索引为 <code>true</code> 的元素。</p><p>如果所有索引都是标量，则结果 <code>X</code> 是数组 <code>A</code> 中的单个元素。否则，<code>X</code> 是一个数组，其维数与所有索引的维数之和相同。</p><p>如果所有索引 <code>I_k</code> 都是向量，则 <code>X</code> 的形状将是 <code>(length(I_1), length(I_2), ..., length(I_n))</code>，其中，<code>X</code> 中位于 <code>i_1, i_2, ..., i_n</code> 处的元素为 <code>A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]</code>。</p><p>例如：</p><pre><code class="language-julia-repl">julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; A[1, 2, 1, 1] # all scalar indices
3

julia&gt; A[[1, 2], [1], [1, 2], [1]] # all vector indices
2×1×2×1 Array{Int64,4}:
[:, :, 1, 1] =
 1
 2

[:, :, 2, 1] =
 5
 6

julia&gt; A[[1, 2], [1], [1, 2], 1] # a mix of index types
2×1×2 Array{Int64,3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 5
 6</code></pre><p>请注意最后两种情况下得到的数组大小为何是不同的。</p><p>如果 <code>I_1</code> 是二维矩阵，则 <code>X</code> 是 <code>n+1</code> 维数组，其形状为 <code>(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))</code>。矩阵会添加一个维度。</p><p>例如：</p><pre><code class="language-julia-repl">julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2));

julia&gt; A[[1 2; 1 2]]
2×2 Array{Int64,2}:
 1  2
 1  2

julia&gt; A[[1 2; 1 2], 1, 2, 1]
2×2 Array{Int64,2}:
 5  6
 5  6</code></pre><p>位于 <code>i_1, i_2, i_3, ..., i_{n+1}</code> 处的元素值是 <code>A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]</code>。所有使用标量索引的维度都将被丢弃，例如，假设 <code>J</code> 是索引数组，那么 <code>A[2，J，3]</code> 的结果是一个大小为 <code>size(J)</code> 的数组、其第 j 个元素由 <code>A[2, J[j], 3]</code> 填充。</p><p>作为此语法的特殊部分，<code>end</code> 关键字可用于表示索引括号内每个维度的最后一个索引，由索引的最内层数组的大小决定。没有 <code>end</code> 关键字的索引语法相当于调用<a href="../../base/collections/#Base.getindex"><code>getindex</code></a>：</p><pre><code class="language-none">X = getindex(A, I_1, I_2, ..., I_n)</code></pre><p>例如：</p><pre><code class="language-julia-repl">julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia&gt; x[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1</code></pre><h2 id="man-indexed-assignment-1"><a class="docs-heading-anchor" href="#man-indexed-assignment-1">Indexed Assignment</a><a class="docs-heading-anchor-permalink" href="#man-indexed-assignment-1" title="Permalink"></a></h2><p>在 n 维数组 <code>A</code> 中赋值的一般语法是：</p><pre><code class="language-none">A[I_1, I_2, ..., I_n] = X</code></pre><p>其中每个 <code>I_k</code> 可以是标量整数，整数数组或任何其他<a href="#man-supported-index-types-1">支持的索引类型</a>。这包括 <a href="../../base/arrays/#Base.Colon"><code>Colon</code></a> (<code>:</code>) 来选择整个维度中的所有索引，形式为 <code>a:c</code> 或 <code>a:b:c</code> 的范围来选择连续或跨步的子区间，以及布尔数组以选择索引为 <code>true</code> 的元素。</p><p>如果所有 <code>I_k</code> 都为整数，则数组 <code>A</code> 中 <code>I_1, I_2, ..., I_n</code> 位置的值将被 <code>X</code> 的值覆盖，必要时将 <a href="../../base/base/#Base.convert"><code>convert</code></a> 为数组 <code>A</code> 的 <a href="../../base/collections/#Base.eltype"><code>eltype</code></a>。</p><p>如果任一 <code>I_k</code> 选择了一个以上的位置，则等号右侧的 <code>X</code> 必须为一个与 <code>A[I_1, I_2, ..., I_n]</code> 形状一致的数组或一个具有相同元素数的向量。数组 <code>A</code> 中 <code>I_1[i_1], I_2[i_2], ..., I_n[i_n]</code> 位置的值将被 <code>X[I_1, I_2, ..., I_n]</code> 的值覆盖，必要时会转换类型。逐元素的赋值运算符 <code>.=</code> 可以用于将 <code>X</code> 沿选择的位置 <a href="#广播-1">broadcast</a>：</p><pre><code class="language-none">A[I_1, I_2, ..., I_n] .= X</code></pre><p>就像在<a href="#man-array-indexing-1">索引</a>中一样，<code>end</code>关键字可用于表示索引括号中每个维度的最后一个索引，由被赋值的数组大小决定。 没有<code>end</code>关键字的索引赋值语法相当于调用<a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a>：</p><pre><code class="language-none">setindex!(A, X, I_1, I_2, ..., I_n)</code></pre><p>例如：</p><pre><code class="language-julia-repl">julia&gt; x = collect(reshape(1:9, 3, 3))
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; x[3, 3] = -9;

julia&gt; x[1:2, 1:2] = [-1 -4; -2 -5];

julia&gt; x
3×3 Array{Int64,2}:
 -1  -4   7
 -2  -5   8
  3   6  -9</code></pre><h2 id="man-supported-index-types-1"><a class="docs-heading-anchor" href="#man-supported-index-types-1">支持的索引类型</a><a class="docs-heading-anchor-permalink" href="#man-supported-index-types-1" title="Permalink"></a></h2><p>在表达式 <code>A[I_1, I_2, ..., I_n]</code> 中，每个 <code>I_k</code> 可以是标量索引，标量索引数组，或者用 <a href="../../base/arrays/#Base.to_indices"><code>to_indices</code></a> 转换成的表示标量索引数组的对象：</p><ol><li>标量索引。默认情况下，这包括：<ul><li>非布尔的整数</li><li><a href="../../base/arrays/#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex{N}</code></a>s，其行为类似于跨越多个维度的 <code>N</code> 维整数元组（详见下文）</li></ul></li><li>标量索引数组。这包括：<ul><li>整数向量和多维整数数组</li><li>像 <code>[]</code> 这样的空数组，它不选择任何元素</li><li>如 <code>a:c</code> 或 <code>a:b:c</code> 的范围，从 <code>a</code> 到 <code>c</code>（包括）选择连续或间隔的部分元素</li><li>任何自定义标量索引数组，它是 <code>AbstractArray</code> 的子类型</li><li><code>CartesianIndex{N}</code> 数组（详见下文）</li></ul></li><li>一个表示标量索引数组的对象，可以通过<a href="../../base/arrays/#Base.to_indices"><code>to_indices</code></a>转换为这样的对象。 默认情况下，这包括：<ul><li><a href="../../base/arrays/#Base.Colon"><code>Colon()</code></a> (<code>:</code>)，表示整个维度内或整个数组中的所有索引</li><li>布尔数组，选择其中值为 <code>true</code> 的索引对应的元素（更多细节见下文）</li></ul></li></ol><p>一些例子：</p><pre><code class="language-julia-repl">julia&gt; A = reshape(collect(1:2:18), (3, 3))
3×3 Array{Int64,2}:
 1   7  13
 3   9  15
 5  11  17

julia&gt; A[4]
7

julia&gt; A[[2, 5, 8]]
3-element Array{Int64,1}:
  3
  9
 15

julia&gt; A[[1 4; 3 8]]
2×2 Array{Int64,2}:
 1   7
 5  15

julia&gt; A[[]]
0-element Array{Int64,1}

julia&gt; A[1:2:5]
3-element Array{Int64,1}:
 1
 5
 9

julia&gt; A[2, :]
3-element Array{Int64,1}:
  3
  9
 15

julia&gt; A[:, 3]
3-element Array{Int64,1}:
 13
 15
 17</code></pre><h3 id="笛卡尔索引-1"><a class="docs-heading-anchor" href="#笛卡尔索引-1">笛卡尔索引</a><a class="docs-heading-anchor-permalink" href="#笛卡尔索引-1" title="Permalink"></a></h3><p>特殊的 <code>CartesianIndex{N}</code> 对象表示一个标量索引，其行为类似于张成多个维度的 <code>N</code> 维整数元组。例如：</p><pre><code class="language-julia-repl">julia&gt; A = reshape(1:32, 4, 4, 2);

julia&gt; A[3, 2, 1]
7

julia&gt; A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true</code></pre><p>如果单独考虑，这可能看起来相对微不足道；<code>CartesianIndex</code> 只是将多个整数聚合成一个表示单个多维索引的对象。 但是，当与其他索引形式和迭代器组合产生多个 <code>CartesianIndex</code> 时，这可以生成非常优雅和高效的代码。请参阅下面的<a href="#迭代-1">迭代</a>，有关更高级的示例，请参阅<a href="https://julialang.org/blog/2016/02/iteration">关于多维算法和迭代博客文章</a>。</p><p>也支持 <code>CartesianIndex {N}</code> 的数组。它们代表一组标量索引，每个索引都跨越 <code>N</code> 个维度，从而实现一种有时也称为逐点索引的索引形式。例如，它可以从上面的 <code>A</code> 的第一「页」访问对角元素：</p><pre><code class="language-julia-repl">julia&gt; page = A[:,:,1]
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; page[[CartesianIndex(1,1),
             CartesianIndex(2,2),
             CartesianIndex(3,3),
             CartesianIndex(4,4)]]
4-element Array{Int64,1}:
  1
  6
 11
 16</code></pre><p>这可以通过 <a href="../functions/#man-vectorized-1">dot broadcasting</a> 以及普通整数索引（而不是把从 <code>A</code> 中提取第一“页”作为单独的步骤）更加简单地表达。它甚至可以与 <code>:</code> 结合使用，同时从两个页面中提取两个对角线：</p><pre><code class="language-julia-repl">julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]
4-element Array{Int64,1}:
  1
  6
 11
 16

julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]
4×2 Array{Int64,2}:
  1  17
  6  22
 11  27
 16  32</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>CartesianIndex</code> and arrays of <code>CartesianIndex</code> are not compatible with the <code>end</code> keyword to represent the last index of a dimension. Do not use <code>end</code> in indexing expressions that may contain either <code>CartesianIndex</code> or arrays thereof.</p></div></div><h3 id="Logical-indexing-1"><a class="docs-heading-anchor" href="#Logical-indexing-1">Logical indexing</a><a class="docs-heading-anchor-permalink" href="#Logical-indexing-1" title="Permalink"></a></h3><p>Often referred to as logical indexing or indexing with a logical mask, indexing by a boolean array selects elements at the indices where its values are <code>true</code>. Indexing by a boolean vector <code>B</code> is effectively the same as indexing by the vector of integers that is returned by <a href="../../base/arrays/#Base.findall-Tuple{Any}"><code>findall(B)</code></a>. Similarly, indexing by a <code>N</code>-dimensional boolean array is effectively the same as indexing by the vector of <code>CartesianIndex{N}</code>s where its values are <code>true</code>. A logical index must be a vector of the same length as the dimension it indexes into, or it must be the only index provided and match the size and dimensionality of the array it indexes into. It is generally more efficient to use boolean arrays as indices directly instead of first calling <a href="../../base/arrays/#Base.findall-Tuple{Any}"><code>findall</code></a>.</p><pre><code class="language-julia-repl">julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[[false, true, true, false], :]
2×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15

julia&gt; mask = map(ispow2, x)
4×4 Array{Bool,2}:
 1  0  0  0
 1  0  0  0
 0  0  0  0
 1  1  0  1

julia&gt; x[mask]
5-element Array{Int64,1}:
  1
  2
  4
  8
 16</code></pre><h3 id="Number-of-indices-1"><a class="docs-heading-anchor" href="#Number-of-indices-1">Number of indices</a><a class="docs-heading-anchor-permalink" href="#Number-of-indices-1" title="Permalink"></a></h3><h4 id="Cartesian-indexing-1"><a class="docs-heading-anchor" href="#Cartesian-indexing-1">Cartesian indexing</a><a class="docs-heading-anchor-permalink" href="#Cartesian-indexing-1" title="Permalink"></a></h4><p>The ordinary way to index into an <code>N</code>-dimensional array is to use exactly <code>N</code> indices; each index selects the position(s) in its particular dimension. For example, in the three-dimensional array <code>A = rand(4, 3, 2)</code>, <code>A[2, 3, 1]</code> will select the number in the second row of the third column in the first &quot;page&quot; of the array. This is often referred to as <em>cartesian indexing</em>.</p><h4 id="Linear-indexing-1"><a class="docs-heading-anchor" href="#Linear-indexing-1">Linear indexing</a><a class="docs-heading-anchor-permalink" href="#Linear-indexing-1" title="Permalink"></a></h4><p>When exactly one index <code>i</code> is provided, that index no longer represents a location in a particular dimension of the array. Instead, it selects the <code>i</code>th element using the column-major iteration order that linearly spans the entire array. This is known as <em>linear indexing</em>. It essentially treats the array as though it had been reshaped into a one-dimensional vector with <a href="../../base/arrays/#Base.vec"><code>vec</code></a>.</p><pre><code class="language-julia-repl">julia&gt; A = [2 6; 4 7; 3 1]
3×2 Array{Int64,2}:
 2  6
 4  7
 3  1

julia&gt; A[5]
7

julia&gt; vec(A)[5]
7</code></pre><p>A linear index into the array <code>A</code> can be converted to a <code>CartesianIndex</code> for cartesian indexing with <code>CartesianIndices(A)[i]</code> (see <a href="../../base/arrays/#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a>), and a set of <code>N</code> cartesian indices can be converted to a linear index with <code>LinearIndices(A)[i_1, i_2, ..., i_N]</code> (see <a href="../../base/arrays/#Base.LinearIndices"><code>LinearIndices</code></a>).</p><pre><code class="language-julia-repl">julia&gt; CartesianIndices(A)[5]
CartesianIndex(2, 2)

julia&gt; LinearIndices(A)[2, 2]
5</code></pre><p>It&#39;s important to note that there&#39;s a very large assymmetry in the performance of these conversions. Converting a linear index to a set of cartesian indices requires dividing and taking the remainder, whereas going the other way is just multiplies and adds. In modern processors, integer division can be 10-50 times slower than multiplication. While some arrays — like <a href="../../base/arrays/#Core.Array"><code>Array</code></a> itself — are implemented using a linear chunk of memory and directly use a linear index in their implementations, other arrays — like <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.Diagonal"><code>Diagonal</code></a> — need the full set of cartesian indices to do their lookup (see <a href="../../base/arrays/#Base.IndexStyle"><code>IndexStyle</code></a> to introspect which is which). As such, when iterating over an entire array, it&#39;s much better to iterate over <a href="../../base/arrays/#Base.eachindex"><code>eachindex(A)</code></a> instead of <code>1:length(A)</code>. Not only will the former be much faster in cases where <code>A</code> is <code>IndexCartesian</code>, but it will also support OffsetArrays, too.</p><h4 id="Omitted-and-extra-indices-1"><a class="docs-heading-anchor" href="#Omitted-and-extra-indices-1">Omitted and extra indices</a><a class="docs-heading-anchor-permalink" href="#Omitted-and-extra-indices-1" title="Permalink"></a></h4><p>In addition to linear indexing, an <code>N</code>-dimensional array may be indexed with fewer or more than <code>N</code> indices in certain situations.</p><p>Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a four-dimensional array with size <code>(3, 4, 2, 1)</code> may be indexed with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that linear indexing takes precedence over this rule.</p><pre><code class="language-julia-repl">julia&gt; A = reshape(1:24, 3, 4, 2, 1)
3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64:
[:, :, 1, 1] =
 1  4  7  10
 2  5  8  11
 3  6  9  12

[:, :, 2, 1] =
 13  16  19  22
 14  17  20  23
 15  18  21  24

julia&gt; A[1, 3, 2] # Omits the fourth dimension (length 1)
19

julia&gt; A[1, 3] # Attempts to omit dimensions 3 &amp; 4 (lengths 2 and 1)
ERROR: BoundsError: attempt to access 3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64 at index [1, 3]

julia&gt; A[19] # Linear indexing
19</code></pre><p>When omitting <em>all</em> indices with <code>A[]</code>, this semantic provides a simple idiom to retrieve the only element in an array and simultaneously ensure that there was only one element.</p><p>Similarly, more than <code>N</code> indices may be provided if all the indices beyond the dimensionality of the array are <code>1</code> (or more generally are the first and only element of <code>axes(A, d)</code> where <code>d</code> is that particular dimension number). This allows vectors to be indexed like one-column matrices, for example:</p><pre><code class="language-julia-repl">julia&gt; A = [8,6,7]
3-element Array{Int64,1}:
 8
 6
 7

julia&gt; A[2,1]
6</code></pre><h2 id="迭代-1"><a class="docs-heading-anchor" href="#迭代-1">迭代</a><a class="docs-heading-anchor-permalink" href="#迭代-1" title="Permalink"></a></h2><p>迭代整个数组的推荐方法是</p><pre><code class="language-julia">for a in A
    # Do something with the element a
end

for i in eachindex(A)
    # Do something with i and/or A[i]
end</code></pre><p>当你需要每个元素的值而不是索引时，使用第一个构造。 在第二个构造中，如果 <code>A</code> 是具有快速线性索引的数组类型，<code>i</code> 将是 <code>Int</code>; 否则，它将是一个 <code>CartesianIndex</code>：</p><pre><code class="language-julia-repl">julia&gt; A = rand(4,3);

julia&gt; B = view(A, 1:3, 2:3);

julia&gt; for i in eachindex(B)
           @show i
       end
i = CartesianIndex(1, 1)
i = CartesianIndex(2, 1)
i = CartesianIndex(3, 1)
i = CartesianIndex(1, 2)
i = CartesianIndex(2, 2)
i = CartesianIndex(3, 2)</code></pre><p>与 <code>for i = 1:length(A)</code> 相比，<a href="../../base/arrays/#Base.eachindex"><code>eachindex</code></a> 提供了一种迭代任何数组类型的有效方法。</p><h2 id="Array-traits-1"><a class="docs-heading-anchor" href="#Array-traits-1">Array traits</a><a class="docs-heading-anchor-permalink" href="#Array-traits-1" title="Permalink"></a></h2><p>如果你编写一个自定义的 <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray</code></a> 类型，你可以用以下代码指定它使用快速线性索引</p><pre><code class="language-julia">Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</code></pre><p>此设置将导致 <code>myArray</code> 上的 <code>eachindex</code> 迭代使用整数。如果未指定此特征，则使用默认值 <code>IndexCartesian()</code>。</p><h2 id="数组、向量化操作符及函数-1"><a class="docs-heading-anchor" href="#数组、向量化操作符及函数-1">数组、向量化操作符及函数</a><a class="docs-heading-anchor-permalink" href="#数组、向量化操作符及函数-1" title="Permalink"></a></h2><p>以下运算符支持对数组操作</p><ol><li>一元运算符 – <code>-</code>, <code>+</code></li><li>二元运算符 – <code>-</code>, <code>+</code>, <code>*</code>, <code>/</code>, <code>\</code>, <code>^</code></li><li>比较操作符 – <code>==</code>, <code>!=</code>, <code>≈</code> (<a href="../../base/math/#Base.isapprox"><code>isapprox</code></a>), <code>≉</code></li></ol><p>另外，为了便于数学上和其他运算的向量化，Julia <a href="../functions/#man-vectorized-1">提供了点语法（dot syntax）</a> <code>f.(args...)</code>，例如，<code>sin.(x)</code> 或 <code>min.(x,y)</code>，用于数组或数组和标量的混合上的按元素运算（<a href="#广播-1">广播</a>运算）；当与其他点调用（dot call）结合使用时，它们的额外优点是能「融合」到单个循环中，例如，<code>sin.(cos.(x))</code>。</p><p>此外，<em>每个</em>二元运算符支持相应的<a href="../mathematical-operations/#man-dot-operators-1">点操作版本</a>，可以应用于此类<a href="../functions/#man-vectorized-1">融合 broadcasting 操作</a>的数组（以及数组和标量的组合），例如 <code>z .== sin.(x .* y)</code>。</p><p>请注意，类似 <code>==</code> 的比较运算在作用于整个数组时，得到一个布尔结果。使用像 <code>.==</code> 这样的点运算符进行按元素的比较。（对于像 <code>&lt;</code> 这样的比较操作，<em>只有</em>按元素运算的版本 <code>.&lt;</code> 适用于数组。）</p><p>还要注意 <code>max.(a,b)</code> 和 <a href="../../base/collections/#Base.maximum"><code>maximum(a)</code></a> 之间的区别，<code>max.(a,b)</code> 对 <code>a</code> 和 <code>b</code> 的每个元素 <a href="../../base/arrays/#Base.Broadcast.broadcast"><code>broadcast</code></a>s <a href="../../base/math/#Base.max"><code>max</code></a>，<a href="../../base/collections/#Base.maximum"><code>maximum(a)</code></a> 寻找在 <code>a</code> 中的最大值。<code>min.(a,b)</code> 和 <code>minimum(a)</code> 也有同样的关系。</p><h2 id="广播-1"><a class="docs-heading-anchor" href="#广播-1">广播</a><a class="docs-heading-anchor-permalink" href="#广播-1" title="Permalink"></a></h2><p>有时需要在不同尺寸的数组上执行元素对元素的操作，例如将矩阵的每一列加一个向量。一种低效的方法是将向量复制成矩阵的大小：</p><pre><code class="language-julia-repl">julia&gt; a = rand(2,1); A = rand(2,3);

julia&gt; repeat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846</code></pre><p>当维度较大的时候，这种方法将会十分浪费，所以 Julia 提供了广播 <a href="../../base/arrays/#Base.Broadcast.broadcast"><code>broadcast</code></a>，它将会将参数中低维度的参数扩展，使得其与其他维度匹配，且不会使用额外的内存，并将所给的函数逐元素地应用。</p><pre><code class="language-julia-repl">julia&gt; broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia&gt; b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia&gt; broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631</code></pre><p>类似 <code>.+</code> 和 <code>.*</code> 的<a href="../mathematical-operations/#man-dot-operators-1">点运算符</a> 等同于 <code>broadcast</code> 调用（除了它们融合两种操作，如下所述）。还有一个 <a href="../../base/arrays/#Base.Broadcast.broadcast!"><code>broadcast!</code></a> 函数来指定一个显式目标（也可以通过 <code>.=</code> 赋值以融合的方式访问它）。事实上，<code>f.(args...)</code> 等价于 <code>broadcast(f, args...)</code>，并为广播任何函数提供了方便的语法（<a href="../functions/#man-vectorized-1">dot syntax</a>）。嵌套的「点调用」<code>f.(...)</code>（包括调用 <code>.+</code> 等）<a href="../mathematical-operations/#man-dot-operators-1">自动融合</a>到单个 <code>broadcast</code> 调用。</p><p>Additionally, <a href="../../base/arrays/#Base.Broadcast.broadcast"><code>broadcast</code></a> is not limited to arrays (see the function documentation); it also handles scalars, tuples and other collections.  By default, only some argument types are considered scalars, including (but not limited to) <code>Number</code>s, <code>String</code>s, <code>Symbol</code>s, <code>Type</code>s, <code>Function</code>s and some common singletons like <code>missing</code> and <code>nothing</code>. All other arguments are iterated over or indexed into elementwise.</p><pre><code class="language-julia-repl">julia&gt; convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0
 2.0

julia&gt; ceil.((UInt8,), [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia&gt; string.(1:3, &quot;. &quot;, [&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;])
3-element Array{String,1}:
 &quot;1. First&quot;
 &quot;2. Second&quot;
 &quot;3. Third&quot;</code></pre><h2 id="实现-1"><a class="docs-heading-anchor" href="#实现-1">实现</a><a class="docs-heading-anchor-permalink" href="#实现-1" title="Permalink"></a></h2><p>Julia 中的基本数组类型是抽象类型 <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray{T,N}</code></a>。它通过维数 <code>N</code> 和元素类型 <code>T</code> 进行参数化。<a href="../../base/arrays/#Base.AbstractVector"><code>AbstractVector</code></a> 和 <a href="../../base/arrays/#Base.AbstractMatrix"><code>AbstractMatrix</code></a> 是一维和二维情况下的别名。<code>AbstractArray</code> 对象的操作是使用更高级别的运算符和函数定义的，其方式独立于底层存储。这些操作可以正确地被用于任何特定数组实现的回退操作。</p><p><code>AbstractArray</code> 类型包含任何模糊类似的东西，它的实现可能与传统数组完全不同。例如，可以根据请求而不是存储来计算元素。但是，任何具体的 <code>AbstractArray{T,N}</code> 类型通常应该至少实现 <a href="../../base/arrays/#Base.size"><code>size(A)</code></a>（返回 <code>Int</code> 元组），<a href="../../base/arrays/#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex(A,i)</code></a> 和 <a href="../../base/collections/#Base.getindex"><code>getindex(A,i1,...,iN)</code></a>；可变数组也应该实现 <a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a>。建议这些操作具有几乎为常数的时间复杂性，或严格说来 Õ(1) 复杂性，否则某些数组函数可能出乎意料的慢。具体类型通常还应提供 <a href="../../base/arrays/#Base.similar"><code>similar(A,T=eltype(A),dims=size(A))</code></a> 方法，用于为 <a href="../../base/base/#Base.copy"><code>copy</code></a> 分配类似的数组和其他位于当前数组空间外的操作。无论在内部如何表示 <code>AbstractArray{T,N}</code>，<code>T</code> 是由 <em>整数</em> 索引返回的对象类型（<code>A[1, ..., 1]</code>，当 <code>A</code> 不为空），<code>N</code> 应该是 <a href="../../base/arrays/#Base.size"><code>size</code></a> 返回的元组的长度。有关定义自定义 <code>AbstractArray</code> 实现的更多详细信息，请参阅<a href="../interfaces/#man-interface-array-1">接口章节中的数组接口导则</a>。</p><p><code>DenseArray</code> is an abstract subtype of <code>AbstractArray</code> intended to include all arrays where elements are stored contiguously in column-major order (see <a href="../performance-tips/#man-performance-column-major-1">additional notes in Performance Tips</a>). The <a href="../../base/arrays/#Core.Array"><code>Array</code></a> type is a specific instance of <code>DenseArray</code>;  <a href="../../base/arrays/#Base.Vector"><code>Vector</code></a> and <a href="../../base/arrays/#Base.Matrix"><code>Matrix</code></a> are aliases for the 1-d and 2-d cases. Very few operations are implemented specifically for <code>Array</code> beyond those that are required for all <code>AbstractArray</code>s; much of the array library is implemented in a generic manner that allows all custom arrays to behave similarly.</p><p><code>SubArray</code> 是 <code>AbstractArray</code> 的特例，它通过与原始数组共享内存而不是复制它来执行索引。 使用<a href="../../base/arrays/#Base.view"><code>view</code></a> 函数创建 <code>SubArray</code>，它的调用方式与<a href="../../base/collections/#Base.getindex"><code>getindex</code></a> 相同（作用于数组和一系列索引参数）。 <a href="../../base/arrays/#Base.view"><code>view</code></a> 的结果看起来与 <a href="../../base/collections/#Base.getindex"><code>getindex</code></a> 的结果相同，只是数据保持不变。 <a href="../../base/arrays/#Base.view"><code>view</code></a> 将输入索引向量存储在 <code>SubArray</code> 对象中，该对象稍后可用于间接索引原始数组。 通过将  <a href="../../base/arrays/#Base.@views"><code>@views</code></a> 宏放在表达式或代码块之前，该表达式中的任何 <code>array [...]</code> 切片将被转换为创建一个 <code>SubArray</code> 视图。</p><p><a href="../../base/arrays/#Base.BitArray"><code>BitArray</code></a> 是节省空间“压缩”的布尔数组，每个比特（bit）存储一个布尔值。 它们可以类似于 <code>Array{Bool}</code> 数组（每个字节（byte）存储一个布尔值），并且可以分别通过 <code>Array(bitarray)</code> 和 <code>BitArray(array)</code> 相互转换。</p><p>「strided」数组存储在内存中，元素以常规偏移量排列，因此元素类型兼容 <code>isbits</code> 的实例可以被传递给期望此内存布局的外部 C 和 Fortran 函数。Strided 数组必须定义一个 <a href="../../base/arrays/#Base.strides"><code>strides(A)</code></a> 方法，该方法为每个维返回一个「strides」元组；提供 <a href="../../base/arrays/#Base.stride"><code>stride(A,k)</code></a> 方法访问该元组中的第 <code>k</code> 个元素。将维数 <code>k</code> 的索引增加 <code>1</code> 应该把 <a href="../../base/arrays/#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex(A,i)</code></a> 得到的索引 <code>i</code> 增加 <a href="../../base/arrays/#Base.stride"><code>stride(A,k)</code></a>。如果提供了指针转换方法 <a href="../../base/c/#Base.unsafe_convert"><code>Base.unsafe_convert(Ptr{T}, A)</code></a>，则内存布局必须以与这些间隔相同的方式对应。<code>DenseArray</code> 是一个非常具体的 strided 数组示例，其中元素是连续排列的，因此它为子类提供了适当的 <code>strides</code> 定义。更多具体的例子可以在 <a href="../interfaces/#man-interface-strided-arrays-1">strided 数组的接口指南</a>中找到。<a href="../../base/arrays/#Base.StridedVector"><code>StridedVector</code></a> 和 <a href="../../base/arrays/#Base.StridedMatrix"><code>StridedMatrix</code></a> 是许多算是 strided 数组的内置数组类型的便捷别名，允许它们只使用指针和 stride 派发来选择调用专门实现，即使用经高度调试和优化的 BLAS 和 LAPACK 函数。</p><p>接下来的例子计算一个大数组中一小部分的 QR 分解，不需要引入任何临时变量。通过正确的维度大小和偏移参数调用合适的 LAPACK 函数。</p><pre><code class="language-julia-repl">julia&gt; a = rand(10, 10)
10×10 Array{Float64,2}:
 0.517515  0.0348206  0.749042   0.0979679  …  0.75984     0.950481   0.579513
 0.901092  0.873479   0.134533   0.0697848     0.0586695   0.193254   0.726898
 0.976808  0.0901881  0.208332   0.920358      0.288535    0.705941   0.337137
 0.657127  0.0317896  0.772837   0.534457      0.0966037   0.700694   0.675999
 0.471777  0.144969   0.0718405  0.0827916     0.527233    0.173132   0.694304
 0.160872  0.455168   0.489254   0.827851   …  0.62226     0.0995456  0.946522
 0.291857  0.769492   0.68043    0.629461      0.727558    0.910796   0.834837
 0.775774  0.700731   0.700177   0.0126213     0.00822304  0.327502   0.955181
 0.9715    0.64354    0.848441   0.241474      0.591611    0.792573   0.194357
 0.646596  0.575456   0.0995212  0.038517      0.709233    0.477657   0.0507231

julia&gt; b = view(a, 2:2:8,2:2:4)
4×2 view(::Array{Float64,2}, 2:2:8, 2:2:4) with eltype Float64:
 0.873479   0.0697848
 0.0317896  0.534457
 0.455168   0.827851
 0.700731   0.0126213

julia&gt; (q, r) = qr(b);

julia&gt; q
4×4 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.722358    0.227524  -0.247784    -0.604181
 -0.0262896  -0.575919  -0.804227     0.144377
 -0.376419   -0.75072    0.540177    -0.0541979
 -0.579497    0.230151  -0.00552346   0.781782

julia&gt; r
2×2 Array{Float64,2}:
 -1.20921  -0.383393
  0.0      -0.910506</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><em>iid</em>，独立同分布</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../metaprogramming/">« 元编程</a><a class="docs-footer-nextpage" href="../missing/">缺失值 »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2020 六月 16 周二 15:43">2020 六月 16 周二</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.3.1版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
