<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>嵌入 Julia · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/embedding/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">变量</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li class="is-active"><a class="tocitem" href>嵌入 Julia</a><ul class="internal"><li><a class="tocitem" href="#高级别嵌入"><span>高级别嵌入</span></a></li><li><a class="tocitem" href="#在-Windows-使用-Visual-Studio-进行高级别嵌入"><span>在 Windows 使用 Visual Studio 进行高级别嵌入</span></a></li><li><a class="tocitem" href="#转换类型"><span>转换类型</span></a></li><li><a class="tocitem" href="#调用-Julia-函数"><span>调用 Julia 函数</span></a></li><li><a class="tocitem" href="#内存管理"><span>内存管理</span></a></li><li><a class="tocitem" href="#使用数组"><span>使用数组</span></a></li><li><a class="tocitem" href="#异常"><span>异常</span></a></li></ul></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">分布式计算</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">交互式组件</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>嵌入 Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>嵌入 Julia</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/embeddingmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="嵌入-Julia"><a class="docs-heading-anchor" href="#嵌入-Julia">嵌入 Julia</a><a id="嵌入-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#嵌入-Julia" title="Permalink"></a></h1><p>正如我们在 <a href="../calling-c-and-fortran-code/#调用-C-和-Fortran-代码">调用 C 和 Fortran 代码</a> 中看到的, Julia 有着简单高效的方法来调用 C 编写的函数。但有时恰恰相反，我们需要在 C 中调用 Julia 的函数。这可以将 Julia 代码集成到一个更大的 C/C++ 项目而无需在 C/C++ 中重写所有内容。Julia 有一个 C API 来实现这一目标。几乎所有编程语言都能以某种方式来调用 C 语言的函数，因此 Julia 的 C API 也就能够进行更多语言的桥接。(例如在 Python 或是 C# 中调用 Julia ).</p><h2 id="高级别嵌入"><a class="docs-heading-anchor" href="#高级别嵌入">高级别嵌入</a><a id="高级别嵌入-1"></a><a class="docs-heading-anchor-permalink" href="#高级别嵌入" title="Permalink"></a></h2><p><strong>Note</strong>: 本节包含可运行在类 Unix 系统上的、使用 C 编写的嵌入式 Julia 代码。Windows 平台请参阅下一节。</p><p>我们从一个简单的 C 程序开始初始化 Julia 并调用一些 Julia 代码：</p><pre><code class="language-c">#include &lt;julia.h&gt;
JULIA_DEFINE_FAST_TLS() // only define this once, in an executable (not in a shared library) if you want fast code.

int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string(&quot;print(sqrt(2.0))&quot;);

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}</code></pre><p>为构建这个程序，你必须将 Julia 头文件的路径放入 include 路径并链接 <code>libjulia</code> 。例如 Julia 被安装到 <code>$JULIA_DIR</code>，则可以用 <code>gcc</code> 来编译上面的测试程序 <code>test.c</code>：</p><pre><code class="language-none">gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib -Wl,-rpath,$JULIA_DIR/lib test.c -ljulia</code></pre><p>或者查看 Julia 源代码目录 <code>test/embedding/</code> 文件夹下的 <code>embedding.c</code> 文件。 文件 <code>ui/repl.c</code> 则是另一个简单示例，用于设置链接 <code>libjulia</code> 时 <code>jl_options</code> 的选项 。</p><p>在调用任何其他 Julia C 函数之前第一件必须要做的事是初始化 Julia，通过调用 <code>jl_init</code> 尝试自动确定 Julia 的安装位置来实现。如果需要自定义位置或指定要加载的系统映像，请改用 <code>jl_init_with_image</code>。</p><p>测试程序中的第二个语句通过调用 <code>jl_eval_string</code> 来执行 Julia 语句。</p><p>在程序结束之前，强烈建议调用 <code>jl_atexit_hook</code>。上面的示例程序在 <code>main</code> 返回之前进行了调用。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>现在，动态链接 <code>libjulia</code> 的共享库需要传递选项 <code>RTLD_GLOBAL</code> 。比如在 Python 中像这样调用：</p><pre><code class="language-none">&gt;&gt;&gt; julia=CDLL(&#39;./libjulia.dylib&#39;,RTLD_GLOBAL)
&gt;&gt;&gt; julia.jl_init.argtypes = []
&gt;&gt;&gt; julia.jl_init()
250593296</code></pre></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>如果 Julia 程序需要访问 主可执行文件 中的符号，那么除了下面描述的由 <code>julia-config.jl</code> 生成的标记之外，可能还需要在 Linux 上的编译时添加 <code>-Wl,--export-dynamic</code> 链接器标志。编译共享库时则不必要。</p></div></div><h3 id="使用-julia-config-自动确定构建参数"><a class="docs-heading-anchor" href="#使用-julia-config-自动确定构建参数">使用 julia-config 自动确定构建参数</a><a id="使用-julia-config-自动确定构建参数-1"></a><a class="docs-heading-anchor-permalink" href="#使用-julia-config-自动确定构建参数" title="Permalink"></a></h3><p><code>julia-config.jl</code> 创建脚本是为了帮助确定使用嵌入的 Julia 程序所需的构建参数。此脚本使用由其调用的特定 Julia 分发的构建参数和系统配置来导出嵌入程序的必要编译器标志以与该分发交互。此脚本位于 Julia 的 share 目录中。</p><h4 id="例子"><a class="docs-heading-anchor" href="#例子">例子</a><a id="例子-1"></a><a class="docs-heading-anchor-permalink" href="#例子" title="Permalink"></a></h4><pre><code class="language-c">#include &lt;julia.h&gt;

int main(int argc, char *argv[])
{
    jl_init();
    (void)jl_eval_string(&quot;println(sqrt(2.0))&quot;);
    jl_atexit_hook(0);
    return 0;
}</code></pre><h4 id="在命令行中"><a class="docs-heading-anchor" href="#在命令行中">在命令行中</a><a id="在命令行中-1"></a><a class="docs-heading-anchor-permalink" href="#在命令行中" title="Permalink"></a></h4><p>命令行脚本简单用法：假设 <code>julia-config.jl</code> 位于 <code>/usr/local/julia/share/julia</code>，它可以直接在命令行上调用，并采用 3 个标志的任意组合：</p><pre><code class="language-none">/usr/local/julia/share/julia/julia-config.jl
Usage: julia-config [--cflags|--ldflags|--ldlibs]</code></pre><p>如果上面的示例源代码保存为文件 <code>embed_example.c</code>，则以下命令将其编译为 Linux 和 Windows 上运行的程序（MSYS2 环境），或者如果在 OS/X 上，则用 <code>clang</code> 替换 <code>gcc</code>。：</p><pre><code class="language-none">/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c</code></pre><h4 id="在-Makefiles-中使用"><a class="docs-heading-anchor" href="#在-Makefiles-中使用">在 Makefiles 中使用</a><a id="在-Makefiles-中使用-1"></a><a class="docs-heading-anchor-permalink" href="#在-Makefiles-中使用" title="Permalink"></a></h4><p>但通常来说，嵌入的项目会比上面更复杂，因此一般会提供 makefile 支持。由于使用了 <strong>shell</strong> 宏扩展，我们就假设用 GNU make 。 另外，尽管很多时候 <code>julia-config.jl</code> 会在目录 <code>/usr/local</code> 中出现多次，不过也未必如此，但 Julia 也定位 <code>julia-config.jl</code>，并且可以使用 makefile 来利用它。上面的示例程序使用 Makefile 来扩展。：</p><pre><code class="language-makefiles">JL_SHARE = $(shell julia -e &#39;print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, &quot;julia&quot;))&#39;)
CFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
CXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
LDFLAGS += $(shell $(JL_SHARE)/julia-config.jl --ldflags)
LDLIBS += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)

all: embed_example</code></pre><p>现在构建的命令就只需要简简单单的<code>make</code>了。</p><h2 id="在-Windows-使用-Visual-Studio-进行高级别嵌入"><a class="docs-heading-anchor" href="#在-Windows-使用-Visual-Studio-进行高级别嵌入">在 Windows 使用 Visual Studio 进行高级别嵌入</a><a id="在-Windows-使用-Visual-Studio-进行高级别嵌入-1"></a><a class="docs-heading-anchor-permalink" href="#在-Windows-使用-Visual-Studio-进行高级别嵌入" title="Permalink"></a></h2><p>If the <code>JULIA_DIR</code> environment variable hasn&#39;t been setup, add it using the System panel before starting Visual Studio. The <code>bin</code> folder under JULIA_DIR should be on the system PATH.</p><p>We start by opening Visual Studio and creating a new Console Application project. To the &#39;stdafx.h&#39; header file, add the following lines at the end:</p><pre><code class="language-c">#include &lt;julia.h&gt;</code></pre><p>Then, replace the main() function in the project with this code:</p><pre><code class="language-c">int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string(&quot;print(sqrt(2.0))&quot;);

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}</code></pre><p>The next step is to set up the project to find the Julia include files and the libraries. It&#39;s important to know whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn&#39;t correspond to the Julia installation before proceeding.</p><p>Using the project Properties dialog, go to <code>C/C++</code> | <code>General</code> and add <code>$(JULIA_DIR)\include\julia\</code> to the Additional Include Directories property. Then, go to the <code>Linker</code> | <code>General</code> section and add <code>$(JULIA_DIR)\lib</code> to the Additional Library Directories property. Finally, under <code>Linker</code> | <code>Input</code>, add <code>libjulia.dll.a;libopenlibm.dll.a;</code> to the list of libraries.</p><p>At this point, the project should build and run.</p><h2 id="转换类型"><a class="docs-heading-anchor" href="#转换类型">转换类型</a><a id="转换类型-1"></a><a class="docs-heading-anchor-permalink" href="#转换类型" title="Permalink"></a></h2><p>真正的应用程序不仅仅要执行表达式，还要返回表达式的值给宿主程序。<code>jl_eval_string</code> 返回 一个 <code>jl_value_t*</code>，它是指向堆分配的 Julia 对象的指针。存储像 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> 这些简单数据类型叫做 <code>装箱</code>，然后提取存储的基础类型数据叫 <code>拆箱</code>。我们改进的示例程序在 Julia 中计算 2 的平方根，并在 C 中读取回结果，如下所示：</p><pre><code class="language-c">jl_value_t *ret = jl_eval_string(&quot;sqrt(2.0)&quot;);

if (jl_typeis(ret, jl_float64_type)) {
    double ret_unboxed = jl_unbox_float64(ret);
    printf(&quot;sqrt(2.0) in C: %e \n&quot;, ret_unboxed);
}
else {
    printf(&quot;ERROR: unexpected return type from sqrt(::Float64)\n&quot;);
}</code></pre><p>为了检查 <code>ret</code> 是否为特定的 Julia 类型，我们可以使用 <code>jl_isa</code>，<code>jl_typeis</code> 或 <code>jl_is_...</code> 函数。通过输入 <code>typeof(sqrt(2.0))</code>到 Julia shell，我们可以看到返回类型是 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>（在C中是 <code>double</code> 类型）。要将装箱的 Julia 值转换为 C 的double，上面的代码片段使用了 <code>jl_unbox_float64</code>函数。</p><p>相应的, 用 <code>jl_box_...</code> 函数是另一种转换的方式。</p><pre><code class="language-c">jl_value_t *a = jl_box_float64(3.0);
jl_value_t *b = jl_box_float32(3.0f);
jl_value_t *c = jl_box_int32(3);</code></pre><p>正如我们将在下面看到的那样，装箱需要在调用 Julia 函数时使用特定参数。</p><h2 id="调用-Julia-函数"><a class="docs-heading-anchor" href="#调用-Julia-函数">调用 Julia 函数</a><a id="调用-Julia-函数-1"></a><a class="docs-heading-anchor-permalink" href="#调用-Julia-函数" title="Permalink"></a></h2><p>虽然 <code>jl_eval_string</code> 允许 C 获取 Julia 表达式的结果，但它不允许将在 C 中计算的参数传递给 Julia。因此需要使用 <code>jl_call</code> 来直接调用Julia函数：</p><pre><code class="language-c">jl_function_t *func = jl_get_function(jl_base_module, &quot;sqrt&quot;);
jl_value_t *argument = jl_box_float64(2.0);
jl_value_t *ret = jl_call1(func, argument);</code></pre><p>在第一步中，通过调用 <code>jl_get_function</code> 检索出 Julia 函数 <code>sqrt</code> 的句柄(handle)。 传递给 <code>jl_get_function</code> 的第一个参数是 指向 定义<code>sqrt</code>所在的 <code>Base</code> 模块 的指针。 然后，double 值通过 <code>jl_box_float64</code> 被装箱。 最后，使用 <code>jl_call1</code> 调用该函数。也有 <code>jl_call0</code>，<code>jl_call2</code>和<code>jl_call3</code> 函数，方便地处理不同数量的参数。 要传递更多参数，使用 <code>jl_call</code>：</p><pre><code class="language-c">jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)</code></pre><p>它的第二个参数 <code>args</code> 是 <code>jl_value_t*</code> 类型的数组，<code>nargs</code> 是参数的个数 </p><h2 id="内存管理"><a class="docs-heading-anchor" href="#内存管理">内存管理</a><a id="内存管理-1"></a><a class="docs-heading-anchor-permalink" href="#内存管理" title="Permalink"></a></h2><p>正如我们所见，Julia 对象在 C 中表示为指针。这就出现了 谁来负责释放这些对象的问题。</p><p>通常，Julia 对象由垃圾收集器（GC）释放，但 GC 不会自动就懂我们正C中保留对Julia值的引用。这意味着 GC 会在你的掌控之外释放对象，从而使指针无效。</p><p>The GC can only run when Julia objects are allocated. Calls like <code>jl_box_float64</code> perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between <code>jl_...</code> calls. But in order to make sure that values can survive <code>jl_...</code> calls, we have to tell Julia that we still hold a reference to Julia <a href="https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf">root</a> values, a process called &quot;GC rooting&quot;. Rooting a value will ensure that the garbage collector does not accidentally identify this value as unused and free the memory backing that value. This can be done using the <code>JL_GC_PUSH</code> macros:</p><pre><code class="language-c">jl_value_t *ret = jl_eval_string(&quot;sqrt(2.0)&quot;);
JL_GC_PUSH1(&amp;ret);
// Do something with ret
JL_GC_POP();</code></pre><p>The <code>JL_GC_POP</code> call releases the references established by the previous <code>JL_GC_PUSH</code>. Note that <code>JL_GC_PUSH</code> stores references on the C stack, so it must be exactly paired with a <code>JL_GC_POP</code> before the scope is exited. That is, before the function returns, or control flow otherwise leaves the block in which the <code>JL_GC_PUSH</code> was invoked.</p><p>Several Julia values can be pushed at once using the <code>JL_GC_PUSH2</code> , <code>JL_GC_PUSH3</code> , <code>JL_GC_PUSH4</code> , <code>JL_GC_PUSH5</code> , and <code>JL_GC_PUSH6</code> macros. To push an array of Julia values one can use the <code>JL_GC_PUSHARGS</code> macro, which can be used as follows:</p><pre><code class="language-c">jl_value_t **args;
JL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects
args[0] = some_value;
args[1] = some_other_value;
// Do something with args (e.g. call jl_... functions)
JL_GC_POP();</code></pre><p>Each scope must have only one call to <code>JL_GC_PUSH*</code>. Hence, if all variables cannot be pushed once by a single call to <code>JL_GC_PUSH*</code>, or if there are more than 6 variables to be pushed and using an array of arguments is not an option, then one can use inner blocks:</p><pre><code class="language-c">jl_value_t *ret1 = jl_eval_string(&quot;sqrt(2.0)&quot;);
JL_GC_PUSH1(&amp;ret1);
jl_value_t *ret2 = 0;
{
    jl_function_t *func = jl_get_function(jl_base_module, &quot;exp&quot;);
    ret2 = jl_call1(func, ret1);
    JL_GC_PUSH1(&amp;ret2);
    // Do something with ret2.
    JL_GC_POP();    // This pops ret2.
}
JL_GC_POP();    // This pops ret1.</code></pre><p>If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use <code>JL_GC_PUSH*</code>. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global <code>IdDict</code> that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.</p><pre><code class="language-c">// This functions shall be executed only once, during the initialization.
jl_value_t* refs = jl_eval_string(&quot;refs = IdDict()&quot;);
jl_function_t* setindex = jl_get_function(jl_base_module, &quot;setindex!&quot;);

...

// `var` is the variable we want to protect between function calls.
jl_value_t* var = 0;

...

// `var` is a `Vector{Float64}`, which is mutable.
var = jl_eval_string(&quot;[sqrt(2.0); sqrt(4.0); sqrt(6.0)]&quot;);

// To protect `var`, add its reference to `refs`.
jl_call3(setindex, refs, var, var);</code></pre><p>If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a <code>RefValue{Any}</code> before it is pushed to <code>IdDict</code>. In this approach, the container has to be created or filled in via C code using, for example, the function <code>jl_new_struct</code>. If the container is created by <code>jl_call*</code>, then you will need to reload the pointer to be used in C code.</p><pre><code class="language-c">// This functions shall be executed only once, during the initialization.
jl_value_t* refs = jl_eval_string(&quot;refs = IdDict()&quot;);
jl_function_t* setindex = jl_get_function(jl_base_module, &quot;setindex!&quot;);
jl_datatype_t* reft = (jl_datatype_t*)jl_eval_string(&quot;Base.RefValue{Any}&quot;);

...

// `var` is the variable we want to protect between function calls.
jl_value_t* var = 0;

...

// `var` is a `Float64`, which is immutable.
var = jl_eval_string(&quot;sqrt(2.0)&quot;);

// Protect `var` until we add its reference to `refs`.
JL_GC_PUSH1(&amp;var);

// Wrap `var` in `RefValue{Any}` and push to `refs` to protect it.
jl_value_t* rvar = jl_new_struct(reft, var);
JL_GC_POP();

jl_call3(setindex, refs, rvar, rvar);</code></pre><p>The GC can be allowed to deallocate a variable by removing the reference to it from <code>refs</code> using the function <code>delete!</code>, provided that no other reference to the variable is kept anywhere:</p><pre><code class="language-c">jl_function_t* delete = jl_get_function(jl_base_module, &quot;delete!&quot;);
jl_call2(delete, refs, rvar);</code></pre><p>As an alternative for very simple cases, it is possible to just create a global container of type <code>Vector{Any}</code> and fetch the elements from that when necessary, or even to create one global variable per pointer using</p><pre><code class="language-c">jl_set_global(jl_main_module, jl_symbol(&quot;var&quot;), var);</code></pre><h3 id="Updating-fields-of-GC-managed-objects"><a class="docs-heading-anchor" href="#Updating-fields-of-GC-managed-objects">Updating fields of GC-managed objects</a><a id="Updating-fields-of-GC-managed-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-fields-of-GC-managed-objects" title="Permalink"></a></h3><p>The garbage collector operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the <code>jl_gc_wb</code> (write barrier) function like so:</p><pre><code class="language-c">jl_value_t *parent = some_old_value, *child = some_young_value;
((some_specific_type*)parent)-&gt;field = child;
jl_gc_wb(parent, child);</code></pre><p>通常情况下不可能在运行时预测 值是否是旧的，因此 写屏障 必须被插入在所有显式存储之后。一个需要注意的例外是如果 <code>parent</code> 对象刚分配，垃圾收集之后并不执行。请记住大多数 <code>jl_...</code> 函数有时候都会执行垃圾收集。</p><p>直接更新数据时，对于指针数组来说 写屏障 也是必需的 例如：</p><pre><code class="language-c">jl_array_t *some_array = ...; // e.g. a Vector{Any}
void **data = (void**)jl_array_data(some_array);
jl_value_t *some_value = ...;
data[0] = some_value;
jl_gc_wb(some_array, some_value);</code></pre><h3 id="控制垃圾收集器"><a class="docs-heading-anchor" href="#控制垃圾收集器">控制垃圾收集器</a><a id="控制垃圾收集器-1"></a><a class="docs-heading-anchor-permalink" href="#控制垃圾收集器" title="Permalink"></a></h3><p>有一些函数能够控制GC。在正常使用情况下这些不是必要的。</p><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><code>jl_gc_collect()</code></td><td style="text-align: left">强制执行 GC</td></tr><tr><td style="text-align: left"><code>jl_gc_enable(0)</code></td><td style="text-align: left">禁用 GC， 返回前一个状态作为 int 类型</td></tr><tr><td style="text-align: left"><code>jl_gc_enable(1)</code></td><td style="text-align: left">启用 GC， 返回前一个状态作为 int 类型</td></tr><tr><td style="text-align: left"><code>jl_gc_is_enabled()</code></td><td style="text-align: left">返回当前状态作为 int 类型</td></tr></table><h2 id="使用数组"><a class="docs-heading-anchor" href="#使用数组">使用数组</a><a id="使用数组-1"></a><a class="docs-heading-anchor-permalink" href="#使用数组" title="Permalink"></a></h2><p>Julia 和 C 可以不通过复制而共享数组数据。下面一个例子将展示它是如何工作的。</p><p>Julia数组用数据类型 <code>jl_array_t *</code> 表示。基本上，<code>jl_array_t</code> 是一个包含以下内容的结构：</p><ul><li>关于数据类型的信息</li><li>指向数据块的指针</li><li>关于数组长度的信息</li></ul><p>为了让事情比较简单，我们从一维数组开始，创建一个存有 10 个 FLoat64 类型的数组如下所示：</p><pre><code class="language-c">jl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);
jl_array_t* x          = jl_alloc_array_1d(array_type, 10);</code></pre><p>或者，如果您已经分配了数组，则可以生成一个简易的包装器来包裹其数据：</p><pre><code class="language-c">double *existingArray = (double*)malloc(sizeof(double)*10);
jl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);</code></pre><p>最后一个参数是一个布尔值，表示 Julia 是否应该获取数据的所有权。 如果这个参数 不为零，当数组不再被引用时，GC 会在数据的指针上调用 <code>free</code> 。</p><p>为了访问 x 的数据，我们可以使用 <code>jl_array_data</code>：</p><pre><code class="language-c">double *xData = (double*)jl_array_data(x);</code></pre><p>现在我们可以填充这个数组：</p><pre><code class="language-c">for(size_t i=0; i&lt;jl_array_len(x); i++)
    xData[i] = i;</code></pre><p>现在让我们调用一个对 <code>x</code> 就地操作的 Julia 函数：</p><pre><code class="language-c">jl_function_t *func = jl_get_function(jl_base_module, &quot;reverse!&quot;);
jl_call1(func, (jl_value_t*)x);</code></pre><p>通过打印数组，可以验证 <code>x</code> 的元素现在是否已被逆置 (reversed)。</p><h3 id="获取返回的数组"><a class="docs-heading-anchor" href="#获取返回的数组">获取返回的数组</a><a id="获取返回的数组-1"></a><a class="docs-heading-anchor-permalink" href="#获取返回的数组" title="Permalink"></a></h3><p>如果 Julia 函数返回一个数组，<code>jl_eval_string</code> 和 <code>jl_call</code> 的返回值可以被强制转换为<code>jl_array_t *</code>：</p><pre><code class="language-c">jl_function_t *func  = jl_get_function(jl_base_module, &quot;reverse&quot;);
jl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);</code></pre><p>现在使用 <code>jl_array_data</code> 可以像前面一样访问 <code>y</code> 的内容。一如既往地，一定要在使用数组的时候确保 持有使用数组的引用。</p><h3 id="多维数组"><a class="docs-heading-anchor" href="#多维数组">多维数组</a><a id="多维数组-1"></a><a class="docs-heading-anchor-permalink" href="#多维数组" title="Permalink"></a></h3><p>Julia的多维数组以 列序优先 存储在内存中。这是一些 创建一个2D数组并访问其属性 的代码：</p><pre><code class="language-c">// Create 2D array of float64 type
jl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);
jl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);

// Get array pointer
double *p = (double*)jl_array_data(x);
// Get number of dimensions
int ndims = jl_array_ndims(x);
// Get the size of the i-th dim
size_t size0 = jl_array_dim(x,0);
size_t size1 = jl_array_dim(x,1);

// Fill array with data
for(size_t i=0; i&lt;size1; i++)
    for(size_t j=0; j&lt;size0; j++)
        p[j + size0*i] = i + j;</code></pre><p>请注意，虽然 Julia 的数组使用基于 1 的索引，但C API 中使用基于 0 的索引（例如 在调用<code>jl_array_dim</code>）以便用C代码的习惯来阅读。</p><h2 id="异常"><a class="docs-heading-anchor" href="#异常">异常</a><a id="异常-1"></a><a class="docs-heading-anchor-permalink" href="#异常" title="Permalink"></a></h2><p>Julia 代码可以抛出异常。比如：</p><pre><code class="language-c">jl_eval_string(&quot;this_function_does_not_exist()&quot;);</code></pre><p>这个调用似乎什么都没做。但可以检查异常是否抛出：</p><pre><code class="language-c">if (jl_exception_occurred())
    printf(&quot;%s \n&quot;, jl_typeof_str(jl_exception_occurred()));</code></pre><p>如果您使用 支持异常的语言的 Julia C API（例如Python，C＃，C ++），使用 检查是否有异常的函数 将每个调用 包装到 <code>libjulia</code> 中是有意义的，然后异常在宿主语言中重新抛出。</p><h3 id="抛出-Julia-异常"><a class="docs-heading-anchor" href="#抛出-Julia-异常">抛出 Julia 异常</a><a id="抛出-Julia-异常-1"></a><a class="docs-heading-anchor-permalink" href="#抛出-Julia-异常" title="Permalink"></a></h3><p>在编写 Julia 可调用函数时，可能需要验证参数 并抛出异常表示错误。 典型的类型检查像这样：</p><pre><code class="language-c">if (!jl_typeis(val, jl_float64_type)) {
    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);
}</code></pre><p>可以使用以下函数 引发一般异常：</p><pre><code class="language-c">void jl_error(const char *str);
void jl_errorf(const char *fmt, ...);</code></pre><p><code>jl_error</code>采用 C 字符串，而 <code>jl_errorf</code> 像 <code>printf</code> 一样调用:</p><pre><code class="language-c">jl_errorf(&quot;argument x = %d is too large&quot;, x);</code></pre><p>在这个例子中假定 <code>x</code> 是一个 int 值。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../environment-variables/">« 环境变量</a><a class="docs-footer-nextpage" href="../code-loading/">代码加载 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2021 一月 3 周日 01:24">2021 一月 3 周日</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.3.1版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
