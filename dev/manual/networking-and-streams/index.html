<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>网络和流 · Julia 中文文档</title><meta name="title" content="网络和流 · Julia 中文文档"/><meta property="og:title" content="网络和流 · Julia 中文文档"/><meta property="twitter:title" content="网络和流 · Julia 中文文档"/><meta name="description" content="Documentation for Julia 中文文档."/><meta property="og:description" content="Documentation for Julia 中文文档."/><meta property="twitter:description" content="Documentation for Julia 中文文档."/><meta property="og:url" content="https://juliacn.github.io/JuliaZH.jl/latest/manual/networking-and-streams/"/><meta property="twitter:url" content="https://juliacn.github.io/JuliaZH.jl/latest/manual/networking-and-streams/"/><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/networking-and-streams/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia 中文文档 logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">变量</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">一维和多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li class="is-active"><a class="tocitem" href>网络和流</a><ul class="internal"><li><a class="tocitem" href="#基础流-I/O"><span>基础流 I/O</span></a></li><li><a class="tocitem" href="#文本-I/O"><span>文本 I/O</span></a></li><li><a class="tocitem" href="#IO-输出的上下文信息"><span>IO 输出的上下文信息</span></a></li><li><a class="tocitem" href="#使用文件"><span>使用文件</span></a></li><li><a class="tocitem" href="#一个简单的-TCP-示例"><span>一个简单的 TCP 示例</span></a></li><li><a class="tocitem" href="#解析-IP-地址"><span>解析 IP 地址</span></a></li><li><a class="tocitem" href="#异步-I/O"><span>异步 I/O</span></a></li><li><a class="tocitem" href="#Multicast"><span>Multicast</span></a></li></ul></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../multi-threading/">多线程</a></li><li><a class="tocitem" href="../distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">标准数值类型</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/reflection/">反射 与 自我检查</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">标准库</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/ArgTools/">ArgTools</a></li><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibCURL/">LibCURL</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/NetworkOptions/">Network Options</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Tar/">Tar</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">开发者文档</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/pkgimg/">Package Images</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../../devdocs/gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../../devdocs/precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../../devdocs/probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../../devdocs/build/linux/">Linux</a></li><li><a class="tocitem" href="../../devdocs/build/macos/">macOS</a></li><li><a class="tocitem" href="../../devdocs/build/windows/">Windows</a></li><li><a class="tocitem" href="../../devdocs/build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../../devdocs/build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../../devdocs/build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>网络和流</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>网络和流</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/zh_CN/doc/src/manual/networking-and-streams.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="网络和流"><a class="docs-heading-anchor" href="#网络和流">网络和流</a><a id="网络和流-1"></a><a class="docs-heading-anchor-permalink" href="#网络和流" title="Permalink"></a></h1><p>Julia 提供了一个功能丰富的接口来处理流式 I/O 对象，如终端、管道和 TCP 套接字。此接口虽然在系统级是异步的，但是其以同步的方式展现给程序员，通常也不需要考虑底层的异步操作。这是通过大量使用 Julia 协作线程（<a href="../control-flow/#man-tasks">协程</a>）功能实现的。</p><h2 id="基础流-I/O"><a class="docs-heading-anchor" href="#基础流-I/O">基础流 I/O</a><a id="基础流-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#基础流-I/O" title="Permalink"></a></h2><p>所有 Julia stream 都暴露了 <a href="../../base/io-network/#Base.read"><code>read</code></a> 和 <a href="../../base/io-network/#Base.write"><code>write</code></a> 方法，将 stream 作为它们的第一个参数，如：</p><pre><code class="language-julia-repl hljs">julia&gt; write(stdout, &quot;Hello World&quot;);  # suppress return value 11 with ;
Hello World
julia&gt; read(stdin, Char)

&#39;\n&#39;: ASCII/Unicode U+000a (category Cc: Other, control)</code></pre><p>注意，<a href="../../base/io-network/#Base.write"><code>write</code></a> 返回 11，字节数（<code>&quot;Hello World&quot;</code>）写入 <a href="../../base/io-network/#Base.stdout"><code>stdout</code></a>，但是返回值使用 <code>;</code> 抑制。</p><p>这里按了两次回车，以便 Julia 能够读取到换行符。正如你在这个例子中所看到的，<a href="../../base/io-network/#Base.write"><code>write</code></a> 以待写入的数据作为其第二个参数，而 <a href="../../base/io-network/#Base.read"><code>read</code></a> 以待读取的数据的类型作为其第二个参数。</p><p>例如，为了读取一个简单的字节数组，我们可以这样做：</p><pre><code class="language-julia-repl hljs">julia&gt; x = zeros(UInt8, 4)
4-element Array{UInt8,1}:
 0x00
 0x00
 0x00
 0x00

julia&gt; read!(stdin, x)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64</code></pre><p>但是，因为这有些繁琐，所以提供了几个方便的方法。例如，我们可以把上面的代码编写为：</p><pre><code class="language-julia-repl hljs">julia&gt; read(stdin, 4)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64</code></pre><p>或者如果我们想要读取一整行：</p><pre><code class="language-julia-repl hljs">julia&gt; readline(stdin)
abcd
&quot;abcd&quot;</code></pre><p>请注意，根据你的终端设置，你的 TTY 可能是行缓冲的，因此在数据发送给 Julia 前可能需要额外的回车。</p><p>若要读取 <a href="../../base/io-network/#Base.stdin"><code>stdin</code></a> 的每一行，可以使用 <a href="../../base/io-network/#Base.eachline"><code>eachline</code></a>：</p><pre><code class="language-julia hljs">for line in eachline(stdin)
    print(&quot;Found $line&quot;)
end</code></pre><p>或者如果你想要按字符读取的话，使用 <a href="../../base/io-network/#Base.read"><code>read</code></a> ：</p><pre><code class="language-julia hljs">while !eof(stdin)
    x = read(stdin, Char)
    println(&quot;Found: $x&quot;)
end</code></pre><h2 id="文本-I/O"><a class="docs-heading-anchor" href="#文本-I/O">文本 I/O</a><a id="文本-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#文本-I/O" title="Permalink"></a></h2><p>请注意，上面提到的 <a href="../../base/io-network/#Base.write"><code>write</code></a> 方法对二进制流进行操作。具体来说，值不会转换为任何规范的文本表示形式，而是按原样输出：</p><pre><code class="language-julia-repl hljs">julia&gt; write(stdout, 0x61);  # suppress return value 1 with ;
a</code></pre><p>请注意，<code>a</code> 被 <a href="../../base/io-network/#Base.write"><code>write</code></a> 函数写入到 <a href="../../base/io-network/#Base.stdout"><code>stdout</code></a> 并且返回值为 <code>1</code>（因为 <code>0x61</code> 为一个字节）。</p><p>对于文本 I/O，请根据需要使用 <a href="../../base/io-network/#Base.print"><code>print</code></a> 或 <a href="../../base/io-network/#Base.show-Tuple{IO, Any}"><code>show</code></a> 方法（有关这两个方法之间的差异的详细讨论，请参阅它们的文档）：</p><pre><code class="language-julia-repl hljs">julia&gt; print(stdout, 0x61)
97</code></pre><p>有关如何实现自定义类型的显示方法的更多信息，请参阅 <a href="../types/#man-custom-pretty-printing">自定义 pretty-printing</a>。</p><h2 id="IO-输出的上下文信息"><a class="docs-heading-anchor" href="#IO-输出的上下文信息">IO 输出的上下文信息</a><a id="IO-输出的上下文信息-1"></a><a class="docs-heading-anchor-permalink" href="#IO-输出的上下文信息" title="Permalink"></a></h2><p>有时，IO 输出可受益于将上下文信息传递到 show 方法的能力。<a href="../../base/io-network/#Base.IOContext"><code>IOContext</code></a> 对象提供了将任意元数据与 IO 对象相关联的框架。例如，<code>:compact =&gt; true</code> 向 IO 对象添加一个参数来提示调用的 show 方法应该打印一个较短的输出（如果适用）。有关常用属性的列表，请参阅 <a href="../../base/io-network/#Base.IOContext"><code>IOContext</code></a> 文档。</p><h2 id="使用文件"><a class="docs-heading-anchor" href="#使用文件">使用文件</a><a id="使用文件-1"></a><a class="docs-heading-anchor-permalink" href="#使用文件" title="Permalink"></a></h2><p>You can write content to a file with the <code>write(filename::String, content)</code> method:</p><pre><code class="language-julia-repl hljs">julia&gt; write(&quot;hello.txt&quot;, &quot;Hello, World!&quot;)
13</code></pre><p><em>(<code>13</code> is the number of bytes written.)</em></p><p>You can read the contents of a file with the <code>read(filename::String)</code> method, or <code>read(filename::String, String)</code> to the contents as a string:</p><pre><code class="language-julia-repl hljs">julia&gt; read(&quot;hello.txt&quot;, String)
&quot;Hello, World!&quot;</code></pre><h3 id="Advanced:-streaming-files"><a class="docs-heading-anchor" href="#Advanced:-streaming-files">Advanced: streaming files</a><a id="Advanced:-streaming-files-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-streaming-files" title="Permalink"></a></h3><p>The <code>read</code> and <code>write</code> methods above allow you to read and write file contents. Like many other environments, Julia also has an <a href="../../base/io-network/#Base.open"><code>open</code></a> function, which takes a filename and returns an <a href="../../base/io-network/#Base.IOStream"><code>IOStream</code></a> object that you can use to read and write things from the file. For example, if we have a file, <code>hello.txt</code>, whose contents are <code>Hello, World!</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; f = open(&quot;hello.txt&quot;)
IOStream(&lt;file hello.txt&gt;)

julia&gt; readlines(f)
1-element Array{String,1}:
 &quot;Hello, World!&quot;</code></pre><p>若要写入文件，则可以带着 write（<code>&quot;w&quot;</code>）标志来打开它：</p><pre><code class="language-julia-repl hljs">julia&gt; f = open(&quot;hello.txt&quot;,&quot;w&quot;)
IOStream(&lt;file hello.txt&gt;)

julia&gt; write(f,&quot;Hello again.&quot;)
12</code></pre><p>你如果在此刻检查 <code>hello.txt</code> 的内容，会注意到它是空的；改动实际上还没有写入到磁盘中。这是因为 <code>IOStream</code> 必须在写入实际刷新到磁盘前关闭：</p><pre><code class="language-julia-repl hljs">julia&gt; close(f)</code></pre><p>再次检查 <code>hello.txt</code> 将显示其内容已被更改。</p><p>打开文件，对其内容执行一些操作，并再次关闭它是一种非常常见的模式。为了使这更容易，<a href="../../base/io-network/#Base.open"><code>open</code></a> 还有另一种调用方式，它以一个函数作为其第一个参数，以文件名作为其第二个参数，以该文件为参数调用该函数，然后再次关闭它。例如，给定函数：</p><pre><code class="language-julia hljs">function read_and_capitalize(f::IOStream)
    return uppercase(read(f, String))
end</code></pre><p>可以调用：</p><pre><code class="language-julia-repl hljs">julia&gt; open(read_and_capitalize, &quot;hello.txt&quot;)
&quot;HELLO AGAIN.&quot;</code></pre><p>来打开 <code>hello.txt</code>，对它调用 <code>read_and_capitalize</code>，关闭 <code>hello.txt</code> 并返回大写的内容。</p><p>为了避免被迫定义一个命名函数，你可以使用 <code>do</code> 语法，它可以动态地创建匿名函数：</p><pre><code class="language-julia-repl hljs">julia&gt; open(&quot;hello.txt&quot;) do f
           uppercase(read(f, String))
       end
&quot;HELLO AGAIN.&quot;</code></pre><h2 id="一个简单的-TCP-示例"><a class="docs-heading-anchor" href="#一个简单的-TCP-示例">一个简单的 TCP 示例</a><a id="一个简单的-TCP-示例-1"></a><a class="docs-heading-anchor-permalink" href="#一个简单的-TCP-示例" title="Permalink"></a></h2><p>让我们直接进入一个 TCP 套接字相关的简单示例。此功能位于名为 <code>Sockets</code> 的标准库中。让我们先创建一个简单的服务器：</p><pre><code class="language-julia-repl hljs">julia&gt; using Sockets

julia&gt; errormonitor(@async begin
           server = listen(2000)
           while true
               sock = accept(server)
               println(&quot;Hello World\n&quot;)
           end
       end)
Task (runnable) @0x00007fd31dc11ae0</code></pre><p>对于那些熟悉 Unix 套接字 API 的人，这些方法名称会让人感觉很熟悉，可是它们的用法比原始的 Unix 套接字 API 要简单些。在本例中，首次调用 <a href="../../stdlib/Sockets/#Sockets.listen-Tuple{Any}"><code>listen</code></a> 会创建一个服务器，等待传入指定端口（2000）的连接。</p><pre><code class="language-julia-repl hljs">julia&gt; listen(2000) # 监听（IPv4 下的）localhost:2000
Sockets.TCPServer(active)

julia&gt; listen(ip&quot;127.0.0.1&quot;,2000) # 等价于第一个
Sockets.TCPServer(active)

julia&gt; listen(ip&quot;::1&quot;,2000) # 监听（IPv6 下的）localhost:2000
Sockets.TCPServer(active)

julia&gt; listen(IPv4(0),2001) # 监听所有 IPv4 接口的端口 2001
Sockets.TCPServer(active)

julia&gt; listen(IPv6(0),2001) # 监听所有 IPv6 接口的端口 2001
Sockets.TCPServer(active)

julia&gt; listen(&quot;testsocket&quot;) # 监听 UNIX 域套接字
Sockets.PipeServer(active)

julia&gt; listen(&quot;\\\\.\\pipe\\testsocket&quot;) # 监听 Windows 命名管道
Sockets.PipeServer(active)</code></pre><p>请注意，最后一次调用返回的类型是不同的。这是因为此服务器不监听 TCP，而是监听命名管道（Windows）或 UNIX 域套接字。还请注意 Windows 命名管道格式必须具有特定的模式，即名称前缀（<code>\\.\pipe\</code>），以便唯一标识<a href="https://docs.microsoft.com/windows/desktop/ipc/pipe-names">文件类型</a>。TCP 和命名管道或 UNIX 域套接字之间的区别是微妙的，这与 <a href="../../stdlib/Sockets/#Sockets.accept"><code>accept</code></a> 和 <a href="../../stdlib/Distributed/#Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}"><code>connect</code></a> 方法有关。<a href="../../stdlib/Sockets/#Sockets.accept"><code>accept</code></a> 方法检索到连接到我们刚创建的服务器的客户端的连接，而 <a href="../../stdlib/Distributed/#Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}"><code>connect</code></a> 函数使用指定的方法连接到服务器。<a href="../../stdlib/Distributed/#Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}"><code>connect</code></a> 函数接收与 <a href="../../stdlib/Sockets/#Sockets.listen-Tuple{Any}"><code>listen</code></a> 相同的参数，因此，假设环境（即 host、cwd 等）相同，你应该能够将相同的参数传递给 <a href="../../stdlib/Distributed/#Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}"><code>connect</code></a>，就像你在监听建立连接时所做的那样。那么让我们尝试一下（在创建上面的服务器之后）：</p><pre><code class="language-julia-repl hljs">julia&gt; connect(2000)
TCPSocket(open, 0 bytes waiting)

julia&gt; Hello World</code></pre><p>不出所料，我们看到「Hello World」被打印出来。那么，让我们分析一下幕后发生的事情。在我们调用 <a href="../../stdlib/Distributed/#Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}"><code>connect</code></a> 时，我们连接到刚刚创建的服务器。与此同时，accept 函数返回到新创建的套接字的服务器端连接，并打印「Hello World」来表明连接成功。</p><p>Julia 的强大优势在于，即使 I/O 实际上是异步发生的，API 也以同步方式暴露，我们不必担心回调，甚至不必确保服务器能够运行。在我们调用 <a href="../../stdlib/Distributed/#Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}"><code>connect</code></a> 时，当前任务等待建立连接，并在这之后才继续执行。在此暂停中，服务器任务恢复执行（因为现在有一个连接请求是可用的），接受该连接，打印信息并等待下一个客户端。读取和写入以同样的方式运行。为了理解这一点，请考虑以下简单的 echo 服务器：</p><pre><code class="language-julia-repl hljs">julia&gt; errormonitor(@async begin
           server = listen(2001)
           while true
               sock = accept(server)
               @async while isopen(sock)
                   write(sock, readline(sock, keep=true))
               end
           end
       end)
Task (runnable) @0x00007fd31dc12e60

julia&gt; clientside = connect(2001)
TCPSocket(RawFD(28) open, 0 bytes waiting)

julia&gt; errormonitor(@async while isopen(clientside)
           write(stdout, readline(clientside, keep=true))
       end)
Task (runnable) @0x00007fd31dc11870

julia&gt; println(clientside,&quot;Hello World from the Echo Server&quot;)
Hello World from the Echo Server</code></pre><p>与其他流一样，使用 <a href="../../base/io-network/#Base.close"><code>close</code></a> 即可断开该套接字：</p><pre><code class="language-julia-repl hljs">julia&gt; close(clientside)</code></pre><h2 id="解析-IP-地址"><a class="docs-heading-anchor" href="#解析-IP-地址">解析 IP 地址</a><a id="解析-IP-地址-1"></a><a class="docs-heading-anchor-permalink" href="#解析-IP-地址" title="Permalink"></a></h2><p>与 <a href="../../stdlib/Sockets/#Sockets.listen-Tuple{Any}"><code>listen</code></a> 方法不一致的 <a href="../../stdlib/Distributed/#Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}"><code>connect</code></a> 方法之一是 <code>connect(host::String,port)</code>，它将尝试连接到由 <code>host</code> 参数给定的主机上的由 <code>port</code> 参数给定的端口。它允许你执行以下操作：</p><pre><code class="language-julia-repl hljs">julia&gt; connect(&quot;google.com&quot;, 80)
TCPSocket(RawFD(30) open, 0 bytes waiting)</code></pre><p>此功能的基础是 <a href="../../stdlib/Sockets/#Sockets.getaddrinfo"><code>getaddrinfo</code></a>，它将执行适当的地址解析：</p><pre><code class="language-julia-repl hljs">julia&gt; getaddrinfo(&quot;google.com&quot;)
ip&quot;74.125.226.225&quot;</code></pre><h2 id="异步-I/O"><a class="docs-heading-anchor" href="#异步-I/O">异步 I/O</a><a id="异步-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#异步-I/O" title="Permalink"></a></h2><p><a href="../../base/io-network/#Base.read"><code>Base.read</code></a> 和 <a href="../../base/io-network/#Base.write"><code>Base.write</code></a> 的所有 I/O 操作都可以通过使用 <a href="../control-flow/#man-tasks">coroutines</a> 异步执行。 你可以使用 <a href="../../base/parallel/#Base.@async"><code>@async</code></a> 宏创建一个新的协程来读取或写入流：</p><pre><code class="language-julia-repl hljs">julia&gt; task = @async open(&quot;foo.txt&quot;, &quot;w&quot;) do io
           write(io, &quot;Hello, World!&quot;)
       end;

julia&gt; wait(task)

julia&gt; readlines(&quot;foo.txt&quot;)
1-element Array{String,1}:
 &quot;Hello, World!&quot;</code></pre><p>通常会遇到您想要同时执行多个异步操作并等待它们全部完成的情况。你可以使用<a href="../../base/parallel/#Base.@sync"><code>@sync</code></a>宏，这会阻塞你的程序直到它所包裹的所有协程运行完毕。</p><pre><code class="language-julia-repl hljs">julia&gt; using Sockets

julia&gt; @sync for hostname in (&quot;google.com&quot;, &quot;github.com&quot;, &quot;julialang.org&quot;)
           @async begin
               conn = connect(hostname, 80)
               write(conn, &quot;GET / HTTP/1.1\r\nHost:$(hostname)\r\n\r\n&quot;)
               readline(conn, keep=true)
               println(&quot;Finished connection to $(hostname)&quot;)
           end
       end
Finished connection to google.com
Finished connection to julialang.org
Finished connection to github.com</code></pre><h2 id="Multicast"><a class="docs-heading-anchor" href="#Multicast">Multicast</a><a id="Multicast-1"></a><a class="docs-heading-anchor-permalink" href="#Multicast" title="Permalink"></a></h2><p>Julia supports <a href="https://datatracker.ietf.org/doc/html/rfc1112">multicast</a> over IPv4 and IPv6 using the User Datagram Protocol (<a href="https://datatracker.ietf.org/doc/html/rfc768">UDP</a>) as transport.</p><p>Unlike the Transmission Control Protocol (<a href="https://datatracker.ietf.org/doc/html/rfc793">TCP</a>), UDP makes almost no assumptions about the needs of the application. TCP provides flow control (it accelerates and decelerates to maximize throughput), reliability (lost or corrupt packets are automatically retransmitted), sequencing (packets are ordered by the operating system before they are given to the application), segment size, and session setup and teardown. UDP provides no such features.</p><p>A common use for UDP is in multicast applications. TCP is a stateful protocol for communication between exactly two devices. UDP can use special multicast addresses to allow simultaneous communication between many devices.</p><h3 id="Receiving-IP-Multicast-Packets"><a class="docs-heading-anchor" href="#Receiving-IP-Multicast-Packets">Receiving IP Multicast Packets</a><a id="Receiving-IP-Multicast-Packets-1"></a><a class="docs-heading-anchor-permalink" href="#Receiving-IP-Multicast-Packets" title="Permalink"></a></h3><p>To transmit data over UDP multicast, simply <code>recv</code> on the socket, and the first packet received will be returned. Note that it may not be the first packet that you sent however!</p><pre><code class="language-julia hljs">using Sockets
group = ip&quot;228.5.6.7&quot;
socket = Sockets.UDPSocket()
bind(socket, ip&quot;0.0.0.0&quot;, 6789)
join_multicast_group(socket, group)
println(String(recv(socket)))
leave_multicast_group(socket, group)
close(socket)</code></pre><h3 id="Sending-IP-Multicast-Packets"><a class="docs-heading-anchor" href="#Sending-IP-Multicast-Packets">Sending IP Multicast Packets</a><a id="Sending-IP-Multicast-Packets-1"></a><a class="docs-heading-anchor-permalink" href="#Sending-IP-Multicast-Packets" title="Permalink"></a></h3><p>To transmit data over UDP multicast, simply <code>send</code> to the socket. Notice that it is not necessary for a sender to join the multicast group.</p><pre><code class="language-julia hljs">using Sockets
group = ip&quot;228.5.6.7&quot;
socket = Sockets.UDPSocket()
send(socket, group, 6789, &quot;Hello over IPv4&quot;)
close(socket)</code></pre><h3 id="IPv6-Example"><a class="docs-heading-anchor" href="#IPv6-Example">IPv6 Example</a><a id="IPv6-Example-1"></a><a class="docs-heading-anchor-permalink" href="#IPv6-Example" title="Permalink"></a></h3><p>This example gives the same functionality as the previous program, but uses IPv6 as the network-layer protocol.</p><p>Listener:</p><pre><code class="language-julia hljs">using Sockets
group = Sockets.IPv6(&quot;ff05::5:6:7&quot;)
socket = Sockets.UDPSocket()
bind(socket, Sockets.IPv6(&quot;::&quot;), 6789)
join_multicast_group(socket, group)
println(String(recv(socket)))
leave_multicast_group(socket, group)
close(socket)</code></pre><p>Sender:</p><pre><code class="language-julia hljs">using Sockets
group = Sockets.IPv6(&quot;ff05::5:6:7&quot;)
socket = Sockets.UDPSocket()
send(socket, group, 6789, &quot;Hello over IPv6&quot;)
close(socket)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../missing/">« 缺失值</a><a class="docs-footer-nextpage" href="../parallel-computing/">并行计算 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>本文档在 <span class="colophon-date" title="2024 十二月 22 周日 18:40">2024 十二月 22 周日</span>用 <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> 1.8.0 版生成使用 1.10.7 版本的 Julia。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
