<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>与其他语言的显著差异 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/noteworthy-differences/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">变量</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../multi-threading/">多线程</a></li><li><a class="tocitem" href="../distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li class="is-active"><a class="tocitem" href>与其他语言的显著差异</a><ul class="internal"><li><a class="tocitem" href="#Noteworthy-differences-from-MATLAB"><span>与 MATLAB 的显著差异</span></a></li><li><a class="tocitem" href="#Noteworthy-differences-from-R"><span>与 R 的显著差异</span></a></li><li><a class="tocitem" href="#Noteworthy-differences-from-Python"><span>与 Python 的显著差异</span></a></li><li><a class="tocitem" href="#Noteworthy-differences-from-C/C"><span>与 C/C++ 的显著差异</span></a></li><li><a class="tocitem" href="#Noteworthy-differences-from-Common-Lisp"><span>与 Common Lisp 的显著差异</span></a></li></ul></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../command-line-options/">命令行选项</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>与其他语言的显著差异</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>与其他语言的显著差异</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/noteworthy-differencesmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="与其他语言的显著差异"><a class="docs-heading-anchor" href="#与其他语言的显著差异">与其他语言的显著差异</a><a id="与其他语言的显著差异-1"></a><a class="docs-heading-anchor-permalink" href="#与其他语言的显著差异" title="Permalink"></a></h1><h2 id="Noteworthy-differences-from-MATLAB"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-MATLAB">与 MATLAB 的显著差异</a><a id="Noteworthy-differences-from-MATLAB-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-MATLAB" title="Permalink"></a></h2><p>虽然 MATLAB 用户可能会发现 Julia 的语法很熟悉，但 Julia 不是 MATLAB 的克隆。 它们之间存在重大的语法和功能差异。 以下是一些可能会使习惯于 MATLAB 的 Julia 用户感到困扰的显著差异：</p><ul><li>Julia 数组使用方括号 <code>A[i,j]</code> 进行索引。</li><li>Julia 数组在分配给另一个变量时不会被复制。 在<code>A = B</code>之后，改变<code>B</code>的元素也会改变<code>A</code>的元素。</li><li>Julia 的值在向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。</li><li>Julia 不会在赋值语句中自动增长数组。 而在 MATLAB 中 <code>a(4) = 3.2</code> 可以创建数组 <code>a = [0 0 0 3.2]</code>，而 <code>a(5) = 7</code> 可以将它增长为 <code>a = [0 0 0 3.2 7]</code>。如果 <code>a</code> 的长度小于 5 或者这个语句是第一次使用标识符 <code>a</code>，则相应的 Julia 语句 <code>a[5] = 7</code> 会抛出错误。Julia 使用 <a href="../../base/collections/#Base.push!"><code>push!</code></a> 和 <a href="../../base/collections/#Base.append!"><code>append!</code></a> 来增长 <code>Vector</code>，它们比 MATLAB 的 <code>a(end+1) = val</code> 更高效。</li><li>虚数单位 <code>sqrt(-1)</code> 在 Julia 中表示为 <a href="../../base/numbers/#Base.im"><code>im</code></a>，而不是在 MATLAB 中的 <code>i</code> 或 <code>j</code>。</li><li>在 Julia 中，没有小数点的数字字面量（例如 <code>42</code>）会创建整数而不是浮点数。也支持任意大整数字面量。因此，某些操作（如 <code>2^-1</code>）将抛出 domain error，因为结果不是整数（有关的详细信息，请参阅<a href="../faq/#faq-domain-errors">常见问题中有关 domain errors 的条目</a>）。 在 Julia 中，没有小数点的数字字面量（例如 <code>42</code>）会创建整数而不是浮点数。因此，某些操作会因为需要浮点数而抛出 domain error；例如 <code>julia &gt; a = -1; 2^a</code> ，因为结果不是整数了。请参阅<a href="../faq/#faq-domain-errors">常见问题中有关 domain errors 的条目</a>）。</li><li>在 Julia 中，能返回多个值并将其赋值为元组，例如 <code>(a, b) = (1, 2)</code> 或 <code>a, b = 1, 2</code>。 在 Julia 中不存在 MATLAB 的 <code>nargout</code>，它通常在 MATLAB 中用于根据返回值的数量执行可选工作。取而代之的是，用户可以使用可选参数和关键字参数来实现类似的功能。</li><li>Julia 拥有真正的一维数组。列向量的大小为 <code>N</code>，而不是 <code>Nx1</code>。例如，<a href="../../stdlib/Random/#Base.rand"><code>rand(N)</code></a> 创建一个一维数组。</li><li>在 Julia 中，<code>[x,y,z]</code> 将始终构造一个包含<code>x</code>、<code>y</code> 和 <code>z</code> 的 3 元数组。<ul><li>要在第一个维度（「垂直列」）中连接元素，请使用 <a href="../../base/arrays/#Base.vcat"><code>vcat(x,y,z)</code></a> 或用分号分隔（<code>[x; y; z]</code>）。</li><li>要在第二个维度（「水平行」）中连接元素，请使用 <a href="../../base/arrays/#Base.hcat"><code>hcat(x,y,z)</code></a> 或用空格分隔（<code>[x y z]</code>）。</li><li>要构造分块矩阵（在前两个维度中连接元素），请使用 <a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a> 或组合空格和分号（<code>[a b; c d]</code>）。</li></ul></li><li>在 Julia 中，<code>a:b</code> 和 <code>a:b:c</code> 构造 <code>AbstractRange</code> 对象。使用 <a href="../../base/collections/#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a> 构造一个类似 MATLAB 中完整的向量。通常，不需要调用 <code>collect</code>。在大多数情况下，<code>AbstractRange</code> 对象将像普通数组一样运行，但效率更高，因为它是懒惰求值。这种创建专用对象而不是完整数组的模式经常被使用，并且也可以在诸如 <a href="../../base/math/#Base.range"><code>range</code></a> 之类的函数中看到，或者在诸如 <code>enumerate</code> 和 <code>zip</code> 之类的迭代器中看到。特殊对象大多可以像正常数组一样使用。</li><li>Julia 中的函数返回其最后一个表达式或 <code>return</code> 关键字的值而无需在函数定义中列出要返回的变量的名称（有关详细信息，请参阅 <a href="../functions/#return-关键字">return 关键字</a>）。</li><li>Julia 脚本可以包含任意数量的函数，并且在加载文件时，所有定义都将在外部可见。可以从当前工作目录之外的文件加载函数定义。</li><li>在 Julia 中，例如 <a href="../../base/collections/#Base.sum"><code>sum</code></a>、<a href="../../base/collections/#Base.prod"><code>prod</code></a> 和 <a href="../../base/math/#Base.max"><code>max</code></a> 的归约操作会作用到数组的每一个元素上，当调用时只有一个函数，例如 <code>sum(A)</code>，即使 <code>A</code> 并不只有一个维度。</li><li>在 Julia 中，调用无参数的函数时必须使用小括号，例如 <a href="../../stdlib/Random/#Base.rand"><code>rand()</code></a>。</li><li>Julia 不鼓励使用分号来结束语句。语句的结果不会自动打印（除了在 REPL 中），并且代码的一行不必使用分号结尾。<a href="../../base/io-network/#Base.println"><code>println</code></a> 或者 <a href="../../stdlib/Printf/#Printf.@printf"><code>@printf</code></a> 能用来打印特定输出。</li><li>在 Julia 中，如果 <code>A</code> 和 <code>B</code> 是数组，像 <code>A == B</code> 这样的逻辑比较运算符不会返回布尔值数组。相反地，请使用 <code>A .== B</code>。对于其他的像是 <a href="../../base/math/#Base.:&lt;"><code>&lt;</code></a>、<a href="../../base/math/#Base.:&gt;"><code>&gt;</code></a> 的布尔运算符同理。</li><li>在 Julia 中，运算符<a href="../../base/math/#Base.:&amp;"><code>&amp;</code></a>、<a href="../../base/math/#Base.:|"><code>|</code></a> 和 <a href="../../base/math/#Base.xor"><code>⊻</code></a>（<a href="../../base/math/#Base.xor"><code>xor</code></a>）进行按位操作，分别与MATLAB中的<code>and</code>、<code>or</code> 和 <code>xor</code> 等价，并且优先级与 Python 的按位运算符相似（不像 C）。他们可以对标量运算或者数组中逐元素运算，可以用来合并逻辑数组，但是注意运算顺序的区别：括号可能是必要的（例如，选择 <code>A</code> 中等于 1 或 2 的元素可使用 <code>(A .== 1) .| (A .== 2)</code>）。</li><li>在 Julia 中，集合的元素可以使用 splat 运算符 <code>...</code> 来作为参数传递给函数，如 <code>xs=[1,2]; f(xs...)</code>。</li><li>Julia 的 <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.svd"><code>svd</code></a> 将奇异值作为向量而非密集对角矩阵返回。</li><li>在 Julia 中，<code>...</code> 不用于延续代码行。不同的是，Julia 中不完整的表达式会自动延续到下一行。</li><li>在 Julia 和 MATLAB 中，变量 <code>ans</code> 被设置为交互式会话中提交的最后一个表达式的值。在 Julia 中与 MATLAB 不同的是，当 Julia 代码以非交互式模式运行时并不会设置 <code>ans</code>。</li><li>Julia 的 <code>struct</code> 不支持在运行时动态地添加字段，这与 MATLAB 的 <code>class</code> 不同。 如需支持，请使用 <a href="../../base/collections/#Base.Dict"><code>Dict</code></a>。Julia 中的字典不是有序的。</li><li>在 Julia 中，每个模块有自身的全局作用域/命名空间，而在 MATLAB 中只有一个全局作用域。</li><li>在 MATLAB 中，删除不需要的值的惯用方法是使用逻辑索引，如表达式 <code>x(x&gt;3)</code> 或语句 <code>x(x&gt;3) = []</code> 来 in-place 修改 <code>x</code>。相比之下，Julia 提供了更高阶的函数 <a href="../../base/collections/#Base.filter"><code>filter</code></a> 和 <a href="../../base/collections/#Base.filter!"><code>filter!</code></a>，允许用户编写 <code>filter(z-&gt;z&gt;3, x)</code> 和 <code>filter!(z-&gt;z&gt;3, x)</code> 来代替相应直译 <code>x[x.&gt;3]</code> 和 <code>x = x[x.&gt;3]</code>。使用 <a href="../../base/collections/#Base.filter!"><code>filter!</code></a> 可以减少临时数组的使用。</li><li>类似于提取（或「解引用」）元胞数组的所有元素的操作，例如 MATLAB 中的 <code>vertcat(A{:})</code>，在 Julia 中是使用 splat 运算符编写的，例如 <code>vcat(A...)</code>。</li><li>在 Julia 中，<code>adjoint</code> 函数执行共轭转置；在 MATLAB 中，<code>adjoint</code> 提供了经典伴随，它是余子式的转置。</li><li>在 Julia 中，a^b^c 被认为是 a^(b^c) 而在 MATLAB 中它是 (a^b)^c。</li></ul><h2 id="Noteworthy-differences-from-R"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-R">与 R 的显著差异</a><a id="Noteworthy-differences-from-R-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-R" title="Permalink"></a></h2><p>Julia 的目标之一是为数据分析和统计编程提供高效的语言。对于从 R 转到 Julia 的用户来说，这是一些显著差异：</p><ul><li><p>Julia 的单引号封闭字符，而不是字符串。</p></li><li><p>Julia 可以通过索引字符串来创建子字符串。在 R 中，在创建子字符串之前必须将字符串转换为字符向量。</p></li><li><p>在 Julia 中，与 Python 相同但与 R 不同的是，字符串可由三重引号 <code>&quot;&quot;&quot; ... &quot;&quot;&quot;</code> 创建。此语法对于构造包含换行符的字符串很方便。</p></li><li><p>在 Julia 中，可变参数使用 splat 运算符 <code>...</code> 指定，该运算符总是跟在具体变量的名称后面，与 R 的不同，R 的 <code>...</code> 可以单独出现。</p></li><li><p>在 Julia 中，模数是 <code>mod(a, b)</code>，而不是 <code>a %% b</code>。Julia 中的 <code>%</code> 是余数运算符。</p></li><li><p>在 Julia 中，并非所有数据结构都支持逻辑索引。此外，Julia 中的逻辑索引只支持长度等于被索引对象的向量。例如：</p><ul><li>在 R 中，<code>c(1, 2, 3, 4)[c(TRUE, FALSE)]</code> 等价于 <code>c(1, 3)</code>。</li><li>在 R 中，<code>c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]</code> 等价于 <code>c(1, 3)</code>。</li><li>在 Julia 中，<code>[1, 2, 3, 4][[true, false]]</code> 抛出 <a href="../../base/base/#Core.BoundsError"><code>BoundsError</code></a>。</li><li>在 Julia 中，<code>[1, 2, 3, 4][[true, false, true, false]]</code> 产生 <code>[1, 3]</code>。</li></ul></li><li><p>与许多语言一样，Julia 并不总是允许对不同长度的向量进行操作，与 R 不同，R 中的向量只需要共享一个公共的索引范围。例如，<code>c(1, 2, 3, 4) + c(1, 2)</code> 是有效的 R，但等价的 <code>[1, 2, 3, 4] + [1, 2]</code> 在 Julia 中会抛出一个错误。</p></li><li><p>在逗号不改变代码含义时，Julia 允许使用可选的尾随括号。在索引数组时，这可能在 R 用户间造成混淆。例如，R 中的 <code>x[1,]</code> 将返回矩阵的第一行；但是，在 Julia 中，引号被忽略，于是 <code>x[1,] == x[1]</code>，并且将返回第一个元素。要提取一行，请务必使用 <code>:</code>，如 <code>x[1,:]</code>。</p></li><li><p>Julia 的 <a href="../../base/collections/#Base.map"><code>map</code></a> 首先接受函数，然后是该函数的参数，这与 R 中的 <code>lapply(&lt;structure&gt;, function, ...)</code> 不同。类似地，R 中的 <code>apply(X, MARGIN, FUN, ...)</code> 等价于 Julia 的 <a href="../../base/arrays/#Base.mapslices"><code>mapslices</code></a>，其中函数是第一个参数。</p></li><li><p>R 中的多变量 apply，如 <code>mapply(choose, 11:13, 1:3)</code>，在 Julia 中可以编写成 <code>broadcast(binomial, 11:13, 1:3)</code>。等价地，Julia 提供了更短的点语法来向量化函数 <code>binomial.(11:13, 1:3)</code>。</p></li><li><p>Julia 使用 <code>end</code> 来表示条件块（如 <code>if</code>）、循环块（如 <code>while</code>/<code>for</code>）和函数的结束。为了代替单行 <code>if ( cond ) statement</code>，Julia 允许形式为 <code>if cond; statement; end</code>、<code>cond &amp;&amp; statement</code> 和 <code>!cond || statement</code> 的语句。后两种语法中的赋值语句必须显式地包含在括号中，例如 <code>cond &amp;&amp; (x = value)</code>，这是因为运算符的优先级。</p></li><li><p>在 Julia 中，<code>&lt;-</code>, <code>&lt;&lt;-</code> 和 <code>-&gt;</code> 不是赋值运算符。</p></li><li><p>Julia 的 <code>-&gt;</code> 创建一个匿名函数。</p></li><li><p>Julia 使用括号构造向量。Julia 的 <code>[1, 2, 3]</code> 等价于 R 的 <code>c(1, 2, 3)</code>。</p></li><li><p>Julia 的 <a href="../../base/math/#Base.:*-Tuple{Any, Vararg{Any, N} where N}"><code>*</code></a> 运算符可以执行矩阵乘法，这与 R 不同。如果 <code>A</code> 和 <code>B</code> 都是矩阵，那么 <code>A * B</code> 在 Julia 中表示矩阵乘法，等价于 R 的 <code>A %*% B</code>。在 R 中，相同的符号将执行逐元素（Hadamard）乘积。要在 Julia 中使用逐元素乘法运算，你需要编写 <code>A .* B</code>。</p></li><li><p>Julia 使用 <code>transpose</code> 函数来执行矩阵转置，使用 <code>&#39;</code> 运算符或 <code>adjoint</code> 函数来执行共轭转置。因此，Julia 的 <code>transpose(A)</code> 等价于 R 的 <code>t(A)</code>。另外，Julia 中的非递归转置由 <code>permutedims</code> 函数提供。</p></li><li><p>Julia 在编写 <code>if</code> 语句或 <code>for</code>/<code>while</code> 循环时不需要括号：请使用 <code>for i in [1, 2, 3]</code> 代替 <code>for (int i=1; i &lt;= 3; i++)</code>，以及 <code>if i == 1</code> 代替 <code>if (i == 1)</code></p></li><li><p>Julia 不把数字 <code>0</code> 和 <code>1</code> 视为布尔值。在 Julia 中不能编写 <code>if (1)</code>，因为 <code>if</code> 语句只接受布尔值。相反，可以编写 <code>if true</code>、<code>if Bool(1)</code> 或 <code>if 1==1</code>。</p></li><li><p>Julia 不提供 <code>nrow</code> 和 <code>ncol</code>。相反，请使用 <code>size(M, 1)</code> 代替 <code>nrow(M)</code> 以及 <code>size(M, 2)</code> 代替 <code>ncol(M)</code></p></li><li><p>Julia 仔细区分了标量、向量和矩阵。在 R 中，<code>1</code> 和 <code>c(1)</code> 是相同的。在 Julia 中，它们不能互换地使用。</p></li><li><p>Julia 的 <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.diag"><code>diag</code></a> 和 <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.diagm"><code>diagm</code></a> 与 R 的不同。</p></li><li><p>Julia 赋值操作的左侧不能为函数调用的结果：你不能编写 <code>diag(M) = fill(1, n)</code>。</p></li><li><p>Julia 不鼓励使用函数填充主命名空间。Julia 的大多数统计功能都可在 <a href="https://github.com/JuliaStats">JuliaStats 组织</a>的<a href="https://pkg.julialang.org/">包</a>中找到。例如：</p><ul><li>与概率分布相关的函数由 <a href="https://github.com/JuliaStats/Distributions.jl">Distributions 包</a>提供。</li><li><a href="https://github.com/JuliaData/DataFrames.jl">DataFrames 包</a>提供数据帧。</li><li>广义线性模型由 <a href="https://github.com/JuliaStats/GLM.jl">GLM 包</a>提供。</li></ul></li><li><p>Julia 提供了元组和真正的哈希表，但不提供 R 风格的列表。在返回多个项时，通常应使用元组或具名元组：请使用 <code>(1, 2)</code> 或 <code>(a=1, b=2)</code> 代替 <code>list(a = 1, b = 2)</code>。</p></li><li><p>Julia 鼓励用户编写自己的类型，它比 R 中的 S3 或 S4 对象更容易使用。Julia 的多重派发系统意味着 <code>table(x::TypeA)</code> 和 <code>table(x::TypeB)</code> 类似于 R 的 <code>table.TypeA(x)</code> 和 <code>table.TypeB(x)</code>。</p></li><li><p>Julia 的值在向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。这与 R 非常不同，允许新函数更高效地操作大型数据结构。</p></li><li><p>在 Julia 中，向量和矩阵使用 <a href="../../base/arrays/#Base.hcat"><code>hcat</code></a>、<a href="../../base/arrays/#Base.vcat"><code>vcat</code></a> 和 <a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a> 拼接，而不是像在 R 中那样使用 <code>c</code>、<code>rbind</code> 和 <code>cbind</code>。</p></li><li><p>在 Julia 中，像 <code>a:b</code> 这样的 range 不是 R 中的向量简写，而是一个专门的 <code>AbstractRange</code> 对象，该对象用于没有高内存开销地进行迭代。要将 range 转换为 vector，请使用 <a href="../../base/collections/#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a>。</p></li><li><p>Julia 的 <a href="../../base/math/#Base.max"><code>max</code></a> 和 <a href="../../base/math/#Base.min"><code>min</code></a> 分别等价于 R 中的 <code>pmax</code> 和 <code>pmin</code>，但两者的参数都需要具有相同的维度。虽然 <a href="../../base/collections/#Base.maximum"><code>maximum</code></a> 和 <a href="../../base/collections/#Base.minimum"><code>minimum</code></a> 代替了 R 中的 <code>max</code> 和 <code>min</code>，但它们之间有重大区别。</p></li><li><p>Julia 的 <a href="../../base/collections/#Base.sum"><code>sum</code></a>、<a href="../../base/collections/#Base.prod"><code>prod</code></a>、<a href="../../base/collections/#Base.maximum"><code>maximum</code></a> 和 <a href="../../base/collections/#Base.minimum"><code>minimum</code></a> 与它们在 R 中的对应物不同。它们都接受一个可选的关键字参数 <code>dims</code>，它表示执行操作的维度。例如，在 Julia 中令 <code>A = [1 2; 3 4]</code>，在 R 中令 <code>B &lt;- rbind(c(1,2),c(3,4))</code> 是与之相同的矩阵。然后 <code>sum(A)</code> 得到与 <code>sum(B)</code> 相同的结果，但 <code>sum(A, dims=1)</code> 是一个包含每一列总和的行向量，<code>sum(A, dims=2)</code> 是一个包含每一行总和的列向量。这与 R 的行为形成了对比，在 R 中，单独的 <code>colSums(B)</code> 和 <code>rowSums(B)</code> 提供了这些功能。如果 <code>dims</code> 关键字参数是向量，则它指定执行求和的所有维度，并同时保持待求和数组的维数，例如 <code>sum(A, dims=(1,2)) == hcat(10)</code>。应该注意的是，没有针对第二个参数的错误检查。</p></li><li><p>Julia 具有一些可以改变其参数的函数。例如，它具有 <a href="../../base/sort/#Base.sort"><code>sort</code></a> 和 <a href="../../base/sort/#Base.sort!"><code>sort!</code></a>。</p></li><li><p>在 R 中，高性能需要向量化。在 Julia 中，这几乎恰恰相反：性能最高的代码通常通过去向量化的循环来实现。</p></li><li><p>Julia 是立即求值的，不支持 R 风格的惰性求值。对于大多数用户来说，这意味着很少有未引用的表达式或列名。</p></li><li><p>Julia 不支持 <code>NULL</code> 类型。最接近的等价物是 <a href="../../base/constants/#Core.nothing"><code>nothing</code></a>，但它的行为类似于标量值而不是列表。请使用 <code>x === nothing</code> 代替 <code>is.null(x)</code>。</p></li><li><p>在 Julia 中，缺失值由 <a href="../../base/base/#Base.missing"><code>missing</code></a> 表示，而不是由 <code>NA</code> 表示。请使用 <a href="../../base/base/#Base.ismissing"><code>ismissing(x)</code></a>（或者在向量上使用逐元素操作 <code>ismissing.(x)</code>）代替 <code>isna(x)</code>。通常使用 <a href="../../base/base/#Base.skipmissing"><code>skipmissing</code></a> 代替 <code>na.rm=TRUE</code>（尽管在某些特定情况下函数接受 <code>skipmissing</code> 参数）。</p></li><li><p>Julia 缺少 R 中的 <code>assign</code> 或 <code>get</code> 的等价物。</p></li><li><p>在 Julia 中，<code>return</code> 不需要括号。</p></li><li><p>在 R 中，删除不需要的值的惯用方法是使用逻辑索引，如表达式 <code>x[x&gt;3]</code> 或语句 <code>x = x[x&gt;3]</code> 来 in-place 修改 <code>x</code>。相比之下，Julia 提供了更高阶的函数 <a href="../../base/collections/#Base.filter"><code>filter</code></a> 和 <a href="../../base/collections/#Base.filter!"><code>filter!</code></a>，允许用户编写 <code>filter(z-&gt;z&gt;3, x)</code> 和 <code>filter!(z-&gt;z&gt;3, x)</code> 来代替相应直译 <code>x[x.&gt;3]</code> 和 <code>x = x[x.&gt;3]</code>。使用 <a href="../../base/collections/#Base.filter!"><code>filter!</code></a> 可以减少临时数组的使用。</p></li></ul><h2 id="Noteworthy-differences-from-Python"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-Python">与 Python 的显著差异</a><a id="Noteworthy-differences-from-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-Python" title="Permalink"></a></h2><ul><li>Julia 的 <code>for</code>, <code>if</code>, <code>while</code> 等语句块都以 <code>end</code> 关键字结束。代码的缩进不像在 Python 中那样重要。Julia 也没有 <code>pass</code> 关键字。 </li><li>Julia 中的字符串使用双引号构造，如 <code>&quot;text&quot;</code>，也可以使用三引号构造多行字符串。而在 Python 中可以使用单引号（<code>&#39;text&#39;</code>）或者双引号（<code>&quot;text&quot;</code>）。单引号在 Julia 中用来表示单个字符，例如 <code>&#39;c&#39;</code>。</li><li>在 Julia 中字符串的拼接使用 <code>*</code>，而不是像 Python 一样使用 <code>+</code>。类似的，字符串重复多次 Julia 使用 <code>^</code> 而不是 <code>*</code>。Julia 也不支持隐式的字符串拼接，例如 Python 中的 <code>&#39;ab&#39; &#39;cd&#39; == &#39;abcd&#39;</code>。</li><li>Python 列表——灵活但缓慢——对应于 Julia 的 <code>Vector{Any}</code> 类型或更一般的 <code>Vector{T}</code>，其中 <code>T</code> 是一些非具体元素类型。 “快”的数组，如 NumPy 数组，它们就地存储元素（即，<code>dtype</code> 是 <code>np.float64</code>、<code>[(&#39;f1&#39;, np.uint64), (&#39;f2&#39;, np.int32)]</code>， 等）可以用 <code>Array{T}</code> 表示，其中 <code>T</code> 是一个具体的、不可变的元素类型。 这包括内置类型，如 <code>Float64</code>、<code>Int32</code>、<code>Int64</code>，也包括更复杂的类型，如 <code>Tuple{UInt64,Float64}</code> 和许多用户定义的类型。</li><li>在 Julia 中，数组、字符串等的索引从 1 开始，而不是从 0 开始。</li><li>Julia 里的切片包含最后一个元素。Julia 里的 <code>a[2:3]</code> 等同于 Python 中的 <code>a[1:3]</code>。</li><li>Julia 不支持负数索引。特别地，列表或数组的最后一个元素在 Julia 中使用 <code>end</code> 索引，而不像在 Python 中使用 <code>-1</code>。</li><li>Julia 的索引必须写全。Python 中的 <code>x[1:]</code> 等价于 Julia 中的 <code>x[2:end]</code>。</li><li>Julia 的范围语法为 <code>x[start:step:stop]</code>，而 Python 的格式为 <code>x[start:(stop+1):step]</code>。</li></ul><p>因此 Python 中的 <code>x[0:10:2]</code> 等价于 Julia 里的 <code>x[1:2:10]</code>。类似的 Python 中的反转数组 <code>x[::-1]</code> 等价于 Julia 中的 <code>x[end:-1:1]</code>。</p><ul><li>在 Julia 中队一个矩阵取索引 <code>X[[1,2], [1,3]]</code> 返回一个子矩阵，它包含了第一和第二行与第一和第三列的交集。</li></ul><p>在 Python 中 <code>X[[1,2], [1,3]]</code> 返回一个向量，它包含索引 <code>[1,1]</code> 和 <code>[2,3]</code> 的值。Julia 中的 <code>X[[1,2], [1,3]]</code> 等价于 Python 中的 <code>X[np.ix_([0,1],[0,2])]</code>。Python 中的 <code>X[[1,2], [1,3]]</code> 等价于 Julia 中的 <code>X[[CartesianIndex(1,1), CartesianIndex(2,3)]]</code>。</p><ul><li>Julia 没有用来续行的语法：如果在行的末尾，到目前为止的输入是一个完整的表达式，则认为其已经结束；否则，认为输入继续。强制表达式继续的一种方式是将其包含在括号中。</li><li>默认情况下，Julia 数组是列优先（Fortran 排序），而 NumPy 数组是行优先（C 排序）。为了在循环数组时获得最佳性能，Julia 中的循环顺序应相对于 NumPy 颠倒（请参阅<a href="../performance-tips/#man-performance-column-major">性能提示的相关部分</a>）。</li><li>Julia 的更新运算符（例如 <code>+=</code>，<code>-=</code>，···）是非原位操作（not in-place），而 Numpy 的是。这意味着 <code>A = [1, 1]; B = A; B += [3, 3]</code> 不会改变 <code>A</code> 中的值，而将名称 <code>B</code> 重新绑定到右侧表达式 <code>B = B + 3</code> 的结果，这是一个新的数组。对于 in-place 操作，使用 <code>B .+= 3</code>（另请参阅 <a href="../mathematical-operations/#man-dot-operators">dot operators</a>）、显式的循环或者 <code>InplaceOps.jl</code>。</li><li>Julia 的函数在调用时，每次都对默认参数重新求值，不像 Python 只在函数定义时对默认参数求一次值。</li></ul><p>举例来说：Julia 的函数 <code>f(x=rand()) = x</code> 在无参数调用时（<code>f()</code>），每次都会返回不同的随机数。 另一方面，函数 <code>g(x=[1,2]) = push!(x,3)</code> 无参数调用时 <code>g()</code>，永远返回 <code>[1,2,3]</code>。</p><ul><li>在 Julia 中，必须使用关键字来传递关键字参数，这与 Python 中通常可以按位置传递它们不同。尝试按位置传递关键字参数会改变方法签名，从而导致 <code>MethodError</code> 或调用错误的方法。</li><li>在 Julia 中，<code>%</code> 是余数运算符，而在 Python 中是模运算符。</li></ul><p>（译注：二者在参数有负数时有区别）</p><ul><li>在 Julia 中，常用的整数类型 Int 对应机器的整数类型，<code>Int32</code> 或 <code>Int64</code>。不像 Python 中的整数 int 是任意精度的。这意味着 Julia 中默认的整数类型会溢出，因此 <code>2^64 == 0</code>。如果你要表示一个大数，请选择一个合适的类型。如：<code>Int128</code>、任意精度的 <code>BigInt</code> 或者浮点类型 <code>Flost64</code>。</li><li>Julia 中虚数单位 <code>sqrt(-1)</code> 是 <code>im</code>，而不是 Python 中的 <code>j</code>。</li><li>Julia 中指数是 <code>^</code>，而不是 Python 中的 <code>**</code>。</li><li>Julia 使用 <code>Nothing</code> 类型的实例 <code>nothing</code> 代表空值（null），而不是 Python 中 <code>NoneType</code> 类的 <code>None</code>。</li><li>在 Julia 中，标准的运算符作用在矩阵上就得到矩阵操作，不像 Python 标准运算符默认是逐元素操作。当 A 和 B 都是矩阵时，<code>A * B</code> 在 Julia 中代表着矩阵乘法，而不是 Python 中的逐元素相乘。即：Julia 中的 <code>A * B</code> 等同于 Python 的 <code>A @ B</code>；Python 中的 <code>A * B</code> 等同于 Julia 中的 <code>A .* B</code>。</li><li>Julia 中的伴随操作符 <code>&#39;</code> 返回向量的转置（一种行向量的懒惰表示法）。Python 中对向量执行 <code>.T</code> 返回它本身（没有效果）。</li><li>在Julia中，一个函数可能包含多个具体实现（称为<em>方法</em>），与Python中的函数相比，这些实现是根据调用的所有参数的类型通过多重派发选择的，它只有一个实现，没有多态性（与Python方法调用相反，Python方法调用使用不同的语法，并允许在方法的接收者上进行派发）。</li><li>Julia 没有类（class），取而代替的是结构体（structures），可以是可变的或不可变的，它们只包含数据而不包含方法。</li></ul><ul><li>在 Python 中调用类实例的方法 (<code>x = MyClass(*args); x.f(y)</code>) 对应于 Julia 中的函数调用，例如 <code>x = MyType(args...); f(x, y)</code>。 总的来说，多重派发比 Python 类系统更灵活和强大。</li><li>Julia 的结构体有且只能有一个抽象超类型（abstract supertype），而 Python 的类可以纪成一个或多个、抽象或具体的超类（superclasses）。</li><li>逻辑 Julia 程序结构（包和模块）独立于文件结构（<code>include</code> 用于附加文件），而 Python 代码结构由目录（包）和文件（模块）定义。</li><li>Julia 中的三元运算符 <code>x &gt; 0 ? 1 :  -1</code> 对应于 Python 中的条件表达式 <code>1 if x &gt; 0 else -1</code>。</li><li>Julia 中以 <code>@</code> 开头的符号是宏（macro），而 Python 中是装饰器（decorator）。</li><li>Julia 的异常处理使用 <code>try</code> — <code>catch</code> — <code>finally</code>，而不是 Python 的 <code>try</code> — <code>except</code> — <code>finally</code>。与 Python 不同的是，因为性能的原因，Julia 不推荐在正常流程中使用异常处理。</li><li>Julia 的循环很快，所以没必要手动向量化（vectorized）。</li><li>小心 Julia 中的非常量全局变量，尤其它出现在循环中时。因为你在 Julia 中可以写出贴近硬件的代码，这时使用全局变量的影响非常大（参见<a href="../performance-tips/#man-performance-tips">性能建议</a>）</li><li>Python 中大多数的值都能用在逻辑运算中。例如：<code>if &quot;a&quot;</code> 永真，<code>if &quot;&quot;</code> 恒假。在 Julia 中你只能使用布尔类型的值，或者显示的将其他值转为布尔类型，否则就会抛出异常。例如当你想测试字符串是否为空是，请使用 <code>if !isempty(&quot;&quot;)</code>。</li><li>在 Julia 中大多数代码块都会引入新的本地作用域（local scope）。例如：循环和异常处理的 try — catch — finally。注意：列表推断（comprehensions）与生成器在 Julia 和 Python 中都会引入新的作用域；而 if 分支则都不会引入。</li></ul><h2 id="Noteworthy-differences-from-C/C"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-C/C">与 C/C++ 的显著差异</a><a id="Noteworthy-differences-from-C/C-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-C/C" title="Permalink"></a></h2><ul><li>Julia 的数组由方括号索引，方括号中可以包含不止一个维度 <code>A[i,j]</code>。这样的语法不仅仅是像 C/C++ 中那样对指针或者地址引用的语法糖，参见<a href="../arrays/#man-multi-dim-arrays">关于数组构造的语法的 Julia 文档</a>。</li><li>在 Julia 中，数组、字符串等的索引从 1 开始，而不是从 0 开始。</li><li>Julia 的数组在赋值给另一个变量时不发生复制。执行 <code>A = B</code> 后，改变 <code>B</code> 中元素也会修改 <code>A</code>。像 <code>+=</code> 这样的更新运算符不会以 in-place 的方式执行，而是相当于 <code>A = A + B</code>，将左侧绑定到右侧表达式的计算结果上。</li><li>Julia 的数组是列优先的（Fortran 顺序），而 C/C++ 的数组默认是行优先的。要使数组上的循环性能最优，在 Julia 中循环的顺序应该与 C/C++ 相反（参见 <a href="../performance-tips/#man-performance-tips">性能建议</a>）。</li><li>Julia 的值在赋值或向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。</li><li>在 Julia 中，空格是有意义的，这与 C/C++ 不同，所以向 Julia 程序中添加或删除空格时必须谨慎。</li><li>在 Julia 中，没有小数点的数值字面量（如 <code>42</code>）生成有符号整数，类型为 <code>Int</code>，但如果字面量太长，超过了机器字长，则会被自动提升为容量更大的类型，例如 <code>Int64</code>（如果 <code>Int</code> 是 <code>Int32</code>）、<code>Int128</code>，或者任意精度的 <code>BigInt</code> 类型。不存在诸如 <code>L</code>, <code>LL</code>, <code>U</code>, <code>UL</code>, <code>ULL</code> 这样的数值字面量后缀指示无符号和/或有符号与无符号。十进制字面量始终是有符号的，十六进制字面量（像 C/C++ 一样由 <code>0x</code> 开头）是无符号的。另外，十六进制字面量与 C/C++/Java 不同，也与 Julia 中的十进制字面量不同，它们的类型取决于字面量的<strong>长度</strong>，包括开头的 0。例如，<code>0x0</code> 和 <code>0x00</code> 的类型是 <a href="../../base/numbers/#Core.UInt8"><code>UInt8</code></a>，<code>0x000</code> 和 <code>0x0000</code> 的类型是 <a href="../../base/numbers/#Core.UInt16"><code>UInt16</code></a>。同理，字面量的长度在 5-8 之间，类型为 <code>UInt32</code>；在 9-16 之间，类型为 <code>UInt64</code>；在 17-32 之间，类型为 <code>UInt128</code>。当定义十六进制掩码时，就需要将这一问题考虑在内，比如 <code>~0xf == 0xf0</code> 与 <code>~0x000f == 0xfff0</code> 完全不同。64 位 <code>Float64</code> 和 32 位 <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a> 的字面量分别表示为 <code>1.0</code> 和 <code>1.0f0</code>。浮点字面量在无法被精确表示时舍入（且不会提升为 <code>BigFloat</code> 类型）。浮点字面量在行为上与 C/C++ 更接近。八进制（前缀为 <code>0o</code>）和二进制（前缀为 <code>0b</code>）也被视为无符号的。</li><li>在 Julia 中，当两个操作数都是整数类型时，除法运算符 <code>/</code> 返回一个浮点数。 要执行整数除法，请使用 <code>div</code> 或 <code>÷</code>。</li><li>使用浮点类型索引数组在 Julia 中通常是错误的。 C 表达式 <code>a[i / 2]</code> 的 Julia 等价写法是 <code>a[i ÷ 2 + 1]</code>，其中 <code>i</code> 是整数类型。</li><li>字符串字面量可用 <code>&quot;</code> 或 <code>&quot;&quot;&quot;</code> 分隔，用 <code>&quot;&quot;&quot;</code> 分隔的字面量可以包含 <code>&quot;</code> 字符而无需像 <code>&quot;\&quot;&quot;</code> 这样来引用它。字符串字面量可以包含插入其中的其他变量或表达式，由 <code>$variablename</code> 或 <code>$(expression)</code> 表示，它在该函数所处的上下文中计算变量名或表达式。</li><li><code>//</code> 表示 <a href="../../base/numbers/#Base.Rational"><code>Rational</code></a> 数，而非单行注释（其在 Julia 中是 <code>#</code>）</li><li><code>#=</code> 表示多行注释的开头，<code>=#</code> 结束之。</li><li>Julia 中的函数返回其最后一个表达式或 <code>return</code> 关键字的值。可以从函数中返回多个值并将其作为元组赋值，如 <code>(a, b) = myfunction()</code> 或 <code>a, b = myfunction()</code>，而不必像在 C/C++ 中那样必须传递指向值的指针（即 <code>a = myfunction(&amp;b)</code>）。</li><li>Julia 不要求使用分号来结束语句。表达式的结果不会自动打印（除了在交互式提示符中，即 REPL），且代码行不需要以分号结尾。<a href="../../base/io-network/#Base.println"><code>println</code></a> 或 <a href="../../stdlib/Printf/#Printf.@printf"><code>@printf</code></a> 可用于打印特定输出。在 REPL 中，<code>;</code> 可用于抑制输出。<code>;</code> 在 <code>[ ]</code> 中也有不同的含义，需要注意。<code>;</code> 可用于在单行中分隔表达式，但在许多情况下不是绝对必要的，更经常是为了可读性。</li><li>在 Julia 中，运算符 <a href="../../base/math/#Base.xor"><code>⊻</code></a>（<a href="../../base/math/#Base.xor"><code>xor</code></a>）执行按位 XOR 操作，即 C/C++ 中的 <a href="../../base/math/#Base.:^-Tuple{Number, Number}"><code>^</code></a>。此外，按位运算符不具有与 C/C++ 相同的优先级，所以可能需要括号。</li><li>Julia 的 <a href="../../base/math/#Base.:^-Tuple{Number, Number}"><code>^</code></a> 是取幂（pow），而非 C/C++ 中的按位 XOR（在 Julia 中请使用 <a href="../../base/math/#Base.xor"><code>⊻</code></a> 或 <code>xor</code>）</li><li>Julia 有两个右移运算符，<code>&gt;&gt;</code> 和 <code>&gt;&gt;&gt;</code>。 <code>&gt;&gt;</code> 执行算术移位，<code>&gt;&gt;&gt;</code> 始终执行逻辑移位，这与 C/C++ 不同，其中 <code>&gt;&gt;</code> 的含义取决于被移位的值的类型。</li><li>Julia 的 <code>-&gt;</code> 创建一个匿名函数，它并不通过指针访问成员。</li><li>Julia 在编写 <code>if</code> 语句或 <code>for</code>/<code>while</code> 循环时不需要括号：请使用 <code>for i in [1, 2, 3]</code> 代替 <code>for (int i=1; i &lt;= 3; i++)</code>，以及 <code>if i == 1</code> 代替 <code>if (i == 1)</code></li><li>Julia 不把数字 <code>0</code> 和 <code>1</code> 视为布尔值。在 Julia 中不能编写 <code>if (1)</code>，因为 <code>if</code> 语句只接受布尔值。相反，可以编写 <code>if true</code>、<code>if Bool(1)</code> 或 <code>if 1==1</code>。</li><li>Julia 使用 <code>end</code> 来表示条件块（如 <code>if</code>）、循环块（如 <code>while</code>/<code>for</code>）和函数的结束。为了代替单行 <code>if ( cond ) statement</code>，Julia 允许形式为 <code>if cond; statement; end</code>、<code>cond &amp;&amp; statement</code> 和 <code>!cond || statement</code> 的语句。后两种语法中的赋值语句必须显式地包含在括号中，例如 <code>cond &amp;&amp; (x = value)</code>，这是因为运算符的优先级。</li><li>Julia 没有用来续行的语法：如果在行的末尾，到目前为止的输入是一个完整的表达式，则认为其已经结束；否则，认为输入继续。强制表达式继续的一种方式是将其包含在括号中。</li><li>Julia 宏对已解析的表达式进行操作，而非程序的文本，这允许它们执行复杂的 Julia 代码转换。宏名称以 <code>@</code> 字符开头，具有类似函数的语法 <code>@mymacro(arg1, arg2, arg3)</code> 和类似语句的语法 <code>@mymacro arg1 arg2 arg3</code>。两种形式的语法可以相互转换；如果宏出现在另一个表达式中，则类似函数的形式尤其有用，并且它通常是最清晰的。类似语句的形式通常用于标注块，如在分布式 <code>for</code> 结构中：<code>@distributed for i in 1:n; #= body =#; end</code>。如果宏结构的结尾不那么清晰，请使用类似函数的形式。</li><li>Julia 有一个枚举类型，使用宏 <code>@enum(name, value1, value2, ...)</code> 来表示，例如：<code>@enum(Fruit, banana=1, apple, pear)</code>。</li><li>按照惯例，修改其参数的函数在名称的末尾有个 <code>!</code>，例如 <code>push!</code>。</li><li>在 C++ 中，默认情况下，你具有静态分派，即为了支持动态派发，你需要将函数标注为 virtual 函数。另一方面，Julia 中的每个方法都是「virtual」（尽管它更通用，因为方法是在每个参数类型上派发的，而不仅仅是 <code>this</code>，并且使用的是最具体的声明规则）。</li></ul><h2 id="Noteworthy-differences-from-Common-Lisp"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-Common-Lisp">与 Common Lisp 的显著差异</a><a id="Noteworthy-differences-from-Common-Lisp-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-Common-Lisp" title="Permalink"></a></h2><ul><li><p>Julia 默认使用 1 开始的数组索引，它也能处理任意的<a href="../../devdocs/offset-arrays/#man-custom-indices">索引顺序</a>。</p></li><li><p>函数和变量共用一个命名空间（&quot;Lisp-1&quot;）。</p></li><li><p>Julia 中有 <a href="../../base/collections/#Base.Pair"><code>Pair</code></a> 类型，但这并不意味着它能用作 <code>COMMON-LISP:CONS</code>。在 Julia 中绝大多数可迭代的集合都能互换使用，例如：集合解包（splatting）、元组等。<code>Tuple</code> 最接近 Common Lisp 中用于异构元素的<strong>短</strong>列表。使用 <code>NamedTuple</code> 来代替关联表（alists）。对于更大的、同类型元素的集合，应该使用 <code>Array</code> 和 <code>Dict</code>。</p></li><li><p>典型的使用 Julia 进行原型开发时，也会对镜像进行连续的修改，<a href="https://github.com/timholy/Revise.jl">Revise.jl</a> 包提供了这个功能。</p></li><li><p>对于性能，Julia 更喜欢操作具有 <a href="../faq/#man-type-stability">类型稳定性</a>。 Common Lisp 从底层机器操作中抽象出来，而 Julia 则更接近它们。 例如：</p><ul><li>使用 <code>/</code> 的整数除法总是返回浮点结果，即使计算是精确的。<ul><li><code>//</code> 总是返回一个有理数结果</li><li><code>÷</code> 总是返回一个（被截断的）整数结果</li></ul></li><li>Julia 支持大整数，但不会自动转换。默认的整数类型会<a href="../faq/#faq-integer-arithmetic">溢出</a>。</li><li>支持复数，但要获得复数结果，<a href="../faq/#faq-domain-errors">你需要复数输入</a>。</li><li>有多种 Complex 和 Rational 类型，具有不同的组成类型。</li></ul></li><li><p>模块（名称空间）可以是分层的。<a href="../../base/base/#import"><code>import</code></a> 和 <a href="../../base/base/#using"><code>using</code></a> 有着双重角色：他们加载代码并让代码在命名空间中可用。<code>import</code> 用于仅有模块名是可用的情况，大致等价于 <code>ASDF:LOAD-OP</code>。槽名（Slot name）不需要单独导出。全局变量不能从模块的外部赋值，除了 <code>eval(mod, :(var = val))</code> 这个例外情况。</p></li><li><p>宏以 <code>@</code> 开头，并没有像 Common Lisp 那样无缝地集成到语言中；因此在 Julia 中，宏的使用不像在 Common Lisp 中那样广泛。Julia 支持<a href="../metaprogramming/#Metaprogramming">宏</a>的一种卫生（hygiene）形式。因为不同的表层语法，Julia 中没有 <code>COMMON-LISP:&amp;BODY</code> 的等价形式。</p></li><li><p><strong>所有的</strong>函数都是通用的并且使用多重分派。函数的参数列表也无需遵循一样的模板，这让我们有了一个强大的范式：<a href="../../base/base/#do"><code>do</code></a>。可选参数与关键字参数的处理方式不同。方法的歧义没有像在 Common Lisp 对象系统中那样得到解决，因此需要为交集定义更具体的方法。</p></li><li><p>符号不属于任何包，它<strong>本身</strong>也不包含任何值。<code>M.var</code> 会对 <code>M</code> 模块里的  <code>var</code> 符号求值。</p></li><li><p>Julia 完全支持函数式编程风格，包括闭包等特性。但这并不是 Julia 的惯用风格。修改捕获变量时需要一些额外的<a href="../performance-tips/#man-performance-captured">变通</a>以便提高性能。</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faq/">« 常见问题</a><a class="docs-footer-nextpage" href="../unicode-input/">Unicode 输入表 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2021 十月 8 周五 05:00">2021 十月 8 周五</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.6.3版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
