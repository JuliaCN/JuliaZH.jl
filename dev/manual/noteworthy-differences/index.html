<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>与其他语言的显著差异 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/noteworthy-differences/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">变量</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li class="is-active"><a class="tocitem" href>与其他语言的显著差异</a><ul class="internal"><li><a class="tocitem" href="#与-MATLAB-的显著差异"><span>与 MATLAB 的显著差异</span></a></li><li><a class="tocitem" href="#与-R-的显著差异"><span>与 R 的显著差异</span></a></li><li><a class="tocitem" href="#与-Python-的显著差异"><span>与 Python 的显著差异</span></a></li><li><a class="tocitem" href="#与-C/C-的显著差异"><span>与 C/C++ 的显著差异</span></a></li><li><a class="tocitem" href="#Noteworthy-differences-from-Common-Lisp"><span>Noteworthy differences from Common Lisp</span></a></li></ul></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">分布式计算</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">交互式组件</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>与其他语言的显著差异</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>与其他语言的显著差异</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/noteworthy-differencesmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="与其他语言的显著差异"><a class="docs-heading-anchor" href="#与其他语言的显著差异">与其他语言的显著差异</a><a id="与其他语言的显著差异-1"></a><a class="docs-heading-anchor-permalink" href="#与其他语言的显著差异" title="Permalink"></a></h1><h2 id="与-MATLAB-的显著差异"><a class="docs-heading-anchor" href="#与-MATLAB-的显著差异">与 MATLAB 的显著差异</a><a id="与-MATLAB-的显著差异-1"></a><a class="docs-heading-anchor-permalink" href="#与-MATLAB-的显著差异" title="Permalink"></a></h2><p>虽然 MATLAB 用户可能会发现 Julia 的语法很熟悉，但 Julia 不是 MATLAB 的克隆。 它们之间存在重大的语法和功能差异。 以下是一些可能会使习惯于 MATLAB 的 Julia 用户感到困扰的显著差异：</p><ul><li>Julia 数组使用方括号 <code>A[i,j]</code> 进行索引。</li><li>Julia 的数组在赋值给另一个变量时不发生复制。执行 <code>A = B</code> 后，改变 <code>B</code> 中元素也会修改 <code>A</code>。</li><li>Julia 的值在向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。</li><li>Julia 不会在赋值语句中自动增长数组。 而在 MATLAB 中 <code>a(4) = 3.2</code> 可以创建数组 <code>a = [0 0 0 3.2]</code>，而 <code>a(5) = 7</code> 可以将它增长为 <code>a = [0 0 0 3.2 7]</code>。如果 <code>a</code> 的长度小于 5 或者这个语句是第一次使用标识符 <code>a</code>，则相应的 Julia 语句 <code>a[5] = 7</code> 会抛出错误。Julia 使用 <a href="../../base/collections/#Base.push!"><code>push!</code></a> 和 <a href="../../base/collections/#Base.append!"><code>append!</code></a> 来增长 <code>Vector</code>，它们比 MATLAB 的 <code>a(end+1) = val</code> 更高效。</li><li>虚数单位 <code>sqrt(-1)</code> 在 Julia 中表示为 <a href="../../base/numbers/#Base.im"><code>im</code></a>，而不是在 MATLAB 中的 <code>i</code> 或 <code>j</code>。</li><li>在 Julia 中，没有小数点的数字字面量（例如 <code>42</code>）会创建整数而不是浮点数。也支持任意大整数字面量。因此，某些操作（如 <code>2^-1</code>）将抛出 domain error，因为结果不是整数（有关的详细信息，请参阅<a href="../faq/#faq-domain-errors">常见问题中有关 domain errors 的条目</a>）。 point numbers. As a result, some operations can throw a domain error if they expect a float; for example, <code>julia&gt; a = -1; 2^a</code> throws a domain error, as the result is not an integer (see <a href="../faq/#faq-domain-errors">the FAQ entry on domain errors</a> for details).</li><li>在 Julia 中，能返回多个值并将其赋值为元组，例如 <code>(a, b) = (1, 2)</code> 或 <code>a, b = 1, 2</code>。 在 Julia 中不存在 MATLAB 的 <code>nargout</code>，它通常在 MATLAB 中用于根据返回值的数量执行可选工作。取而代之的是，用户可以使用可选参数和关键字参数来实现类似的功能。</li><li>Julia 拥有真正的一维数组。列向量的大小为 <code>N</code>，而不是 <code>Nx1</code>。例如，<a href="../../stdlib/Random/#Base.rand"><code>rand(N)</code></a> 创建一个一维数组。</li><li>在 Julia 中，<code>[x,y,z]</code> 将始终构造一个包含<code>x</code>、<code>y</code> 和 <code>z</code> 的 3 元数组。<ul><li>要在第一个维度（「垂直列」）中连接元素，请使用 <a href="../../base/arrays/#Base.vcat"><code>vcat(x,y,z)</code></a> 或用分号分隔（<code>[x; y; z]</code>）。</li><li>要在第二个维度（「水平行」）中连接元素，请使用 <a href="../../base/arrays/#Base.hcat"><code>hcat(x,y,z)</code></a> 或用空格分隔（<code>[x y z]</code>）。</li><li>要构造分块矩阵（在前两个维度中连接元素），请使用 <a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a> 或组合空格和分号（<code>[a b; c d]</code>）。</li></ul></li><li>在 Julia 中，<code>a:b</code> 和 <code>a:b:c</code> 构造 <code>AbstractRange</code> 对象。使用 <a href="../../base/collections/#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a> 构造一个类似 MATLAB 中完整的向量。通常，不需要调用 <code>collect</code>。在大多数情况下，<code>AbstractRange</code> 对象将像普通数组一样运行，但效率更高，因为它是懒惰求值。这种创建专用对象而不是完整数组的模式经常被使用，并且也可以在诸如 <a href="../../base/math/#Base.range"><code>range</code></a> 之类的函数中看到，或者在诸如 <code>enumerate</code> 和 <code>zip</code> 之类的迭代器中看到。特殊对象大多可以像正常数组一样使用。</li><li>Julia 中的函数返回其最后一个表达式或 <code>return</code> 关键字的值而无需在函数定义中列出要返回的变量的名称（有关详细信息，请参阅 <a href="../functions/#return-关键字">return 关键字</a>）。</li><li>Julia 脚本可以包含任意数量的函数，并且在加载文件时，所有定义都将在外部可见。可以从当前工作目录之外的文件加载函数定义。</li><li>在 Julia 中，例如 <a href="../../base/collections/#Base.sum"><code>sum</code></a>、<a href="../../base/collections/#Base.prod"><code>prod</code></a> 和 <a href="../../base/math/#Base.max"><code>max</code></a> 的归约操作会作用到数组的每一个元素上，当调用时只有一个函数，例如 <code>sum(A)</code>，即使 <code>A</code> 并不只有一个维度。</li><li>在 Julia 中，调用无参数的函数时必须使用小括号，例如 <a href="../../stdlib/Random/#Base.rand"><code>rand()</code></a>。</li><li>Julia 不鼓励使用分号来结束语句。语句的结果不会自动打印（除了在 REPL 中），并且代码的一行不必使用分号结尾。<a href="../../base/io-network/#Base.println"><code>println</code></a> 或者 <a href="../../stdlib/Printf/#Printf.@printf"><code>@printf</code></a> 能用来打印特定输出。</li><li>在 Julia 中，如果 <code>A</code> 和 <code>B</code> 是数组，像 <code>A == B</code> 这样的逻辑比较运算符不会返回布尔值数组。相反地，请使用 <code>A .== B</code>。对于其他的像是 <a href="../../base/math/#Base.:&lt;"><code>&lt;</code></a>、<a href="../../base/math/#Base.:&gt;"><code>&gt;</code></a> 的布尔运算符同理。</li><li>在 Julia 中，运算符<a href="../../base/math/#Base.:&amp;"><code>&amp;</code></a>、<a href="../../base/math/#Base.:|"><code>|</code></a> 和 <a href="../../base/math/#Base.xor"><code>⊻</code></a>（<a href="../../base/math/#Base.xor"><code>xor</code></a>）进行按位操作，分别与MATLAB中的<code>and</code>、<code>or</code> 和 <code>xor</code> 等价，并且优先级与 Python 的按位运算符相似（不像 C）。他们可以对标量运算或者数组中逐元素运算，可以用来合并逻辑数组，但是注意运算顺序的区别：括号可能是必要的（例如，选择 <code>A</code> 中等于 1 或 2 的元素可使用 <code>(A .== 1) .| (A .== 2)</code>）。</li><li>在 Julia 中，集合的元素可以使用 splat 运算符 <code>...</code> 来作为参数传递给函数，如 <code>xs=[1,2]; f(xs...)</code>。</li><li>Julia 的 <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.svd"><code>svd</code></a> 将奇异值作为向量而非密集对角矩阵返回。</li><li>在 Julia 中，<code>...</code> 不用于延续代码行。不同的是，Julia 中不完整的表达式会自动延续到下一行。</li><li>在 Julia 和 MATLAB 中，变量 <code>ans</code> 被设置为交互式会话中提交的最后一个表达式的值。在 Julia 中与 MATLAB 不同的是，当 Julia 代码以非交互式模式运行时并不会设置 <code>ans</code>。</li><li>Julia 的 <code>struct</code> 不支持在运行时动态地添加字段，这与 MATLAB 的 <code>class</code> 不同。如需支持，请使用 <a href="../../base/collections/#Base.Dict"><code>Dict</code></a>。</li><li>在 Julia 中，每个模块有自身的全局作用域/命名空间，而在 MATLAB 中只有一个全局作用域。</li><li>在 MATLAB 中，删除不需要的值的惯用方法是使用逻辑索引，如表达式 <code>x(x&gt;3)</code> 或语句 <code>x(x&gt;3) = []</code> 来 in-place 修改 <code>x</code>。相比之下，Julia 提供了更高阶的函数 <a href="../../base/collections/#Base.filter"><code>filter</code></a> 和 <a href="../../base/collections/#Base.filter!"><code>filter!</code></a>，允许用户编写 <code>filter(z-&gt;z&gt;3, x)</code> 和 <code>filter!(z-&gt;z&gt;3, x)</code> 来代替相应直译 <code>x[x.&gt;3]</code> 和 <code>x = x[x.&gt;3]</code>。使用 <a href="../../base/collections/#Base.filter!"><code>filter!</code></a> 可以减少临时数组的使用。</li><li>类似于提取（或「解引用」）元胞数组的所有元素的操作，例如 MATLAB 中的 <code>vertcat(A{:})</code>，在 Julia 中是使用 splat 运算符编写的，例如 <code>vcat(A...)</code>。</li><li>In Julia, the <code>adjoint</code> function performs conjugate transposition; in MATLAB, <code>adjoint</code> provides the &quot;adjugate&quot; or classical adjoint, which is the transpose of the matrix of cofactors.</li></ul><h2 id="与-R-的显著差异"><a class="docs-heading-anchor" href="#与-R-的显著差异">与 R 的显著差异</a><a id="与-R-的显著差异-1"></a><a class="docs-heading-anchor-permalink" href="#与-R-的显著差异" title="Permalink"></a></h2><p>Julia 的目标之一是为数据分析和统计编程提供高效的语言。对于从 R 转到 Julia 的用户来说，这是一些显著差异：</p><ul><li><p>Julia 的单引号封闭字符，而不是字符串。</p></li><li><p>Julia 可以通过索引字符串来创建子字符串。在 R 中，在创建子字符串之前必须将字符串转换为字符向量。</p></li><li><p>在 Julia 中，与 Python 相同但与 R 不同的是，字符串可由三重引号 <code>&quot;&quot;&quot; ... &quot;&quot;&quot;</code> 创建。此语法对于构造包含换行符的字符串很方便。</p></li><li><p>在 Julia 中，可变参数使用 splat 运算符 <code>...</code> 指定，该运算符总是跟在具体变量的名称后面，与 R 的不同，R 的 <code>...</code> 可以单独出现。</p></li><li><p>在 Julia 中，模数是 <code>mod(a, b)</code>，而不是 <code>a %% b</code>。Julia 中的 <code>%</code> 是余数运算符。</p></li><li><p>在 Julia 中，并非所有数据结构都支持逻辑索引。此外，Julia 中的逻辑索引只支持长度等于被索引对象的向量。例如：</p><ul><li>在 R 中，<code>c(1, 2, 3, 4)[c(TRUE, FALSE)]</code> 等价于 <code>c(1, 3)</code>。</li><li>在 R 中，<code>c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]</code> 等价于 <code>c(1, 3)</code>。</li><li>在 Julia 中，<code>[1, 2, 3, 4][[true, false]]</code> 抛出 <a href="../../base/base/#Core.BoundsError"><code>BoundsError</code></a>。</li><li>在 Julia 中，<code>[1, 2, 3, 4][[true, false, true, false]]</code> 产生 <code>[1, 3]</code>。</li></ul></li><li><p>与许多语言一样，Julia 并不总是允许对不同长度的向量进行操作，与 R 不同，R 中的向量只需要共享一个公共的索引范围。例如，<code>c(1, 2, 3, 4) + c(1, 2)</code> 是有效的 R，但等价的 <code>[1, 2, 3, 4] + [1, 2]</code> 在 Julia 中会抛出一个错误。</p></li><li><p>在逗号不改变代码含义时，Julia 允许使用可选的尾随括号。在索引数组时，这可能在 R 用户间造成混淆。例如，R 中的 <code>x[1,]</code> 将返回矩阵的第一行；但是，在 Julia 中，引号被忽略，于是 <code>x[1,] == x[1]</code>，并且将返回第一个元素。要提取一行，请务必使用 <code>:</code>，如 <code>x[1,:]</code>。</p></li><li><p>Julia 的 <a href="../../base/collections/#Base.map"><code>map</code></a> 首先接受函数，然后是该函数的参数，这与 R 中的 <code>lapply(&lt;structure&gt;, function, ...)</code> 不同。类似地，R 中的 <code>apply(X, MARGIN, FUN, ...)</code> 等价于 Julia 的 <a href="../../base/arrays/#Base.mapslices"><code>mapslices</code></a>，其中函数是第一个参数。</p></li><li><p>R 中的多变量 apply，如 <code>mapply(choose, 11:13, 1:3)</code>，在 Julia 中可以编写成 <code>broadcast(binomial, 11:13, 1:3)</code>。等价地，Julia 提供了更短的点语法来向量化函数 <code>binomial.(11:13, 1:3)</code>。</p></li><li><p>Julia 使用 <code>end</code> 来表示条件块（如 <code>if</code>）、循环块（如 <code>while</code>/<code>for</code>）和函数的结束。为了代替单行 <code>if ( cond ) statement</code>，Julia 允许形式为 <code>if cond; statement; end</code>、<code>cond &amp;&amp; statement</code> 和 <code>!cond || statement</code> 的语句。后两种语法中的赋值语句必须显式地包含在括号中，例如 <code>cond &amp;&amp; (x = value)</code>，这是因为运算符的优先级。</p></li><li><p>在 Julia 中，<code>&lt;-</code>, <code>&lt;&lt;-</code> 和 <code>-&gt;</code> 不是赋值运算符。</p></li><li><p>Julia 的 <code>-&gt;</code> 创建一个匿名函数。</p></li><li><p>Julia 使用括号构造向量。Julia 的 <code>[1, 2, 3]</code> 等价于 R 的 <code>c(1, 2, 3)</code>。</p></li><li><p>Julia 的 <a href="../../base/math/#Base.:*-Tuple{Any, Vararg{Any, N} where N}"><code>*</code></a> 运算符可以执行矩阵乘法，这与 R 不同。如果 <code>A</code> 和 <code>B</code> 都是矩阵，那么 <code>A * B</code> 在 Julia 中表示矩阵乘法，等价于 R 的 <code>A %*% B</code>。在 R 中，相同的符号将执行逐元素（Hadamard）乘积。要在 Julia 中使用逐元素乘法运算，你需要编写 <code>A .* B</code>。</p></li><li><p>Julia 使用 <code>transpose</code> 函数来执行矩阵转置，使用 <code>&#39;</code> 运算符或 <code>adjoint</code> 函数来执行共轭转置。因此，Julia 的 <code>transpose(A)</code> 等价于 R 的 <code>t(A)</code>。另外，Julia 中的非递归转置由 <code>permutedims</code> 函数提供。</p></li><li><p>Julia 在编写 <code>if</code> 语句或 <code>for</code>/<code>while</code> 循环时不需要括号：请使用 <code>for i in [1, 2, 3]</code> 代替 <code>for (int i=1; i &lt;= 3; i++)</code>，以及 <code>if i == 1</code> 代替 <code>if (i == 1)</code></p></li><li><p>Julia 不把数字 <code>0</code> 和 <code>1</code> 视为布尔值。在 Julia 中不能编写 <code>if (1)</code>，因为 <code>if</code> 语句只接受布尔值。相反，可以编写 <code>if true</code>、<code>if Bool(1)</code> 或 <code>if 1==1</code>。</p></li><li><p>Julia 不提供 <code>nrow</code> 和 <code>ncol</code>。相反，请使用 <code>size(M, 1)</code> 代替 <code>nrow(M)</code> 以及 <code>size(M, 2)</code> 代替 <code>ncol(M)</code></p></li><li><p>Julia 仔细区分了标量、向量和矩阵。在 R 中，<code>1</code> 和 <code>c(1)</code> 是相同的。在 Julia 中，它们不能互换地使用。</p></li><li><p>Julia 的 <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.diag"><code>diag</code></a> 和 <a href="../../stdlib/LinearAlgebra/#LinearAlgebra.diagm"><code>diagm</code></a> 与 R 的不同。</p></li><li><p>Julia 赋值操作的左侧不能为函数调用的结果：你不能编写 <code>diag(M) = fill(1, n)</code>。</p></li><li><p>Julia 不鼓励使用函数填充主命名空间。Julia 的大多数统计功能都可在 <a href="https://github.com/JuliaStats">JuliaStats 组织</a>的<a href="https://pkg.julialang.org/">包</a>中找到。例如：</p><ul><li>与概率分布相关的函数由 <a href="https://github.com/JuliaStats/Distributions.jl">Distributions 包</a>提供。</li><li><a href="https://github.com/JuliaData/DataFrames.jl">DataFrames 包</a>提供数据帧。</li><li>广义线性模型由 <a href="https://github.com/JuliaStats/GLM.jl">GLM 包</a>提供。</li></ul></li><li><p>Julia 提供了元组和真正的哈希表，但不提供 R 风格的列表。在返回多个项时，通常应使用元组或具名元组：请使用 <code>(1, 2)</code> 或 <code>(a=1, b=2)</code> 代替 <code>list(a = 1, b = 2)</code>。</p></li><li><p>Julia 鼓励用户编写自己的类型，它比 R 中的 S3 或 S4 对象更容易使用。Julia 的多重派发系统意味着 <code>table(x::TypeA)</code> 和 <code>table(x::TypeB)</code> 类似于 R 的 <code>table.TypeA(x)</code> 和 <code>table.TypeB(x)</code>。</p></li><li><p>Julia 的值在向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。这与 R 非常不同，允许新函数更高效地操作大型数据结构。</p></li><li><p>在 Julia 中，向量和矩阵使用 <a href="../../base/arrays/#Base.hcat"><code>hcat</code></a>、<a href="../../base/arrays/#Base.vcat"><code>vcat</code></a> 和 <a href="../../base/arrays/#Base.hvcat"><code>hvcat</code></a> 拼接，而不是像在 R 中那样使用 <code>c</code>、<code>rbind</code> 和 <code>cbind</code>。</p></li><li><p>在 Julia 中，像 <code>a:b</code> 这样的 range 不是 R 中的向量简写，而是一个专门的 <code>AbstractRange</code> 对象，该对象用于没有高内存开销地进行迭代。要将 range 转换为 vector，请使用 <a href="../../base/collections/#Base.collect-Tuple{Any}"><code>collect(a:b)</code></a>。</p></li><li><p>Julia 的 <a href="../../base/math/#Base.max"><code>max</code></a> 和 <a href="../../base/math/#Base.min"><code>min</code></a> 分别等价于 R 中的 <code>pmax</code> 和 <code>pmin</code>，但两者的参数都需要具有相同的维度。虽然 <a href="../../base/collections/#Base.maximum"><code>maximum</code></a> 和 <a href="../../base/collections/#Base.minimum"><code>minimum</code></a> 代替了 R 中的 <code>max</code> 和 <code>min</code>，但它们之间有重大区别。</p></li><li><p>Julia 的 <a href="../../base/collections/#Base.sum"><code>sum</code></a>、<a href="../../base/collections/#Base.prod"><code>prod</code></a>、<a href="../../base/collections/#Base.maximum"><code>maximum</code></a> 和 <a href="../../base/collections/#Base.minimum"><code>minimum</code></a> 与它们在 R 中的对应物不同。它们都接受一个可选的关键字参数 <code>dims</code>，它表示执行操作的维度。例如，在 Julia 中令 <code>A = [1 2; 3 4]</code>，在 R 中令 <code>B &lt;- rbind(c(1,2),c(3,4))</code> 是与之相同的矩阵。然后 <code>sum(A)</code> 得到与 <code>sum(B)</code> 相同的结果，但 <code>sum(A, dims=1)</code> 是一个包含每一列总和的行向量，<code>sum(A, dims=2)</code> 是一个包含每一行总和的列向量。这与 R 的行为形成了对比，在 R 中，单独的 <code>colSums(B)</code> 和 <code>rowSums(B)</code> 提供了这些功能。如果 <code>dims</code> 关键字参数是向量，则它指定执行求和的所有维度，并同时保持待求和数组的维数，例如 <code>sum(A, dims=(1,2)) == hcat(10)</code>。应该注意的是，没有针对第二个参数的错误检查。</p></li><li><p>Julia 具有一些可以改变其参数的函数。例如，它具有 <a href="../../base/sort/#Base.sort"><code>sort</code></a> 和 <a href="../../base/sort/#Base.sort!"><code>sort!</code></a>。</p></li><li><p>在 R 中，高性能需要向量化。在 Julia 中，这几乎恰恰相反：性能最高的代码通常通过去向量化的循环来实现。</p></li><li><p>Julia 是立即求值的，不支持 R 风格的惰性求值。对于大多数用户来说，这意味着很少有未引用的表达式或列名。</p></li><li><p>Julia 不支持 <code>NULL</code> 类型。最接近的等价物是 <a href="../../base/constants/#Core.nothing"><code>nothing</code></a>，但它的行为类似于标量值而不是列表。请使用 <code>x === nothing</code> 代替 <code>is.null(x)</code>。</p></li><li><p>在 Julia 中，缺失值由 <a href="../../base/base/#Base.missing"><code>missing</code></a> 表示，而不是由 <code>NA</code> 表示。请使用 <a href="../../base/base/#Base.ismissing"><code>ismissing(x)</code></a>（或者在向量上使用逐元素操作 <code>ismissing.(x)</code>）代替 <code>isna(x)</code>。通常使用 <a href="../../base/base/#Base.skipmissing"><code>skipmissing</code></a> 代替 <code>na.rm=TRUE</code>（尽管在某些特定情况下函数接受 <code>skipmissing</code> 参数）。</p></li><li><p>Julia 缺少 R 中的 <code>assign</code> 或 <code>get</code> 的等价物。</p></li><li><p>在 Julia 中，<code>return</code> 不需要括号。</p></li><li><p>在 R 中，删除不需要的值的惯用方法是使用逻辑索引，如表达式 <code>x[x&gt;3]</code> 或语句 <code>x = x[x&gt;3]</code> 来 in-place 修改 <code>x</code>。相比之下，Julia 提供了更高阶的函数 <a href="../../base/collections/#Base.filter"><code>filter</code></a> 和 <a href="../../base/collections/#Base.filter!"><code>filter!</code></a>，允许用户编写 <code>filter(z-&gt;z&gt;3, x)</code> 和 <code>filter!(z-&gt;z&gt;3, x)</code> 来代替相应直译 <code>x[x.&gt;3]</code> 和 <code>x = x[x.&gt;3]</code>。使用 <a href="../../base/collections/#Base.filter!"><code>filter!</code></a> 可以减少临时数组的使用。</p></li></ul><h2 id="与-Python-的显著差异"><a class="docs-heading-anchor" href="#与-Python-的显著差异">与 Python 的显著差异</a><a id="与-Python-的显著差异-1"></a><a class="docs-heading-anchor-permalink" href="#与-Python-的显著差异" title="Permalink"></a></h2><ul><li>Julia 的 <code>for</code>、<code>if</code>、<code>while</code>等代码块由<code>end</code>关键字终止。缩进级别并不像在 Python 中那么重要。 is not significant as it is in Python. Unlike Python, Julia has no <code>pass</code> keyword.</li><li>Strings are denoted by double quotation marks (<code>&quot;text&quot;</code>) in Julia (with three double quotation marks for multi-line strings), whereas in Python they can be denoted either by single (<code>&#39;text&#39;</code>) or double quotation marks (<code>&quot;text&quot;</code>). Single quotation marks are used for characters in Julia (<code>&#39;c&#39;</code>).</li><li>String concatenation is done with <code>*</code> in Julia, not <code>+</code> like in Python. Analogously, string repetition is done with <code>^</code>, not <code>*</code>. Implicit string concatenation of string literals like in Python (e.g. <code>&#39;ab&#39; &#39;cd&#39; == &#39;abcd&#39;</code>) is not done in Julia.</li><li>Python Lists—flexible but slow—correspond to the Julia <code>Vector{Any}</code> type or more generally <code>Vector{T}</code> where <code>T</code> is some non-concrete element type. &quot;Fast&quot; arrays like Numpy arrays that store elements in-place (i.e., <code>dtype</code> is <code>np.float64</code>, <code>[(&#39;f1&#39;, np.uint64), (&#39;f2&#39;, np.int32)]</code>, etc.) can be represented by <code>Array{T}</code> where <code>T</code> is a concrete, immutable element type. This includes built-in types like <code>Float64</code>, <code>Int32</code>, <code>Int64</code> but also more complex types like <code>Tuple{UInt64,Float64}</code> and many user-defined types as well.</li><li>在 Julia 中，数组、字符串等的索引从 1 开始，而不是从 0 开始。</li><li>Julia 的切片索引包含最后一个元素，这与 Python 不同。Julia 中的 <code>a[2:3]</code> 就是 Python 中的 <code>a[1:3]</code>。</li><li>Julia 不支持负数索引。特别地，列表或数组的最后一个元素在 Julia 中使用 <code>end</code> 索引，而不像在 Python 中使用 <code>-1</code>。</li><li>Julia requires <code>end</code> for indexing until the last element. <code>x[1:]</code> in Python is equivalent to <code>x[2:end]</code> in Julia.</li><li>Julia&#39;s range indexing has the format of <code>x[start:step:stop]</code>, whereas Python&#39;s format is <code>x[start:(stop+1):step]</code>. Hence, <code>x[0:10:2]</code> in Python is equivalent to <code>x[1:2:10]</code> in Julia. Similarly, <code>x[::-1]</code> in Python, which refers to the reversed array, is equivalent to <code>x[end:-1:1]</code> in Julia.</li><li>In Julia, indexing a matrix with arrays like <code>X[[1,2], [1,3]]</code> refers to a sub-matrix that contains the intersections of the first and second rows with the first and third columns. In Python, <code>X[[1,2], [1,3]]</code> refers to a vector that contains the values of cell <code>[1,1]</code> and <code>[2,3]</code> in the matrix. <code>X[[1,2], [1,3]]</code> in Julia is equivalent with <code>X[np.ix_([0,1],[0,2])]</code> in Python. <code>X[[0,1], [0,2]]</code> in Python is equivalent with <code>X[[CartesianIndex(1,1), CartesianIndex(2,3)]]</code> in Julia.</li><li>Julia 没有用来续行的语法：如果在行的末尾，到目前为止的输入是一个完整的表达式，则认为其已经结束；否则，认为输入继续。强制表达式继续的一种方式是将其包含在括号中。</li><li>默认情况下，Julia 数组是列优先的（Fortran 顺序），而 NumPy 数组是行优先（C 顺序）。为了在循环数组时获得最佳性能，循环顺序应该在 Julia 中相对于 NumPy 反转（请参阅 <a href="../performance-tips/#man-performance-tips">Performance Tips</a> 中的对应章节）。be reversed in Julia relative to NumPy (see <a href="../performance-tips/#man-performance-column-major">relevant section of Performance Tips</a>).</li><li>Julia 的更新运算符（例如 <code>+=</code>，<code>-=</code>，···）是 <em>not in-place</em>，而 Numpy 的是。这意味着 <code>A = [1, 1]; B = A; B += [3, 3]</code> 不会改变 <code>A</code> 中的值，而将名称 <code>B</code> 重新绑定到右侧表达式 <code>B = B + 3</code> 的结果，这是一个新的数组。对于 in-place 操作，使用 <code>B .+= 3</code>（另请参阅 <a href="../mathematical-operations/#man-dot-operators">dot operators</a>）、显式的循环或者 <code>InplaceOps.jl</code>。</li><li>每次调用方法时，Julia 都会计算函数参数的默认值，不像在 Python 中，默认值只会在函数定义时被计算一次。例如，每次无输入参数调用时，函数<code>f(x=rand()) = x</code>都返回一个新的随机数在另一方面，函数 <code>g(x=[1,2]) = push!(x,3)</code> 在每次以 <code>g()</code> 调用时返回 <code>[1,2,3]</code>。</li><li>在 Julia 中，<code>%</code> 是余数运算符，而在 Python 中是模运算符。</li><li>In Julia, the commonly used <code>Int</code> type corresponds to the machine integer type (<code>Int32</code> or <code>Int64</code>), unlike in Python, where <code>int</code> is an arbitrary length integer. This means in Julia the <code>Int</code> type will overflow, such that <code>2^64 == 0</code>. If you need larger values use another appropriate type, such as <code>Int128</code>, <a href="../../base/numbers/#Base.GMP.BigInt"><code>BigInt</code></a> or a floating point type like <code>Float64</code>.</li><li>The imaginary unit <code>sqrt(-1)</code> is represented in Julia as <code>im</code>, not <code>j</code> as in Python.</li><li>In Julia, the exponentiation operator is <code>^</code>, not <code>**</code> as in Python.</li><li>Julia uses <code>nothing</code> of type <code>Nothing</code> to represent a null value, whereas Python uses <code>None</code> of type <code>NoneType</code>.</li><li>In Julia, the standard operators over a matrix type are matrix operations, whereas, in Python, the standard operators are element-wise operations. When both <code>A</code> and <code>B</code> are matrices, <code>A * B</code> in Julia performs matrix multiplication, not element-wise multiplication as in Python. <code>A * B</code> in Julia is equivalent with <code>A @ B</code> in Python, whereas <code>A * B</code> in Python is equivalent with <code>A .* B</code> in Julia.</li><li>The adjoint operator <code>&#39;</code> in Julia returns an adjoint of a vector (a lazy representation of row vector), whereas the transpose operator <code>.T</code> over a vector in Python returns the original vector (non-op).</li><li>In Julia, a function may contain multiple concrete implementations (called <em>Methods</em>), selected via multiple dispatch, whereas functions in Python have a single implementation (no polymorphism).</li><li>There are no classes in Julia. Instead they are structures (mutable or immutable), containing data but no methods.</li><li>Calling a method of a class in Python (<code>a = MyClass(x), x.func(y)</code>) corresponds to a function call in Julia, e.g. <code>a = MyStruct(x), func(x::MyStruct, y)</code>. In general, multiple dispatch is more flexible and powerful than the Python class system.</li><li>Julia structures may have exactly one abstract supertype, whereas Python classes can inherit from one or more (abstract or concrete) superclasses.</li><li>The logical Julia program structure (Packages and Modules) is independent of the file strucutre (<code>include</code> for additional files), whereas the Python code structure is defined by directories (Packages) and files (Modules).</li><li>The ternary operator <code>x &gt; 0 ? 1 : -1</code> in Julia corresponds to conditional expression in Python <code>1 if x &gt; 0 else -1</code>.</li><li>In Julia the <code>@</code> symbol refers to a macro, whereas in Python it refers to a decorator.</li><li>Exception handling in Julia is done using <code>try</code> — <code>catch</code> — <code>finally</code>, instead of <code>try</code> — <code>except</code> — <code>finally</code>. In contrast to Python, it is not recommended to use exception handling as part of the normal workflow in Julia due to performance reasons.</li><li>In Julia loops are fast, there is no need to write &quot;vectorized&quot; code for performance reasons.</li><li>Be careful with non-constant global variables in Julia, especially in tight loops. Since you can write close-to-metal code in Julia (unlike Python), the effect of globals can be drastic (see <a href="../performance-tips/#man-performance-tips">Performance Tips</a>).</li><li>In Python, the majority of values can be used in logical contexts (e.g. <code>if &quot;a&quot;:</code> means the following block is executed, and <code>if &quot;&quot;:</code> means it is not). In Julia, you need explicit conversion to <code>Bool</code> (e.g. <code>if &quot;a&quot;</code> throws an exception). If you want to test for a non-empty string in Julia, you would explicitly write <code>if !isempty(&quot;&quot;)</code>.</li><li>In Julia, a new local scope is introduced by most code blocks, including loops and <code>try</code> — <code>catch</code> — <code>finally</code>. Note that comprehensions (list, generator, etc.) introduce a new local scope both in Python and Julia, whereas <code>if</code> blocks do not introduce a new local scope in both languages.</li></ul><h2 id="与-C/C-的显著差异"><a class="docs-heading-anchor" href="#与-C/C-的显著差异">与 C/C++ 的显著差异</a><a id="与-C/C-的显著差异-1"></a><a class="docs-heading-anchor-permalink" href="#与-C/C-的显著差异" title="Permalink"></a></h2><ul><li>Julia 的数组由方括号索引，方括号中可以包含不止一个维度 <code>A[i,j]</code>。这样的语法不仅仅是像 C/C++ 中那样对指针或者地址引用的语法糖，参见关于数组构造的语法的 Julia 文档（依版本不同有所变动）。</li><li>在 Julia 中，数组、字符串等的索引从 1 开始，而不是从 0 开始。</li><li>Julia 的数组在赋值给另一个变量时不发生复制。执行 <code>A = B</code> 后，改变 <code>B</code> 中元素也会修改 <code>A</code>。像 <code>+=</code> 这样的更新运算符不会以 in-place 的方式执行，而是相当于 <code>A = A + B</code>，将左侧绑定到右侧表达式的计算结果上。</li><li>Julia 的数组是列优先的（Fortran 顺序），而 C/C++ 的数组默认是行优先的。要使数组上的循环性能最优，在 Julia 中循环的顺序应该与 C/C++ 相反（参见 <a href="../performance-tips/#man-performance-tips">性能建议</a>）。reversed in Julia relative to C/C++ (see <a href="../performance-tips/#man-performance-column-major">relevant section of Performance Tips</a>).</li><li>Julia 的值在赋值或向函数传递时不发生复制。如果某个函数修改了数组，这一修改对调用者是可见的。</li><li>在 Julia 中，空格是有意义的，这与 C/C++ 不同，所以向 Julia 程序中添加或删除空格时必须谨慎。</li><li>在 Julia 中，没有小数点的数值字面量（如 <code>42</code>）生成有符号整数，类型为 <code>Int</code>，但如果字面量太长，超过了机器字长，则会被自动提升为容量更大的类型，例如 <code>Int64</code>（如果 <code>Int</code> 是 <code>Int32</code>）、<code>Int128</code>，或者任意精度的 <code>BigInt</code> 类型。不存在诸如 <code>L</code>, <code>LL</code>, <code>U</code>, <code>UL</code>, <code>ULL</code> 这样的数值字面量后缀指示无符号和/或有符号与无符号。十进制字面量始终是有符号的，十六进制字面量（像 C/C++ 一样由 <code>0x</code> 开头）是无符号的。另外，十六进制字面量与 C/C++/Java 不同，也与 Julia 中的十进制字面量不同，它们的类型取决于字面量的<strong>长度</strong>，包括开头的 0。例如，<code>0x0</code> 和 <code>0x00</code> 的类型是 <a href="../../base/numbers/#Core.UInt8"><code>UInt8</code></a>，<code>0x000</code> 和 <code>0x0000</code> 的类型是 <a href="../../base/numbers/#Core.UInt16"><code>UInt16</code></a>。同理，字面量的长度在 5-8 之间，类型为 <code>UInt32</code>；在 9-16 之间，类型为 <code>UInt64</code>；在 17-32 之间，类型为 <code>UInt128</code>。当定义十六进制掩码时，就需要将这一问题考虑在内，比如 <code>~0xf == 0xf0</code> 与 <code>~0x000f == 0xfff0</code> 完全不同。64 位 <code>Float64</code> 和 32 位 <a href="../../base/numbers/#Core.Float32"><code>Float32</code></a> 的字面量分别表示为 <code>1.0</code> 和 <code>1.0f0</code>。浮点字面量在无法被精确表示时舍入（且不会提升为 <code>BigFloat</code> 类型）。浮点字面量在行为上与 C/C++ 更接近。八进制（前缀为 <code>0o</code>）和二进制（前缀为 <code>0b</code>）也被视为无符号的。</li><li>字符串字面量可用 <code>&quot;</code> 或 <code>&quot;&quot;&quot;</code> 分隔，用 <code>&quot;&quot;&quot;</code> 分隔的字面量可以包含 <code>&quot;</code> 字符而无需像 <code>&quot;\&quot;&quot;</code> 这样来引用它。字符串字面量可以包含插入其中的其他变量或表达式，由 <code>$variablename</code> 或 <code>$(expression)</code> 表示，它在该函数所处的上下文中计算变量名或表达式。</li><li><code>//</code> 表示 <a href="../../base/numbers/#Base.Rational"><code>Rational</code></a> 数，而非单行注释（其在 Julia 中是 <code>#</code>）</li><li><code>#=</code> 表示多行注释的开头，<code>=#</code> 结束之。</li><li>Julia 中的函数返回其最后一个表达式或 <code>return</code> 关键字的值。可以从函数中返回多个值并将其作为元组赋值，如 <code>(a, b) = myfunction()</code> 或 <code>a, b = myfunction()</code>，而不必像在 C/C++ 中那样必须传递指向值的指针（即 <code>a = myfunction(&amp;b)</code>）。</li><li>Julia 不要求使用分号来结束语句。表达式的结果不会自动打印（除了在交互式提示符中，即 REPL），且代码行不需要以分号结尾。<a href="../../base/io-network/#Base.println"><code>println</code></a> 或 <a href="../../stdlib/Printf/#Printf.@printf"><code>@printf</code></a> 可用于打印特定输出。在 REPL 中，<code>;</code> 可用于抑制输出。<code>;</code> 在 <code>[ ]</code> 中也有不同的含义，需要注意。<code>;</code> 可用于在单行中分隔表达式，但在许多情况下不是绝对必要的，更经常是为了可读性。</li><li>在 Julia 中，运算符 <a href="../../base/math/#Base.xor"><code>⊻</code></a>（<a href="../../base/math/#Base.xor"><code>xor</code></a>）执行按位 XOR 操作，即 C/C++ 中的 <a href="../../base/math/#Base.:^-Tuple{Number, Number}"><code>^</code></a>。此外，按位运算符不具有与 C/C++ 相同的优先级，所以可能需要括号。</li><li>Julia 的 <a href="../../base/math/#Base.:^-Tuple{Number, Number}"><code>^</code></a> 是取幂（pow），而非 C/C++ 中的按位 XOR（在 Julia 中请使用 <a href="../../base/math/#Base.xor"><code>⊻</code></a> 或 <code>xor</code>） <a href="manual/@ref"> </a>, in Julia)</li><li>Julia 中有两个右移运算符，<code>&gt;&gt;</code> 和 <code>&gt;&gt;&gt;</code>。<code>&gt;&gt;&gt;</code> 执行逻辑移位，<code>&gt;&gt;</code> 总是执行算术移位（译注：此处原文为「<code>&gt;&gt;&gt;</code> performs an arithmetic shift, <code>&gt;&gt;</code> always performs a logical shift」，疑误），与 C/C++ 不同，C/C++ 中的 <code>&gt;&gt;</code> 的含义依赖于被移位的值的类型。</li><li>Julia 的 <code>-&gt;</code> 创建一个匿名函数，它并不通过指针访问成员。</li><li>Julia 在编写 <code>if</code> 语句或 <code>for</code>/<code>while</code> 循环时不需要括号：请使用 <code>for i in [1, 2, 3]</code> 代替 <code>for (int i=1; i &lt;= 3; i++)</code>，以及 <code>if i == 1</code> 代替 <code>if (i == 1)</code></li><li>Julia 不把数字 <code>0</code> 和 <code>1</code> 视为布尔值。在 Julia 中不能编写 <code>if (1)</code>，因为 <code>if</code> 语句只接受布尔值。相反，可以编写 <code>if true</code>、<code>if Bool(1)</code> 或 <code>if 1==1</code>。</li><li>Julia 使用 <code>end</code> 来表示条件块（如 <code>if</code>）、循环块（如 <code>while</code>/<code>for</code>）和函数的结束。为了代替单行 <code>if ( cond ) statement</code>，Julia 允许形式为 <code>if cond; statement; end</code>、<code>cond &amp;&amp; statement</code> 和 <code>!cond || statement</code> 的语句。后两种语法中的赋值语句必须显式地包含在括号中，例如 <code>cond &amp;&amp; (x = value)</code>，这是因为运算符的优先级。</li><li>Julia 没有用来续行的语法：如果在行的末尾，到目前为止的输入是一个完整的表达式，则认为其已经结束；否则，认为输入继续。强制表达式继续的一种方式是将其包含在括号中。</li><li>Julia 宏对已解析的表达式进行操作，而非程序的文本，这允许它们执行复杂的 Julia 代码转换。宏名称以 <code>@</code> 字符开头，具有类似函数的语法 <code>@mymacro(arg1, arg2, arg3)</code> 和类似语句的语法 <code>@mymacro arg1 arg2 arg3</code>。两种形式的语法可以相互转换；如果宏出现在另一个表达式中，则类似函数的形式尤其有用，并且它通常是最清晰的。类似语句的形式通常用于标注块，如在分布式 <code>for</code> 结构中：<code>@distributed for i in 1:n; #= body =#; end</code>。如果宏结构的结尾不那么清晰，请使用类似函数的形式。</li><li>Julia 有一个枚举类型，使用宏 <code>@enum(name, value1, value2, ...)</code> 来表示，例如：<code>@enum(Fruit, banana=1, apple, pear)</code>。</li><li>按照惯例，修改其参数的函数在名称的末尾有个 <code>!</code>，例如 <code>push!</code>。</li><li>在 C++ 中，默认情况下，你具有静态分派，即为了支持动态派发，你需要将函数标注为 virtual 函数。另一方面，Julia 中的每个方法都是「virtual」（尽管它更通用，因为方法是在每个参数类型上派发的，而不仅仅是 <code>this</code>，并且使用的是最具体的声明规则）。</li></ul><h2 id="Noteworthy-differences-from-Common-Lisp"><a class="docs-heading-anchor" href="#Noteworthy-differences-from-Common-Lisp">Noteworthy differences from Common Lisp</a><a id="Noteworthy-differences-from-Common-Lisp-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-differences-from-Common-Lisp" title="Permalink"></a></h2><ul><li><p>Julia uses 1-based indexing for arrays by default, and it can also handle arbitrary <a href="../../devdocs/offset-arrays/#man-custom-indices">index offsets</a>.</p></li><li><p>Functions and variables share the same namespace (“Lisp-1”).</p></li><li><p>There is a <a href="../../base/collections/#Base.Pair"><code>Pair</code></a> type, but it is not meant to be used as a <code>COMMON-LISP:CONS</code>. Various iterable collections can be used interchangeably in most parts of the language (eg splatting, tuples, etc). <code>Tuple</code>s are the closest to Common Lisp lists for <em>short</em> collections of heterogeneous elements. Use <code>NamedTuple</code>s in place of alists. For larger collections of homogeneous types, <code>Array</code>s and <code>Dict</code>s should be used.</p></li><li><p>The typical Julia workflow for prototyping also uses continuous manipulation of the image, implemented with the <a href="https://github.com/timholy/Revise.jl">Revise.jl</a> package.</p></li><li><p>Bignums are supported, but conversion is not automatic; ordinary integers <a href="../faq/#faq-integer-arithmetic">overflow</a>.</p></li><li><p>Modules (namespaces) can be hierarchical. <a href="../../base/base/#import"><code>import</code></a> and <a href="../../base/base/#using"><code>using</code></a> have a dual role: they load the code and make it available in the namespace. <code>import</code> for only the module name is possible (roughly equivalent to <code>ASDF:LOAD-OP</code>). Slot names don&#39;t need to be exported separately. Global variables can&#39;t be assigned to from outside the module (except with <code>eval(mod, :(var = val))</code> as an escape hatch).</p></li><li><p>Macros start with <code>@</code>, and are not as seamlessly integrated into the language as Common Lisp; consequently, macro usage is not as widespread as in the latter. A form of hygiene for <a href="manual/@ref Metaprogramming">macros</a> is supported by the language. Because of the different surface syntax, there is no equivalent to <code>COMMON-LISP:&amp;BODY</code>.</p></li><li><p><em>All</em> functions are generic and use multiple dispatch. Argument lists don&#39;t have to follow the same template, which leads to a powerful idiom (see <a href="../../base/base/#do"><code>do</code></a>). Optional and keyword arguments are handled differently. Method ambiguities are not resolved like in the Common Lisp Object System, necessitating the definition of a more specific method for the intersection.</p></li><li><p>Symbols do not belong to any package, and do not contain any values <em>per se</em>. <code>M.var</code> evaluates the symbol <code>var</code> in the module <code>M</code>.</p></li><li><p>A functional programming style is fully supported by the language, including closures, but isn&#39;t always the idiomatic solution for Julia. Some <a href="../performance-tips/#man-performance-captured">workarounds</a> may be necessary for performance when modifying captured variables.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faq/">« 常见问题</a><a class="docs-footer-nextpage" href="../unicode-input/">Unicode 输入表 »</a><div class="flexbox-break"></div><p class="footer-message">📢📢📢Julia中文社区现已加入“开源软件供应链点亮计划”，如果你想改善Julia中文文档的翻译，那就赶快来 <a href="https://summer.iscas.ac.cn/#/org/prodetail/210370191">报名</a> 吧！</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2021 八月 12 周四 18:36">2021 八月 12 周四</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.6.2版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
