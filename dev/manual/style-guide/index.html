<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>代码风格指南 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/style-guide/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li class="is-active"><a class="tocitem" href>代码风格指南</a><ul class="internal"><li><a class="tocitem" href="#写函数，而不是仅仅写脚本-1"><span>写函数，而不是仅仅写脚本</span></a></li><li><a class="tocitem" href="#类型不要写得过于具体-1"><span>类型不要写得过于具体</span></a></li><li><a class="tocitem" href="#让调用者处理多余的参数多样性-1"><span>让调用者处理多余的参数多样性</span></a></li><li><a class="tocitem" href="#bang-convention-1"><span>Append <code>!</code> to names of functions that modify their arguments</span></a></li><li><a class="tocitem" href="#避免使用奇怪的-Union-类型-1"><span>避免使用奇怪的 <code>Union</code> 类型</span></a></li><li><a class="tocitem" href="#避免复杂的容器类型-1"><span>避免复杂的容器类型</span></a></li><li><a class="tocitem" href="#使用和-Julia-base/-文件夹中的代码一致的命名习惯-1"><span>使用和 Julia <code>base/</code> 文件夹中的代码一致的命名习惯</span></a></li><li><a class="tocitem" href="#使用与-Julia-Base-中的函数类似的参数顺序-1"><span>使用与 Julia Base 中的函数类似的参数顺序</span></a></li><li><a class="tocitem" href="#不要过度使用-try-catch-1"><span>不要过度使用 try-catch</span></a></li><li><a class="tocitem" href="#不要给条件语句加括号-1"><span>不要给条件语句加括号</span></a></li><li><a class="tocitem" href="#不要过度使用-...-1"><span>不要过度使用 <code>...</code></span></a></li><li><a class="tocitem" href="#不要使用不必要的静态参数-1"><span>不要使用不必要的静态参数</span></a></li><li><a class="tocitem" href="#避免判断变量是实例还是类型的混乱-1"><span>避免判断变量是实例还是类型的混乱</span></a></li><li><a class="tocitem" href="#不要过度使用宏-1"><span>不要过度使用宏</span></a></li><li><a class="tocitem" href="#不要把不安全的操作暴露在接口层-1"><span>不要把不安全的操作暴露在接口层</span></a></li><li><a class="tocitem" href="#不要重载基础容器类型的方法-1"><span>不要重载基础容器类型的方法</span></a></li><li><a class="tocitem" href="#避免类型盗版-1"><span>避免类型盗版</span></a></li><li><a class="tocitem" href="#注意类型相等-1"><span>注意类型相等</span></a></li><li><a class="tocitem" href="#不要写-x-f(x)-1"><span>不要写 <code>x-&gt;f(x)</code></span></a></li><li><a class="tocitem" href="#尽可能避免使用浮点数作为通用代码的字面量-1"><span>尽可能避免使用浮点数作为通用代码的字面量</span></a></li></ul></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">分布式计算</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">交互式组件</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>代码风格指南</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>代码风格指南</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/style-guidemd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="代码风格指南-1"><a class="docs-heading-anchor" href="#代码风格指南-1">代码风格指南</a><a class="docs-heading-anchor-permalink" href="#代码风格指南-1" title="Permalink"></a></h1><p>接下来的部分将介绍如何写出具有 Julia 风格的代码。当然，这些规则并不是绝对的，它们只是一些建议，以便更好地帮助你熟悉这门语言，以及在不同的代码设计中做出选择。</p><h2 id="写函数，而不是仅仅写脚本-1"><a class="docs-heading-anchor" href="#写函数，而不是仅仅写脚本-1">写函数，而不是仅仅写脚本</a><a class="docs-heading-anchor-permalink" href="#写函数，而不是仅仅写脚本-1" title="Permalink"></a></h2><p>一开始解决问题的时候，直接从最外层一步步写代码的确很便捷，但你应该尽早地将代码组织成函数。函数有更强的复用性和可测试性，并且能更清楚地让人知道哪些步骤做完了，以及每一步骤的输入输出分别是什么。此外，由于 Julia 编译器特殊的工作方式，写在函数中的代码往往要比最外层的代码运行地快得多。</p><p>此外值得一提的是，函数应当接受参数，而不是直接使用全局变量进行操作（<a href="../../base/numbers/#Base.MathConstants.pi"><code>pi</code></a> 等常数除外）。</p><h2 id="类型不要写得过于具体-1"><a class="docs-heading-anchor" href="#类型不要写得过于具体-1">类型不要写得过于具体</a><a class="docs-heading-anchor-permalink" href="#类型不要写得过于具体-1" title="Permalink"></a></h2><p>代码应该写得尽可能通用。例如，下面这段代码:</p><pre><code class="language-julia">Complex{Float64}(x)</code></pre><p>更好的写法是写成下面的通用函数：</p><pre><code class="language-julia">complex(float(x))</code></pre><p>第二个版本会把 <code>x</code> 转换成合适的类型，而不是某个写死的类型。</p><p>这种代码风格与函数的参数尤其相关。例如，当一个参数可以是任何整型时，不要将它的类型声明为 <code>Int</code> 或 <a href="../../base/numbers/#Core.Int32"><code>Int32</code></a>，而要使用抽象类型（abstract type）<a href="../../base/numbers/#Core.Integer"><code>Integer</code></a> 来表示。事实上，除非确实需要将其与其它的方法定义区分开，很多情况下你可以干脆完全省略掉参数的类型，因为如果你的操作中有不支持某种参数类型的操作的话，反正都会抛出 <a href="../../base/base/#Core.MethodError"><code>MethodError</code></a> 的。这也称作 <a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">鸭子类型</a>）。</p><p>例如，考虑这样的一个叫做 <code>addone</code> 的函数，其返回值为它的参数加 1 ：</p><pre><code class="language-julia">addone(x::Int) = x + 1                 # works only for Int
addone(x::Integer) = x + oneunit(x)    # any integer type
addone(x::Number) = x + oneunit(x)     # any numeric type
addone(x) = x + oneunit(x)             # any type supporting + and oneunit</code></pre><p>最后一种定义可以处理所有支持 <a href="../../base/numbers/#Base.oneunit"><code>oneunit</code></a> （返回和 <code>x</code> 相同类型的 1，以避免不需要的类型提升（type promotion））以及 <a href="../../base/math/#Base.:+"><code>+</code></a> 函数的类型。这里的关键点在于，<strong>只</strong>定义通用的 <code>addone(x) = x + oneunit(x)</code> 并<strong>不会</strong>带来性能上的损失，因为 Julia 会在需要的时候自动编译特定的版本。比如说，当第一次调用 <code>addone(12)</code> 时，Julia 会自动编译一个特定的 <code>addone</code> 函数，它接受一个 <code>x::Int</code> 的参数，并把调用的 <code>oneunit</code> 替换为内连的值 <code>1</code>。因此，上述的前三种 <code>addone</code> 的定义对于第四种来说是完全多余的。</p><h2 id="让调用者处理多余的参数多样性-1"><a class="docs-heading-anchor" href="#让调用者处理多余的参数多样性-1">让调用者处理多余的参数多样性</a><a class="docs-heading-anchor-permalink" href="#让调用者处理多余的参数多样性-1" title="Permalink"></a></h2><p>如下的代码：</p><pre><code class="language-julia">function foo(x, y)
    x = Int(x); y = Int(y)
    ...
end
foo(x, y)</code></pre><p>请写成这样：</p><pre><code class="language-julia">function foo(x::Int, y::Int)
    ...
end
foo(Int(x), Int(y))</code></pre><p>这种风格更好，因为 <code>foo</code> 函数其实不需要接受所有类型的数，而只需要接受 <code>Int</code>。</p><p>这里的关键在于，如果一个函数需要处理的是整数，强制让调用者来决定非整数如何被转换（比如说向下还是向上取整）会更好。同时，把类型声明得具体一些的话可以为以后的方法定义留有更多的空间。</p><h2 id="bang-convention-1"><a class="docs-heading-anchor" href="#bang-convention-1">Append <code>!</code> to names of functions that modify their arguments</a><a class="docs-heading-anchor-permalink" href="#bang-convention-1" title="Permalink"></a></h2><p>如下的代码：</p><pre><code class="language-julia">function double(a::AbstractArray{&lt;:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end</code></pre><p>请写成这样：</p><pre><code class="language-julia">function double!(a::AbstractArray{&lt;:Number})
    for i = firstindex(a):lastindex(a)
        a[i] *= 2
    end
    return a
end</code></pre><p>Julia 的 Base 模块中的函数都遵循了这种规范，且包含很多例子：有的函数同时有拷贝和修改的形式（比如 <a href="../../base/sort/#Base.sort"><code>sort</code></a> 和 <a href="../../base/sort/#Base.sort!"><code>sort!</code></a>），还有一些只有修改（比如 <a href="../../base/collections/#Base.push!"><code>push!</code></a>，<a href="../../base/collections/#Base.pop!"><code>pop!</code></a> 和 <a href="../../base/collections/#Base.splice!"><code>splice!</code></a>）。为了方便起见，这类函数通常也会把修改后的数组作为返回值。</p><h2 id="避免使用奇怪的-Union-类型-1"><a class="docs-heading-anchor" href="#避免使用奇怪的-Union-类型-1">避免使用奇怪的 <code>Union</code> 类型</a><a class="docs-heading-anchor-permalink" href="#避免使用奇怪的-Union-类型-1" title="Permalink"></a></h2><p>使用 <code>Union{Function,AbstractString}</code> 这样的类型的时候通常意味着设计还不够清晰。</p><h2 id="避免复杂的容器类型-1"><a class="docs-heading-anchor" href="#避免复杂的容器类型-1">避免复杂的容器类型</a><a class="docs-heading-anchor-permalink" href="#避免复杂的容器类型-1" title="Permalink"></a></h2><p>像下面这样构造数组通常没有什么好处：</p><pre><code class="language-julia">a = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)</code></pre><p>这种情况下，<code>Vector{Any}(undef, n)</code>更合适些。此外，相比将所有可能的类型都打包在一起，直接在使用时标注具体的数据类型（比如：<code>a[i]::Int</code>）对编译器来说更有用。</p><h2 id="使用和-Julia-base/-文件夹中的代码一致的命名习惯-1"><a class="docs-heading-anchor" href="#使用和-Julia-base/-文件夹中的代码一致的命名习惯-1">使用和 Julia <code>base/</code> 文件夹中的代码一致的命名习惯</a><a class="docs-heading-anchor-permalink" href="#使用和-Julia-base/-文件夹中的代码一致的命名习惯-1" title="Permalink"></a></h2><ul><li>module 和 type 的名字使用大写开头的驼峰命名法：<code>module SparseArrays</code>，<code>struct UnitRange</code>。</li><li>函数名使用小写字母，且当可读时可以将多个单词拼在一起。必要的时候，可以使用下划线作为单词分隔符。下划线也被用于指明概念的组合（比如 <a href="../../stdlib/Distributed/#Distributed.remotecall_fetch-Tuple{Any,Integer,Vararg{Any,N} where N}"><code>remotecall_fetch</code></a> 作为 <code>fetch(remotecall(...))</code> 的一个更高效的实现）或者变化。</li><li>虽然简洁性很重要，但避免使用缩写（用 <a href="../../base/collections/#Base.indexin"><code>indexin</code></a> 而不是 <code>indxin</code>），因为这会让记住单词有没有被缩写或如何被缩写变得十分困难。</li></ul><p>如果一个函数名需要多个单词，请考虑这个函数是否代表了超过一个概念，是不是分成几个更小的部分更好。</p><h2 id="使用与-Julia-Base-中的函数类似的参数顺序-1"><a class="docs-heading-anchor" href="#使用与-Julia-Base-中的函数类似的参数顺序-1">使用与 Julia Base 中的函数类似的参数顺序</a><a class="docs-heading-anchor-permalink" href="#使用与-Julia-Base-中的函数类似的参数顺序-1" title="Permalink"></a></h2><p>一般来说，Base 库使用以下的函数参数顺序（如适用）：</p><ol><li><p><strong>函数参数</strong>. 函数的第一个参数可以接受 <code>Function</code> 类型，以便使用 <a href="../../base/base/#do"><code>do</code></a> blocks 来传递多行匿名函数。</p></li><li><p><strong>I/O stream</strong>. 函数的第一个参数可以接受 <code>IO</code> 对象，以便将函数传递给 <a href="../../base/io-network/#Base.sprint"><code>sprint</code></a> 之类的函数，例如 <code>sprint(show, x)</code>。</p></li><li><p><strong>在输入参数的内容会被更改的情况下</strong>. 比如，在 <a href="../../base/arrays/#Base.fill!"><code>fill!(x, v)</code></a> 中，<code>x</code> 是要被修改的对象，所以放在要被插入 <code>x</code> 中的值前面。</p></li><li><p><strong>Type</strong>. 把类型作为参数传入函数通常意味着返回值也会是同样的类型。 在 <a href="../../base/numbers/#Base.parse"><code>parse(Int, &quot;1&quot;)</code></a> 中，类型在需要解析的字符串之前。 还有很多类似的将类型作为函数第一个参数的例子，但是同时也需要注意到例如 <a href="../../base/io-network/#Base.read"><code>read(io, String)</code></a> 这样的函数中，会把 <code>IO</code> 参数放在类型的更前面，这样还是保持着这里描述的顺序。</p></li><li><p><strong>在输入参数的内容不会被更改的情况下</strong>. 比如在 <code>fill!(x, v)</code> 中的<strong>不</strong>被修改的 <code>v</code>，会放在 <code>x</code> 之后传入。</p></li><li><p><strong>Key</strong>. 对于关联集合来说，指的是键值对的键。 对于其它有索引的集合来说，指的是索引。</p></li><li><p><strong>Value</strong>. 对于关联集合来说，指的是键值对的值。 In cases like <a href="../../base/arrays/#Base.fill!"><code>fill!(x, v)</code></a>, this is <code>v</code>.</p></li><li><p><strong>Everything else</strong>. 任何的其它参数。</p></li><li><p><strong>Varargs</strong>. 指的是在函数调用时可以被无限列在后面的参数。 比如在 <code>Matrix{T}(uninitialized, dims)</code> 中，维数（dims）可以作为 <a href="../../base/base/#Core.Tuple"><code>Tuple</code></a> 被传入（如 <code>Matrix{T}(uninitialized, (1,2))</code>），也可以作为可变参数（<a href="../../base/base/#Core.Vararg"><code>Vararg</code></a>，如 <code>Matrix{T}(uninitialized, 1, 2)</code>。</p></li><li><p><strong>Keyword arguments</strong>. 在 Julia 中，关键字参数本来就不得不定义在函数定义的最后，列在这里仅仅是为了完整性。</p></li></ol><p>大多数函数并不会接受上述所有种类的参数，这些数字仅仅是表示当适用时的优先权。</p><p>当然，在一些情况下有例外。例如，<a href="../../base/base/#Base.convert"><code>convert</code></a> 函数总是把类型作为第一个参数。<a href="../../base/collections/#Base.setindex!"><code>setindex!</code></a> 函数的值参数在索引参数之前，这样可以让索引作为可变参数传入。</p><p>设计 API 时，尽可能秉承着这种一般顺序会让函数的使用者有一种更一致的体验。</p><h2 id="不要过度使用-try-catch-1"><a class="docs-heading-anchor" href="#不要过度使用-try-catch-1">不要过度使用 try-catch</a><a class="docs-heading-anchor-permalink" href="#不要过度使用-try-catch-1" title="Permalink"></a></h2><p>比起依赖于捕获错误，更好的是避免错误。</p><h2 id="不要给条件语句加括号-1"><a class="docs-heading-anchor" href="#不要给条件语句加括号-1">不要给条件语句加括号</a><a class="docs-heading-anchor-permalink" href="#不要给条件语句加括号-1" title="Permalink"></a></h2><p>Julia 不要求在 <code>if</code> 和 <code>while</code> 后的条件两边加括号。使用如下写法：</p><pre><code class="language-julia">if a == b</code></pre><p>而不是:</p><pre><code class="language-julia">if (a == b)</code></pre><h2 id="不要过度使用-...-1"><a class="docs-heading-anchor" href="#不要过度使用-...-1">不要过度使用 <code>...</code></a><a class="docs-heading-anchor-permalink" href="#不要过度使用-...-1" title="Permalink"></a></h2><p>拼接函数参数是会上瘾的。请用简单的 <code>[a; b]</code> 来代替 <code>[a..., b...]</code>，因为前者已经是被拼接的数组了。<a href="../../base/collections/#Base.collect-Tuple{Any}"><code>collect(a)</code></a> 也比 <code>[a...]</code> 更好，但因为 <code>a</code> 已经是一个可迭代的变量了，通常不把它转换成数组就直接使用甚至更好。</p><h2 id="不要使用不必要的静态参数-1"><a class="docs-heading-anchor" href="#不要使用不必要的静态参数-1">不要使用不必要的静态参数</a><a class="docs-heading-anchor-permalink" href="#不要使用不必要的静态参数-1" title="Permalink"></a></h2><p>如下的函数签名：</p><pre><code class="language-julia">foo(x::T) where {T&lt;:Real} = ...</code></pre><p>应当被写作：</p><pre><code class="language-julia">foo(x::Real) = ...</code></pre><p>尤其是当 <code>T</code> 没有被用在函数体中时格外有意义。即使 <code>T</code> 被用到了，通常也可以被替换为 <a href="../../base/base/#Core.typeof"><code>typeof(x)</code></a>，后者不会导致性能上的差别。注意这并不是针对静态参数的一般警告，而仅仅是针对那些不必要的情况。</p><p>同样需要注意的是，容器类型在函数调用中可能明确地需要类型参数。详情参见<a href="../performance-tips/#避免使用带抽象容器的字段-1">避免使用带抽象容器的字段</a>。</p><h2 id="避免判断变量是实例还是类型的混乱-1"><a class="docs-heading-anchor" href="#避免判断变量是实例还是类型的混乱-1">避免判断变量是实例还是类型的混乱</a><a class="docs-heading-anchor-permalink" href="#避免判断变量是实例还是类型的混乱-1" title="Permalink"></a></h2><p>如下的一组定义容易令人困惑：</p><pre><code class="language-julia">foo(::Type{MyType}) = ...
foo(::MyType) = foo(MyType)</code></pre><p>请决定问题里的概念应当是 <code>MyType</code> 还是 <code>MyType()</code>，然后坚持使用其一。</p><p>默认使用实例是比较受推崇的风格，然后只在为了解决一些问题必要时添加涉及到 <code>Type{MyType}</code> 的方法。</p><p>如果一个类型实际上是个枚举，它应该被定义成一个单一的类型（理想的情况是不可变结构或原始类型），把枚举值作为它的实例。构造器和转换器可以检查那些值是否有效。这种设计比把枚举做成抽象类型，并把“值”做成子类型来得更受推崇。</p><h2 id="不要过度使用宏-1"><a class="docs-heading-anchor" href="#不要过度使用宏-1">不要过度使用宏</a><a class="docs-heading-anchor-permalink" href="#不要过度使用宏-1" title="Permalink"></a></h2><p>请注意有的宏实际上可以被写成一个函数。</p><p>在宏内部调用 <a href="../../base/base/#Base.MainInclude.eval"><code>eval</code></a> 是一个特别危险的警告标志，它意味着这个宏仅在被最外层调用时起作用。如果这样的宏被写成函数，它会自然地访问得到它所需要的运行时值。</p><h2 id="不要把不安全的操作暴露在接口层-1"><a class="docs-heading-anchor" href="#不要把不安全的操作暴露在接口层-1">不要把不安全的操作暴露在接口层</a><a class="docs-heading-anchor-permalink" href="#不要把不安全的操作暴露在接口层-1" title="Permalink"></a></h2><p>如果你有一个使用本地指针的类型：</p><pre><code class="language-julia">mutable struct NativeType
    p::Ptr{UInt8}
    ...
end</code></pre><p>不要定义类似如下的函数：</p><pre><code class="language-julia">getindex(x::NativeType, i) = unsafe_load(x.p, i)</code></pre><p>这里的问题在于，这个类型的用户可能会在意识不到这个操作不安全的情况下写出 <code>x[i]</code>，然后容易遇到内存错误。</p><p>在这样的函数中，可以加上对操作的检查来确保安全，或者可以在名字的某处加上 <code>unsafe</code> 来警告调用者。</p><h2 id="不要重载基础容器类型的方法-1"><a class="docs-heading-anchor" href="#不要重载基础容器类型的方法-1">不要重载基础容器类型的方法</a><a class="docs-heading-anchor-permalink" href="#不要重载基础容器类型的方法-1" title="Permalink"></a></h2><p>有时可能会想要写这样的定义：</p><pre><code class="language-julia">show(io::IO, v::Vector{MyType}) = ...</code></pre><p>这样可以提供对特定的某种新元素类型的向量的自定义显示。这种做法虽然很诱人，但应当被避免。这里的问题在于用户会想着一个像 <code>Vector()</code> 这样熟知的类型以某种方式表现，但过度自定义的行为会让使用变得更难。</p><h2 id="避免类型盗版-1"><a class="docs-heading-anchor" href="#避免类型盗版-1">避免类型盗版</a><a class="docs-heading-anchor-permalink" href="#避免类型盗版-1" title="Permalink"></a></h2><p>“类型盗版”（type piracy）指的是扩展或是重定义 Base 或其它包中的并不是你所定义的类型的方法。在某些情况下，你可以几乎毫无副作用地逃避类型盗版。但在极端情况下，你甚至会让 Julia 崩溃（比如说你的方法扩展或重定义造成了对 <code>ccall</code> 传入了无效的输入）。类型盗版也让代码推导变得更复杂，且可能会引入难以预料和诊断的不兼容性。</p><p>例如，你也许想在一个模块中定义符号上的乘法：</p><pre><code class="language-julia">module A
import Base.*
*(x::Symbol, y::Symbol) = Symbol(x,y)
end</code></pre><p>这里的问题时现在其它用到 <code>Base.*</code> 的模块同样会看到这个定义。由于 <code>Symbol</code> 是定义在 Base 里再被其它模块所使用的，这可能不可预料地改变无关代码的行为。这里有几种替代的方式，包括使用一个不同的函数名称，或是把 <code>Symbol</code> 给包在另一个你自己定义的类型中。</p><p>有时候，耦合的包可能会使用类型盗版，以此来从定义分隔特性，尤其是当那些包是一些合作的作者设计的时候，且那些定义是可重用的时候。例如，一个包可能提供一些对处理色彩有用的类型，另一个包可能为那些类型定义色彩空间之间转换的方法。再举一个例子，一个包可能是一些 C 代码的简易包装，另一个包可能就“盗版”来实现一些更高级别的、对 Julia 友好的 API。</p><h2 id="注意类型相等-1"><a class="docs-heading-anchor" href="#注意类型相等-1">注意类型相等</a><a class="docs-heading-anchor-permalink" href="#注意类型相等-1" title="Permalink"></a></h2><p>通常会用 <a href="../../base/base/#Core.isa"><code>isa</code></a> 和 <a href="../../base/base/#Core.:&lt;:"><code>&lt;:</code></a> 来对类型进行测试，而不会用到 <code>==</code>。检测类型的相等通常只对和一个已知的具体类型比较有意义（例如 <code>T == Float64</code>），或者你<strong>真的真的</strong>知道自己在做什么。</p><h2 id="不要写-x-f(x)-1"><a class="docs-heading-anchor" href="#不要写-x-f(x)-1">不要写 <code>x-&gt;f(x)</code></a><a class="docs-heading-anchor-permalink" href="#不要写-x-f(x)-1" title="Permalink"></a></h2><p>因为调用高阶函数时经常会用到匿名函数，很容易认为这是合理甚至必要的。但任何函数都可以被直接传递，并不需要被“包&quot;在一个匿名函数中。比如 <code>map(x-&gt;f(x), a)</code> 应当被写成 <a href="../../base/collections/#Base.map"><code>map(f, a)</code></a>。</p><h2 id="尽可能避免使用浮点数作为通用代码的字面量-1"><a class="docs-heading-anchor" href="#尽可能避免使用浮点数作为通用代码的字面量-1">尽可能避免使用浮点数作为通用代码的字面量</a><a class="docs-heading-anchor-permalink" href="#尽可能避免使用浮点数作为通用代码的字面量-1" title="Permalink"></a></h2><p>当写处理数字，且可以处理多种不同数字类型的参数的通用代码时，请使用对参数影响（通过类型提升）尽可能少的类型的字面量。</p><p>例如，</p><pre><code class="language-julia-repl">julia&gt; f(x) = 2.0 * x
f (generic function with 1 method)

julia&gt; f(1//2)
1.0

julia&gt; f(1/2)
1.0

julia&gt; f(1)
2.0</code></pre><p>而应当被写作：</p><pre><code class="language-julia-repl">julia&gt; g(x) = 2 * x
g (generic function with 1 method)

julia&gt; g(1//2)
1//1

julia&gt; g(1/2)
1.0

julia&gt; g(1)
2</code></pre><p>如你所见，使用了 <code>Int</code> 字面量的第二个版本保留了输入参数的类型，而第一个版本没有。这是因为例如 <code>promote_type(Int, Float64) == Float64</code>，且做乘法时会需要类型提升。类似地，<a href="../../base/numbers/#Base.Rational"><code>Rational</code></a> 字面量比 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> 字面量对类型有着更小的破坏性，但比 <code>Int</code> 大。</p><pre><code class="language-julia-repl">julia&gt; h(x) = 2//1 * x
h (generic function with 1 method)

julia&gt; h(1//2)
1//1

julia&gt; h(1/2)
1.0

julia&gt; h(1)
2//1</code></pre><p>所以，可能时尽量使用 <code>Int</code> 字面量，对非整数字面量使用 <code>Rational{Int}</code>，这样可以让代码变得更容易使用。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../workflow-tips/">« 工作流程建议</a><a class="docs-footer-nextpage" href="../faq/">常见问题 »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2020 六月 18 周四 07:18">2020 六月 18 周四</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.3.1版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
