<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>数学运算和初等函数 · Julia 中文文档</title><meta name="title" content="数学运算和初等函数 · Julia 中文文档"/><meta property="og:title" content="数学运算和初等函数 · Julia 中文文档"/><meta property="twitter:title" content="数学运算和初等函数 · Julia 中文文档"/><meta name="description" content="Documentation for Julia 中文文档."/><meta property="og:description" content="Documentation for Julia 中文文档."/><meta property="twitter:description" content="Documentation for Julia 中文文档."/><meta property="og:url" content="https://juliacn.github.io/JuliaZH.jl/latest/manual/mathematical-operations/"/><meta property="twitter:url" content="https://juliacn.github.io/JuliaZH.jl/latest/manual/mathematical-operations/"/><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/mathematical-operations/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia 中文文档 logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">变量</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li class="is-active"><a class="tocitem" href>数学运算和初等函数</a><ul class="internal"><li><a class="tocitem" href="#算术运算符"><span>算术运算符</span></a></li><li><a class="tocitem" href="#布尔运算符"><span>布尔运算符</span></a></li><li><a class="tocitem" href="#位运算符"><span>位运算符</span></a></li><li><a class="tocitem" href="#复合赋值运算符"><span>复合赋值运算符</span></a></li><li><a class="tocitem" href="#man-dot-operators"><span>向量化 “点” 运算符</span></a></li><li><a class="tocitem" href="#数值比较"><span>数值比较</span></a></li><li><a class="tocitem" href="#运算符的优先级与结合性"><span>运算符的优先级与结合性</span></a></li><li><a class="tocitem" href="#数值转换"><span>数值转换</span></a></li></ul></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">一维和多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../multi-threading/">多线程</a></li><li><a class="tocitem" href="../distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../environment-variables/">环境变量</a></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">数值类型</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">任务</a></li><li><a class="tocitem" href="../../base/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/reflection/">反射与内省</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">标准库</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/ArgTools/">ArgTools</a></li><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibCURL/">LibCURL</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/NetworkOptions/">Network Options</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Tar/">Tar</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">开发者文档</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/pkgimg/">Package Images</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../../devdocs/gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../../devdocs/precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../../devdocs/probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../../devdocs/build/linux/">Linux</a></li><li><a class="tocitem" href="../../devdocs/build/macos/">macOS</a></li><li><a class="tocitem" href="../../devdocs/build/windows/">Windows</a></li><li><a class="tocitem" href="../../devdocs/build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../../devdocs/build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../../devdocs/build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>数学运算和初等函数</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>数学运算和初等函数</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/zh_CN/doc/src/manual/mathematical-operations.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="数学运算和初等函数"><a class="docs-heading-anchor" href="#数学运算和初等函数">数学运算和初等函数</a><a id="数学运算和初等函数-1"></a><a class="docs-heading-anchor-permalink" href="#数学运算和初等函数" title="Permalink"></a></h1><p>Julia 为它所有的基础数值类型，提供了整套的基础算术和位运算，也提供了一套高效、可移植的标准数学函数。</p><h2 id="算术运算符"><a class="docs-heading-anchor" href="#算术运算符">算术运算符</a><a id="算术运算符-1"></a><a class="docs-heading-anchor-permalink" href="#算术运算符" title="Permalink"></a></h2><p>以下<a href="https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations">算术运算符</a>支持所有的原始数值类型：</p><table><tr><th style="text-align: left">表达式</th><th style="text-align: left">名称</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><code>+x</code></td><td style="text-align: left">一元加法运算符</td><td style="text-align: left">全等操作</td></tr><tr><td style="text-align: left"><code>-x</code></td><td style="text-align: left">一元减法运算符</td><td style="text-align: left">将值变为其相反数</td></tr><tr><td style="text-align: left"><code>x + y</code></td><td style="text-align: left">二元加法运算符</td><td style="text-align: left">执行加法</td></tr><tr><td style="text-align: left"><code>x - y</code></td><td style="text-align: left">二元减法运算符</td><td style="text-align: left">执行减法</td></tr><tr><td style="text-align: left"><code>x * y</code></td><td style="text-align: left">乘法运算符</td><td style="text-align: left">执行乘法</td></tr><tr><td style="text-align: left"><code>x / y</code></td><td style="text-align: left">除法运算符</td><td style="text-align: left">执行除法</td></tr><tr><td style="text-align: left"><code>x ÷ y</code></td><td style="text-align: left">整除</td><td style="text-align: left">取 x / y 的整数部分</td></tr><tr><td style="text-align: left"><code>x \ y</code></td><td style="text-align: left">反向除法</td><td style="text-align: left">等价于 <code>y / x</code></td></tr><tr><td style="text-align: left"><code>x ^ y</code></td><td style="text-align: left">幂操作符</td><td style="text-align: left"><code>x</code> 的 <code>y</code> 次幂</td></tr><tr><td style="text-align: left"><code>x % y</code></td><td style="text-align: left">取余</td><td style="text-align: left">等价于 <code>rem(x,y)</code></td></tr></table><p>除了优先级比二元操作符高以外，直接放在标识符或括号前的数字，如 <code>2x</code> 或 <code>2(x+y)</code> 还会被视为乘法。详见<a href="../integers-and-floating-point-numbers/#man-numeric-literal-coefficients">数值字面量系数</a>。</p><p>Julia 的类型提升系统使得混合参数类型上的代数运算也能顺其自然的工作，请参考<a href="../conversion-and-promotion/#conversion-and-promotion">类型提升系统</a>来了解更多内容。</p><p>符号 ÷ 可以通过输入 <code>\div&lt;tab&gt;</code>  到 REPL 或 Julia IDE 的方式来打出. 更多信息参见 <a href="../unicode-input/#Unicode-Input">Unicode 输入表</a>。</p><p>这里是使用算术运算符的一些简单例子：</p><pre><code class="language-julia-repl hljs">julia&gt; 1 + 2 + 3
6

julia&gt; 1 - 2
-1

julia&gt; 3*2/12
0.5</code></pre><p>习惯上我们会把优先运算的操作符紧邻操作数，比如 <code>-x + 2</code> 表示先要给 <code>x</code>  取反，然后再加 <code>2</code> 。</p><p>在乘法操作中，<code>false</code> 被视作 <strong>零</strong>。</p><pre><code class="language-julia-repl hljs">julia&gt; NaN * false
0.0

julia&gt; false * Inf
0.0</code></pre><p>这在已知某些量为零时，可以避免 <code>NaN</code> 的传播。详细的动机参见：<a href="https://arxiv.org/abs/math/9205211">Knuth (1992)</a>。</p><h2 id="布尔运算符"><a class="docs-heading-anchor" href="#布尔运算符">布尔运算符</a><a id="布尔运算符-1"></a><a class="docs-heading-anchor-permalink" href="#布尔运算符" title="Permalink"></a></h2><p><a href="../../base/numbers/#Core.Bool"><code>Bool</code></a> 类型支持以下<a href="https://en.wikipedia.org/wiki/Boolean_algebra#Operations">布尔运算符</a>：</p><table><tr><th style="text-align: left">表达式</th><th style="text-align: left">名称</th></tr><tr><td style="text-align: left"><code>!x</code></td><td style="text-align: left">否定</td></tr><tr><td style="text-align: left"><code>x &amp;&amp; y</code></td><td style="text-align: left"><a href="../control-flow/#man-conditional-evaluation">短路与</a></td></tr><tr><td style="text-align: left"><code>x || y</code></td><td style="text-align: left"><a href="../control-flow/#man-conditional-evaluation">短路或</a></td></tr></table><p>否定将 <code>true</code> 更改为 <code>false</code>，反之亦然。链接页面上解释了逻辑短路。</p><p>请注意，<code>Bool</code> 是一个整数类型，所有常用的类型提升规则和数字运算符仍然对它适用。</p><h2 id="位运算符"><a class="docs-heading-anchor" href="#位运算符">位运算符</a><a id="位运算符-1"></a><a class="docs-heading-anchor-permalink" href="#位运算符" title="Permalink"></a></h2><p>所有原始整数类型都支持以下<a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators">位运算符</a>：</p><table><tr><th style="text-align: left">表达式</th><th style="text-align: left">名称</th></tr><tr><td style="text-align: left"><code>~x</code></td><td style="text-align: left">按位取反</td></tr><tr><td style="text-align: left"><code>x &amp; y</code></td><td style="text-align: left">按位与</td></tr><tr><td style="text-align: left"><code>x | y</code></td><td style="text-align: left">按位或</td></tr><tr><td style="text-align: left"><code>x ⊻ y</code></td><td style="text-align: left">按位异或（逻辑异或）</td></tr><tr><td style="text-align: left"><code>x ⊼ y</code></td><td style="text-align: left">按位与（非与）</td></tr><tr><td style="text-align: left"><code>x ⊽ y</code></td><td style="text-align: left">按位或（非或）</td></tr><tr><td style="text-align: left"><code>x &gt;&gt;&gt; y</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Logical_shift">逻辑右移</a></td></tr><tr><td style="text-align: left"><code>x &gt;&gt; y</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Arithmetic_shift">算术右移</a></td></tr><tr><td style="text-align: left"><code>x &lt;&lt; y</code></td><td style="text-align: left">逻辑/算术左移</td></tr></table><p>以下是位运算符的一些示例：</p><pre><code class="language-julia-repl hljs">julia&gt; ~123
-124

julia&gt; 123 &amp; 234
106

julia&gt; 123 | 234
251

julia&gt; 123 ⊻ 234
145

julia&gt; xor(123, 234)
145

julia&gt; nand(123, 123)
-124

julia&gt; 123 ⊼ 123
-124

julia&gt; nor(123, 124)
-128

julia&gt; 123 ⊽ 124
-128

julia&gt; ~UInt32(123)
0xffffff84

julia&gt; ~UInt8(123)
0x84</code></pre><h2 id="复合赋值运算符"><a class="docs-heading-anchor" href="#复合赋值运算符">复合赋值运算符</a><a id="复合赋值运算符-1"></a><a class="docs-heading-anchor-permalink" href="#复合赋值运算符" title="Permalink"></a></h2><p>每一个二元运算符和位运算符都可以给左操作数复合赋值：方法是把 <code>=</code> 直接放在二元运算符后面。比如，<code>x += 3</code> 等价于 <code>x = x + 3</code> 。</p><pre><code class="language-julia-repl hljs">julia&gt; x = 1
1

julia&gt; x += 3
4

julia&gt; x
4</code></pre><p>二元运算符和位运算符的复合赋值操作符有下面几种：</p><pre><code class="nohighlight hljs">+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>复合赋值后会把变量重新绑定到左操作数上，所以变量的类型可能会改变。</p><pre><code class="language-julia-repl hljs">julia&gt; x = 0x01; typeof(x)
UInt8

julia&gt; x *= 2 # 与 x = x * 2 相同
2

julia&gt; typeof(x)
Int64</code></pre></div></div><h2 id="man-dot-operators"><a class="docs-heading-anchor" href="#man-dot-operators">向量化 “点” 运算符</a><a id="man-dot-operators-1"></a><a class="docs-heading-anchor-permalink" href="#man-dot-operators" title="Permalink"></a></h2><p>Julia 中，<strong>每个</strong>二元运算符都有一个 “点” 运算符与之对应，例如 <code>^</code> 就有对应的 <code>.^</code> 存在。这个对应的 <code>.^</code> 被 Julia <strong>自动地</strong>定义为逐元素地执行 <code>^</code> 运算。比如 <code>[1,2,3] ^ 3</code> 是非法的，因为数学上没有给（长宽不一样的）数组的立方下过定义。但是 <code>[1,2,3] .^ 3</code> 在 Julia 里是合法的，它会逐元素地执行 <code>^</code> 运算（或称向量化运算），得到 <code>[1^3, 2^3, 3^3]</code>。类似地，<code>!</code> 或 <code>√</code> 这样的一元运算符，也都有一个对应的 <code>.√</code> 用于执行逐元素运算。</p><pre><code class="language-julia-repl hljs">julia&gt; [1,2,3] .^ 3
3-element Vector{Int64}:
  1
  8
 27</code></pre><p>更确切地说，<code>a .^b</code> 被解析为 <a href="../functions/#man-vectorized">“点运算” 调用</a> <code>(^).(a,b)</code>，这会执行 <a href="../arrays/#Broadcasting">广播</a> 操作： 该操作能结合数组和标量、相同大小的数组（进行元素之间的运算），甚至不同形状的数组（例如行、列向量结合生成矩阵）。 此外，就像所有向量化的点运算调用一样，这些点运算符是<em>融合</em>的。 例如，在计算关于数组 <code>A</code> 的表达式 <code>2 .* A.^2 .+ sin.(A)</code>（或者等价地，使用<a href="../../base/arrays/#Base.Broadcast.@__dot__"><code>@.</code></a> 宏，<code>@. 2A^2 + sin(A)</code>）， Julia 只对 <code>A</code> 进行做<em>一次</em>循环，遍历 <code>A</code> 中的每个元素 <code>a</code> 并计算 <code>2a^2 + sin(a)</code>。 特别的，类似 <code>f.(g.(x))</code> 的嵌套点运算调用也是融合的，并且“相邻的”二元运算符表达式 <code>x .+ 3 .* x.^2</code> 可以等价转换为嵌套 dot 调用： <code>(+).(x, (*).(3, (^).(x, 2)))</code>。</p><p>除了点运算符，我们还有逐点赋值运算符，类似 <code>a .+= b</code>（或者 <code>@. a += b</code>）会被解析成 <code>a .= a .+ b</code>，这里的 <code>.=</code> 是一个<strong>融合</strong>的 in-place 运算，更多信息请查看 <a href="../functions/#man-vectorized"><code>dot</code> 文档</a>）。</p><p>这个点语法，也能用在用户自定义的运算符上。例如，通过定义 <code>⊗(A,B) = kron(A,B)</code> 可以为 Kronecker 积（<a href="../../stdlib/LinearAlgebra/#Base.kron"><code>kron</code></a>）提供一个方便的中缀语法 <code>A ⊗ B</code>，那么配合点语法 <code>[A,B] .⊗ [C,D]</code> 就等价于 <code>[A⊗C, B⊗D]</code>。</p><p>将点运算符用于数值字面量可能会导致歧义。例如，<code>1.+x</code> 到底是表示 <code>1. + x</code> 还是 <code>1 .+ x</code>？这会令人疑惑。因此不允许使用这种语法，遇到这种情况时，必须明确地用空格消除歧义。</p><h2 id="数值比较"><a class="docs-heading-anchor" href="#数值比较">数值比较</a><a id="数值比较-1"></a><a class="docs-heading-anchor-permalink" href="#数值比较" title="Permalink"></a></h2><p>标准的比较操作对所有原始数值类型有定义：</p><table><tr><th style="text-align: left">操作符</th><th style="text-align: left">名称</th></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:=="><code>==</code></a></td><td style="text-align: left">相等</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:!="><code>!=</code></a>, <a href="../../base/math/#Base.:!="><code>≠</code></a></td><td style="text-align: left">不等</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:&lt;"><code>&lt;</code></a></td><td style="text-align: left">小于</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:&lt;="><code>&lt;=</code></a>, <a href="../../base/math/#Base.:&lt;="><code>≤</code></a></td><td style="text-align: left">小于等于</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:&gt;"><code>&gt;</code></a></td><td style="text-align: left">大于</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:&gt;="><code>&gt;=</code></a>, <a href="../../base/math/#Base.:&gt;="><code>≥</code></a></td><td style="text-align: left">大于等于</td></tr></table><p>下面是一些简单的例子：</p><pre><code class="language-julia-repl hljs">julia&gt; 1 == 1
true

julia&gt; 1 == 2
false

julia&gt; 1 != 2
true

julia&gt; 1 == 1.0
true

julia&gt; 1 &lt; 2
true

julia&gt; 1.0 &gt; 3
false

julia&gt; 1 &gt;= 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 &lt;= -1
true

julia&gt; -1 &lt;= -2
false

julia&gt; 3 &lt; -0.5
false</code></pre><p>整数的比较方式是标准的按位比较，而浮点数的比较方式则遵循 <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 标准</a>。</p><ul><li>有限数的大小顺序，和我们所熟知的相同。</li><li><code>+0</code> 等于但不大于 <code>-0</code>.</li><li><code>Inf</code> 等于自身，并且大于除了 <code>NaN</code> 外的所有数。</li><li><code>-Inf</code> 等于自身，并且小于除了 <code>NaN</code> 外的所有数。</li><li><code>NaN</code> 不等于、不小于且不大于任何数值，包括它自己。</li></ul><p><code>NaN</code> 不等于它自己这一点可能会令人感到惊奇，所以需要注意：</p><pre><code class="language-julia-repl hljs">julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false</code></pre><p>当你将 <code>NaN</code> 和 <a href="../arrays/#man-multi-dim-arrays">数组</a> 一起连用时，你就会感到头疼：</p><pre><code class="language-julia-repl hljs">julia&gt; [1 NaN] == [1 NaN]
false</code></pre><p>为此，Julia 给这些特别的数提供了下面几个额外的测试函数。这些函数在某些情况下很有用处，比如在做 hash 比较时。</p><table><tr><th style="text-align: left">函数</th><th style="text-align: left">测试是否满足如下性质</th></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.isequal"><code>isequal(x, y)</code></a></td><td style="text-align: left"><code>x</code> 与 <code>y</code> 是完全相同的</td></tr><tr><td style="text-align: left"><a href="../../base/numbers/#Base.isfinite"><code>isfinite(x)</code></a></td><td style="text-align: left"><code>x</code> 是有限大的数字</td></tr><tr><td style="text-align: left"><a href="../../base/numbers/#Base.isinf"><code>isinf(x)</code></a></td><td style="text-align: left"><code>x</code> 是（正/负）无穷大</td></tr><tr><td style="text-align: left"><a href="../../base/numbers/#Base.isnan"><code>isnan(x)</code></a></td><td style="text-align: left"><code>x</code> 是 <code>NaN</code></td></tr></table><p><a href="../../base/base/#Base.isequal"><code>isequal</code></a> 认为 <code>NaN</code> 之间是相等的：</p><pre><code class="language-julia-repl hljs">julia&gt; isequal(NaN, NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN, NaN32)
true</code></pre><p><code>isequal</code> 也能用来区分带符号的零：</p><pre><code class="language-julia-repl hljs">julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false</code></pre><p>有符号整数、无符号整数以及浮点数之间的混合类型比较是很棘手的。开发者费了很大精力来确保 Julia 在这个问题上做的是正确的。</p><p>对于其它类型，<code>isequal</code> 会默认调用 <a href="../../base/math/#Base.:=="><code>==</code></a>，所以如果你想给自己的类型定义相等，那么就只需要为 <a href="../../base/math/#Base.:=="><code>==</code></a> 增加一个方法。如果你想定义一个你自己的相等函数，你可能需要定义一个对应的 <a href="../../base/base/#Base.hash"><code>hash</code></a> 方法，用于确保 <code>isequal(x,y)</code> 隐含着 <code>hash(x) == hash(y)</code>。</p><h3 id="链式比较"><a class="docs-heading-anchor" href="#链式比较">链式比较</a><a id="链式比较-1"></a><a class="docs-heading-anchor-permalink" href="#链式比较" title="Permalink"></a></h3><p>与其他多数语言不同，就像 <a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators">notable exception of Python</a> 一样，Julia 允许链式比较：</p><pre><code class="language-julia-repl hljs">julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true</code></pre><p>链式比较在写数值代码时特别方便，它使用 <code>&amp;&amp;</code> 运算符比较标量，数组则用 <a href="../../base/math/#Base.:&amp;"><code>&amp;</code></a> 进行按元素比较。比如，<code>0 .&lt; A .&lt; 1</code> 会得到一个 boolean 数组，如果 <code>A</code> 的元素都在 0 和 1 之间则数组元素就都是 true。</p><p>注意链式比较的执行顺序：</p><pre><code class="language-julia-repl hljs">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; v(1) &lt; v(2) &lt;= v(3)
2
1
3
true

julia&gt; v(1) &gt; v(2) &lt;= v(3)
2
1
false</code></pre><p>中间的表达式只会计算一次，而如果写成 <code>v(1) &lt; v(2) &amp;&amp; v(2) &lt;= v(3)</code> 是计算了两次的。然而，链式比较中的顺序是不确定的。强烈建议不要在表达式中使用有副作用（比如 printing）的函数。如果的确需要，请使用短路运算符 <code>&amp;&amp;</code>（请参考<a href="../control-flow/#短路求值">短路求值</a>）。</p><h3 id="初等函数"><a class="docs-heading-anchor" href="#初等函数">初等函数</a><a id="初等函数-1"></a><a class="docs-heading-anchor-permalink" href="#初等函数" title="Permalink"></a></h3><p>Julia 提供了强大的数学函数和运算符集合。这些数学运算定义在各种合理的数值上，包括整型、浮点数、分数和复数，只要这些定义有数学意义就行。</p><p>而且，和其它 Julia 函数一样，这些函数也能通过 <a href="../functions/#man-vectorized">点语法</a> <code>f.(A)</code> 以“向量化”的方式作用于数组和其它集合上。 比如，<code>sin.(A)</code> 会计算 <code>A</code> 中每个元素的 sin 值。</p><h2 id="运算符的优先级与结合性"><a class="docs-heading-anchor" href="#运算符的优先级与结合性">运算符的优先级与结合性</a><a id="运算符的优先级与结合性-1"></a><a class="docs-heading-anchor-permalink" href="#运算符的优先级与结合性" title="Permalink"></a></h2><p>从高到低，Julia 运算符的优先级与结合性为：</p><table><tr><th style="text-align: left">分类</th><th style="text-align: left">运算符</th><th style="text-align: left">结合性</th></tr><tr><td style="text-align: left">语法</td><td style="text-align: left"><code>.</code> followed by <code>::</code></td><td style="text-align: left">左结合</td></tr><tr><td style="text-align: left">幂运算</td><td style="text-align: left"><code>^</code></td><td style="text-align: left">右结合</td></tr><tr><td style="text-align: left">一元运算符</td><td style="text-align: left"><code>+ - √</code></td><td style="text-align: left">右结合<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></td></tr><tr><td style="text-align: left">移位运算</td><td style="text-align: left"><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td><td style="text-align: left">左结合</td></tr><tr><td style="text-align: left">除法</td><td style="text-align: left"><code>//</code></td><td style="text-align: left">左结合</td></tr><tr><td style="text-align: left">乘法</td><td style="text-align: left"><code>* / % &amp; \ ÷</code></td><td style="text-align: left">左结合<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></td></tr><tr><td style="text-align: left">加法</td><td style="text-align: left"><code>+ - | ⊻</code></td><td style="text-align: left">左结合<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></td></tr><tr><td style="text-align: left">语法</td><td style="text-align: left"><code>: ..</code></td><td style="text-align: left">左结合</td></tr><tr><td style="text-align: left">语法</td><td style="text-align: left"><code>|&gt;</code></td><td style="text-align: left">左结合</td></tr><tr><td style="text-align: left">语法</td><td style="text-align: left"><code>&lt;|</code></td><td style="text-align: left">右结合</td></tr><tr><td style="text-align: left">比较</td><td style="text-align: left"><code>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</code></td><td style="text-align: left">无结合性</td></tr><tr><td style="text-align: left">流程控制</td><td style="text-align: left"><code>&amp;&amp;</code> followed by <code>||</code> followed by <code>?</code></td><td style="text-align: left">右结合</td></tr><tr><td style="text-align: left">Pair 操作</td><td style="text-align: left"><code>=&gt;</code></td><td style="text-align: left">右结合</td></tr><tr><td style="text-align: left">赋值</td><td style="text-align: left"><code>= += -= *= /= //= \= ^= ÷= %= |= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code></td><td style="text-align: left">右结合</td></tr></table><p>想查看 <em>每个</em> Julia 运算符的优先级，可以参考这个文件：<a href="https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm"><code>src/julia-parser.scm</code></a>。注意到有一些运算符在 <code>Base</code> 模块中没有定义但是可能是在标准库、包或者用户代码中定义的。</p><p>你也可以通过内置函数 <code>Base.operator_precedence</code> 查看任何给定运算符的优先级数值，数值越大优先级越高：</p><pre><code class="language-julia-repl hljs">julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 12, 17)

julia&gt; Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (注意：等号前后必须有括号 `:(=)`)
(0, 1, 1)</code></pre><p>另外，内置函数 <code>Base.operator_associativity</code> 可以返回运算符结合性的符号表示：</p><pre><code class="language-julia-repl hljs">julia&gt; Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia&gt; Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)</code></pre><p>注意诸如 <code>:sin</code> 这样的符号返回优先级 <code>0</code>，此值代表无效的运算符或非最低优先级运算符。类似地，它们的结合性被认为是 <code>:none</code>。</p><p><a href="../integers-and-floating-point-numbers/#man-numeric-literal-coefficients">数字字面量系数</a>，例如 <code>2x</code>  被视为比任何其他二元运算具有更高优先级的乘法，除了<code>^</code>，指数计算具有更高的优先级。</p><pre><code class="language-julia-repl hljs">julia&gt; x = 3; 2x^2
18

julia&gt; x = 3; 2^2x
64</code></pre><p>并列解析就像一元运算符，它在指数周围具有相同的自然不对称性：<code>-x^y</code> 和 <code>2x^y</code>解析为 <code>-(x^y)</code> 和 <code>2(x^y)</code> 而 <code>x^-y</code> 和 <code>x^2y</code> 解析为<code>x^(-y)</code> 和 <code>x^(2y)</code>。</p><h2 id="数值转换"><a class="docs-heading-anchor" href="#数值转换">数值转换</a><a id="数值转换-1"></a><a class="docs-heading-anchor-permalink" href="#数值转换" title="Permalink"></a></h2><p>Julia 支持三种数值转换，它们在处理不精确转换上有所不同。</p><ul><li><p><code>T(x)</code> 和 <code>convert(T,x)</code> 都会把 <code>x</code> 转换为 <code>T</code>类型。</p><ul><li>如果 <code>T</code> 是浮点类型，转换的结果就是最近的可表示值， 可能会是正负无穷大。</li><li>如果 <code>T</code> 为整数类型，当 <code>x</code> 不能由 <code>T</code> 类型表示时，会抛出 <code>InexactError</code>。</li></ul></li><li><p><code>x % T</code> 将整数 <code>x</code> 转换为整型 <code>T</code>，与 <code>x</code> 模 <code>2^n</code> 的结果一致，其中 <code>n</code> 是 <code>T</code> 的位数。换句话说，在二进制表示下被截掉了一部分。</p></li><li><p><a href="#舍入函数">舍入函数</a> 接收一个 <code>T</code> 类型的可选参数。比如，<code>round(Int,x)</code> 是 <code>Int(round(x))</code> 的简写版。</p></li></ul><p>下面的例子展示了不同的形式</p><pre><code class="language-julia-repl hljs">julia&gt; Int8(127)
127

julia&gt; Int8(128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]

julia&gt; Int8(127.0)
127

julia&gt; Int8(3.14)
ERROR: InexactError: Int8(3.14)
Stacktrace:
[...]

julia&gt; Int8(128.0)
ERROR: InexactError: Int8(128.0)
Stacktrace:
[...]

julia&gt; 127 % Int8
127

julia&gt; 128 % Int8
-128

julia&gt; round(Int8,127.4)
127

julia&gt; round(Int8,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]</code></pre><p>请参考<a href="../conversion-and-promotion/#conversion-and-promotion">类型转换与类型提升</a>一节来定义你自己的类型转换和提升规则。</p><h3 id="舍入函数"><a class="docs-heading-anchor" href="#舍入函数">舍入函数</a><a id="舍入函数-1"></a><a class="docs-heading-anchor-permalink" href="#舍入函数" title="Permalink"></a></h3><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th><th style="text-align: left">返回类型</th></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.round"><code>round(x)</code></a></td><td style="text-align: left"><code>x</code> 舍到最接近的整数</td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.round"><code>round(T, x)</code></a></td><td style="text-align: left"><code>x</code> 舍到最接近的整数</td><td style="text-align: left"><code>T</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.floor"><code>floor(x)</code></a></td><td style="text-align: left"><code>x</code> 向 <code>-Inf</code> 舍入</td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.floor"><code>floor(T, x)</code></a></td><td style="text-align: left"><code>x</code> 向 <code>-Inf</code> 舍入</td><td style="text-align: left"><code>T</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.ceil"><code>ceil(x)</code></a></td><td style="text-align: left"><code>x</code> 向 <code>+Inf</code> 方向取整</td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.ceil"><code>ceil(T, x)</code></a></td><td style="text-align: left"><code>x</code> 向 <code>+Inf</code> 方向取整</td><td style="text-align: left"><code>T</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.trunc"><code>trunc(x)</code></a></td><td style="text-align: left"><code>x</code> 向 0 取整</td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.trunc"><code>trunc(T, x)</code></a></td><td style="text-align: left"><code>x</code> 向 0 取整</td><td style="text-align: left"><code>T</code></td></tr></table><h3 id="除法函数"><a class="docs-heading-anchor" href="#除法函数">除法函数</a><a id="除法函数-1"></a><a class="docs-heading-anchor-permalink" href="#除法函数" title="Permalink"></a></h3><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.div"><code>div(x,y)</code></a>, <code>x÷y</code></td><td style="text-align: left">截断除法；商向零近似</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.fld"><code>fld(x,y)</code></a></td><td style="text-align: left">向下取整除法；商向 <code>-Inf</code> 近似</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.cld"><code>cld(x,y)</code></a></td><td style="text-align: left">向上取整除法；商向 <code>+Inf</code> 近似</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.rem"><code>rem(x,y)</code></a>, <code>x%y</code></td><td style="text-align: left">取余；满足 <code>x == div(x,y)*y + rem(x,y)</code>；符号与 <code>x</code> 一致</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.mod"><code>mod(x,y)</code></a></td><td style="text-align: left">取模；满足 <code>x == fld(x,y)*y + mod(x,y)</code>；符号与 <code>y</code> 一致</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.mod1"><code>mod1(x,y)</code></a></td><td style="text-align: left">偏移 1 的 <code>mod</code>；若 <code>y&gt;0</code>，则返回 <code>r∈(0,y]</code>，若 <code>y&lt;0</code>，则 <code>r∈[y,0)</code> 且满足 <code>mod(r, y) == mod(x, y)</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.Math.mod2pi"><code>mod2pi(x)</code></a></td><td style="text-align: left">对 2pi 取模；<code>0 &lt;= mod2pi(x) &lt; 2pi</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.divrem"><code>divrem(x,y)</code></a></td><td style="text-align: left">返回 <code>(div(x,y),rem(x,y))</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.fldmod"><code>fldmod(x,y)</code></a></td><td style="text-align: left">返回 <code>(fld(x,y),mod(x,y))</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.gcd"><code>gcd(x,y...)</code></a></td><td style="text-align: left"><code>x</code>, <code>y</code>,... 的最大公约数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.lcm"><code>lcm(x,y...)</code></a></td><td style="text-align: left"><code>x</code>, <code>y</code>,... 的最小公倍数</td></tr></table><h3 id="符号和绝对值函数"><a class="docs-heading-anchor" href="#符号和绝对值函数">符号和绝对值函数</a><a id="符号和绝对值函数-1"></a><a class="docs-heading-anchor-permalink" href="#符号和绝对值函数" title="Permalink"></a></h3><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.abs"><code>abs(x)</code></a></td><td style="text-align: left"><code>x</code> 的模</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.abs2"><code>abs2(x)</code></a></td><td style="text-align: left"><code>x</code> 的模的平方</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.sign"><code>sign(x)</code></a></td><td style="text-align: left">表示 <code>x</code> 的符号，返回 -1，0，或 +1</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.signbit"><code>signbit(x)</code></a></td><td style="text-align: left">表示符号位是 true 或 false</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.copysign"><code>copysign(x,y)</code></a></td><td style="text-align: left">返回一个数，其值等于 <code>x</code> 的模，符号与 <code>y</code> 一致</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.flipsign"><code>flipsign(x,y)</code></a></td><td style="text-align: left">返回一个数，其值等于 <code>x</code> 的模，符号与 <code>x*y</code> 一致</td></tr></table><h3 id="幂、对数与平方根"><a class="docs-heading-anchor" href="#幂、对数与平方根">幂、对数与平方根</a><a id="幂、对数与平方根-1"></a><a class="docs-heading-anchor-permalink" href="#幂、对数与平方根" title="Permalink"></a></h3><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.sqrt-Tuple{Number}"><code>sqrt(x)</code></a>, <code>√x</code></td><td style="text-align: left"><code>x</code> 的平方根</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.Math.cbrt-Tuple{AbstractFloat}"><code>cbrt(x)</code></a>, <code>∛x</code></td><td style="text-align: left"><code>x</code> 的立方根</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.Math.hypot"><code>hypot(x,y)</code></a></td><td style="text-align: left">当直角边的长度为 <code>x</code> 和 <code>y</code>时，直角三角形斜边的长度</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.exp-Tuple{Float64}"><code>exp(x)</code></a></td><td style="text-align: left">自然指数函数在 <code>x</code> 处的值</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.expm1"><code>expm1(x)</code></a></td><td style="text-align: left">当 <code>x</code> 接近 0 时的 <code>exp(x)-1</code> 的精确值</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.Math.ldexp"><code>ldexp(x,n)</code></a></td><td style="text-align: left"><code>x*2^n</code> 的高效算法，<code>n</code> 为整数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.log-Tuple{Number}"><code>log(x)</code></a></td><td style="text-align: left"><code>x</code> 的自然对数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.log-Tuple{Number}"><code>log(b,x)</code></a></td><td style="text-align: left">以 <code>b</code> 为底 <code>x</code> 的对数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.log2"><code>log2(x)</code></a></td><td style="text-align: left">以 2 为底 <code>x</code> 的对数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.log10"><code>log10(x)</code></a></td><td style="text-align: left">以 10 为底 <code>x</code> 的对数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.log1p"><code>log1p(x)</code></a></td><td style="text-align: left">当 <code>x</code>接近 0 时的 <code>log(1+x)</code> 的精确值</td></tr><tr><td style="text-align: left"><a href="../../base/numbers/#Base.Math.exponent"><code>exponent(x)</code></a></td><td style="text-align: left"><code>x</code> 的二进制指数</td></tr><tr><td style="text-align: left"><a href="../../base/numbers/#Base.Math.significand"><code>significand(x)</code></a></td><td style="text-align: left">浮点数 <code>x</code> 的二进制有效数（也就是尾数）</td></tr></table><p>想大概了解一下为什么诸如 <a href="../../base/math/#Base.Math.hypot"><code>hypot</code></a>、<a href="../../base/math/#Base.expm1"><code>expm1</code></a>和 <a href="../../base/math/#Base.log1p"><code>log1p</code></a> 函数是必要和有用的，可以看一下 John D. Cook 关于这些主题的两篇优秀博文：<a href="https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/">expm1, log1p, erfc</a>， 和 <a href="https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/">hypot</a>。</p><h3 id="三角和双曲函数"><a class="docs-heading-anchor" href="#三角和双曲函数">三角和双曲函数</a><a id="三角和双曲函数-1"></a><a class="docs-heading-anchor-permalink" href="#三角和双曲函数" title="Permalink"></a></h3><p>所有标准的三角和双曲函数也都已经定义了：</p><pre><code class="nohighlight hljs">sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc</code></pre><p>所有这些函数都是单参数函数，不过 <a href="../../base/math/#Base.atan-Tuple{Number}"><code>atan</code></a> 也可以接收两个参数 来表示传统的 <a href="https://en.wikipedia.org/wiki/Atan2"><code>atan2</code></a> 函数。</p><p>另外，<a href="../../base/math/#Base.Math.sinpi"><code>sinpi(x)</code></a> 和 <a href="../../base/math/#Base.Math.cospi"><code>cospi(x)</code></a> 分别用来对 <a href="../../base/math/#Base.sin-Tuple{Number}"><code>sin(pi*x)</code></a> 和 <a href="../../base/math/#Base.cos-Tuple{Number}"><code>cos(pi*x)</code></a> 进行更精确的计算。</p><p>要计算角度而非弧度的三角函数，以 <code>d</code> 做后缀。 比如，<a href="../../base/math/#Base.Math.sind"><code>sind(x)</code></a> 计算 <code>x</code> 的 sine 值，其中 <code>x</code> 是一个角度值。 下面是角度变量的三角函数完整列表：</p><pre><code class="nohighlight hljs">sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd</code></pre><h3 id="特殊函数"><a class="docs-heading-anchor" href="#特殊函数">特殊函数</a><a id="特殊函数-1"></a><a class="docs-heading-anchor-permalink" href="#特殊函数" title="Permalink"></a></h3><p><a href="https://github.com/JuliaMath/SpecialFunctions.jl">SpecialFunctions.jl</a> 提供了许多其他的特殊数学函数。</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>一元运算符 <code>+</code> 和 <code>-</code> 需要显式调用，即给它们的参数加上括号，以免和 <code>++</code> 等运算符混淆。其它一元运算符的混合使用都被解析为右结合的，比如 <code>√√-a</code> 解析为 <code>√(√(-a))</code>。</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>运算符 <code>+</code>、<code>++</code> 和 <code>*</code> 是非结合性的。 <code>a + b + c</code> 被解析为 <code>+(a, b, c)</code> 而不是 <code>+(+(a, b), c)</code>。 然而，<code>+(a, b, c, d...)</code> 和 <code>*(a, b, c, d...)</code> 的回退方法默认为左结合求值。</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../integers-and-floating-point-numbers/">« 整数和浮点数</a><a class="docs-footer-nextpage" href="../complex-and-rational-numbers/">复数和有理数 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>本文档在 <span class="colophon-date" title="2025 八月 15 周五 15:00">2025 八月 15 周五</span>用 <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> 1.10.2 版生成使用 1.10.10 版本的 Julia。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
