<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>数学运算和初等函数 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/mathematical-operations/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li class="current"><a class="toctext" href>数学运算和初等函数</a><ul class="internal"><li><a class="toctext" href="#算术运算符-1">算术运算符</a></li><li><a class="toctext" href="#位运算符-1">位运算符</a></li><li><a class="toctext" href="#复合赋值操作符-1">复合赋值操作符</a></li><li><a class="toctext" href="#man-dot-operators-1">向量化 <code>dot</code> 运算符</a></li><li><a class="toctext" href="#数值比较-1">数值比较</a></li><li><a class="toctext" href="#运算符的优先级与结合性-1">运算符的优先级与结合性</a></li><li><a class="toctext" href="#数值转换-1">数值转换</a></li></ul></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">接口</a></li><li><a class="toctext" href="../modules/">模块</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">元编程</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">性能分析</a></li><li><a class="toctext" href="../stacktraces/">栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li><a class="toctext" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">基本功能</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学相关</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">数组</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O 与网络</a></li><li><a class="toctext" href="../../base/punctuation/">运算符与记号</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">迭代相关</a></li><li><a class="toctext" href="../../base/c/">C 接口</a></li><li><a class="toctext" href="../../base/libc/">C 标准库</a></li><li><a class="toctext" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="toctext" href="../../stdlib/Distributed/">分布式计算</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">交互式组件</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="toctext" href="../../stdlib/Logging/">日志记录</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">性能分析</a></li><li><a class="toctext" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">随机数</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">序列化</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="toctext" href="../../stdlib/Sockets/">套接字</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="toctext" href="../../stdlib/Statistics/">统计</a></li><li><a class="toctext" href="../../stdlib/Test/">单元测试</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="toctext" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">子数组</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>数学运算和初等函数</a></li></ul><a class="edit-page" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/mathematical-operationsmd"><span class="fa"></span> 完善 Transifex 上的翻译</a></nav><hr/><div id="topbar"><span>数学运算和初等函数</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="数学运算和初等函数-1" href="#数学运算和初等函数-1">数学运算和初等函数</a></h1><p>Julia 为它所有的基础数值类型，提供了整套的基础算术和位运算，也提供了一套高效、可移植的标准数学函数。</p><h2><a class="nav-anchor" id="算术运算符-1" href="#算术运算符-1">算术运算符</a></h2><p>以下<a href="https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations">算术运算符</a>支持所有的原始数值类型：</p><table><tr><th style="text-align: left">表达式</th><th style="text-align: left">名称</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><code>+x</code></td><td style="text-align: left">一元加法运算符</td><td style="text-align: left">全等操作</td></tr><tr><td style="text-align: left"><code>-x</code></td><td style="text-align: left">一元减法运算符</td><td style="text-align: left">将值变为其相反数</td></tr><tr><td style="text-align: left"><code>x + y</code></td><td style="text-align: left">二元加法运算符</td><td style="text-align: left">执行加法</td></tr><tr><td style="text-align: left"><code>x - y</code></td><td style="text-align: left">二元减法运算符</td><td style="text-align: left">执行减法</td></tr><tr><td style="text-align: left"><code>x * y</code></td><td style="text-align: left">乘法运算符</td><td style="text-align: left">执行乘法</td></tr><tr><td style="text-align: left"><code>x / y</code></td><td style="text-align: left">除法运算符</td><td style="text-align: left">执行除法</td></tr><tr><td style="text-align: left"><code>x ÷ y</code></td><td style="text-align: left">整除</td><td style="text-align: left">取 x / y 的整数部分</td></tr><tr><td style="text-align: left"><code>x \ y</code></td><td style="text-align: left">反向除法</td><td style="text-align: left">等价于 <code>y / x</code></td></tr><tr><td style="text-align: left"><code>x ^ y</code></td><td style="text-align: left">幂操作符</td><td style="text-align: left"><code>x</code> 的 <code>y</code> 次幂</td></tr><tr><td style="text-align: left"><code>x % y</code></td><td style="text-align: left">取余</td><td style="text-align: left">等价于 <code>rem(x,y)</code></td></tr></table><p>以及对 <a href="../../base/numbers/#Core.Bool"><code>Bool</code></a> 类型的否定：</p><table><tr><th style="text-align: left">表达式</th><th style="text-align: left">名称</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><code>!x</code></td><td style="text-align: left">否定</td><td style="text-align: left">将 <code>true</code> 和 <code>false</code> 互换</td></tr></table><p>Julia 的类型提升系统使得混合参数类型上的代数运算也能顺其自然的工作，请参考<a href="../conversion-and-promotion/#conversion-and-promotion-1">类型提升系统</a>来了解更多内容。</p><p>这里是使用算术运算符的一些简单例子：</p><pre><code class="language-julia-repl">julia&gt; 1 + 2 + 3
6

julia&gt; 1 - 2
-1

julia&gt; 3*2/12
0.5</code></pre><p>习惯上我们会把优先运算的操作符紧邻操作数，比如 <code>-x + 2</code> 表示先要给 <code>x</code>  取反，然后再加 <code>2</code> 。</p><h2><a class="nav-anchor" id="位运算符-1" href="#位运算符-1">位运算符</a></h2><p>所有原始整数类型都支持以下<a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators">位运算符</a>：</p><table><tr><th style="text-align: left">表达式</th><th style="text-align: left">名称</th></tr><tr><td style="text-align: left"><code>~x</code></td><td style="text-align: left">按位取反</td></tr><tr><td style="text-align: left"><code>x &amp; y</code></td><td style="text-align: left">按位与</td></tr><tr><td style="text-align: left"><code>x | y</code></td><td style="text-align: left">按位或</td></tr><tr><td style="text-align: left"><code>x ⊻ y</code></td><td style="text-align: left">按位异或（逻辑异或）</td></tr><tr><td style="text-align: left"><code>x &gt;&gt;&gt; y</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Logical_shift">逻辑右移</a></td></tr><tr><td style="text-align: left"><code>x &gt;&gt; y</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Arithmetic_shift">算术右移</a></td></tr><tr><td style="text-align: left"><code>x &lt;&lt; y</code></td><td style="text-align: left">逻辑/算术左移</td></tr></table><p>以下是位运算符的一些示例：</p><pre><code class="language-julia-repl">julia&gt; ~123
-124

julia&gt; 123 &amp; 234
106

julia&gt; 123 | 234
251

julia&gt; 123 ⊻ 234
145

julia&gt; xor(123, 234)
145

julia&gt; ~UInt32(123)
0xffffff84

julia&gt; ~UInt8(123)
0x84</code></pre><h2><a class="nav-anchor" id="复合赋值操作符-1" href="#复合赋值操作符-1">复合赋值操作符</a></h2><p>每一个二元运算符和位运算符都可以给左操作数复合赋值：方法是把 <code>=</code> 直接放在二元运算符后面。比如，<code>x += 3</code> 等价于 <code>x = x + 3</code> 。</p><pre><code class="language-julia-repl">julia&gt; x = 1
1

julia&gt; x += 3
4

julia&gt; x
4</code></pre><p>二元运算和位运算的复合赋值操作符有下面几种：</p><pre><code class="language-none">+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>复合赋值后会把变量重新绑定到左操作数上，所以变量的类型可能会改变。</p><pre><code class="language-julia-repl">julia&gt; x = 0x01; typeof(x)
UInt8

julia&gt; x *= 2 # 与 x = x * 2 相同
2

julia&gt; typeof(x)
Int64</code></pre></div></div><h2><a class="nav-anchor" id="man-dot-operators-1" href="#man-dot-operators-1">向量化 <code>dot</code> 运算符</a></h2><p>Julia 中，<strong>每个</strong>二元运算符都有一个 <code>dot</code> 运算符与之对应，例如 <code>^</code> 就有对应的 <code>.^</code> 存在。这个对应的 <code>.^</code> 被 Julia <strong>自动地</strong>定义为逐元素地执行 <code>^</code> 运算。比如 <code>[1,2,3] ^ 3</code> 是非法的，因为数学上没有给（长宽不一样的）数组的立方下过定义。但是 <code>[1,2,3] .^ 3</code> 在 Julia 里是合法的，它会逐元素地执行 <code>^</code> 运算（或称向量化运算），得到 <code>[1^3, 2^3, 3^3]</code>。类似地，<code>!</code> 或 <code>√</code> 这样的一元运算符，也都有一个对应的 <code>.√</code> 用于执行逐元素运算。</p><pre><code class="language-julia-repl">julia&gt; [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27</code></pre><p>具体来说，<code>a .^ b</code> 被解析为 <a href="../functions/#man-vectorized-1"><code>dot</code> 调用</a> <code>(^).(a,b)</code>，这会执行 <a href="manual/@ref Broadcasting">broadcast</a> 操作：该操作能结合数组和标量、相同大小的数组（元素之间的运算）、甚至不同形状的数组（例如行、列向量结合生成矩阵）。更进一步，就像所有向量化的 <code>dot</code> 调用一样，这些 <code>dot</code> 运算符是<strong>融合</strong>的（fused）。例如，在计算表达式 <code>2 .* A.^2 .+ sin.(A)</code> 时，Julia 只对 <code>A</code> 进行做<strong>一次</strong>循环，遍历 <code>A</code> 中的每个元素 a 并计算 <code>2a^2 + sin(a)</code>。上述表达式也可以用<a href="../../base/arrays/#Base.Broadcast.@__dot__"><code>@.</code></a> 宏简写为 <code>@. 2A^2 + sin(A)</code>。特别的，类似 <code>f.(g.(x))</code> 的嵌套 <code>dot</code> 调用也是<strong>融合</strong>的，并且“相邻的”二元运算符表达式 <code>x .+ 3 .* x.^2</code> 可以等价转换为嵌套 <code>dot</code> 调用：<code>(+).(x, (*).(3, (^).(x, 2)))</code>。</p><p>除了 <code>dot</code> 运算符，我们还有 <code>dot</code> 复合赋值运算符，类似 <code>a .+= b</code>（或者 <code>@. a += b</code>）会被解析成 <code>a .= a .+ b</code>，这里的 <code>.=</code> 是一个<strong>融合</strong>的 in-place 运算，更多信息请查看 <a href="../functions/#man-vectorized-1"><code>dot</code> 文档</a>）。</p><p>这个点语法，也能用在用户自定义的运算符上。例如，通过定义 <code>⊗(A,B) = kron(A,B)</code> 可以为 Kronecker 积（<a href="../../stdlib/LinearAlgebra/#Base.kron"><code>kron</code></a>）提供一个方便的中缀语法 <code>A ⊗ B</code>，那么配合点语法 <code>[A,B] .⊗ [C,D]</code> 就等价于 <code>[A⊗C, B⊗D]</code>。</p><p>将点运算符用于数值字面量可能会导致歧义。例如，<code>1.+x</code> 到底是表示 <code>1. + x</code> 还是 <code>1 .+ x</code>？这会令人疑惑。因此不允许使用这种语法，遇到这种情况时，必须明确地用空格消除歧义。</p><h2><a class="nav-anchor" id="数值比较-1" href="#数值比较-1">数值比较</a></h2><p>标准的比较操作对所有原始数值类型有定义：</p><table><tr><th style="text-align: left">操作符</th><th style="text-align: left">名称</th></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:=="><code>==</code></a></td><td style="text-align: left">相等</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:!="><code>!=</code></a>, <a href="../../base/math/#Base.:!="><code>≠</code></a></td><td style="text-align: left">不等</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:&lt;"><code>&lt;</code></a></td><td style="text-align: left">小于</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:&lt;="><code>&lt;=</code></a>, <a href="../../base/math/#Base.:&lt;="><code>≤</code></a></td><td style="text-align: left">小于等于</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:&gt;"><code>&gt;</code></a></td><td style="text-align: left">大于</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.:&gt;="><code>&gt;=</code></a>, <a href="../../base/math/#Base.:&gt;="><code>≥</code></a></td><td style="text-align: left">大于等于</td></tr></table><p>下面是一些简单的例子：</p><pre><code class="language-julia-repl">julia&gt; 1 == 1
true

julia&gt; 1 == 2
false

julia&gt; 1 != 2
true

julia&gt; 1 == 1.0
true

julia&gt; 1 &lt; 2
true

julia&gt; 1.0 &gt; 3
false

julia&gt; 1 &gt;= 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 &lt;= -1
true

julia&gt; -1 &lt;= -2
false

julia&gt; 3 &lt; -0.5
false</code></pre><p>整数的比较方式是标准的按位比较，而浮点数的比较方式则遵循 <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 标准</a>。</p><ul><li>有限数的大小顺序，和我们所熟知的相同。</li><li><code>+0</code> 等于但不大于 <code>-0</code>.</li><li><code>Inf</code> 等于自身，并且大于除了 <code>NaN</code> 外的所有数。</li><li><code>-Inf</code> 等于自身，并且小于除了 <code>NaN</code> 外的所有数。</li><li><code>NaN</code> 不等于、不小于且不大于任何数值，包括它自己。</li></ul><p><code>NaN</code> 不等于它自己这一点可能会令人感到惊奇，所以需要注意：</p><pre><code class="language-julia-repl">julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false</code></pre><p>由于 <code>NaN</code> 的存在，在做<a href="../arrays/#man-multi-dim-arrays-1">数组</a>比较时会特别头疼：</p><pre><code class="language-julia-repl">julia&gt; [1 NaN] == [1 NaN]
false</code></pre><p>为此，Julia 给这些特别的数提供了下面几个额外的测试函数。这些函数在某些情况下很有用处，比如在做 hash 比较时。</p><table><tr><th style="text-align: left">函数</th><th style="text-align: left">测试是否满足如下性质</th></tr><tr><td style="text-align: left"><a href="../../base/base/#Base.isequal"><code>isequal(x, y)</code></a></td><td style="text-align: left"><code>x</code> 与 <code>y</code> 是完全相同的</td></tr><tr><td style="text-align: left"><a href="../../base/numbers/#Base.isfinite"><code>isfinite(x)</code></a></td><td style="text-align: left"><code>x</code> 是有限大的数字</td></tr><tr><td style="text-align: left"><a href="../../base/numbers/#Base.isinf"><code>isinf(x)</code></a></td><td style="text-align: left"><code>x</code> 是（正/负）无穷大</td></tr><tr><td style="text-align: left"><a href="../../base/numbers/#Base.isnan"><code>isnan(x)</code></a></td><td style="text-align: left"><code>x</code> 是 <code>NaN</code></td></tr></table><p><a href="../../base/base/#Base.isequal"><code>isequal</code></a> 认为 <code>NaN</code> 之间是相等的：</p><pre><code class="language-julia-repl">julia&gt; isequal(NaN, NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN, NaN32)
true</code></pre><p><code>isequal</code> 也能用来区分带符号的零：</p><pre><code class="language-julia-repl">julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false</code></pre><p>有符号整数、无符号整数以及浮点数之间的混合类型比较是很棘手的。开发者费了很大精力来确保 Julia 在这个问题上做的是正确的。</p><p>对于其它类型，<code>isequal</code> 会默认调用 <a href="../../base/math/#Base.:=="><code>==</code></a>，所以如果你想给自己的类型定义相等，那么就只需要为 <a href="../../base/math/#Base.:=="><code>==</code></a> 增加一个方法。如果你想定义一个你自己的相等函数，你可能需要定义一个对应的 <a href="../../base/base/#Base.hash"><code>hash</code></a> 方法，用于确保 <code>isequal(x,y)</code> 隐含着 <code>hash(x) == hash(y)</code>。</p><h3><a class="nav-anchor" id="链式比较-1" href="#链式比较-1">链式比较</a></h3><p>与其他多数语言不同，就像 <a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators">notable exception of Python</a> 一样，Julia 允许链式比较：</p><pre><code class="language-julia-repl">julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true</code></pre><p>链式比较在写数值代码时特别方便，它使用 <code>&amp;&amp;</code> 运算符比较标量，数组则用 <a href="../../base/math/#Base.:&amp;"><code>&amp;</code></a> 进行按元素比较。比如，<code>0 .&lt; A .&lt; 1</code> 会得到一个 boolean 数组，如果 <code>A</code> 的元素都在 0 和 1 之间则数组元素就都是 true。</p><p>注意链式比较的执行顺序：</p><pre><code class="language-julia-repl">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; v(1) &lt; v(2) &lt;= v(3)
2
1
3
true

julia&gt; v(1) &gt; v(2) &lt;= v(3)
2
1
false</code></pre><p>中间的表达式只会计算一次，而如果写成 <code>v(1) &lt; v(2) &amp;&amp; v(2) &lt;= v(3)</code> 是计算了两次的。然而，链式比较中的顺序是不确定的。强烈建议不要在表达式中使用有副作用（比如 printing）的函数。如果的确需要，请使用短路运算符 <code>&amp;&amp;</code>（请参考<a href="../control-flow/#短路求值-1">短路求值</a>）。</p><h3><a class="nav-anchor" id="初等函数-1" href="#初等函数-1">初等函数</a></h3><p>Julia 提供了强大的数学函数和运算符集合。这些数学运算定义在各种合理的数值上，包括整型、浮点数、分数和复数，只要这些定义有数学意义就行。</p><p>而且，和其它 Julia 函数一样，这些函数也能通过 <a href="../functions/#man-vectorized-1">点语法</a> <code>f.(A)</code> 以“向量化”的方式作用于数组和其它集合上。 比如，<code>sin.(A)</code> 会计算 <code>A</code> 中每个元素的 sin 值。</p><h2><a class="nav-anchor" id="运算符的优先级与结合性-1" href="#运算符的优先级与结合性-1">运算符的优先级与结合性</a></h2><p>从高到低，Julia 运算符的优先级与结合性为：</p><table><tr><th style="text-align: left">分类</th><th style="text-align: left">运算符</th><th style="text-align: left">结合性</th></tr><tr><td style="text-align: left">语法</td><td style="text-align: left"><code>.</code> followed by <code>::</code></td><td style="text-align: left">左结合</td></tr><tr><td style="text-align: left">幂运算</td><td style="text-align: left"><code>^</code></td><td style="text-align: left">右结合</td></tr><tr><td style="text-align: left">一元运算符</td><td style="text-align: left"><code>+ - √</code></td><td style="text-align: left">右结合<a href="#footnote-1">[1]</a></td></tr><tr><td style="text-align: left">移位运算</td><td style="text-align: left"><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td><td style="text-align: left">左结合</td></tr><tr><td style="text-align: left">除法</td><td style="text-align: left"><code>//</code></td><td style="text-align: left">左结合</td></tr><tr><td style="text-align: left">乘法</td><td style="text-align: left"><code>* / % &amp; \ ÷</code></td><td style="text-align: left">左结合<a href="#footnote-2">[2]</a></td></tr><tr><td style="text-align: left">加法</td><td style="text-align: left"><code>+ - | ⊻</code></td><td style="text-align: left">左结合<a href="#footnote-2">[2]</a></td></tr><tr><td style="text-align: left">语法</td><td style="text-align: left"><code>: ..</code></td><td style="text-align: left">左结合</td></tr><tr><td style="text-align: left">语法</td><td style="text-align: left"><code>|&gt;</code></td><td style="text-align: left">左结合</td></tr><tr><td style="text-align: left">语法</td><td style="text-align: left"><code>&lt;|</code></td><td style="text-align: left">右结合</td></tr><tr><td style="text-align: left">比较</td><td style="text-align: left"><code>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</code></td><td style="text-align: left">无结合性</td></tr><tr><td style="text-align: left">流程控制</td><td style="text-align: left"><code>&amp;&amp;</code> followed by <code>||</code> followed by <code>?</code></td><td style="text-align: left">右结合</td></tr><tr><td style="text-align: left">Pair 操作</td><td style="text-align: left"><code>=&gt;</code></td><td style="text-align: left">右结合</td></tr><tr><td style="text-align: left">赋值</td><td style="text-align: left"><code>= += -= *= /= //= \= ^= ÷= %= |= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code></td><td style="text-align: left">右结合</td></tr></table><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>一元运算符 <code>+</code> 和 <code>-</code> 需要显式调用，即给它们的参数加上括号，以免和 <code>++</code> 等运算符混淆。其它一元运算符的混合使用都被解析为右结合的，比如 <code>√√-a</code> 解析为 <code>√(√(-a))</code>。</p></div><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p>The operators <code>+</code>, <code>++</code> and <code>*</code> are non-associative. <code>a + b + c</code> is parsed as <code>+(a, b, c)</code> not <code>+(+(a, b), c)</code>. However, the fallback methods for <code>+(a, b, c, d...)</code> and <code>*(a, b, c, d...)</code> both default to left-associative evaluation.</p></div><p>要看<strong>全部</strong> Julia 运算符的优先级关系，可以看这个文件的最上面部分：<a href="https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm"><code>src/julia-parser.scm</code></a></p><p>你也可以通过内置函数 <code>Base.operator_precedence</code> 查看任何给定运算符的优先级数值，数值越大优先级越高：</p><pre><code class="language-julia-repl">julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 13, 17)

julia&gt; Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  #（请注意 `:(=)` 中的括号是必要的）
(0, 1, 1)</code></pre><p>另外，内置函数 <code>Base.operator_associativity</code> 可以返回运算符结合性的符号表示：</p><pre><code class="language-julia-repl">julia&gt; Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia&gt; Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)</code></pre><p>注意诸如 <code>:sin</code> 这样的符号返回优先级 <code>0</code>，此值代表无效的运算符或非最低优先级运算符。类似地，它们的结合性被认为是 <code>:none</code>。</p><h2><a class="nav-anchor" id="数值转换-1" href="#数值转换-1">数值转换</a></h2><p>Julia 支持三种数值转换，它们在处理不精确转换上有所不同。</p><ul><li><p><code>T(x)</code> 和 <code>convert(T,x)</code> 都会把 <code>x</code> 转换为 <code>T</code>类型。</p><ul><li>如果 <code>T</code> 是浮点类型，转换的结果就是最近的可表示值， 可能会是正负无穷大。</li><li>如果 <code>T</code> 为整数类型，当 <code>x</code> 不为 <code>T</code> 类型时，会触发 <code>InexactError</code></li></ul></li><li><p><code>x % T</code> 将整数 <code>x</code> 转换为整型 <code>T</code>，与 <code>x</code> 模 <code>2^n</code> 的结果一致，其中 <code>n</code> 是 <code>T</code> 的位数。换句话说，如果用二进制表示是被砍掉一部分的。</p></li><li><p><a href="#舍入函数-1">舍入函数</a> 接收一个 <code>T</code> 类型的可选参数。比如，<code>round(Int,x)</code> 是 <code>Int(round(x))</code> 的简写版。</p></li></ul><p>下面的例子展示了不同的形式</p><pre><code class="language-julia-repl">julia&gt; Int8(127)
127

julia&gt; Int8(128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]

julia&gt; Int8(127.0)
127

julia&gt; Int8(3.14)
ERROR: InexactError: Int8(3.14)
Stacktrace:
[...]

julia&gt; Int8(128.0)
ERROR: InexactError: Int8(128.0)
Stacktrace:
[...]

julia&gt; 127 % Int8
127

julia&gt; 128 % Int8
-128

julia&gt; round(Int8,127.4)
127

julia&gt; round(Int8,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]</code></pre><p>请参考<a href="../conversion-and-promotion/#conversion-and-promotion-1">类型转换与类型提升</a>一节来定义你自己的类型转换和提升规则。</p><h3><a class="nav-anchor" id="舍入函数-1" href="#舍入函数-1">舍入函数</a></h3><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th><th style="text-align: left">返回类型</th></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.round-Tuple{Type,Any}"><code>round(x)</code></a></td><td style="text-align: left"><code>x</code> 舍到最接近的整数</td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.round-Tuple{Type,Any}"><code>round(T, x)</code></a></td><td style="text-align: left"><code>x</code> 舍到最接近的整数</td><td style="text-align: left"><code>T</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.floor"><code>floor(x)</code></a></td><td style="text-align: left"><code>x</code> 舍到<code>-Inf</code></td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.floor"><code>floor(T, x)</code></a></td><td style="text-align: left"><code>x</code> 舍到<code>-Inf</code></td><td style="text-align: left"><code>T</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.ceil"><code>ceil(x)</code></a></td><td style="text-align: left"><code>x</code> 向 <code>+Inf</code> 方向取整</td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.ceil"><code>ceil(T, x)</code></a></td><td style="text-align: left"><code>x</code> 向 <code>+Inf</code> 方向取整</td><td style="text-align: left"><code>T</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.trunc"><code>trunc(x)</code></a></td><td style="text-align: left"><code>x</code> 向 0 取整</td><td style="text-align: left"><code>typeof(x)</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.trunc"><code>trunc(T, x)</code></a></td><td style="text-align: left"><code>x</code> 向 0 取整</td><td style="text-align: left"><code>T</code></td></tr></table><h3><a class="nav-anchor" id="除法函数-1" href="#除法函数-1">除法函数</a></h3><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.div"><code>div(x,y)</code></a>, <code>x÷y</code></td><td style="text-align: left">截断除法；商向零近似</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.fld"><code>fld(x,y)</code></a></td><td style="text-align: left">向下取整除法；商向 <code>-Inf</code> 近似</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.cld"><code>cld(x,y)</code></a></td><td style="text-align: left">向上取整除法；商向 <code>+Inf</code> 近似</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.rem"><code>rem(x,y)</code></a></td><td style="text-align: left">取余；满足 <code>x == div(x,y)*y + rem(x,y)</code>；符号与 <code>x</code> 一致</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.mod"><code>mod(x,y)</code></a></td><td style="text-align: left">取模；满足 <code>x == fld(x,y)*y + mod(x,y)</code>；符号与 <code>y</code> 一致</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.mod1"><code>mod1(x,y)</code></a></td><td style="text-align: left">偏移 1 的 <code>mod</code>；若 <code>y&gt;0</code>，则返回 <code>r∈(0,y]</code>，若 <code>y&lt;0</code>，则 <code>r∈[y,0)</code> 且满足 <code>mod(r, y) == mod(x, y)</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.Math.mod2pi"><code>mod2pi(x)</code></a></td><td style="text-align: left">以 2pi 为基取模；<code>0 &lt;= mod2pi(x) &lt; 2pi</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.divrem"><code>divrem(x,y)</code></a></td><td style="text-align: left">返回 <code>(div(x,y),rem(x,y))</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.fldmod"><code>fldmod(x,y)</code></a></td><td style="text-align: left">返回 <code>(fld(x,y),mod(x,y))</code></td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.gcd"><code>gcd(x,y...)</code></a></td><td style="text-align: left"><code>x</code>, <code>y</code>,... 的最大公约数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.lcm"><code>lcm(x,y...)</code></a></td><td style="text-align: left"><code>x</code>, <code>y</code>,... 的最小公倍数</td></tr></table><h3><a class="nav-anchor" id="符号和绝对值函数-1" href="#符号和绝对值函数-1">符号和绝对值函数</a></h3><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.abs"><code>abs(x)</code></a></td><td style="text-align: left"><code>x</code> 的模</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.abs2"><code>abs2(x)</code></a></td><td style="text-align: left"><code>x</code> 的模的平方</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.sign"><code>sign(x)</code></a></td><td style="text-align: left">表示 <code>x</code> 的符号，返回 -1，0，或 +1</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.signbit"><code>signbit(x)</code></a></td><td style="text-align: left">表示符号位是 true 或 false</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.copysign"><code>copysign(x,y)</code></a></td><td style="text-align: left">返回一个数，其值等于 <code>x</code> 的模，符号与 <code>y</code> 一致</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.flipsign"><code>flipsign(x,y)</code></a></td><td style="text-align: left">返回一个数，其值等于 <code>x</code> 的模，符号与 <code>x*y</code> 一致</td></tr></table><h3><a class="nav-anchor" id="幂、对数与平方根-1" href="#幂、对数与平方根-1">幂、对数与平方根</a></h3><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.sqrt-Tuple{Real}"><code>sqrt(x)</code></a>, <code>√x</code></td><td style="text-align: left"><code>x</code> 的平方根</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.Math.cbrt"><code>cbrt(x)</code></a>, <code>∛x</code></td><td style="text-align: left"><code>x</code> 的立方根</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.Math.hypot"><code>hypot(x,y)</code></a></td><td style="text-align: left">当直角边的长度为 <code>x</code> 和 <code>y</code>时，直角三角形斜边的长度</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.exp-Tuple{Float64}"><code>exp(x)</code></a></td><td style="text-align: left">自然指数函数在 <code>x</code> 处的值</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.expm1"><code>expm1(x)</code></a></td><td style="text-align: left">当 <code>x</code> 接近 0 时的 <code>exp(x)-1</code> 的精确值</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.Math.ldexp"><code>ldexp(x,n)</code></a></td><td style="text-align: left"><code>x*2^n</code> 的高效算法，<code>n</code> 为整数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.log-Tuple{Number}"><code>log(x)</code></a></td><td style="text-align: left"><code>x</code> 的自然对数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.log-Tuple{Number}"><code>log(b,x)</code></a></td><td style="text-align: left">以 <code>b</code> 为底 <code>x</code> 的对数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.log2"><code>log2(x)</code></a></td><td style="text-align: left">以 2 为底 <code>x</code> 的对数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.log10"><code>log10(x)</code></a></td><td style="text-align: left">以 10 为底 <code>x</code> 的对数</td></tr><tr><td style="text-align: left"><a href="../../base/math/#Base.log1p"><code>log1p(x)</code></a></td><td style="text-align: left">当 <code>x</code>接近 0 时的 <code>log(1+x)</code> 的精确值</td></tr><tr><td style="text-align: left"><a href="../../base/numbers/#Base.Math.exponent"><code>exponent(x)</code></a></td><td style="text-align: left"><code>x</code> 的二进制指数</td></tr><tr><td style="text-align: left"><a href="../../base/numbers/#Base.Math.significand"><code>significand(x)</code></a></td><td style="text-align: left">浮点数 <code>x</code> 的二进制有效数（也就是尾数）</td></tr></table><p>想大概了解一下为什么诸如 <a href="../../base/math/#Base.Math.hypot"><code>hypot</code></a>、<a href="../../base/math/#Base.expm1"><code>expm1</code></a>和 <a href="../../base/math/#Base.log1p"><code>log1p</code></a> 函数是必要和有用的，可以看一下 John D. Cook 关于这些主题的两篇优秀博文：<a href="https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/">expm1, log1p, erfc</a>， 和 <a href="https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/">hypot</a>。</p><h3><a class="nav-anchor" id="三角和双曲函数-1" href="#三角和双曲函数-1">三角和双曲函数</a></h3><p>所有标准的三角函数和双曲函数也都已经定义了：</p><pre><code class="language-none">sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc</code></pre><p>所有这些函数都是单参数函数，不过 <a href="../../base/math/#Base.atan-Tuple{Number}"><code>atan</code></a> 也可以接收两个参数 来表示传统的 <a href="https://en.wikipedia.org/wiki/Atan2"><code>atan2</code></a> 函数。</p><p>另外，<a href="../../base/math/#Base.Math.sinpi"><code>sinpi(x)</code></a> 和 <a href="../../base/math/#Base.Math.cospi"><code>cospi(x)</code></a> 分别用来对 <a href="../../base/math/#Base.sin-Tuple{Number}"><code>sin(pi*x)</code></a> 和 <a href="../../base/math/#Base.cos-Tuple{Number}"><code>cos(pi*x)</code></a> 进行更精确的计算。</p><p>要计算角度而非弧度的三角函数，以 <code>d</code> 做后缀。 比如，<a href="../../base/math/#Base.Math.sind"><code>sind(x)</code></a> 计算 <code>x</code> 的 sine 值，其中 <code>x</code> 是一个角度值。 下面是角度变量的三角函数完整列表：</p><pre><code class="language-none">sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd</code></pre><h3><a class="nav-anchor" id="特殊函数-1" href="#特殊函数-1">特殊函数</a></h3><p><a href="https://github.com/JuliaMath/SpecialFunctions.jl">SpecialFunctions.jl</a> 提供了许多其他的特殊数学函数。</p><footer><hr/><a class="previous" href="../integers-and-floating-point-numbers/"><span class="direction">上一篇</span><span class="title">整数和浮点数</span></a><a class="next" href="../complex-and-rational-numbers/"><span class="direction">下一篇</span><span class="title">复数和有理数</span></a></footer></article></body></html>
