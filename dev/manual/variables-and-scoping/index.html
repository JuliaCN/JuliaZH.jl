<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>变量作用域 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/variables-and-scoping/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li class="current"><a class="toctext" href>变量作用域</a><ul class="internal"><li><a class="toctext" href="#全局作用域-1">全局作用域</a></li><li><a class="toctext" href="#局部作用域-1">局部作用域</a></li><li><a class="toctext" href="#常量-1">常量</a></li></ul></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">接口</a></li><li><a class="toctext" href="../modules/">模块</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">元编程</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li><a class="toctext" href="../embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">性能分析</a></li><li><a class="toctext" href="../stacktraces/">栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li><a class="toctext" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">基本功能</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学相关</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">数组</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O 与网络</a></li><li><a class="toctext" href="../../base/punctuation/">运算符与记号</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">迭代相关</a></li><li><a class="toctext" href="../../base/c/">C 接口</a></li><li><a class="toctext" href="../../base/libc/">C 标准库</a></li><li><a class="toctext" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="toctext" href="../../stdlib/Distributed/">分布式计算</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">交互式组件</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="toctext" href="../../stdlib/Logging/">日志记录</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">性能分析</a></li><li><a class="toctext" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">随机数</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">序列化</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="toctext" href="../../stdlib/Sockets/">套接字</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="toctext" href="../../stdlib/Statistics/">统计</a></li><li><a class="toctext" href="../../stdlib/Test/">单元测试</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="toctext" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">子数组</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>变量作用域</a></li></ul><a class="edit-page" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/variables-and-scopingmd"><span class="fa"></span> 完善 Transifex 上的翻译</a></nav><hr/><div id="topbar"><span>变量作用域</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="scope-of-variables-1" href="#scope-of-variables-1">变量作用域</a></h1><p>变量的<em>作用域</em>是代码的一个区域，在这个区域中这个变量是可见的。给变量划分作用域有助于解决变量命名冲突。这个概念是符合直觉的：两个函数可能同时都有叫做 <code>x</code> 的参量，而这两个 <code>x</code> 并不指向同一个东西。相似地，也有很多其他的情况下代码的不同块会使用同样名字而并不指向同一个东西。相同的变量名是否指向同一个东西的规则被称为作用域规则；这一届会详细地把这个规则讲清楚。</p><p>语言中的某些结构会引入<em>作用域块</em>，这是有资格成为一些变量集合的作用域的代码区域。一个变量的作用域不可能是源代码行的任意集合；相反，它始终与这些块之一关系密切。在 Julia 中主要有两种作用域，<em>全局作用域</em>与<em>局部作用域</em>，后者可以嵌套。引入作用域块的结构有：</p><h3><a class="nav-anchor" id="man-scope-table-1" href="#man-scope-table-1">作用域结构</a></h3><table><tr><th style="text-align: right">结构</th><th style="text-align: right">作用域类型</th><th style="text-align: right">可嵌入的作用域块</th></tr><tr><td style="text-align: right"><a href="../../base/base/#module"><code>module</code></a>, <a href="../../base/base/#baremodule"><code>baremodule</code></a></td><td style="text-align: right">全局</td><td style="text-align: right">全局</td></tr><tr><td style="text-align: right">交互式提示符（REPL）</td><td style="text-align: right">全局</td><td style="text-align: right">全局</td></tr><tr><td style="text-align: right">(mutable) <a href="../../base/base/#struct"><code>struct</code></a>, <a href="../../base/base/#macro"><code>macro</code></a></td><td style="text-align: right">局部</td><td style="text-align: right">全局</td></tr><tr><td style="text-align: right"><a href="../../base/base/#for"><code>for</code></a>, <a href="../../base/base/#while"><code>while</code></a>, <a href="../../base/base/#try"><code>try-catch-finally</code></a>, <a href="../../base/base/#let"><code>let</code></a></td><td style="text-align: right">局部</td><td style="text-align: right">全局或局部</td></tr><tr><td style="text-align: right">函数（语法，匿名或者do语法块）</td><td style="text-align: right">局部</td><td style="text-align: right">全局或局部</td></tr><tr><td style="text-align: right">推导式，broadcast-fusing</td><td style="text-align: right">局部</td><td style="text-align: right">全局或局部</td></tr></table><p>值得注意的是，这个表内没有的是<a href="manual/@ref man-compound-experessions"> begin 块</a>和<a href="../control-flow/#man-conditional-evaluation-1"> if 块</a>，这两个块<em>不会</em>引进新的作用域块。这两种作用域遵循的规则有点不一样，会在下面解释。</p><p>Julia使用<a href="https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping">词法作用域</a>，也就是说一个函数的作用域不会从其调用者的作用域继承，而从函数定义处的作用域继承。举个例子，在下列的代码中<code>foo</code>中的<code>x</code>指向的是模块<code>Bar</code>的全局作用域中的<code>x</code>。</p><pre><code class="language-julia-repl">julia&gt; module Bar
           x = 1
           foo() = x
       end;</code></pre><p>并且在<code>foo</code>被使用的地方<code>x</code>并不在作用域中：</p><pre><code class="language-julia-repl">julia&gt; import .Bar

julia&gt; x = -1;

julia&gt; Bar.foo()
1</code></pre><p>所以<em>词法作用域</em>表明变量作用域只能通过源码推断。</p><h2><a class="nav-anchor" id="全局作用域-1" href="#全局作用域-1">全局作用域</a></h2><p>每个模块会引进一个新的全局作用域，与其他所有模块的全局作用域分开；无所不包的全局作用域不存在。模块可以把其他模块的变量引入到它的作用域中，通过<a href="../modules/#modules-1">using 或者 import</a>语句或者通过点符号这种有资格的通路，也就是说每个模块都是所谓的<em>命名空间</em>。值得注意的是变量绑定只能在它们的全局作用域中改变，在外部模块中不行。</p><pre><code class="language-julia-repl">julia&gt; module A
           a = 1 # a global in A&#39;s scope
       end;

julia&gt; module B
           module C
               c = 2
           end
           b = C.c    # can access the namespace of a nested global scope
                      # through a qualified access
           import ..A # makes module A available
           d = A.a
       end;

julia&gt; module D
           b = a # errors as D&#39;s global scope is separate from A&#39;s
       end;
ERROR: UndefVarError: a not defined

julia&gt; module E
           import ..A # make module A available
           A.a = 2    # throws below error
       end;
ERROR: cannot assign variables in other modules</code></pre><p>注意交互式提示行（即REPL）是在模块<code>Main</code>的全局作用域中。</p><h2><a class="nav-anchor" id="局部作用域-1" href="#局部作用域-1">局部作用域</a></h2><p>大多数代码块都会引进一个新的局部作用域（参见上面的<a href="#man-scope-table-1">表</a>以获取完整列表）。局部作用域会从父作用域中继承所有的变量，读和写都一样。另外，局部作用域还会继承在其父全局作用域块中赋值的所有全局变量（如果由全局 <code>if</code> 或者 <code>begin</code> 作用域包围）。与全局作用域不同，局部作用域并不是命名空间，所以在其内部作用域中的变量无法通过一些合格的通路在其父作用域中得到。</p><p>接下来的规则和例子都适用于局部作用域。 在局部作用域中新引进的变量不会反向传播到其父作用域。 例如，这里<span>$z$</span>并没有引入到顶层作用域：</p><pre><code class="language-julia-repl">julia&gt; for i = 1:10
           z = i
       end

julia&gt; z
ERROR: UndefVarError: z not defined</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>在这个和以下所有的例子中都假设了它们的顶层作用域是一个工作空间是空的全局作用域，比如一个新打开的REPL。</p></div></div><p>在局部作用域中可以使用 <a href="../../base/base/#local"><code>local</code></a> 关键字来使一个变量强制为新的局部变量。</p><pre><code class="language-julia-repl">julia&gt; x = 0;

julia&gt; for i = 1:10
           local x # this is also the default
           x = i + 1
       end

julia&gt; x
0</code></pre><p>在局部作用域内部，可以使用 <a href="../../base/base/#global"><code>global</code></a> 关键字来给全局变量赋值：</p><pre><code class="language-julia-repl">julia&gt; for i = 1:10
           global z
           z = i
       end

julia&gt; z
10</code></pre><p>在作用域块中<code>local</code>和<code>global</code>关键字的位置都无关痛痒。下面的例子与上面最后的一个例子是等价的（虽然在文体上更差）:</p><pre><code class="language-julia-repl">julia&gt; for i = 1:10
           z = i
           global z
       end

julia&gt; z
10</code></pre><p><code>local</code>和<code>global</code>关键字都可以用于解构赋值，也就是说<code>local x, y = 1, 2</code>。在这个例子中关键字影响所有的列出来的变量。</p><p>大多数块关键字都会引入局部作用域，而<code>begin</code>和<code>if</code>是例外。</p><p>在一个局部作用域中，所有的变量都会从其父作用域块中继承，除非：</p><ul><li>赋值会导致<em>全局</em>变量改变，或者</li><li>变量专门使用<code>local</code>关键字标记。</li></ul><p>所以全局变量只能通过读来继承，不能通过写来继承。</p><pre><code class="language-julia-repl">julia&gt; x, y = 1, 2;

julia&gt; function foo()
           x = 2        # assignment introduces a new local
           return x + y # y refers to the global
       end;

julia&gt; foo()
4

julia&gt; x
1</code></pre><p>为一个全局变量赋值需要显式的<code>global</code>：</p><div class="admonition sidebar"><div class="admonition-title">避免使用全局变量</div><div class="admonition-text"><p>为了使得编出来的程序是最好的，很多人都考虑了避免改变全局变量的值。一个原因是远程改变其他模块中的全局变量的状态会导致程序的局部行为变得难以琢磨，应该小心行事。这也是为什么引入局部作用域的作用域块需要 <code>global</code> 关键字来声明其改变一个全局变量的意图。</p></div></div><pre><code class="language-julia-repl">julia&gt; x = 1;

julia&gt; function foobar()
           global x = 2
       end;

julia&gt; foobar();

julia&gt; x
2</code></pre><p>注意<em>嵌套函数</em>会改变其父作用域的<em>局部</em>变量：</p><pre><code class="language-julia-repl">julia&gt; x, y = 1, 2;

julia&gt; function baz()
           x = 2 # introduces a new local
           function bar()
               x = 10       # modifies the parent&#39;s x
               return x + y # y is global
           end
           return bar() + x # 12 + 10 (x is modified in call of bar())
       end;

julia&gt; baz()
22

julia&gt; x, y # verify that global x and y are unchanged
(1, 2)</code></pre><p>允许嵌套函数<em>修改</em>其父作用域的<em>局部</em>变量的原因是允许构建<a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29">闭包</a>，闭包中有一个私有的态，例如下面例子中的 <code>state</code> 变量：</p><pre><code class="language-julia-repl">julia&gt; let state = 0
           global counter() = (state += 1)
       end;

julia&gt; counter()
1

julia&gt; counter()
2</code></pre><p>也可以参见接下来两节例子中的闭包。内部函数从包含它的作用域中继承的变量有时被称为<em>被捕获</em>变量，比如在第一个例子中的 <code>x</code> 与在第二个例子中的 <code>state</code>。被捕获变量可能带来性能挑战，这会在<a href="../performance-tips/#man-performance-tips-1">性能建议</a>中讨论。</p><p>继承全局作用域与嵌套局部作用域的区别可能导致在局部或者全局作用域中定义的函数在变量赋值上有稍许区别。考虑一下上面最后一个例子的一个变化，把 <code>bar</code> 移动到全局作用域中：</p><pre><code class="language-julia-repl">julia&gt; x, y = 1, 2;

julia&gt; function bar()
           x = 10 # local, no longer a closure variable
           return x + y
       end;

julia&gt; function quz()
           x = 2 # local
           return bar() + x # 12 + 2 (x is not modified)
       end;

julia&gt; quz()
14

julia&gt; x, y # verify that global x and y are unchanged
(1, 2)</code></pre><p>注意到在上面的嵌套规则并不适用于类型和宏定义因为他们只能出现在全局作用域中。涉及到<a href="../functions/#man-functions-1">函数</a>中提到的默认和关键字函数参数的评估的话会有特别的作用域规则。</p><p>在函数，类型或者宏定义内部使用的变量，将其引入到作用域中的赋值行为不必在其内部使用之前进行：</p><pre><code class="language-julia-repl">julia&gt; f = y -&gt; y + a;

julia&gt; f(3)
ERROR: UndefVarError: a not defined
Stacktrace:
[...]

julia&gt; a = 1
1

julia&gt; f(3)
4</code></pre><p>这个行为看起来对于普通变量来说有点奇怪，但是这个允许命名过的函数 – 它只是连接了函数对象的普通变量 – 在定义之前就能被使用。这就允许函数能以符合直觉和方便的顺序定义，而非强制以颠倒顺序或者需要前置声明，只要在实际调用之前被定义就行。举个例子，这里有个不高效的，相互递归的方法去检验正整数是奇数还是偶数的方法：</p><pre><code class="language-julia-repl">julia&gt; even(n) = (n == 0) ? true : odd(n - 1);

julia&gt; odd(n) = (n == 0) ? false : even(n - 1);

julia&gt; even(3)
false

julia&gt; odd(3)
true</code></pre><p>Julia提供了叫做<a href="../../base/numbers/#Base.iseven"><code>iseven</code></a>和<a href="../../base/numbers/#Base.isodd"><code>isodd</code></a>的内置的高效的奇偶性检验的函数，所以之上的定义只能被认为是作用域的一个例子，而非高效的设计。</p><h3><a class="nav-anchor" id="let块-1" href="#let块-1">let块</a></h3><p>不像局部变量的赋值行为，<code>let</code>语句每次运行都新建一个新的变量绑定。赋值改变的是已存在值的位置，<code>let</code>会新建新的位置。这个区别通常都不重要，只会在通过闭包跳出作用域的变量的情况下能探测到。<code>let</code>语法接受由逗号隔开的一系列的赋值和变量名：</p><pre><code class="language-julia-repl">julia&gt; x, y, z = -1, -1, -1;

julia&gt; let x = 1, z
           println(&quot;x: $x, y: $y&quot;) # x is local variable, y the global
           println(&quot;z: $z&quot;) # errors as z has not been assigned yet but is local
       end
x: 1, y: -1
ERROR: UndefVarError: z not defined</code></pre><p>这个赋值会按顺序评估，在左边的新变量被引入之前右边的每隔两都会在作用域中被评估。所以编写像<code>let x = x</code>这样的东西是有意义的，因为两个<code>x</code>变量是不一样的，拥有不同的存储位置。这里有个例子，在例子中<code>let</code>的行为是必须的：</p><pre><code class="language-julia-repl">julia&gt; Fs = Vector{Any}(undef, 2); i = 1;

julia&gt; while i &lt;= 2
           Fs[i] = ()-&gt;i
           global i += 1
       end

julia&gt; Fs[1]()
3

julia&gt; Fs[2]()
3</code></pre><p>这里我创建并存储了两个返回变量<code>i</code>的闭包。但是这两个始终是同一个变量<code>i</code>。所以这两个闭包行为是相同的。我们可以使用<code>let</code>来为<code>i</code>创建新的绑定：</p><pre><code class="language-julia-repl">julia&gt; Fs = Vector{Any}(undef, 2); i = 1;

julia&gt; while i &lt;= 2
           let i = i
               Fs[i] = ()-&gt;i
           end
           global i += 1
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</code></pre><p>因为 <code>begin</code> 结构不会引入新的作用域，使用没有参数的 <code>let</code> 来只引进一个新的作用域块而不创建新的绑定可能是有用的：</p><pre><code class="language-julia-repl">julia&gt; let
           local x = 1
           let
               local x = 2
           end
           x
       end
1</code></pre><p>因为<code>let</code>引进了一个新的作用域块，内部的局部<code>x</code>与外部的局部<code>x</code>是不同的变量。</p><h3><a class="nav-anchor" id="对于循环和推导式-1" href="#对于循环和推导式-1">对于循环和推导式</a></h3><p><code>for</code> 循环，<code>while</code> 循环，和<a href="../arrays/#数组推导-1">数组推导</a>拥有下述的行为：任何在它们的内部的作用域中引入的新变量在每次循环迭代中都会被新分配一块内存，就像循环体是被 <code>let</code> 块包围一样。</p><pre><code class="language-julia-repl">julia&gt; Fs = Vector{Any}(undef, 2);

julia&gt; for j = 1:2
           Fs[j] = ()-&gt;j
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</code></pre><p><code>for</code>循环或者推导式的迭代变量始终是个新的变量：</p><pre><code class="language-julia-repl">julia&gt; function f()
 i = 0
 for i = 1:3
 end
 return i
 end;

julia&gt; f()
0</code></pre><p>但是，有时重复使用一个存在的局部变量作为迭代变量是有用的。这能够通过添加关键字 <code>outer</code> 来方便地做到：</p><pre><code class="language-julia-repl">julia&gt; function f()
           i = 0
           for outer i = 1:3
           end
           return i
       end;

julia&gt; f()
3</code></pre><h2><a class="nav-anchor" id="常量-1" href="#常量-1">常量</a></h2><p>变量的经常的一个使用方式是给一个特定的不变的值一个名字。这样的变量只会被赋值一次。这个想法可以通过使用 <a href="../../base/base/#const"><code>const</code></a> 关键字传递给编译器：</p><pre><code class="language-julia-repl">julia&gt; const e  = 2.71828182845904523536;

julia&gt; const pi = 3.14159265358979323846;</code></pre><p>多个变量可以使用单个<code>const</code>语句进行声明：</p><pre><code class="language-julia-repl">julia&gt; const a, b = 1, 2
(1, 2)</code></pre><p><code>const</code>声明只应该在全局作用域中对全局变量使用。编译器很难为包含全局变量的代码优化，因为它们的值（甚至它们的类型）可以任何时候改变。如果一个全局变量不会改变，添加<code>const</code>声明会解决这个问题。</p><p>局部常量却大有不同。编译器能够自动确定一个局部变量什么时候是不变的，所以局部常量声明是不必要的，其实现在也并不支持。</p><p>特别的顶层赋值，比如使用<code>function</code>和<code>structure</code>关键字进行的，默认是不变的。</p><p>注意 <code>const</code> 只会影响变量绑定；变量可能会绑定到一个可变的对象上（比如一个数组）使得其仍然能被改变。另外当尝试给一个声明为常量的变量赋值时下列情景是可能的：</p><ul><li>如果一个新值的类型与常量类型不一样时会扔出一个错误：</li></ul><pre><code class="language-julia-repl">julia&gt; const x = 1.0
1.0

julia&gt; x = 1
ERROR: invalid redefinition of constant x</code></pre><ul><li>如果一个新值的类型与常量一样会打印一个警告：</li></ul><pre><code class="language-julia-repl">julia&gt; const y = 1.0
1.0

julia&gt; y = 2.0
WARNING: redefining constant y
2.0</code></pre><ul><li>如果赋值不会导致变量值的变化，不会给出任何信息：</li></ul><pre><code class="language-julia-repl">julia&gt; const z = 100
100

julia&gt; z = 100
100</code></pre><p>最后一条规则适用于不可变对象，即使变量绑定会改变，例如：</p><pre><code class="language-julia-repl">julia&gt; const s1 = &quot;1&quot;
&quot;1&quot;

julia&gt; s2 = &quot;1&quot;
&quot;1&quot;

julia&gt; pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x00000000132c9638
 Ptr{UInt8} @0x0000000013dd3d18

julia&gt; s1 = s2
&quot;1&quot;

julia&gt; pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x0000000013dd3d18
 Ptr{UInt8} @0x0000000013dd3d18</code></pre><p>但是对于可变对象，警告会如预期出现：</p><pre><code class="language-julia-repl">julia&gt; const a = [1]
1-element Array{Int64,1}:
 1

julia&gt; a = [1]
WARNING: redefining constant a
1-element Array{Int64,1}:
 1</code></pre><p>注意，改变一个声明为常量的变量的值虽然有时是可能的，但是十分不推荐这样做，并且在交互式使用中这样做仅仅是为了更加方便。举个例子，如果一个方法引用了一个常量并且在常量被改变之前已经被编译了，那么这个变量还是会保留使用原来的值：</p><pre><code class="language-julia-repl">julia&gt; const x = 1
1

julia&gt; f() = x
f (generic function with 1 method)

julia&gt; f()
1

julia&gt; x = 2
WARNING: redefining constant x
2

julia&gt; f()
1</code></pre><footer><hr/><a class="previous" href="../control-flow/"><span class="direction">上一篇</span><span class="title">流程控制</span></a><a class="next" href="../types/"><span class="direction">下一篇</span><span class="title">类型</span></a></footer></article></body></html>
