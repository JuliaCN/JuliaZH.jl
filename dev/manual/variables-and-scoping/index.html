<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>å˜é‡ä½œç”¨åŸŸ Â· Juliaä¸­æ–‡æ–‡æ¡£</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/variables-and-scoping/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Juliaä¸­æ–‡æ–‡æ¡£ logo"/></a><div class="docs-package-name"><span class="docs-autofit">Juliaä¸­æ–‡æ–‡æ¡£</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">ä¸»é¡µ</a></li><li><span class="tocitem">æ‰‹å†Œ</span><ul><li><a class="tocitem" href="../getting-started/">å…¥é—¨</a></li><li><a class="tocitem" href="../variables/">å˜é‡</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">æ•´æ•°å’Œæµ®ç‚¹æ•°</a></li><li><a class="tocitem" href="../mathematical-operations/">æ•°å­¦è¿ç®—å’Œåˆç­‰å‡½æ•°</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">å¤æ•°å’Œæœ‰ç†æ•°</a></li><li><a class="tocitem" href="../strings/">å­—ç¬¦ä¸²</a></li><li><a class="tocitem" href="../functions/">å‡½æ•°</a></li><li><a class="tocitem" href="../control-flow/">æµç¨‹æ§åˆ¶</a></li><li class="is-active"><a class="tocitem" href>å˜é‡ä½œç”¨åŸŸ</a><ul class="internal"><li><a class="tocitem" href="#å…¨å±€ä½œç”¨åŸŸ"><span>å…¨å±€ä½œç”¨åŸŸ</span></a></li><li><a class="tocitem" href="#å±€éƒ¨ä½œç”¨åŸŸ"><span>å±€éƒ¨ä½œç”¨åŸŸ</span></a></li><li><a class="tocitem" href="#å¸¸é‡"><span>å¸¸é‡</span></a></li></ul></li><li><a class="tocitem" href="../types/">ç±»å‹</a></li><li><a class="tocitem" href="../methods/">æ–¹æ³•</a></li><li><a class="tocitem" href="../constructors/">æ„é€ å‡½æ•°</a></li><li><a class="tocitem" href="../conversion-and-promotion/">ç±»å‹è½¬æ¢å’Œç±»å‹æå‡</a></li><li><a class="tocitem" href="../interfaces/">æ¥å£</a></li><li><a class="tocitem" href="../modules/">æ¨¡å—</a></li><li><a class="tocitem" href="../documentation/">æ–‡æ¡£</a></li><li><a class="tocitem" href="../metaprogramming/">å…ƒç¼–ç¨‹</a></li><li><a class="tocitem" href="../arrays/">å¤šç»´æ•°ç»„</a></li><li><a class="tocitem" href="../missing/">ç¼ºå¤±å€¼</a></li><li><a class="tocitem" href="../networking-and-streams/">ç½‘ç»œå’Œæµ</a></li><li><a class="tocitem" href="../parallel-computing/">å¹¶è¡Œè®¡ç®—</a></li><li><a class="tocitem" href="../running-external-programs/">è¿è¡Œå¤–éƒ¨ç¨‹åº</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">è°ƒç”¨ C å’Œ Fortran ä»£ç </a></li><li><a class="tocitem" href="../handling-operating-system-variation/">å¤„ç†æ“ä½œç³»ç»Ÿå·®å¼‚</a></li><li><a class="tocitem" href="../environment-variables/">ç¯å¢ƒå˜é‡</a></li><li><a class="tocitem" href="../embedding/">åµŒå…¥ Julia</a></li><li><a class="tocitem" href="../code-loading/">ä»£ç åŠ è½½</a></li><li><a class="tocitem" href="../profile/">æ€§èƒ½åˆ†æ</a></li><li><a class="tocitem" href="../stacktraces/">æ ˆè·Ÿè¸ª</a></li><li><a class="tocitem" href="../performance-tips/">æ€§èƒ½å»ºè®®</a></li><li><a class="tocitem" href="../workflow-tips/">å·¥ä½œæµç¨‹å»ºè®®</a></li><li><a class="tocitem" href="../style-guide/">ä»£ç é£æ ¼æŒ‡å—</a></li><li><a class="tocitem" href="../faq/">å¸¸è§é—®é¢˜</a></li><li><a class="tocitem" href="../noteworthy-differences/">ä¸å…¶ä»–è¯­è¨€çš„æ˜¾è‘—å·®å¼‚</a></li><li><a class="tocitem" href="../unicode-input/">Unicode è¾“å…¥è¡¨</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">åŸºæœ¬åŠŸèƒ½</a></li><li><a class="tocitem" href="../../base/collections/">é›†åˆå’Œæ•°æ®ç»“æ„</a></li><li><a class="tocitem" href="../../base/math/">æ•°å­¦ç›¸å…³</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">å­—ç¬¦ä¸²</a></li><li><a class="tocitem" href="../../base/arrays/">æ•°ç»„</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">å¸¸é‡</a></li><li><a class="tocitem" href="../../base/file/">æ–‡ä»¶ç³»ç»Ÿ</a></li><li><a class="tocitem" href="../../base/io-network/">I/O ä¸ç½‘ç»œ</a></li><li><a class="tocitem" href="../../base/punctuation/">è¿ç®—ç¬¦ä¸è®°å·</a></li><li><a class="tocitem" href="../../base/sort/">æ’åºåŠç›¸å…³å‡½æ•°</a></li><li><a class="tocitem" href="../../base/iterators/">è¿­ä»£ç›¸å…³</a></li><li><a class="tocitem" href="../../base/c/">C æ¥å£</a></li><li><a class="tocitem" href="../../base/libc/">C æ ‡å‡†åº“</a></li><li><a class="tocitem" href="../../base/stacktraces/">å †æ ˆè·Ÿè¸ª</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD æ”¯æŒ</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">æ—¥æœŸ</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">åˆ†éš”ç¬¦æ–‡ä»¶</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">åˆ†å¸ƒå¼è®¡ç®—</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">æ–‡ä»¶ç›¸å…³äº‹ä»¶</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">äº¤äº’å¼ç»„ä»¶</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">åŠ¨æ€é“¾æ¥å™¨</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">çº¿æ€§ä»£æ•°</a></li><li><a class="tocitem" href="../../stdlib/Logging/">æ—¥å¿—è®°å½•</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">å†…å­˜æ˜ å°„ I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">æ€§èƒ½åˆ†æ</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">éšæœºæ•°</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">åºåˆ—åŒ–</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">å…±äº«æ•°ç»„</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">å¥—æ¥å­—</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">ç¨€ç–æ•°ç»„</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">ç»Ÿè®¡</a></li><li><a class="tocitem" href="../../stdlib/Test/">å•å…ƒæµ‹è¯•</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">åå°„ ä¸ è‡ªæˆ‘æ£€æŸ¥</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia è¿è¡Œæ—¶çš„åˆå§‹åŒ–</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia çš„ AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia ä»£ç çš„ eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia å‡½æ•°</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">ç¬›å¡å°”</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">å­æ•°ç»„</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">è¾¹ç•Œæ£€æŸ¥</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">ç±»å‹æ¨å¯¼</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">æŠ¥å‘Šå’Œåˆ†æå´©æºƒï¼ˆæ®µé”™è¯¯ï¼‰</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb è°ƒè¯•æç¤º</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">åœ¨Juliaä¸­ä½¿ç”¨Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">æ‰‹å†Œ</a></li><li class="is-active"><a href>å˜é‡ä½œç”¨åŸŸ</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>å˜é‡ä½œç”¨åŸŸ</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/variables-and-scopingmd" title=" å®Œå–„ Transifex ä¸Šçš„ç¿»è¯‘"><span class="docs-icon fab">ï‚¬</span><span class="docs-label is-hidden-touch"> å®Œå–„ Transifex ä¸Šçš„ç¿»è¯‘</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="è®¾ç½®"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="scope-of-variables"><a class="docs-heading-anchor" href="#scope-of-variables">å˜é‡ä½œç”¨åŸŸ</a><a id="scope-of-variables-1"></a><a class="docs-heading-anchor-permalink" href="#scope-of-variables" title="Permalink"></a></h1><p>å˜é‡çš„ <strong>ä½œç”¨åŸŸ</strong> æ˜¯ä»£ç çš„ä¸€ä¸ªåŒºåŸŸï¼Œåœ¨è¿™ä¸ªåŒºåŸŸä¸­è¿™ä¸ªå˜é‡æ˜¯å¯è§çš„ã€‚ç»™å˜é‡åˆ’åˆ†ä½œç”¨åŸŸæœ‰åŠ©äºè§£å†³å˜é‡å‘½åå†²çªã€‚è¿™ä¸ªæ¦‚å¿µæ˜¯ç¬¦åˆç›´è§‰çš„ï¼šä¸¤ä¸ªå‡½æ•°å¯èƒ½åŒæ—¶éƒ½æœ‰å«åš <code>x</code> çš„å‚é‡ï¼Œè€Œè¿™ä¸¤ä¸ª <code>x</code> å¹¶ä¸æŒ‡å‘åŒä¸€ä¸ªä¸œè¥¿ã€‚ ç›¸ä¼¼åœ°ï¼Œä¹Ÿæœ‰å¾ˆå¤šå…¶ä»–çš„æƒ…å†µï¼Œä»£ç çš„ä¸åŒå—ä¼šä½¿ç”¨åŒæ ·åå­—ï¼Œä½†å¹¶ä¸æŒ‡å‘åŒä¸€ä¸ªä¸œè¥¿ã€‚ç›¸åŒçš„å˜é‡åæ˜¯å¦æŒ‡å‘åŒä¸€ä¸ªä¸œè¥¿çš„è§„åˆ™è¢«ç§°ä¸ºä½œç”¨åŸŸè§„åˆ™ï¼›è¿™ä¸€èŠ‚ä¼šè¯¦ç»†åœ°æŠŠè¿™ä¸ªè§„åˆ™è®²æ¸…æ¥šã€‚</p><p>è¯­è¨€ä¸­çš„æŸäº›ç»“æ„ä¼šå¼•å…¥<strong>ä½œç”¨åŸŸå—</strong>ï¼Œè¿™æ˜¯æœ‰èµ„æ ¼æˆä¸ºä¸€äº›å˜é‡é›†åˆçš„ä½œç”¨åŸŸçš„ä»£ç åŒºåŸŸã€‚ä¸€ä¸ªå˜é‡çš„ä½œç”¨åŸŸä¸å¯èƒ½æ˜¯æºä»£ç è¡Œçš„ä»»æ„é›†åˆï¼›ç›¸åï¼Œå®ƒå§‹ç»ˆä¸è¿™äº›å—ä¹‹ä¸€å…³ç³»å¯†åˆ‡ã€‚åœ¨ Julia ä¸­ä¸»è¦æœ‰ä¸¤ç§ä½œç”¨åŸŸï¼Œ<strong>å…¨å±€ä½œç”¨åŸŸ</strong> ä¸ <strong>å±€éƒ¨ä½œç”¨åŸŸ</strong>ï¼Œåè€…å¯ä»¥åµŒå¥—ã€‚ åœ¨ Julia ä¸­è¿˜å­˜åœ¨å¼•å…¥â€œç¡¬ä½œç”¨åŸŸâ€çš„æ„é€ å’Œåªå¼•å…¥â€œè½¯ä½œç”¨åŸŸâ€çš„æ„é€ ä¹‹é—´çš„åŒºåˆ«ï¼Œè¿™å½±å“åˆ°æ˜¯å¦å…è®¸ä»¥ç›¸åŒçš„åç§°é®è”½å…¨å±€å˜é‡ã€‚</p><h3 id="man-scope-table"><a class="docs-heading-anchor" href="#man-scope-table">ä½œç”¨åŸŸç»“æ„</a><a id="man-scope-table-1"></a><a class="docs-heading-anchor-permalink" href="#man-scope-table" title="Permalink"></a></h3><p>å¼•å…¥ä½œç”¨åŸŸå—çš„ç»“æ„æœ‰ï¼š</p><table><tr><th style="text-align: right">ç»“æ„</th><th style="text-align: right">ä½œç”¨åŸŸç±»å‹</th><th style="text-align: right">Allowed within</th></tr><tr><td style="text-align: right"><a href="../../base/base/#module"><code>module</code></a>, <a href="../../base/base/#baremodule"><code>baremodule</code></a></td><td style="text-align: right">å…¨å±€</td><td style="text-align: right">å…¨å±€</td></tr><tr><td style="text-align: right"><a href="../../base/base/#struct"><code>struct</code></a></td><td style="text-align: right">local (soft)</td><td style="text-align: right">å…¨å±€</td></tr><tr><td style="text-align: right"><a href="../../base/base/#for"><code>for</code></a>, <a href="../../base/base/#while"><code>while</code></a>, <a href="../../base/base/#try"><code>try</code></a></td><td style="text-align: right">local (soft)</td><td style="text-align: right">å…¨å±€æˆ–å±€éƒ¨</td></tr><tr><td style="text-align: right"><a href="../../base/base/#macro"><code>macro</code></a></td><td style="text-align: right">local (hard)</td><td style="text-align: right">å…¨å±€</td></tr><tr><td style="text-align: right"><a href="../../base/base/#let"><code>let</code></a>, functions, comprehensions, generators</td><td style="text-align: right">local (hard)</td><td style="text-align: right">å…¨å±€æˆ–å±€éƒ¨</td></tr></table><p>å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªè¡¨å†…æ²¡æœ‰çš„æ˜¯<a href="manual/@ref man-compound-experessions"> begin å—</a>å’Œ<a href="../control-flow/#man-conditional-evaluation"> if å—</a>ï¼Œè¿™ä¸¤ä¸ªå—<strong>ä¸ä¼š</strong>å¼•è¿›æ–°çš„ä½œç”¨åŸŸå—ã€‚è¿™ä¸¤ç§ä½œç”¨åŸŸéµå¾ªçš„è§„åˆ™æœ‰ç‚¹ä¸ä¸€æ ·ï¼Œä¼šåœ¨ä¸‹é¢è§£é‡Šã€‚</p><p>Juliaä½¿ç”¨<a href="https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping">è¯æ³•ä½œç”¨åŸŸ</a>ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ªå‡½æ•°çš„ä½œç”¨åŸŸä¸ä¼šä»å…¶è°ƒç”¨è€…çš„ä½œç”¨åŸŸç»§æ‰¿ï¼Œè€Œä»å‡½æ•°å®šä¹‰å¤„çš„ä½œç”¨åŸŸç»§æ‰¿ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œåœ¨ä¸‹åˆ—çš„ä»£ç ä¸­<code>foo</code>ä¸­çš„<code>x</code>æŒ‡å‘çš„æ˜¯æ¨¡å—<code>Bar</code>çš„å…¨å±€ä½œç”¨åŸŸä¸­çš„<code>x</code>ã€‚</p><pre><code class="language-julia-repl">julia&gt; module Bar
           x = 1
           foo() = x
       end;</code></pre><p>å¹¶ä¸”åœ¨<code>foo</code>è¢«ä½¿ç”¨çš„åœ°æ–¹<code>x</code>å¹¶ä¸åœ¨ä½œç”¨åŸŸä¸­ï¼š</p><pre><code class="language-julia-repl">julia&gt; import .Bar

julia&gt; x = -1;

julia&gt; Bar.foo()
1</code></pre><p>Thus <em>lexical scope</em> means that what a variable in a particular piece of code refers to can be deduced from the code in which it appears alone and does not depend on how the program executes. A scope nested inside another scope can &quot;see&quot; variables in all the outer scopes in which it is contained. Outer scopes, on the other hand, cannot see variables in inner scopes.</p><h2 id="å…¨å±€ä½œç”¨åŸŸ"><a class="docs-heading-anchor" href="#å…¨å±€ä½œç”¨åŸŸ">å…¨å±€ä½œç”¨åŸŸ</a><a id="å…¨å±€ä½œç”¨åŸŸ-1"></a><a class="docs-heading-anchor-permalink" href="#å…¨å±€ä½œç”¨åŸŸ" title="Permalink"></a></h2><p>æ¯ä¸ªæ¨¡å—ä¼šå¼•è¿›ä¸€ä¸ªæ–°çš„å…¨å±€ä½œç”¨åŸŸï¼Œä¸å…¶ä»–æ‰€æœ‰æ¨¡å—çš„å…¨å±€ä½œç”¨åŸŸåˆ†å¼€ï¼›æ— æ‰€ä¸åŒ…çš„å…¨å±€ä½œç”¨åŸŸä¸å­˜åœ¨ã€‚æ¨¡å—å¯ä»¥æŠŠå…¶ä»–æ¨¡å—çš„å˜é‡å¼•å…¥åˆ°å®ƒçš„ä½œç”¨åŸŸä¸­ï¼Œé€šè¿‡<a href="../modules/#modules">using æˆ–è€… import</a>è¯­å¥æˆ–è€…é€šè¿‡ç‚¹ç¬¦å·è¿™ç§æœ‰èµ„æ ¼çš„é€šè·¯ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªæ¨¡å—éƒ½æ˜¯æ‰€è°“çš„<em>å‘½åç©ºé—´</em>ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯å˜é‡ç»‘å®šåªèƒ½åœ¨å®ƒä»¬çš„å…¨å±€ä½œç”¨åŸŸä¸­æ”¹å˜ï¼Œåœ¨å¤–éƒ¨æ¨¡å—ä¸­ä¸è¡Œã€‚ ä½œä¸ºä¸€ä¸ªé€ƒç”Ÿçª—å£ï¼Œä½ æ€»æ˜¯å¯ä»¥æ‰§è¡Œè¯¥æ¨¡å—å†…çš„ä»£ç æ¥ä¿®æ”¹ä¸€ä¸ªå˜é‡ï¼›è¿™ç‰¹åˆ«ä¿è¯äº†ä¸è°ƒç”¨â€œevalâ€çš„å¤–éƒ¨ä»£ç ç»ä¸ä¼šä¿®æ”¹æ¨¡å—ç»‘å®šã€‚</p><pre><code class="language-julia-repl">julia&gt; module A
           a = 1 # a global in A&#39;s scope
       end;

julia&gt; module B
           module C
               c = 2
           end
           b = C.c    # can access the namespace of a nested global scope
                      # through a qualified access
           import ..A # makes module A available
           d = A.a
       end;

julia&gt; module D
           b = a # errors as D&#39;s global scope is separate from A&#39;s
       end;
ERROR: UndefVarError: a not defined

julia&gt; module E
           import ..A # make module A available
           A.a = 2    # throws below error
       end;
ERROR: cannot assign variables in other modules</code></pre><p>æ³¨æ„äº¤äº’å¼æç¤ºè¡Œï¼ˆå³REPLï¼‰æ˜¯åœ¨æ¨¡å—<code>Main</code>çš„å…¨å±€ä½œç”¨åŸŸä¸­ã€‚</p><h2 id="å±€éƒ¨ä½œç”¨åŸŸ"><a class="docs-heading-anchor" href="#å±€éƒ¨ä½œç”¨åŸŸ">å±€éƒ¨ä½œç”¨åŸŸ</a><a id="å±€éƒ¨ä½œç”¨åŸŸ-1"></a><a class="docs-heading-anchor-permalink" href="#å±€éƒ¨ä½œç”¨åŸŸ" title="Permalink"></a></h2><p>A new local scope is introduced by most code blocks (see above <a href="#man-scope-table">table</a> for a complete list). Some programming languages require explicitly declaring new variables before using them. Explicit declaration works in Julia too: in any local scope, writing <code>local x</code> declares a new local variable in that scope, regardless of whether there is already a variable named <code>x</code> in an outer scope or not. Declaring each new local like this is somewhat verbose and tedious, however, so Julia, like many other languages, considers assignment to a new variable in a local scope to implicitly declare that variable as a new local. Mostly this is pretty intuitive, but as with many things that behave intuitively, the details are more subtle than one might naÃ¯vely imagine.</p><p>When <code>x = &lt;value&gt;</code> occurs in a local scope, Julia applies the following rules to decide what the expression means based on where the assignment expression occurs and what <code>x</code> already refers to at that location:</p><ol><li><strong>Existing local:</strong> If <code>x</code> is <em>already a local variable</em>, then the existing local <code>x</code> is assigned;</li><li><strong>Hard scope:</strong> If <code>x</code> is <em>not already a local variable</em> and assignment occurs inside of any hard scope construct (i.e. within a let block, function or macro body, comprehension, or generator), a new local named <code>x</code> is created in the scope of the assignment;</li><li><strong>Soft scope:</strong> If <code>x</code> is <em>not already a local variable</em> and all of the scope constructs containing the assignment are soft scopes (loops, <code>try</code>/<code>catch</code> blocks, or <code>struct</code> blocks), the behavior depends on whether the global variable <code>x</code> is defined:<ul><li>if global <code>x</code> is <em>undefined</em>, a new local named <code>x</code> is created in the scope of the assignment;</li><li>if global <code>x</code> is <em>defined</em>, the assignment is considered ambiguous:<ul><li>in <em>non-interactive</em> contexts (files, eval), an ambiguity warning is printed and a new local is created;</li><li>in <em>interactive</em> contexts (REPL, notebooks), the global variable <code>x</code> is assigned.</li></ul></li></ul></li></ol><p>You may note that in non-interactive contexts the hard and soft scope behaviors are identical except that a warning is printed when an implicitly local variable (i.e. not declared with <code>local x</code>) shadows a global. In interactive contexts, the rules follow a more complex heuristic for the sake of convenience. This is covered in depth in examples that follow.</p><p>Now that you know the rules, let&#39;s look at some examples. Each example is assumed to be evaluated in a fresh REPL session so that the only globals in each snippet are the ones that are assigned in that block of code.</p><p>We&#39;ll begin with a nice and clear-cut situationâ€”assignment inside of a hard scope, in this case a function body, when no local variable by that name already exists:</p><pre><code class="language-julia-repl">julia&gt; function greet()
           x = &quot;hello&quot; # new local
           println(x)
       end
greet (generic function with 1 method)

julia&gt; greet()
hello

julia&gt; x # global
ERROR: UndefVarError: x not defined</code></pre><p>Inside of the <code>greet</code> function, the assignment <code>x = &quot;hello&quot;</code> causes <code>x</code> to be a new local variable in the function&#39;s scope. There are two relevant facts: the assignment occurs in local scope and there is no existing local <code>x</code> variable. Since <code>x</code> is local, it doesn&#39;t matter if there is a global named <code>x</code> or not. Here for example we define <code>x = 123</code> before defining and calling <code>greet</code>:</p><pre><code class="language-julia-repl">julia&gt; x = 123 # global
123

julia&gt; function greet()
           x = &quot;hello&quot; # new local
           println(x)
       end
greet (generic function with 1 method)

julia&gt; greet()
hello

julia&gt; x # global
123</code></pre><p>Since the <code>x</code> in <code>greet</code> is local, the value (or lack thereof) of the global <code>x</code> is unaffected by calling <code>greet</code>. The hard scope rule doesn&#39;t care whether a global named <code>x</code> exists or not: assignment to <code>x</code> in a hard scope is local (unless <code>x</code> is declared global).</p><p>The next clear cut situation we&#39;ll consider is when there is already a local variable named <code>x</code>, in which case <code>x = &lt;value&gt;</code> always assigns to this existing local <code>x</code>.  The function <code>sum_to</code> computes the sum of the numbers from one up to <code>n</code>:</p><pre><code class="language-julia">function sum_to(n)
    s = 0 # new local
    for i = 1:n
        s = s + i # assign existing local
    end
    return s # same local
end</code></pre><p>As in the previous example, the first assignment to <code>s</code> at the top of <code>sum_to</code> causes <code>s</code> to be a new local variable in the body of the function. The <code>for</code> loop has its own inner local scope within the function scope. At the point where <code>s = s + i</code> occurs, <code>s</code> is already a local variable, so the assignment updates the existing <code>s</code> instead of creating a new local. We can test this out by calling <code>sum_to</code> in the REPL:</p><pre><code class="language-julia-repl">julia&gt; function sum_to(n)
           s = 0 # new local
           for i = 1:n
               s = s + i # assign existing local
           end
           return s # same local
       end
sum_to (generic function with 1 method)

julia&gt; sum_to(10)
55

julia&gt; s # global
ERROR: UndefVarError: s not defined</code></pre><p>Since <code>s</code> is local to the function <code>sum_to</code>, calling the function has no effect on the global variable <code>s</code>. We can also see that the update <code>s = s + i</code> in the <code>for</code> loop must have updated the same <code>s</code> created by the initialization <code>s = 0</code> since we get the correct sum of 55 for the integers 1 through 10.</p><p>Let&#39;s dig into the fact that the <code>for</code> loop body has its own scope for a second by writing a slightly more verbose variation which we&#39;ll call <code>sum_toâ€²</code>, in which we save the sum <code>s + i</code> in a variable <code>t</code> before updating <code>s</code>:</p><pre><code class="language-julia-repl">julia&gt; function sum_toâ€²(n)
           s = 0 # new local
           for i = 1:n
               t = s + i # new local `t`
               s = t # assign existing local `s`
           end
           return s, @isdefined(t)
       end
sum_toâ€² (generic function with 1 method)

julia&gt; sum_toâ€²(10)
(55, false)</code></pre><p>This version returns <code>s</code> as before but it also uses the <code>@isdefined</code> macro to return a boolean indicating whether there is a local variable named <code>t</code> defined in the function&#39;s outermost local scope. As you can see, there is no <code>t</code> defined outside of the <code>for</code> loop body. This is because of the hard scope rule again: since the assignment to <code>t</code> occurs inside of a function, which introduces a hard scope, the assignment causes <code>t</code> to become a new local variable in the local scope where it appears, i.e. inside of the loop body. Even if there were a global named <code>t</code>, it would make no differenceâ€”the hard scope rule isn&#39;t affected by anything in global scope.</p><p>Let&#39;s move onto some more ambiguous cases covered by the soft scope rule. We&#39;ll explore this by extracting the bodies of the <code>greet</code> and <code>sum_toâ€²</code> functions into soft scope contexts. First, let&#39;s put the body of <code>greet</code> in a <code>for</code> loopâ€”which is soft, rather than hardâ€”and evaluate it in the REPL:</p><pre><code class="language-julia-repl">julia&gt; for i = 1:3
           x = &quot;hello&quot; # new local
           println(x)
       end
hello
hello
hello

julia&gt; x
ERROR: UndefVarError: x not defined</code></pre><p>Since the global <code>x</code> is not defined when the <code>for</code> loop is evaluated, the first clause of the soft scope rule applies and <code>x</code> is created as local to the <code>for</code> loop and therefore global <code>x</code> remains undefined after the loop executes. Next, let&#39;s consider the body of <code>sum_toâ€²</code> extracted into global scope, fixing its argument to <code>n = 10</code></p><pre><code class="language-julia">s = 0
for i = 1:10
    t = s + i
    s = t
end
s
@isdefined(t)</code></pre><p>What does this code do? Hint: it&#39;s a trick question. The answer is &quot;it depends.&quot; If this code is entered interactively, it behaves the same way it does in a function body. But if the code appears in a file, it  prints an ambiguity warning and throws an undefined variable error. Let&#39;s see it working in the REPL first:</p><pre><code class="language-julia-repl">julia&gt; s = 0 # global
0

julia&gt; for i = 1:10
           t = s + i # new local `t`
           s = t # assign global `s`
       end

julia&gt; s # global
55

julia&gt; @isdefined(t) # global
false</code></pre><p>The REPL approximates being in the body of a function by deciding whether assignment inside the loop assigns to a global or creates new local based on whether a global variable by that name is defined or not. If a global by the name exists, then the assignment updates it. If no global exists, then the assignment creates a new local variable. In this example we see both cases in action:</p><ul><li>There is no global named <code>t</code>, so <code>t = s + i</code> creates a new <code>t</code> that is local to the <code>for</code> loop;</li><li>There is a global named <code>s</code>, so <code>s = t</code> assigns to it.</li></ul><p>The second fact is why execution of the loop changes the global value of <code>s</code> and the first fact is why <code>t</code> is still undefined after the loop executes. Now, let&#39;s try evaluating this same code as though it were in a file instead:</p><pre><code class="language-julia-repl">julia&gt; code = &quot;&quot;&quot;
       s = 0 # global
       for i = 1:10
           t = s + i # new local `t`
           s = t # new local `s` with warning
       end
       s, # global
       @isdefined(t) # global
       &quot;&quot;&quot;;

julia&gt; include_string(Main, code)
â”Œ Warning: Assignment to `s` in soft scope is ambiguous because a global variable by the same name exists: `s` will be treated as a new local. Disambiguate by using `local s` to suppress this warning or `global s` to assign to the existing global variable.
â”” @ string:4
ERROR: LoadError: UndefVarError: s not defined</code></pre><p>Here we use <a href="../../base/base/#Base.include_string"><code>include_string</code></a>, to evaluate <code>code</code> as though it were the contents of a file. We could also save <code>code</code> to a file and then call <code>include</code> on that fileâ€”the result would be the same. As you can see, this behaves quite different from evaluating the same code in the REPL. Let&#39;s break down what&#39;s happening here:</p><ul><li>global <code>s</code> is defined with the value <code>0</code> before the loop is evaluated</li><li>the assignment <code>s = t</code> occurs in a soft scopeâ€”a <code>for</code> loop outside of any function body or other hard scope construct</li><li>therefore the second clause of the soft scope rule applies, and the assignment is ambiguous so a warning is emitted</li><li>execution continues, making <code>s</code> local to the <code>for</code> loop body</li><li>since <code>s</code> is local to the <code>for</code> loop, it is undefined when <code>t = s + i</code> is evaluated, causing an error</li><li>evaluation stops there, but if it got to <code>s</code> and <code>@isdefined(t)</code>, it would return <code>0</code> and <code>false</code>.</li></ul><p>This demonstrates some important aspects of scope: in a scope, each variable can only have one meaning, and that meaning is determined regardless of the order of expressions. The presence of the expression <code>s = t</code> in the loop causes <code>s</code> to be local to the loop, which means that it is also local when it appears on the right hand side of <code>t = s + i</code>, even though that expression appears first and is evaluated first. One might imagine that the <code>s</code> on the first line of the loop could be global while the <code>s</code> on the second line of the loop is local, but that&#39;s not possible since the two lines are in the same scope block and each variable can only mean one thing in a given scope.</p><h4 id="On-Soft-Scope"><a class="docs-heading-anchor" href="#On-Soft-Scope">On Soft Scope</a><a id="On-Soft-Scope-1"></a><a class="docs-heading-anchor-permalink" href="#On-Soft-Scope" title="Permalink"></a></h4><p>We have now covered all the local scope rules, but before wrapping up this section, perhaps a few words should be said about why the ambiguous soft scope case is handled differently in interactive and non-interactive contexts. There are two obvious questions one could ask:</p><ol><li>Why doesn&#39;t it just work like the REPL everywhere?</li><li>Why doesn&#39;t it just work like in files everywhere? And maybe skip the warning?</li></ol><p>In Julia â‰¤ 0.6, all global scopes did work like the current REPL: when <code>x = &lt;value&gt;</code> occurred in a loop (or <code>try</code>/<code>catch</code>, or <code>struct</code> body) but outside of a function body (or <code>let</code> block or comprehension), it was decided based on whether a global named <code>x</code> was defined or not whether <code>x</code> should be local to the loop. This behavior has the advantage of being intuitive and convenient since it approximates the behavior inside of a function body as closely as possible. In particular, it makes it easy to move code back and forth between a function body and the REPL when trying to debug the behavior of a function. However, it has some downsides. First, it&#39;s quite a complex behavior: many people over the years were confused about this behavior and complained that it was complicated and hard both to explain and understand. Fair point. Second, and arguably worse, is that it&#39;s bad for programming &quot;at scale.&quot; When you see a small piece of code in one place like this, it&#39;s quite clear what&#39;s going on:</p><pre><code class="language-julia">s = 0
for i = 1:10
    s += i
end</code></pre><p>Obviously the intention is to modify the existing global variable <code>s</code>. What else could it mean? However, not all real world code is so short or so clear. We found that code like the following often occurs in the wild:</p><pre><code class="language-julia">x = 123

# much later
# maybe in a different file

for i = 1:10
    x = &quot;hello&quot;
    println(x)
end

# much later
# maybe in yet another file
# or maybe back in the first one where `x = 123`

y = x + 234</code></pre><p>It&#39;s far less clear what should happen here. Since <code>x + &quot;hello&quot;</code> is a method error, it seems probable that the intention is for <code>x</code> to be local to the <code>for</code> loop. But runtime values and what methods happen to exist cannot be used to determine the scopes of variables. With the Julia â‰¤ 0.6 behavior, it&#39;s especially concerning that someone might have written the <code>for</code> loop first, had it working just fine, but later when someone else adds a new global far awayâ€”possibly in a different fileâ€”the code suddenly changes meaning and either breaks noisily or, worse still, silently does the wrong thing. This kind of <a href="https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)">&quot;spooky action at a distance&quot;</a> is something that good programming language designs should prevent.</p><p>So in Julia 1.0, we simplified the rules for scope: in any local scope, assignment to a name that wasn&#39;t already a local variable created a new local variable. This eliminated the notion of soft scope entirely as well as removing the potential for spooky action. We uncovered and fixed a significant number of bugs due to the removal of soft scope, vindicating the choice to get rid of it. And there was much rejoicing! Well, no, not really. Because some people were angry that they now had to write:</p><pre><code class="language-julia">s = 0
for i = 1:10
    global s += i
end</code></pre><p>Do you see that <code>global</code> annotation in there? Hideous. Obviously this situation could not be tolerated. But seriously, there are two main issues with requiring <code>global</code> for this kind of top-level code:</p><ol><li><p>It&#39;s no longer convenient to copy and paste the code from inside a function body into the REPL to debug itâ€”you have to add <code>global</code> annotations and then remove them again to go back;</p></li><li><p>Beginners will write this kind of code without the <code>global</code> and have no idea why their code doesn&#39;t workâ€”the error that they get is that <code>s</code> is undefined, which does not seem to enlighten anyone who happens to make this mistake.</p></li></ol><p>As of Julia 1.5, this code works without the <code>global</code> annotation in interactive contexts like the REPL or Jupyter notebooks (just like Julia 0.6) and in files and other non-interactive contexts, it prints this very direct warning:</p><blockquote><p>Assignment to <code>s</code> in soft scope is ambiguous because a global variable by the same name exists: <code>s</code> will be treated as a new local. Disambiguate by using <code>local s</code> to suppress this warning or <code>global s</code> to assign to the existing global variable.</p></blockquote><p>This addresses both issues while preserving the &quot;programming at scale&quot; benefits of the 1.0 behavior: global variables have no spooky effect on the meaning of code that may be far away; in the REPL copy-and-paste debugging works and beginners don&#39;t have any issues; any time someone either forgets a <code>global</code>Â annotation or accidentally shadows an existing global with a local in a soft scope, which would be confusing anyway, they get a nice clear warning.</p><p>An important property of this design is that any code that executes in a file without a warning will behave the same way in a fresh REPL. And on the flip side, if you take a REPL session and save it to file, if it behaves differently than it did in the REPL, then you will get a warning.</p><h3 id="letå—"><a class="docs-heading-anchor" href="#letå—">letå—</a><a id="letå—-1"></a><a class="docs-heading-anchor-permalink" href="#letå—" title="Permalink"></a></h3><p>ä¸åƒå±€éƒ¨å˜é‡çš„èµ‹å€¼è¡Œä¸ºï¼Œ<code>let</code>è¯­å¥æ¯æ¬¡è¿è¡Œéƒ½æ–°å»ºä¸€ä¸ªæ–°çš„å˜é‡ç»‘å®šã€‚èµ‹å€¼æ”¹å˜çš„æ˜¯å·²å­˜åœ¨å€¼çš„ä½ç½®ï¼Œ<code>let</code>ä¼šæ–°å»ºæ–°çš„ä½ç½®ã€‚è¿™ä¸ªåŒºåˆ«é€šå¸¸éƒ½ä¸é‡è¦ï¼Œåªä¼šåœ¨é€šè¿‡é—­åŒ…è·³å‡ºä½œç”¨åŸŸçš„å˜é‡çš„æƒ…å†µä¸‹èƒ½æ¢æµ‹åˆ°ã€‚<code>let</code>è¯­æ³•æ¥å—ç”±é€—å·éš”å¼€çš„ä¸€ç³»åˆ—çš„èµ‹å€¼å’Œå˜é‡åï¼š</p><pre><code class="language-julia-repl">julia&gt; x, y, z = -1, -1, -1;

julia&gt; let x = 1, z
           println(&quot;x: $x, y: $y&quot;) # x is local variable, y the global
           println(&quot;z: $z&quot;) # errors as z has not been assigned yet but is local
       end
x: 1, y: -1
ERROR: UndefVarError: z not defined</code></pre><p>è¿™ä¸ªèµ‹å€¼ä¼šæŒ‰é¡ºåºè¯„ä¼°ï¼Œåœ¨å·¦è¾¹çš„æ–°å˜é‡è¢«å¼•å…¥ä¹‹å‰å³è¾¹çš„æ¯éš”ä¸¤éƒ½ä¼šåœ¨ä½œç”¨åŸŸä¸­è¢«è¯„ä¼°ã€‚æ‰€ä»¥ç¼–å†™åƒ<code>let x = x</code>è¿™æ ·çš„ä¸œè¥¿æ˜¯æœ‰æ„ä¹‰çš„ï¼Œå› ä¸ºä¸¤ä¸ª<code>x</code>å˜é‡æ˜¯ä¸ä¸€æ ·çš„ï¼Œæ‹¥æœ‰ä¸åŒçš„å­˜å‚¨ä½ç½®ã€‚è¿™é‡Œæœ‰ä¸ªä¾‹å­ï¼Œåœ¨ä¾‹å­ä¸­<code>let</code>çš„è¡Œä¸ºæ˜¯å¿…é¡»çš„ï¼š</p><pre><code class="language-julia-repl">julia&gt; Fs = Vector{Any}(undef, 2); i = 1;

julia&gt; while i &lt;= 2
           Fs[i] = ()-&gt;i
           global i += 1
       end

julia&gt; Fs[1]()
3

julia&gt; Fs[2]()
3</code></pre><p>è¿™é‡Œæˆ‘åˆ›å»ºå¹¶å­˜å‚¨äº†ä¸¤ä¸ªè¿”å›å˜é‡<code>i</code>çš„é—­åŒ…ã€‚ä½†æ˜¯è¿™ä¸¤ä¸ªå§‹ç»ˆæ˜¯åŒä¸€ä¸ªå˜é‡<code>i</code>ã€‚æ‰€ä»¥è¿™ä¸¤ä¸ªé—­åŒ…è¡Œä¸ºæ˜¯ç›¸åŒçš„ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>let</code>æ¥ä¸º<code>i</code>åˆ›å»ºæ–°çš„ç»‘å®šï¼š</p><pre><code class="language-julia-repl">julia&gt; Fs = Vector{Any}(undef, 2); i = 1;

julia&gt; while i &lt;= 2
           let i = i
               Fs[i] = ()-&gt;i
           end
           global i += 1
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</code></pre><p>å› ä¸º <code>begin</code> ç»“æ„ä¸ä¼šå¼•å…¥æ–°çš„ä½œç”¨åŸŸï¼Œä½¿ç”¨æ²¡æœ‰å‚æ•°çš„ <code>let</code> æ¥åªå¼•è¿›ä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸå—è€Œä¸åˆ›å»ºæ–°çš„ç»‘å®šå¯èƒ½æ˜¯æœ‰ç”¨çš„ï¼š</p><pre><code class="language-julia-repl">julia&gt; let
           local x = 1
           let
               local x = 2
           end
           x
       end
1</code></pre><p>å› ä¸º<code>let</code>å¼•è¿›äº†ä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸå—ï¼Œå†…éƒ¨çš„å±€éƒ¨<code>x</code>ä¸å¤–éƒ¨çš„å±€éƒ¨<code>x</code>æ˜¯ä¸åŒçš„å˜é‡ã€‚</p><h3 id="Loops-and-Comprehensions"><a class="docs-heading-anchor" href="#Loops-and-Comprehensions">Loops and Comprehensions</a><a id="Loops-and-Comprehensions-1"></a><a class="docs-heading-anchor-permalink" href="#Loops-and-Comprehensions" title="Permalink"></a></h3><p>In loops and <a href="../arrays/#man-comprehensions">comprehensions</a>, new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a <code>let</code> block, as demonstrated by this example:</p><pre><code class="language-julia-repl">julia&gt; Fs = Vector{Any}(undef, 2);

julia&gt; for j = 1:2
           Fs[j] = ()-&gt;j
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</code></pre><p><code>for</code>å¾ªç¯æˆ–è€…æ¨å¯¼å¼çš„è¿­ä»£å˜é‡å§‹ç»ˆæ˜¯ä¸ªæ–°çš„å˜é‡ï¼š</p><pre><code class="language-julia-repl">julia&gt; function f()
           i = 0
           for i = 1:3
               # empty
           end
           return i
       end;

julia&gt; f()
0</code></pre><p>ä½†æ˜¯ï¼Œæœ‰æ—¶é‡å¤ä½¿ç”¨ä¸€ä¸ªå­˜åœ¨çš„å±€éƒ¨å˜é‡ä½œä¸ºè¿­ä»£å˜é‡æ˜¯æœ‰ç”¨çš„ã€‚ è¿™èƒ½å¤Ÿé€šè¿‡æ·»åŠ å…³é”®å­— <code>outer</code> æ¥æ–¹ä¾¿åœ°åšåˆ°ï¼š</p><pre><code class="language-julia-repl">julia&gt; function f()
           i = 0
           for outer i = 1:3
               # empty
           end
           return i
       end;

julia&gt; f()
3</code></pre><h2 id="å¸¸é‡"><a class="docs-heading-anchor" href="#å¸¸é‡">å¸¸é‡</a><a id="å¸¸é‡-1"></a><a class="docs-heading-anchor-permalink" href="#å¸¸é‡" title="Permalink"></a></h2><p>å˜é‡çš„ç»å¸¸çš„ä¸€ä¸ªä½¿ç”¨æ–¹å¼æ˜¯ç»™ä¸€ä¸ªç‰¹å®šçš„ä¸å˜çš„å€¼ä¸€ä¸ªåå­—ã€‚è¿™æ ·çš„å˜é‡åªä¼šè¢«èµ‹å€¼ä¸€æ¬¡ã€‚è¿™ä¸ªæƒ³æ³•å¯ä»¥é€šè¿‡ä½¿ç”¨ <a href="../../base/base/#const"><code>const</code></a> å…³é”®å­—ä¼ é€’ç»™ç¼–è¯‘å™¨ï¼š</p><pre><code class="language-julia-repl">julia&gt; const e  = 2.71828182845904523536;

julia&gt; const pi = 3.14159265358979323846;</code></pre><p>å¤šä¸ªå˜é‡å¯ä»¥ä½¿ç”¨å•ä¸ª<code>const</code>è¯­å¥è¿›è¡Œå£°æ˜ï¼š</p><pre><code class="language-julia-repl">julia&gt; const a, b = 1, 2
(1, 2)</code></pre><p><code>const</code>å£°æ˜åªåº”è¯¥åœ¨å…¨å±€ä½œç”¨åŸŸä¸­å¯¹å…¨å±€å˜é‡ä½¿ç”¨ã€‚ç¼–è¯‘å™¨å¾ˆéš¾ä¸ºåŒ…å«å…¨å±€å˜é‡çš„ä»£ç ä¼˜åŒ–ï¼Œå› ä¸ºå®ƒä»¬çš„å€¼ï¼ˆç”šè‡³å®ƒä»¬çš„ç±»å‹ï¼‰å¯ä»¥ä»»ä½•æ—¶å€™æ”¹å˜ã€‚å¦‚æœä¸€ä¸ªå…¨å±€å˜é‡ä¸ä¼šæ”¹å˜ï¼Œæ·»åŠ <code>const</code>å£°æ˜ä¼šè§£å†³è¿™ä¸ªé—®é¢˜ã€‚</p><p>å±€éƒ¨å¸¸é‡å´å¤§æœ‰ä¸åŒã€‚ç¼–è¯‘å™¨èƒ½å¤Ÿè‡ªåŠ¨ç¡®å®šä¸€ä¸ªå±€éƒ¨å˜é‡ä»€ä¹ˆæ—¶å€™æ˜¯ä¸å˜çš„ï¼Œæ‰€ä»¥å±€éƒ¨å¸¸é‡å£°æ˜æ˜¯ä¸å¿…è¦çš„ï¼Œå…¶å®ç°åœ¨ä¹Ÿå¹¶ä¸æ”¯æŒã€‚</p><p>ç‰¹åˆ«çš„é¡¶å±‚èµ‹å€¼ï¼Œæ¯”å¦‚ä½¿ç”¨<code>function</code>å’Œ<code>structure</code>å…³é”®å­—è¿›è¡Œçš„ï¼Œé»˜è®¤æ˜¯ä¸å˜çš„ã€‚</p><p>æ³¨æ„ <code>const</code> åªä¼šå½±å“å˜é‡ç»‘å®šï¼›å˜é‡å¯èƒ½ä¼šç»‘å®šåˆ°ä¸€ä¸ªå¯å˜çš„å¯¹è±¡ä¸Šï¼ˆæ¯”å¦‚ä¸€ä¸ªæ•°ç»„ï¼‰ä½¿å¾—å…¶ä»ç„¶èƒ½è¢«æ”¹å˜ã€‚å¦å¤–å½“å°è¯•ç»™ä¸€ä¸ªå£°æ˜ä¸ºå¸¸é‡çš„å˜é‡èµ‹å€¼æ—¶ä¸‹åˆ—æƒ…æ™¯æ˜¯å¯èƒ½çš„ï¼š</p><ul><li>å¦‚æœä¸€ä¸ªæ–°å€¼çš„ç±»å‹ä¸å¸¸é‡ç±»å‹ä¸ä¸€æ ·æ—¶ä¼šæ‰”å‡ºä¸€ä¸ªé”™è¯¯ï¼š</li></ul><pre><code class="language-julia-repl">julia&gt; const x = 1.0
1.0

julia&gt; x = 1
ERROR: invalid redefinition of constant x</code></pre><ul><li>å¦‚æœä¸€ä¸ªæ–°å€¼çš„ç±»å‹ä¸å¸¸é‡ä¸€æ ·ä¼šæ‰“å°ä¸€ä¸ªè­¦å‘Šï¼š</li></ul><pre><code class="language-julia-repl">julia&gt; const y = 1.0
1.0

julia&gt; y = 2.0
WARNING: redefinition of constant y. This may fail, cause incorrect answers, or produce other errors.
2.0</code></pre><ul><li>å¦‚æœèµ‹å€¼ä¸ä¼šå¯¼è‡´å˜é‡å€¼çš„å˜åŒ–ï¼Œä¸ä¼šç»™å‡ºä»»ä½•ä¿¡æ¯ï¼š</li></ul><pre><code class="language-julia-repl">julia&gt; const z = 100
100

julia&gt; z = 100
100</code></pre><p>æœ€åä¸€æ¡è§„åˆ™é€‚ç”¨äºä¸å¯å˜å¯¹è±¡ï¼Œå³ä½¿å˜é‡ç»‘å®šä¼šæ”¹å˜ï¼Œä¾‹å¦‚ï¼š</p><pre><code class="language-julia-repl">julia&gt; const s1 = &quot;1&quot;
&quot;1&quot;

julia&gt; s2 = &quot;1&quot;
&quot;1&quot;

julia&gt; pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x00000000132c9638
 Ptr{UInt8} @0x0000000013dd3d18

julia&gt; s1 = s2
&quot;1&quot;

julia&gt; pointer.([s1, s2], 1)
2-element Array{Ptr{UInt8},1}:
 Ptr{UInt8} @0x0000000013dd3d18
 Ptr{UInt8} @0x0000000013dd3d18</code></pre><p>ä½†æ˜¯å¯¹äºå¯å˜å¯¹è±¡ï¼Œè­¦å‘Šä¼šå¦‚é¢„æœŸå‡ºç°ï¼š</p><pre><code class="language-julia-repl">julia&gt; const a = [1]
1-element Array{Int64,1}:
 1

julia&gt; a = [1]
WARNING: redefinition of constant a. This may fail, cause incorrect answers, or produce other errors.
1-element Array{Int64,1}:
 1</code></pre><p>Note that although sometimes possible, changing the value of a <code>const</code> variable is strongly discouraged, and is intended only for convenience during interactive use. Changing constants can cause various problems or unexpected behaviors. For instance, if a method references a constant and is already compiled before the constant is changed, then it might keep using the old value:</p><pre><code class="language-julia-repl">julia&gt; const x = 1
1

julia&gt; f() = x
f (generic function with 1 method)

julia&gt; f()
1

julia&gt; x = 2
WARNING: redefinition of constant x. This may fail, cause incorrect answers, or produce other errors.
2

julia&gt; f()
1</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../control-flow/">Â« æµç¨‹æ§åˆ¶</a><a class="docs-footer-nextpage" href="../types/">ç±»å‹ Â»</a><div class="flexbox-break"></div><p class="footer-message">ğŸ“¢ğŸ“¢ğŸ“¢Juliaä¸­æ–‡ç¤¾åŒºç°å·²åŠ å…¥â€œå¼€æºè½¯ä»¶ä¾›åº”é“¾ç‚¹äº®è®¡åˆ’â€ï¼Œå¦‚æœä½ æƒ³æ”¹å–„Juliaä¸­æ–‡æ–‡æ¡£çš„ç¿»è¯‘ï¼Œé‚£å°±èµ¶å¿«æ¥ <a href="https://summer.iscas.ac.cn/#/org/prodetail/210370191">æŠ¥å</a> å§ï¼</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">è®¾ç½®</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">é€‰æ‹©ä¸»é¢˜</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>æœ¬æ–‡æ¡£åœ¨<span class="colophon-date" title="2021 å…«æœˆ 12 å‘¨å›› 18:36">2021 å…«æœˆ 12 å‘¨å››</span>ç”±<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>ä½¿ç”¨1.6.2ç‰ˆæœ¬çš„Juliaç”Ÿæˆã€‚</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
