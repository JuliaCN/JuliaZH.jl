<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>任务 · Julia 中文文档</title><meta name="title" content="任务 · Julia 中文文档"/><meta property="og:title" content="任务 · Julia 中文文档"/><meta property="twitter:title" content="任务 · Julia 中文文档"/><meta name="description" content="Documentation for Julia 中文文档."/><meta property="og:description" content="Documentation for Julia 中文文档."/><meta property="twitter:description" content="Documentation for Julia 中文文档."/><meta property="og:url" content="https://juliacn.github.io/JuliaZH.jl/latest/base/parallel/"/><meta property="twitter:url" content="https://juliacn.github.io/JuliaZH.jl/latest/base/parallel/"/><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/base/parallel/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia 中文文档 logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">一维和多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/">基本功能</a></li><li><a class="tocitem" href="../collections/">集合和数据结构</a></li><li><a class="tocitem" href="../math/">数学相关</a></li><li><a class="tocitem" href="../numbers/">数值类型</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../arrays/">数组</a></li><li class="is-active"><a class="tocitem" href>任务</a><ul class="internal"><li><a class="tocitem" href="#调度"><span>调度</span></a></li><li><a class="tocitem" href="#lib-task-sync"><span>同步</span></a></li><li><a class="tocitem" href="#Channels"><span>Channels</span></a></li><li><a class="tocitem" href="#low-level-schedule-wait"><span>使用 <code>schedule</code> 和 <code>wait</code> 的低级同步</span></a></li></ul></li><li><a class="tocitem" href="../multi-threading/">多线程</a></li><li><a class="tocitem" href="../constants/">常量</a></li><li><a class="tocitem" href="../file/">文件系统</a></li><li><a class="tocitem" href="../io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../sort/">排序及相关函数</a></li><li><a class="tocitem" href="../iterators/">迭代相关</a></li><li><a class="tocitem" href="../reflection/">反射与内省</a></li><li><a class="tocitem" href="../c/">C 接口</a></li><li><a class="tocitem" href="../libc/">C 标准库</a></li><li><a class="tocitem" href="../stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">标准库</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/ArgTools/">ArgTools</a></li><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibCURL/">LibCURL</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/NetworkOptions/">Network Options</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Tar/">Tar</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">开发者文档</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/pkgimg/">Package Images</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../../devdocs/gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../../devdocs/precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../../devdocs/probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../../devdocs/build/linux/">Linux</a></li><li><a class="tocitem" href="../../devdocs/build/macos/">macOS</a></li><li><a class="tocitem" href="../../devdocs/build/windows/">Windows</a></li><li><a class="tocitem" href="../../devdocs/build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../../devdocs/build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../../devdocs/build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href>任务</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>任务</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/zh_CN/doc/src/base/parallel.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="任务"><a class="docs-heading-anchor" href="#任务">任务</a><a id="任务-1"></a><a class="docs-heading-anchor-permalink" href="#任务" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Task" href="#Core.Task"><code>Core.Task</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Task(func)</code></pre><p>Create a <code>Task</code> (i.e. coroutine) to execute the given function <code>func</code> (which must be callable with no arguments). The task exits when this function returns. The task will run in the &quot;world age&quot; from the parent at construction when <a href="#Base.schedule"><code>schedule</code></a>d.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>By default tasks will have the sticky bit set to true <code>t.sticky</code>. This models the historic default for <a href="#Base.@async"><code>@async</code></a>. Sticky tasks can only be run on the worker thread they are first scheduled on, and when scheduled will make the task that they were scheduled from sticky. To obtain the behavior of <a href="../multi-threading/#Base.Threads.@spawn"><code>Threads.@spawn</code></a> set the sticky bit manually to <code>false</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a() = sum(i for i in 1:1000);

julia&gt; b = Task(a);</code></pre><p>In this example, <code>b</code> is a runnable <code>Task</code> that hasn&#39;t started yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/docs/basedocs.jl#L1767-L1789">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@task" href="#Base.@task"><code>Base.@task</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@task</code></pre><p>Wrap an expression in a <a href="#Core.Task"><code>Task</code></a> without executing it, and return the <a href="#Core.Task"><code>Task</code></a>. This only creates a task, and does not run it.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>By default tasks will have the sticky bit set to true <code>t.sticky</code>. This models the historic default for <a href="#Base.@async"><code>@async</code></a>. Sticky tasks can only be run on the worker thread they are first scheduled on, and when scheduled will make the task that they were scheduled from sticky. To obtain the behavior of <a href="../multi-threading/#Base.Threads.@spawn"><code>Threads.@spawn</code></a> set the sticky bit manually to <code>false</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a1() = sum(i for i in 1:1000);

julia&gt; b = @task a1();

julia&gt; istaskstarted(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskdone(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L110-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@async" href="#Base.@async"><code>Base.@async</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@async</code></pre><p>Wrap an expression in a <a href="#Core.Task"><code>Task</code></a> and add it to the local machine&#39;s scheduler queue.</p><p>Values can be interpolated into <code>@async</code> via <code>$</code>, which copies the value directly into the constructed underlying closure. This allows you to insert the <em>value</em> of a variable, isolating the asynchronous code from changes to the variable&#39;s value in the current task.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is strongly encouraged to favor <code>Threads.@spawn</code> over <code>@async</code> always <strong>even when no parallelism is required</strong> especially in publicly distributed libraries.  This is because a use of <code>@async</code> disables the migration of the <em>parent</em> task across worker threads in the current implementation of Julia.  Thus, seemingly innocent use of <code>@async</code> in a library function can have a large impact on the performance of very different parts of user applications.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>Interpolating values via <code>$</code> is available as of Julia 1.4.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L495-L514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.asyncmap" href="#Base.asyncmap"><code>Base.asyncmap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">asyncmap(f, c...; ntasks=0, batch_size=nothing)</code></pre><p>Uses multiple concurrent tasks to map <code>f</code> over a collection (or multiple equal length collections). For multiple collection arguments, <code>f</code> is applied elementwise.</p><p><code>ntasks</code> specifies the number of tasks to run concurrently. Depending on the length of the collections, if <code>ntasks</code> is unspecified, up to 100 tasks will be used for concurrent mapping.</p><p><code>ntasks</code> can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of <code>ntasks_func</code> is greater than the current number of tasks.</p><p>If <code>batch_size</code> is specified, the collection is processed in batch mode. <code>f</code> must then be a function that must accept a <code>Vector</code> of argument tuples and must return a vector of results. The input vector will have a length of <code>batch_size</code> or less.</p><p>The following examples highlight execution in different tasks by returning the <code>objectid</code> of the tasks in which the mapping function is executed.</p><p>First, with <code>ntasks</code> undefined, each element is processed in a different task.</p><pre><code class="nohighlight hljs">julia&gt; tskoid() = objectid(current_task());

julia&gt; asyncmap(x-&gt;tskoid(), 1:5)
5-element Array{UInt64,1}:
 0x6e15e66c75c75853
 0x440f8819a1baa682
 0x9fb3eeadd0c83985
 0xebd3e35fe90d4050
 0x29efc93edce2b961

julia&gt; length(unique(asyncmap(x-&gt;tskoid(), 1:5)))
5</code></pre><p>With <code>ntasks=2</code> all elements are processed in 2 tasks.</p><pre><code class="nohighlight hljs">julia&gt; asyncmap(x-&gt;tskoid(), 1:5; ntasks=2)
5-element Array{UInt64,1}:
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94

julia&gt; length(unique(asyncmap(x-&gt;tskoid(), 1:5; ntasks=2)))
2</code></pre><p>With <code>batch_size</code> defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. <code>map</code> is used in the modified mapping function to achieve this.</p><pre><code class="nohighlight hljs">julia&gt; batch_func(input) = map(x-&gt;string(&quot;args_tuple: &quot;, x, &quot;, element_val: &quot;, x[1], &quot;, task: &quot;, tskoid()), input)
batch_func (generic function with 1 method)

julia&gt; asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)
5-element Array{String,1}:
 &quot;args_tuple: (1,), element_val: 1, task: 9118321258196414413&quot;
 &quot;args_tuple: (2,), element_val: 2, task: 4904288162898683522&quot;
 &quot;args_tuple: (3,), element_val: 3, task: 9118321258196414413&quot;
 &quot;args_tuple: (4,), element_val: 4, task: 4904288162898683522&quot;
 &quot;args_tuple: (5,), element_val: 5, task: 9118321258196414413&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/asyncmap.jl#L5-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.asyncmap!" href="#Base.asyncmap!"><code>Base.asyncmap!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)</code></pre><p>Like <a href="#Base.asyncmap"><code>asyncmap</code></a>, but stores output in <code>results</code> rather than returning a collection.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Behavior can be unexpected when any mutated argument shares memory with any other argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/asyncmap.jl#L392-L399">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.current_task" href="#Base.current_task"><code>Base.current_task</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">current_task()</code></pre><p>Get the currently running <a href="#Core.Task"><code>Task</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.istaskdone" href="#Base.istaskdone"><code>Base.istaskdone</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">istaskdone(t::Task) -&gt; Bool</code></pre><p>Determine whether a task has exited.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a2() = sum(i for i in 1:1000);

julia&gt; b = Task(a2);

julia&gt; istaskdone(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskdone(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L193-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.istaskstarted" href="#Base.istaskstarted"><code>Base.istaskstarted</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">istaskstarted(t::Task) -&gt; Bool</code></pre><p>Determine whether a task has started executing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a3() = sum(i for i in 1:1000);

julia&gt; b = Task(a3);

julia&gt; istaskstarted(b)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L217-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.istaskfailed" href="#Base.istaskfailed"><code>Base.istaskfailed</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">istaskfailed(t::Task) -&gt; Bool</code></pre><p>Determine whether a task has exited because an exception was thrown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a4() = error(&quot;task failed&quot;);

julia&gt; b = Task(a4);

julia&gt; istaskfailed(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskfailed(b)
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L234-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.task_local_storage-Tuple{Any}" href="#Base.task_local_storage-Tuple{Any}"><code>Base.task_local_storage</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">task_local_storage(key)</code></pre><p>Look up the value of a key in the current task&#39;s task-local storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.task_local_storage-Tuple{Any, Any}" href="#Base.task_local_storage-Tuple{Any, Any}"><code>Base.task_local_storage</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">task_local_storage(key, value)</code></pre><p>Assign a value to a key in the current task&#39;s task-local storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.task_local_storage-Tuple{Function, Any, Any}" href="#Base.task_local_storage-Tuple{Function, Any, Any}"><code>Base.task_local_storage</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">task_local_storage(body, key, value)</code></pre><p>Call the function <code>body</code> with a modified task-local storage, in which <code>value</code> is assigned to <code>key</code>; the previous value of <code>key</code>, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L291-L297">source</a></section></article><h2 id="调度"><a class="docs-heading-anchor" href="#调度">调度</a><a id="调度-1"></a><a class="docs-heading-anchor-permalink" href="#调度" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.yield" href="#Base.yield"><code>Base.yield</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">yield()</code></pre><p>Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L878-L884">source</a></section><section><div><pre><code class="language-julia hljs">yield(t::Task, arg = nothing)</code></pre><p>A fast, unfair-scheduling version of <code>schedule(t, arg); yield()</code> which immediately yields to <code>t</code> before calling the scheduler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L898-L903">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.yieldto" href="#Base.yieldto"><code>Base.yieldto</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">yieldto(t::Task, arg = nothing)</code></pre><p>Switch to the given task. The first time a task is switched to, the task&#39;s function is called with no arguments. On subsequent switches, <code>arg</code> is returned from the task&#39;s last call to <code>yieldto</code>. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L912-L919">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sleep" href="#Base.sleep"><code>Base.sleep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sleep(seconds)</code></pre><p>Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of <code>0.001</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/asyncevent.jl#L257-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.schedule" href="#Base.schedule"><code>Base.schedule</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schedule(t::Task, [val]; error=false)</code></pre><p>Add a <a href="#Core.Task"><code>Task</code></a> to the scheduler&#39;s queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as <a href="#Base.wait"><code>wait</code></a>.</p><p>If a second argument <code>val</code> is provided, it will be passed to the task (via the return value of <a href="#Base.yieldto"><code>yieldto</code></a>) when it runs again. If <code>error</code> is <code>true</code>, the value is raised as an exception in the woken task.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is incorrect to use <code>schedule</code> on an arbitrary <code>Task</code> that has already been started. See <a href="#low-level-schedule-wait">the API reference</a> for more information.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>By default tasks will have the sticky bit set to true <code>t.sticky</code>. This models the historic default for <a href="#Base.@async"><code>@async</code></a>. Sticky tasks can only be run on the worker thread they are first scheduled on, and when scheduled will make the task that they were scheduled from sticky. To obtain the behavior of <a href="../multi-threading/#Base.Threads.@spawn"><code>Threads.@spawn</code></a> set the sticky bit manually to <code>false</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a5() = sum(i for i in 1:1000);

julia&gt; b = Task(a5);

julia&gt; istaskstarted(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskstarted(b)
true

julia&gt; istaskdone(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L822-L862">source</a></section></article><h2 id="lib-task-sync"><a class="docs-heading-anchor" href="#lib-task-sync">同步</a><a id="lib-task-sync-1"></a><a class="docs-heading-anchor-permalink" href="#lib-task-sync" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.errormonitor" href="#Base.errormonitor"><code>Base.errormonitor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">errormonitor(t::Task)</code></pre><p>Print an error log to <code>stderr</code> if task <code>t</code> fails.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base._wait(errormonitor(Threads.@spawn error(&quot;task failed&quot;)))
Unhandled Task ERROR: task failed
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L567-L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@sync" href="#Base.@sync"><code>Base.@sync</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@sync</code></pre><p>Wait until all lexically-enclosed uses of <a href="#Base.@async"><code>@async</code></a>, <a href="../multi-threading/#Base.Threads.@spawn"><code>@spawn</code></a>, <code>@spawnat</code> and <code>@distributed</code> are complete. All exceptions thrown by enclosed async operations are collected and thrown as a <a href="../base/#Base.CompositeException"><code>CompositeException</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Threads.nthreads()
4

julia&gt; @sync begin
           Threads.@spawn println(&quot;Thread-id $(Threads.threadid()), task 1&quot;)
           Threads.@spawn println(&quot;Thread-id $(Threads.threadid()), task 2&quot;)
       end;
Thread-id 3, task 1
Thread-id 1, task 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L462-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.wait" href="#Base.wait"><code>Base.wait</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Special note for <a href="#Base.Threads.Condition"><code>Threads.Condition</code></a>:</p><p>The caller must be holding the <a href="#Base.lock"><code>lock</code></a> that owns a <code>Threads.Condition</code> before calling this method. The calling task will be blocked until some other task wakes it, usually by calling <a href="#Base.notify"><code>notify</code></a> on the same <code>Threads.Condition</code> object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L318-L326">source</a></section><section><div><pre><code class="language-julia hljs">wait(r::Future)</code></pre><p>Wait for a value to become available for the specified <a href="../../stdlib/Future/#Future"><code>Future</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L581-L585">source</a></section><section><div><pre><code class="language-julia hljs">wait(r::RemoteChannel, args...)</code></pre><p>Wait for a value to become available on the specified <a href="../../stdlib/Distributed/#Distributed.RemoteChannel"><code>RemoteChannel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L588-L592">source</a></section><section><div><pre><code class="language-julia hljs">wait([x])</code></pre><p>Block the current task until some event occurs, depending on the type of the argument:</p><ul><li><a href="#Base.Channel"><code>Channel</code></a>: Wait for a value to be appended to the channel.</li><li><a href="#Base.Condition"><code>Condition</code></a>: Wait for <a href="#Base.notify"><code>notify</code></a> on a condition and return the <code>val</code> parameter passed to <code>notify</code>. Waiting on a condition additionally allows passing <code>first=true</code> which results in the waiter being put <em>first</em> in line to wake up on <code>notify</code> instead of the usual first-in-first-out behavior.</li><li><code>Process</code>: Wait for a process or process chain to exit. The <code>exitcode</code> field of a process can be used to determine success or failure.</li><li><a href="#Core.Task"><code>Task</code></a>: Wait for a <code>Task</code> to finish. If the task fails with an exception, a <code>TaskFailedException</code> (which wraps the failed task) is thrown.</li><li><a href="../file/#Base.Libc.RawFD"><code>RawFD</code></a>: Wait for changes on a file descriptor (see the <code>FileWatching</code> package).</li></ul><p>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to <a href="#Base.schedule"><code>schedule</code></a> or <a href="#Base.yieldto"><code>yieldto</code></a>.</p><p>Often <code>wait</code> is called within a <code>while</code> loop to ensure a waited-for condition is met before proceeding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/condition.jl#L103-L124">source</a></section><section><div><pre><code class="language-julia hljs">wait(c::Channel)</code></pre><p>Blocks until the <code>Channel</code> <a href="#Base.isready-Tuple{Channel}"><code>isready</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; c = Channel(1);

julia&gt; isready(c)
false

julia&gt; task = Task(() -&gt; wait(c));

julia&gt; schedule(task);

julia&gt; istaskdone(task)  # task is blocked because channel is not ready
false

julia&gt; put!(c, 1);

julia&gt; istaskdone(task)  # task is now unblocked
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/channels.jl#L551-L574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.fetch-Tuple{Task}" href="#Base.fetch-Tuple{Task}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fetch(t::Task)</code></pre><p>Wait for a <a href="#Core.Task"><code>Task</code></a> to finish, then return its result value. If the task fails with an exception, a <a href="../base/#Base.TaskFailedException"><code>TaskFailedException</code></a> (which wraps the failed task) is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L371-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.fetch-Tuple{Any}" href="#Base.fetch-Tuple{Any}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fetch(x::Any)</code></pre><p>Return <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L364-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.timedwait" href="#Base.timedwait"><code>Base.timedwait</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timedwait(testcb, timeout::Real; pollint::Real=0.1)</code></pre><p>Waits until <code>testcb()</code> returns <code>true</code> or <code>timeout</code> seconds have passed, whichever is earlier. The test function is polled every <code>pollint</code> seconds. The minimum value for <code>pollint</code> is 0.001 seconds, that is, 1 millisecond.</p><p>Return <code>:ok</code> or <code>:timed_out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/asyncevent.jl#L327-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Condition" href="#Base.Condition"><code>Base.Condition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Condition()</code></pre><p>Create an edge-triggered event source that tasks can wait for. Tasks that call <a href="#Base.wait"><code>wait</code></a> on a <code>Condition</code> are suspended and queued. Tasks are woken up when <a href="#Base.notify"><code>notify</code></a> is later called on the <code>Condition</code>. Edge triggering means that only tasks waiting at the time <a href="#Base.notify"><code>notify</code></a> is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The <a href="#Base.Channel"><code>Channel</code></a> and <a href="#Base.Event"><code>Threads.Event</code></a> types do this, and can be used for level-triggered events.</p><p>This object is NOT thread-safe. See <a href="#Base.Threads.Condition"><code>Threads.Condition</code></a> for a thread-safe version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/condition.jl#L173-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.Condition" href="#Base.Threads.Condition"><code>Base.Threads.Condition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.Condition([lock])</code></pre><p>A thread-safe version of <a href="#Base.Condition"><code>Base.Condition</code></a>.</p><p>To call <a href="#Base.wait"><code>wait</code></a> or <a href="#Base.notify"><code>notify</code></a> on a <code>Threads.Condition</code>, you must first call <a href="#Base.lock"><code>lock</code></a> on it. When <code>wait</code> is called, the lock is atomically released during blocking, and will be reacquired before <code>wait</code> returns. Therefore idiomatic use of a <code>Threads.Condition</code> <code>c</code> looks like the following:</p><pre><code class="nohighlight hljs">lock(c)
try
    while !thing_we_are_waiting_for
        wait(c)
    end
finally
    unlock(c)
end</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This functionality requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L292-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Event" href="#Base.Event"><code>Base.Event</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Event([autoreset=false])</code></pre><p>Create a level-triggered event source. Tasks that call <a href="#Base.wait"><code>wait</code></a> on an <code>Event</code> are suspended and queued until <a href="#Base.notify"><code>notify</code></a> is called on the <code>Event</code>. After <code>notify</code> is called, the <code>Event</code> remains in a signaled state and tasks will no longer block when waiting for it, until <code>reset</code> is called.</p><p>If <code>autoreset</code> is true, at most one task will be released from <code>wait</code> for each call to <code>notify</code>.</p><p>This provides an acquire &amp; release memory ordering on notify/wait.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This functionality requires at least Julia 1.1.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>The <code>autoreset</code> functionality and memory ordering guarantee requires at least Julia 1.8.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L418-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.notify" href="#Base.notify"><code>Base.notify</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">notify(condition, val=nothing; all=true, error=false)</code></pre><p>Wake up tasks waiting for a condition, passing them <code>val</code>. If <code>all</code> is <code>true</code> (the default), all waiting tasks are woken, otherwise only one is. If <code>error</code> is <code>true</code>, the passed value is raised as an exception in the woken tasks.</p><p>Return the count of tasks woken up. Return 0 if no tasks are waiting on <code>condition</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/condition.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reset-Tuple{Base.Event}" href="#Base.reset-Tuple{Base.Event}"><code>Base.reset</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset(::Event)</code></pre><p>Reset an <a href="#Base.Event"><code>Event</code></a> back into an un-set state. Then any future calls to <code>wait</code> will block until <a href="#Base.notify"><code>notify</code></a> is called again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L481-L486">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Semaphore" href="#Base.Semaphore"><code>Base.Semaphore</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Semaphore(sem_size)</code></pre><p>Create a counting semaphore that allows at most <code>sem_size</code> acquires to be in use at any time. Each acquire must be matched with a release.</p><p>This provides a acquire &amp; release memory ordering on acquire/release calls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L330-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.acquire" href="#Base.acquire"><code>Base.acquire</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acquire(s::Semaphore)</code></pre><p>Wait for one of the <code>sem_size</code> permits to be available, blocking until one can be acquired.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L346-L351">source</a></section><section><div><pre><code class="language-julia hljs">acquire(f, s::Semaphore)</code></pre><p>Execute <code>f</code> after acquiring from Semaphore <code>s</code>, and <code>release</code> on completion or error.</p><p>For example, a do-block form that ensures only 2 calls of <code>foo</code> will be active at the same time:</p><pre><code class="language-julia hljs">s = Base.Semaphore(2)
@sync for _ in 1:100
    Threads.@spawn begin
        Base.acquire(s) do
            foo()
        end
    end
end</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>This method requires at least Julia 1.8.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L365-L388">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.release" href="#Base.release"><code>Base.release</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">release(s::Semaphore)</code></pre><p>Return one permit to the pool, possibly allowing another task to acquire it and resume execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L398-L404">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.AbstractLock" href="#Base.AbstractLock"><code>Base.AbstractLock</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractLock</code></pre><p>Abstract supertype describing types that implement the synchronization primitives: <a href="#Base.lock"><code>lock</code></a>, <a href="#Base.trylock"><code>trylock</code></a>, <a href="#Base.unlock"><code>unlock</code></a>, and <a href="#Base.islocked"><code>islocked</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/condition.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.lock" href="#Base.lock"><code>Base.lock</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lock(lock)</code></pre><p>Acquire the <code>lock</code> when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.</p><p>Each <code>lock</code> must be matched by an <a href="#Base.unlock"><code>unlock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L137-L145">source</a></section><section><div><pre><code class="language-julia hljs">lock(f::Function, lock)</code></pre><p>Acquire the <code>lock</code>, execute <code>f</code> with the <code>lock</code> held, and release the <code>lock</code> when <code>f</code> returns. If the lock is already locked by a different task/thread, wait for it to become available.</p><p>When this function returns, the <code>lock</code> has been released, so the caller should not attempt to <code>unlock</code> it.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>Using a <a href="#Base.Channel"><code>Channel</code></a> as the second argument requires Julia 1.7 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L213-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.unlock" href="#Base.unlock"><code>Base.unlock</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unlock(lock)</code></pre><p>Releases ownership of the <code>lock</code>.</p><p>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L166-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.trylock" href="#Base.trylock"><code>Base.trylock</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trylock(lock) -&gt; Success (Boolean)</code></pre><p>Acquire the lock if it is available, and return <code>true</code> if successful. If the lock is already locked by a different task/thread, return <code>false</code>.</p><p>Each successful <code>trylock</code> must be matched by an <a href="#Base.unlock"><code>unlock</code></a>.</p><p>Function <code>trylock</code> combined with <a href="#Base.islocked"><code>islocked</code></a> can be used for writing the test-and-test-and-set or exponential backoff algorithms <em>if it is supported by the <code>typeof(lock)</code></em> (read its documentation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L97-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.islocked" href="#Base.islocked"><code>Base.islocked</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">islocked(lock) -&gt; Status (Boolean)</code></pre><p>Check whether the <code>lock</code> is held by any task/thread. This function alone should not be used for synchronization. However, <code>islocked</code> combined with <a href="#Base.trylock"><code>trylock</code></a> can be used for writing the test-and-test-and-set or exponential backoff algorithms <em>if it is supported by the <code>typeof(lock)</code></em> (read its documentation).</p><p><strong>Extended help</strong></p><p>For example, an exponential backoff can be implemented as follows if the <code>lock</code> implementation satisfied the properties documented below.</p><pre><code class="language-julia hljs">nspins = 0
while true
    while islocked(lock)
        GC.safepoint()
        nspins += 1
        nspins &gt; LIMIT &amp;&amp; error(&quot;timeout&quot;)
    end
    trylock(lock) &amp;&amp; break
    backoff()
end</code></pre><p><strong>Implementation</strong></p><p>A lock implementation is advised to define <code>islocked</code> with the following properties and note it in its docstring.</p><ul><li><code>islocked(lock)</code> is data-race-free.</li><li>If <code>islocked(lock)</code> returns <code>false</code>, an immediate invocation of <code>trylock(lock)</code> must succeed (returns <code>true</code>) if there is no interference from other tasks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L54-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.ReentrantLock" href="#Base.ReentrantLock"><code>Base.ReentrantLock</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReentrantLock()</code></pre><p>Creates a re-entrant lock for synchronizing <a href="#Core.Task"><code>Task</code></a>s. The same task can acquire the lock as many times as required (this is what the &quot;Reentrant&quot; part of the name means). Each <a href="#Base.lock"><code>lock</code></a> must be matched with an <a href="#Base.unlock"><code>unlock</code></a>.</p><p>Calling &#39;lock&#39; will also inhibit running of finalizers on that thread until the corresponding &#39;unlock&#39;. Use of the standard lock pattern illustrated below should naturally be supported, but beware of inverting the try/lock order or missing the try block entirely (e.g. attempting to return with the lock still held):</p><p>This provides a acquire/release memory ordering on lock/unlock calls.</p><pre><code class="nohighlight hljs">lock(l)
try
    &lt;atomic work&gt;
finally
    unlock(l)
end</code></pre><p>If <a href="#Base.islocked"><code>!islocked(lck::ReentrantLock)</code></a> holds, <a href="#Base.trylock"><code>trylock(lck)</code></a> succeeds unless there are other tasks attempting to hold the lock &quot;at the same time.&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/lock.jl#L6-L32">source</a></section></article><h2 id="Channels"><a class="docs-heading-anchor" href="#Channels">Channels</a><a id="Channels-1"></a><a class="docs-heading-anchor-permalink" href="#Channels" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.AbstractChannel" href="#Base.AbstractChannel"><code>Base.AbstractChannel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractChannel{T}</code></pre><p>Representation of a channel passing objects of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/channels.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Channel" href="#Base.Channel"><code>Base.Channel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Channel{T=Any}(size::Int=0)</code></pre><p>Constructs a <code>Channel</code> with an internal buffer that can hold a maximum of <code>size</code> objects of type <code>T</code>. <a href="#Base.put!-Tuple{Channel, Any}"><code>put!</code></a> calls on a full channel block until an object is removed with <a href="../io-network/#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a>.</p><p><code>Channel(0)</code> constructs an unbuffered channel. <code>put!</code> blocks until a matching <code>take!</code> is called. And vice-versa.</p><p>Other constructors:</p><ul><li><code>Channel()</code>: default constructor, equivalent to <code>Channel{Any}(0)</code></li><li><code>Channel(Inf)</code>: equivalent to <code>Channel{Any}(typemax(Int))</code></li><li><code>Channel(sz)</code>: equivalent to <code>Channel{Any}(sz)</code></li></ul><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>The default constructor <code>Channel()</code> and default <code>size=0</code> were added in Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/channels.jl#L13-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Channel-Tuple{Function}" href="#Base.Channel-Tuple{Function}"><code>Base.Channel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Channel{T=Any}(func::Function, size=0; taskref=nothing, spawn=false, threadpool=nothing)</code></pre><p>Create a new task from <code>func</code>, <a href="../../stdlib/Sockets/#Base.bind"><code>bind</code></a> it to a new channel of type <code>T</code> and size <code>size</code>, and schedule the task, all in a single call. The channel is automatically closed when the task terminates.</p><p><code>func</code> must accept the bound channel as its only argument.</p><p>If you need a reference to the created task, pass a <code>Ref{Task}</code> object via the keyword argument <code>taskref</code>.</p><p>If <code>spawn=true</code>, the <code>Task</code> created for <code>func</code> may be scheduled on another thread in parallel, equivalent to creating a task via <a href="../multi-threading/#Base.Threads.@spawn"><code>Threads.@spawn</code></a>.</p><p>If <code>spawn=true</code> and the <code>threadpool</code> argument is not set, it defaults to <code>:default</code>.</p><p>If the <code>threadpool</code> argument is set (to <code>:default</code> or <code>:interactive</code>), this implies that <code>spawn=true</code> and the new Task is spawned to the specified threadpool.</p><p>Return a <code>Channel</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; chnl = Channel() do ch
           foreach(i -&gt; put!(ch, i), 1:4)
       end;

julia&gt; typeof(chnl)
Channel{Any}

julia&gt; for i in chnl
           @show i
       end;
i = 1
i = 2
i = 3
i = 4</code></pre><p>Referencing the created task:</p><pre><code class="language-julia-repl hljs">julia&gt; taskref = Ref{Task}();

julia&gt; chnl = Channel(taskref=taskref) do ch
           println(take!(ch))
       end;

julia&gt; istaskdone(taskref[])
false

julia&gt; put!(chnl, &quot;Hello&quot;);
Hello

julia&gt; istaskdone(taskref[])
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>The <code>spawn=</code> parameter was added in Julia 1.3. This constructor was added in Julia 1.3. In earlier versions of Julia, Channel used keyword arguments to set <code>size</code> and <code>T</code>, but those constructors are deprecated.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.9</header><div class="admonition-body"><p>The <code>threadpool=</code> argument was added in Julia 1.9.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; chnl = Channel{Char}(1, spawn=true) do ch
           for c in &quot;hello world&quot;
               put!(ch, c)
           end
       end
Channel{Char}(1) (2 items available)

julia&gt; String(collect(chnl))
&quot;hello world&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/channels.jl#L61-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.put!-Tuple{Channel, Any}" href="#Base.put!-Tuple{Channel, Any}"><code>Base.put!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">put!(c::Channel, v)</code></pre><p>Append an item <code>v</code> to the channel <code>c</code>. Blocks if the channel is full.</p><p>For unbuffered channels, blocks until a <a href="../io-network/#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a> is performed by a different task.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p><code>v</code> now gets converted to the channel&#39;s type with <a href="../base/#Base.convert"><code>convert</code></a> as <code>put!</code> is called.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/channels.jl#L328-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.take!-Tuple{Channel}" href="#Base.take!-Tuple{Channel}"><code>Base.take!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">take!(c::Channel)</code></pre><p>Removes and returns a value from a <a href="#Base.Channel"><code>Channel</code></a> in order. Blocks until data is available. For unbuffered channels, blocks until a <a href="#Base.put!-Tuple{Channel, Any}"><code>put!</code></a> is performed by a different task.</p><p><strong>Examples</strong></p><p>Buffered channel:</p><pre><code class="language-julia-repl hljs">julia&gt; c = Channel(1);

julia&gt; put!(c, 1);

julia&gt; take!(c)
1</code></pre><p>Unbuffered channel:</p><pre><code class="language-julia-repl hljs">julia&gt; c = Channel(0);

julia&gt; task = Task(() -&gt; put!(c, 1));

julia&gt; schedule(task);

julia&gt; take!(c)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/channels.jl#L441-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isready-Tuple{Channel}" href="#Base.isready-Tuple{Channel}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isready(c::Channel)</code></pre><p>Determines whether a <a href="#Base.Channel"><code>Channel</code></a> has a value stored in it. Returns immediately, does not block.</p><p>For unbuffered channels returns <code>true</code> if there are tasks waiting on a <a href="#Base.put!-Tuple{Channel, Any}"><code>put!</code></a>.</p><p><strong>Examples</strong></p><p>Buffered channel:</p><pre><code class="language-julia-repl hljs">julia&gt; c = Channel(1);

julia&gt; isready(c)
false

julia&gt; put!(c, 1);

julia&gt; isready(c)
true</code></pre><p>Unbuffered channel:</p><pre><code class="language-julia-repl hljs">julia&gt; c = Channel();

julia&gt; isready(c)  # no tasks waiting to put!
false

julia&gt; task = Task(() -&gt; put!(c, 1));

julia&gt; schedule(task);  # schedule a put! task

julia&gt; isready(c)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/channels.jl#L500-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.fetch-Tuple{Channel}" href="#Base.fetch-Tuple{Channel}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fetch(c::Channel)</code></pre><p>Waits for and returns (without removing) the first available item from the <code>Channel</code>. Note: <code>fetch</code> is unsupported on an unbuffered (0-size) <code>Channel</code>.</p><p><strong>Examples</strong></p><p>Buffered channel:</p><pre><code class="language-julia-repl hljs">julia&gt; c = Channel(3) do ch
           foreach(i -&gt; put!(ch, i), 1:3)
       end;

julia&gt; fetch(c)
1

julia&gt; collect(c)  # item is not removed
3-element Vector{Any}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/channels.jl#L401-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.close-Tuple{Channel}" href="#Base.close-Tuple{Channel}"><code>Base.close</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">close(c::Channel[, excp::Exception])</code></pre><p>Close a channel. An exception (optionally given by <code>excp</code>), is thrown by:</p><ul><li><a href="#Base.put!-Tuple{Channel, Any}"><code>put!</code></a> on a closed channel.</li><li><a href="../io-network/#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a> and <a href="#Base.fetch-Tuple{Task}"><code>fetch</code></a> on an empty, closed channel.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/channels.jl#L192-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.bind-Tuple{Channel, Task}" href="#Base.bind-Tuple{Channel, Task}"><code>Base.bind</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bind(chnl::Channel, task::Task)</code></pre><p>Associate the lifetime of <code>chnl</code> with a task. <code>Channel</code> <code>chnl</code> is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on <code>chnl</code>.</p><p>The <code>chnl</code> object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed <code>Channel</code> objects.</p><p>When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Channel(0);

julia&gt; task = @async foreach(i-&gt;put!(c, i), 1:4);

julia&gt; bind(c,task);

julia&gt; for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia&gt; isopen(c)
false</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = Channel(0);

julia&gt; task = @async (put!(c, 1); error(&quot;foo&quot;));

julia&gt; bind(c, task);

julia&gt; take!(c)
1

julia&gt; put!(c, 1);
ERROR: TaskFailedException
Stacktrace:
[...]
    nested task error: foo
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/channels.jl#L221-L272">source</a></section></article><h2 id="low-level-schedule-wait"><a class="docs-heading-anchor" href="#low-level-schedule-wait">使用 <code>schedule</code> 和 <code>wait</code> 的低级同步</a><a id="low-level-schedule-wait-1"></a><a class="docs-heading-anchor-permalink" href="#low-level-schedule-wait" title="Permalink"></a></h2><p><a href="#Base.schedule"><code>schedule</code></a> 最简单的正确使用方式是在一个尚未启动（调度）的 <code>Task</code> 上使用。 然而，也可以将 <a href="#Base.schedule"><code>schedule</code></a> 和 <a href="#Base.wait"><code>wait</code></a> 用作构建同步接口的非常低级的构建块。 调用 <code>schedule(task)</code> 的一个关键前提条件是调用者必须&quot;拥有&quot;该 <code>task</code>； 也就是说，它必须知道在给定 <code>task</code> 中的 <code>wait</code> 调用正发生在调用 <code>schedule(task)</code> 的代码所知道的位置。 确保这种前提条件的一种策略是使用原子操作，如下例所示：</p><pre><code class="language-julia hljs">@enum OWEState begin
    OWE_EMPTY
    OWE_WAITING
    OWE_NOTIFYING
end

mutable struct OneWayEvent
    @atomic state::OWEState
    task::Task
    OneWayEvent() = new(OWE_EMPTY)
end

function Base.notify(ev::OneWayEvent)
    state = @atomic ev.state
    while state !== OWE_NOTIFYING
        # Spin until we successfully update the state to OWE_NOTIFYING:
        state, ok = @atomicreplace(ev.state, state =&gt; OWE_NOTIFYING)
        if ok
            if state == OWE_WAITING
                # OWE_WAITING -&gt; OWE_NOTIFYING transition means that the waiter task is
                # already waiting or about to call `wait`. The notifier task must wake up
                # the waiter task.
                schedule(ev.task)
            else
                @assert state == OWE_EMPTY
                # Since we are assuming that there is only one notifier task (for
                # simplicity), we know that the other possible case here is OWE_EMPTY.
                # We do not need to do anything because we know that the waiter task has
                # not called `wait(ev::OneWayEvent)` yet.
            end
            break
        end
    end
    return
end

function Base.wait(ev::OneWayEvent)
    ev.task = current_task()
    state, ok = @atomicreplace(ev.state, OWE_EMPTY =&gt; OWE_WAITING)
    if ok
        # OWE_EMPTY -&gt; OWE_WAITING transition means that the notifier task is guaranteed to
        # invoke OWE_WAITING -&gt; OWE_NOTIFYING transition.  The waiter task must call
        # `wait()` immediately.  In particular, it MUST NOT invoke any function that may
        # yield to the scheduler at this point in code.
        wait()
    else
        @assert state == OWE_NOTIFYING
        # Otherwise, the `state` must have already been moved to OWE_NOTIFYING by the
        # notifier task.
    end
    return
end

ev = OneWayEvent()
@sync begin
    @async begin
        wait(ev)
        println(&quot;done&quot;)
    end
    println(&quot;notifying...&quot;)
    notify(ev)
end

# output
notifying...
done</code></pre><p><code>OneWayEvent</code> 允许一个任务通过 <code>wait</code> 等待另一个任务的 <code>notify</code>。 这是一个受限的通信接口，因为 <code>wait</code> 只能被单个任务使用一次（注意 <code>ev.task</code> 的非原子赋值）。</p><p>在这个例子中，<code>notify(ev::OneWayEvent)</code> 只有在<em>它</em>将状态从 <code>OWE_WAITING</code> 修改为 <code>OWE_NOTIFYING</code> 时， 才允许调用 <code>schedule(ev.task)</code>。 这让我们知道执行 <code>wait(ev::OneWayEvent)</code> 的任务现在在 <code>ok</code> 分支中， 并且不可能有其他任务尝试 <code>schedule(ev.task)</code>， 因为它们的 <code>@atomicreplace(ev.state, state =&gt; OWE_NOTIFYING)</code> 将会失败。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../arrays/">« 数组</a><a class="docs-footer-nextpage" href="../multi-threading/">多线程 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>本文档在 <span class="colophon-date" title="2025 八月 15 周五 14:57">2025 八月 15 周五</span>用 <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> 1.10.2 版生成使用 1.10.10 版本的 Julia。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
