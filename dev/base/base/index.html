<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>基本功能 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/base/base/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-options/">命令行选项</a></li></ul></li><li><span class="tocitem">Base</span><ul><li class="is-active"><a class="tocitem" href>基本功能</a><ul class="internal"><li><a class="tocitem" href="#介绍"><span>介绍</span></a></li><li><a class="tocitem" href="#Getting-Around"><span>Getting Around</span></a></li><li><a class="tocitem" href="#Keywords"><span>Keywords</span></a></li><li><a class="tocitem" href="#Standard-Modules"><span>Standard Modules</span></a></li><li><a class="tocitem" href="#Base-Submodules"><span>Base Submodules</span></a></li><li><a class="tocitem" href="#All-Objects"><span>All Objects</span></a></li><li><a class="tocitem" href="#Properties-of-Types"><span>Properties of Types</span></a></li><li><a class="tocitem" href="#Special-Types"><span>Special Types</span></a></li><li><a class="tocitem" href="#Generic-Functions"><span>Generic Functions</span></a></li><li><a class="tocitem" href="#Syntax"><span>Syntax</span></a></li><li><a class="tocitem" href="#Missing-Values"><span>Missing Values</span></a></li><li><a class="tocitem" href="#System"><span>System</span></a></li><li><a class="tocitem" href="#Versioning"><span>Versioning</span></a></li><li><a class="tocitem" href="#Errors"><span>Errors</span></a></li><li><a class="tocitem" href="#Events"><span>Events</span></a></li><li><a class="tocitem" href="#Reflection"><span>Reflection</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li><a class="tocitem" href="#Meta"><span>Meta</span></a></li></ul></li><li><a class="tocitem" href="../collections/">集合和数据结构</a></li><li><a class="tocitem" href="../math/">数学相关</a></li><li><a class="tocitem" href="../numbers/">Numbers</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../arrays/">数组</a></li><li><a class="tocitem" href="../parallel/">Tasks</a></li><li><a class="tocitem" href="../multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../constants/">常量</a></li><li><a class="tocitem" href="../file/">文件系统</a></li><li><a class="tocitem" href="../io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../sort/">排序及相关函数</a></li><li><a class="tocitem" href="../iterators/">迭代相关</a></li><li><a class="tocitem" href="../c/">C 接口</a></li><li><a class="tocitem" href="../libc/">C 标准库</a></li><li><a class="tocitem" href="../stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href>基本功能</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>基本功能</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/base-zh_cn/translate/#zh_CN/basemd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="基本功能"><a class="docs-heading-anchor" href="#基本功能">基本功能</a><a id="基本功能-1"></a><a class="docs-heading-anchor-permalink" href="#基本功能" title="Permalink"></a></h1><h2 id="介绍"><a class="docs-heading-anchor" href="#介绍">介绍</a><a id="介绍-1"></a><a class="docs-heading-anchor-permalink" href="#介绍" title="Permalink"></a></h2><p>Julia Base 中包含一系列适用于科学及数值计算的函数和宏，但也可以用于通用编程，其它功能则由 Julia 生态圈中的各种库来提供。函数按主题划分如下：</p><p>一些通用的提示：</p><ul><li>可以通过 <code>Import Module</code> 导入想要使用的模块，并利用 <code>Module.fn(x)</code> 语句来实现对模块内函数的调用。</li><li>此外，<code>using Module</code> 语句会将名为 <code>Module</code> 的模块中的所有可调函数引入当前的命名空间。</li><li>按照约定，名字以感叹号（<code>!</code>）结尾的函数会改变其输入参数的内容。 一些函数同时拥有改变参数（例如 <code>sort!</code>）和不改变参数（<code>sort</code>）的版本</li></ul><p>The behaviors of <code>Base</code> and standard libraries are stable as defined in <a href="https://semver.org/">SemVer</a> only if they are documented; i.e., included in the <a href="https://docs.julialang.org/">Julia documentation</a> and not marked as unstable. See <a href="../../manual/faq/#man-api">API FAQ</a> for more information.</p><h2 id="Getting-Around"><a class="docs-heading-anchor" href="#Getting-Around">Getting Around</a><a id="Getting-Around-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Around" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.exit" href="#Base.exit"><code>Base.exit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">exit(code=0)</code></pre><p>Stop the program with an exit code. The default exit code is zero, indicating that the program completed successfully. In an interactive session, <code>exit()</code> can be called with the keyboard shortcut <code>^D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/initdefs.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.atexit" href="#Base.atexit"><code>Base.atexit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">atexit(f)</code></pre><p>Register a zero-argument function <code>f()</code> to be called at process exit. <code>atexit()</code> hooks are called in last in first out (LIFO) order and run before object finalizers.</p><p>Exit hooks are allowed to call <code>exit(n)</code>, in which case Julia will exit with exit code <code>n</code> (instead of the original exit code). If more than one exit hook calls <code>exit(n)</code>, then Julia will exit with the exit code corresponding to the last called exit hook that calls <code>exit(n)</code>. (Because exit hooks are called in LIFO order, &quot;last called&quot; is equivalent to &quot;first registered&quot;.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/initdefs.jl#L354-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isinteractive" href="#Base.isinteractive"><code>Base.isinteractive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isinteractive() -&gt; Bool</code></pre><p>Determine whether Julia is running an interactive session.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/initdefs.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.summarysize" href="#Base.summarysize"><code>Base.summarysize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -&gt; Int</code></pre><p>Compute the amount of memory, in bytes, used by all unique objects reachable from the argument.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>exclude</code>: specifies the types of objects to exclude from the traversal.</li><li><code>chargeall</code>: specifies the types of objects to always charge the size of all of their fields, even if those fields would normally be excluded.</li></ul><p>See also <a href="#Base.sizeof-Tuple{Type}"><code>sizeof</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Base.summarysize(1.0)
8

julia&gt; Base.summarysize(Ref(rand(100)))
848

julia&gt; sizeof(Ref(rand(100)))
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/summarysize.jl#L11-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.require" href="#Base.require"><code>Base.require</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">require(into::Module, module::Symbol)</code></pre><p>This function is part of the implementation of <a href="#using"><code>using</code></a> / <a href="#import"><code>import</code></a>, if a module is not already defined in <code>Main</code>. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).</p><p>Loads a source file, in the context of the <code>Main</code> module, on every active node, searching standard locations for files. <code>require</code> is considered a top-level operation, so it sets the current <code>include</code> path but does not use it to search for files (see help for <a href="#Base.include"><code>include</code></a>). This function is typically used to load library code, and is implicitly called by <code>using</code> to load packages.</p><p>When searching for files, <code>require</code> first looks for package code in the global array <a href="../constants/#Base.LOAD_PATH"><code>LOAD_PATH</code></a>. <code>require</code> is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.</p><p>For more details regarding code loading, see the manual sections on <a href="../../manual/modules/#modules">modules</a> and <a href="../../manual/distributed-computing/#code-availability">parallel computing</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L1122-L1142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.compilecache" href="#Base.compilecache"><code>Base.compilecache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.compilecache(module::PkgId)</code></pre><p>Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in <code>DEPOT_PATH[1]/compiled</code>. See <a href="base/@ref">Module initialization and precompilation</a> for important notes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L1629-L1636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.__precompile__" href="#Base.__precompile__"><code>Base.__precompile__</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">__precompile__(isprecompilable::Bool)</code></pre><p>Specify whether the file calling this function is precompilable, defaulting to <code>true</code>. If a module or file is <em>not</em> safely precompilable, it should call <code>__precompile__(false)</code> in order to throw an error if Julia attempts to precompile it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L1105-L1111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.include" href="#Base.include"><code>Base.include</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.include([mapexpr::Function,] [m::Module,] path::AbstractString)</code></pre><p>Evaluate the contents of the input source file in the global scope of module <code>m</code>. Every module (except those defined with <a href="#baremodule"><code>baremodule</code></a>) has its own definition of <code>include</code> omitting the <code>m</code> argument, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to <code>include</code> will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</p><p>The optional first argument <code>mapexpr</code> can be used to transform the included code before it is evaluated: for each parsed expression <code>expr</code> in <code>path</code>, the <code>include</code> function actually evaluates <code>mapexpr(expr)</code>.  If it is omitted, <code>mapexpr</code> defaults to <a href="#Base.identity"><code>identity</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Julia 1.5 is required for passing the <code>mapexpr</code> argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L1457-L1474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.MainInclude.include" href="#Base.MainInclude.include"><code>Base.MainInclude.include</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">include([mapexpr::Function,] path::AbstractString)</code></pre><p>Evaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with <code>baremodule</code>) has its own definition of <code>include</code>, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to <code>include</code> will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files. The argument <code>path</code> is normalized using <a href="../file/#Base.Filesystem.normpath"><code>normpath</code></a> which will resolve relative path tokens such as <code>..</code> and convert <code>/</code> to the appropriate path separator.</p><p>The optional first argument <code>mapexpr</code> can be used to transform the included code before it is evaluated: for each parsed expression <code>expr</code> in <code>path</code>, the <code>include</code> function actually evaluates <code>mapexpr(expr)</code>.  If it is omitted, <code>mapexpr</code> defaults to <a href="#Base.identity"><code>identity</code></a>.</p><p>Use <a href="#Base.include"><code>Base.include</code></a> to evaluate a file into another module.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Julia 1.5 is required for passing the <code>mapexpr</code> argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/client.jl#L490-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.include_string" href="#Base.include_string"><code>Base.include_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">include_string([mapexpr::Function,] m::Module, code::AbstractString, filename::AbstractString=&quot;string&quot;)</code></pre><p>Like <a href="#Base.include"><code>include</code></a>, except reads code from the given string rather than from a file.</p><p>The optional first argument <code>mapexpr</code> can be used to transform the included code before it is evaluated: for each parsed expression <code>expr</code> in <code>code</code>, the <code>include_string</code> function actually evaluates <code>mapexpr(expr)</code>.  If it is omitted, <code>mapexpr</code> defaults to <a href="#Base.identity"><code>identity</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Julia 1.5 is required for passing the <code>mapexpr</code> argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L1398-L1409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.include_dependency" href="#Base.include_dependency"><code>Base.include_dependency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">include_dependency(path::AbstractString)</code></pre><p>In a module, declare that the file specified by <code>path</code> (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.</p><p>This is only needed if your module depends on a file that is not used via <a href="#Base.include"><code>include</code></a>. It has no effect outside of compilation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L1080-L1089">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.which-Tuple{Any, Any}" href="#Base.which-Tuple{Any, Any}"><code>Base.which</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">which(f, types)</code></pre><p>Returns the method of <code>f</code> (a <code>Method</code> object) that would be called for arguments of the given <code>types</code>.</p><p>If <code>types</code> is an abstract type, then the method that would be called by <code>invoke</code> is returned.</p><p>See also: <a href="#Base.parentmodule"><code>parentmodule</code></a>, and <code>@which</code> and <code>@edit</code> in <a href="../../stdlib/InteractiveUtils/#man-interactive-utils"><code>InteractiveUtils</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L1399-L1407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.methods" href="#Base.methods"><code>Base.methods</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">methods(f, [types], [module])</code></pre><p>Return the method table for <code>f</code>.</p><p>If <code>types</code> is specified, return an array of methods whose types match. If <code>module</code> is specified, return an array of methods defined in that module. A list of modules can also be specified as an array.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>At least Julia 1.4 is required for specifying a module.</p></div></div><p>See also: <a href="#Base.which-Tuple{Any, Any}"><code>which</code></a> and <code>@which</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L967-L980">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@show" href="#Base.@show"><code>Base.@show</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@show exs...</code></pre><p>Prints one or more expressions, and their results, to <code>stdout</code>, and returns the last result.</p><p>See also: <a href="../io-network/#Base.show-Tuple{IO, Any}"><code>show</code></a>, <a href="../math/#Base.:--Tuple{Any, Any}"><code>@info</code></a>, <a href="../io-network/#Base.println"><code>println</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = @show 1+2
1 + 2 = 3
3

julia&gt; @show x^2 x/2;
x ^ 2 = 9
x / 2 = 1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/show.jl#L1025-L1042">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ans" href="#ans"><code>ans</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">ans</code></pre><p>A variable referring to the last computed value, automatically set at the interactive prompt.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1259-L1263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.active_project" href="#Base.active_project"><code>Base.active_project</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">active_project()</code></pre><p>Return the path of the active <code>Project.toml</code> file. See also <a href="base/@ref"><code>Base.set_active_project</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/initdefs.jl#L285-L289">source</a></section></article><h2 id="Keywords"><a class="docs-heading-anchor" href="#Keywords">Keywords</a><a id="Keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Keywords" title="Permalink"></a></h2><p>This is the list of reserved keywords in Julia: <code>baremodule</code>, <code>begin</code>, <code>break</code>, <code>catch</code>, <code>const</code>, <code>continue</code>, <code>do</code>, <code>else</code>, <code>elseif</code>, <code>end</code>, <code>export</code>, <code>false</code>, <code>finally</code>, <code>for</code>, <code>function</code>, <code>global</code>, <code>if</code>, <code>import</code>, <code>let</code>, <code>local</code>, <code>macro</code>, <code>module</code>, <code>quote</code>, <code>return</code>, <code>struct</code>, <code>true</code>, <code>try</code>, <code>using</code>, <code>while</code>. Those keywords are not allowed to be used as variable names.</p><p>The following two-word sequences are reserved: <code>abstract type</code>, <code>mutable struct</code>, <code>primitive type</code>. However, you can create variables with names: <code>abstract</code>, <code>mutable</code>, <code>primitive</code> and <code>type</code>.</p><p>Finally: <code>where</code> is parsed as an infix operator for writing parametric method and type definitions; <code>in</code> and <code>isa</code> are parsed as infix operators; and <code>outer</code> is parsed as a keyword when used to modify the scope of a variable in an iteration specification of a <code>for</code> loop or <code>generator</code> expression. Creation of variables named <code>where</code>, <code>in</code>, <code>isa</code> or <code>outer</code> is allowed though.</p><article class="docstring"><header><a class="docstring-binding" id="module" href="#module"><code>module</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">module</code></pre><p><code>module</code> declares a <a href="#Core.Module"><code>Module</code></a>, which is a separate global variable workspace. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else’s. See the <a href="../../manual/modules/#modules">manual section about modules</a> for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia">module Foo
import Base.show
export MyType, foo

struct MyType
    x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1
show(io::IO, a::MyType) = print(io, &quot;MyType $(a.x)&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L78-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="export" href="#export"><code>export</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">export</code></pre><p><code>export</code> is used within modules to tell Julia which functions should be made available to the user. For example: <code>export foo</code> makes the name <code>foo</code> available when <a href="#using"><code>using</code></a> the module. See the <a href="../../manual/modules/#modules">manual section about modules</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L52-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="import" href="#import"><code>import</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">import</code></pre><p><code>import Foo</code> will load the module or package <code>Foo</code>. Names from the imported <code>Foo</code> module can be accessed with dot syntax (e.g. <code>Foo.foo</code> to access the name <code>foo</code>). See the <a href="../../manual/modules/#modules">manual section about modules</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="using" href="#using"><code>using</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">using</code></pre><p><code>using Foo</code> will load the module or package <code>Foo</code> and make its <a href="#export"><code>export</code></a>ed names available for direct use. Names can also be used via dot syntax (e.g. <code>Foo.foo</code> to access the name <code>foo</code>), whether they are <code>export</code>ed or not. See the <a href="../../manual/modules/#modules">manual section about modules</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="baremodule" href="#baremodule"><code>baremodule</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">baremodule</code></pre><p><code>baremodule</code> declares a module that does not contain <code>using Base</code> or local definitions of <a href="#Base.MainInclude.eval"><code>eval</code></a> and <a href="#Base.include"><code>include</code></a>. It does still import <code>Core</code>. In other words,</p><pre><code class="language-julia">module Mod

...

end</code></pre><p>is equivalent to</p><pre><code class="language-julia">baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
include(p) = Base.include(Mod, p)

...

end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L129-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="function" href="#function"><code>function</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">function</code></pre><p>Functions are defined with the <code>function</code> keyword:</p><pre><code class="language-julia">function add(a, b)
    return a + b
end</code></pre><p>Or the short form notation:</p><pre><code class="language-julia">add(a, b) = a + b</code></pre><p>The use of the <a href="#return"><code>return</code></a> keyword is exactly the same as in other languages, but is often optional. A function without an explicit <code>return</code> statement will return the last expression in the function body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L611-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="macro" href="#macro"><code>macro</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">macro</code></pre><p><code>macro</code> defines a method for inserting generated code into a program. A macro maps a sequence of argument expressions to a returned expression, and the resulting expression is substituted directly into the program at the point where the macro is invoked. Macros are a way to run generated code without calling <a href="#Base.MainInclude.eval"><code>eval</code></a>, since the generated code instead simply becomes part of the surrounding program. Macro arguments may include expressions, literal values, and symbols. Macros can be defined for variable number of arguments (varargs), but do not accept keyword arguments. Every macro also implicitly gets passed the arguments <code>__source__</code>, which contains the line number and file name the macro is called from, and <code>__module__</code>, which is the module the macro is expanded in.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; macro sayhello(name)
           return :( println(&quot;Hello, &quot;, $name, &quot;!&quot;) )
       end
@sayhello (macro with 1 method)

julia&gt; @sayhello &quot;Charlie&quot;
Hello, Charlie!

julia&gt; macro saylots(x...)
           return :( println(&quot;Say: &quot;, $(x...)) )
       end
@saylots (macro with 1 method)

julia&gt; @saylots &quot;hey &quot; &quot;there &quot; &quot;friend&quot;
Say: hey there friend</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L178-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="return" href="#return"><code>return</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">return</code></pre><p><code>return x</code> causes the enclosing function to exit early, passing the given value <code>x</code> back to its caller. <code>return</code> by itself with no value is equivalent to <code>return nothing</code> (see <a href="../constants/#Core.nothing"><code>nothing</code></a>).</p><pre><code class="language-julia">function compare(a, b)
    a == b &amp;&amp; return &quot;equal to&quot;
    a &lt; b ? &quot;less than&quot; : &quot;greater than&quot;
end</code></pre><p>In general you can place a <code>return</code> statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with <code>do</code> blocks. For example:</p><pre><code class="language-julia">function test1(xs)
    for x in xs
        iseven(x) &amp;&amp; return 2x
    end
end

function test2(xs)
    map(xs) do x
        iseven(x) &amp;&amp; return 2x
        x
    end
end</code></pre><p>In the first example, the return breaks out of <code>test1</code> as soon as it hits an even number, so <code>test1([5,6,7])</code> returns <code>12</code>.</p><p>You might expect the second example to behave the same way, but in fact the <code>return</code> there only breaks out of the <em>inner</em> function (inside the <code>do</code> block) and gives a value back to <code>map</code>. <code>test2([5,6,7])</code> then returns <code>[5,12,7]</code>.</p><p>When used in a top-level expression (i.e. outside any function), <code>return</code> causes the entire current top-level expression to terminate early.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L659-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="do" href="#do"><code>do</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">do</code></pre><p>Create an anonymous function and pass it as the first argument to a function call. For example:</p><pre><code class="language-julia">map(1:10) do x
    2x
end</code></pre><p>is equivalent to <code>map(x-&gt;2x, 1:10)</code>.</p><p>Use multiple arguments like so:</p><pre><code class="language-julia">map(1:10, 11:20) do x, y
    x + y
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L926-L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="begin" href="#begin"><code>begin</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">begin</code></pre><p><code>begin...end</code> denotes a block of code.</p><pre><code class="language-julia">begin
    println(&quot;Hello, &quot;)
    println(&quot;World!&quot;)
end</code></pre><p>Usually <code>begin</code> will not be necessary, since keywords such as <a href="#function"><code>function</code></a> and <a href="#let"><code>let</code></a> implicitly begin blocks of code. See also <a href="#;"><code>;</code></a>.</p><p><code>begin</code> may also be used when indexing to represent the first index of a collection or the first index of a dimension of an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; A[begin, :]
2-element Array{Int64,1}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1108-L1138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="end" href="#end"><code>end</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">end</code></pre><p><code>end</code> marks the conclusion of a block of expressions, for example <a href="#module"><code>module</code></a>, <a href="#struct"><code>struct</code></a>, <a href="#mutable struct"><code>mutable struct</code></a>, <a href="#begin"><code>begin</code></a>, <a href="#let"><code>let</code></a>, <a href="#for"><code>for</code></a> etc.</p><p><code>end</code> may also be used when indexing to represent the last index of a collection or the last index of a dimension of an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64, 2}:
 1  2
 3  4

julia&gt; A[end, :]
2-element Array{Int64, 1}:
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L797-L819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="let" href="#let"><code>let</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">let</code></pre><p><code>let</code> statements create a new hard scope block and introduce new variable bindings each time they run. Whereas assignments might reassign a new value to an existing value location, <code>let</code> always creates a new location. This difference is only detectable in the case of variables that outlive their scope via closures. The <code>let</code> syntax accepts a comma-separated series of assignments and variable names:</p><pre><code class="language-julia">let var1 = value1, var2, var3 = value3
    code
end</code></pre><p>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like <code>let x = x</code>, since the two <code>x</code> variables are distinct and have separate storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L430-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="if" href="#if"><code>if</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">if/elseif/else</code></pre><p><code>if</code>/<code>elseif</code>/<code>else</code> performs conditional evaluation, which allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the <code>if</code>/<code>elseif</code>/<code>else</code> conditional syntax:</p><pre><code class="language-julia">if x &lt; y
    println(&quot;x is less than y&quot;)
elseif x &gt; y
    println(&quot;x is greater than y&quot;)
else
    println(&quot;x is equal to y&quot;)
end</code></pre><p>If the condition expression <code>x &lt; y</code> is true, then the corresponding block is evaluated; otherwise the condition expression <code>x &gt; y</code> is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the <code>else</code> block is evaluated. The <code>elseif</code> and <code>else</code> blocks are optional, and as many <code>elseif</code> blocks as desired can be used.</p><p>In contrast to some other languages conditions must be of type <code>Bool</code>. It does not suffice for conditions to be convertible to <code>Bool</code>.</p><pre><code class="language-julia-repl">julia&gt; if 1 end
ERROR: TypeError: non-boolean (Int64) used in boolean context</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L702-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="for" href="#for"><code>for</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">for</code></pre><p><code>for</code> loops repeatedly evaluate a block of statements while iterating over a sequence of values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; for i in [1, 4, 0]
           println(i)
       end
1
4
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L755-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="while" href="#while"><code>while</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">while</code></pre><p><code>while</code> loops repeatedly evaluate a conditional expression, and continue evaluating the body of the while loop as long as the expression remains true. If the condition expression is false when the while loop is first reached, the body is never evaluated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; i = 1
1

julia&gt; while i &lt; 5
           println(i)
           global i += 1
       end
1
2
3
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L773-L794">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="break" href="#break"><code>break</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">break</code></pre><p>Break out of a loop immediately.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; i = 0
0

julia&gt; while true
           global i += 1
           i &gt; 5 &amp;&amp; break
           println(i)
       end
1
2
3
4
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L884-L905">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="continue" href="#continue"><code>continue</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">continue</code></pre><p>Skip the rest of the current loop iteration.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; for i = 1:6
           iseven(i) &amp;&amp; continue
           println(i)
       end
1
3
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L908-L923">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="try" href="#try"><code>try</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">try/catch</code></pre><p>A <code>try</code>/<code>catch</code> statement allows intercepting errors (exceptions) thrown by <a href="#Core.throw"><code>throw</code></a> so that program execution can continue. For example, the following code attempts to write a file, but warns the user and proceeds instead of terminating execution if the file cannot be written:</p><pre><code class="language-julia">try
    open(&quot;/danger&quot;, &quot;w&quot;) do f
        println(f, &quot;Hello&quot;)
    end
catch
    @warn &quot;Could not write file.&quot;
end</code></pre><p>or, when the file cannot be read into a variable:</p><pre><code class="language-julia">lines = try
    open(&quot;/danger&quot;, &quot;r&quot;) do f
        readlines(f)
    end
catch
    @warn &quot;File not found.&quot;
end</code></pre><p>The syntax <code>catch e</code> (where <code>e</code> is any variable) assigns the thrown exception object to the given variable within the <code>catch</code> block.</p><p>The power of the <code>try</code>/<code>catch</code> construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L822-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="finally" href="#finally"><code>finally</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">finally</code></pre><p>Run some code when a given block of code exits, regardless of how it exits. For example, here is how we can guarantee that an opened file is closed:</p><pre><code class="language-julia">f = open(&quot;file&quot;)
try
    operate_on_file(f)
finally
    close(f)
end</code></pre><p>When control leaves the <a href="#try"><code>try</code></a> block (for example, due to a <a href="#return"><code>return</code></a>, or just finishing normally), <a href="../io-network/#Base.close"><code>close(f)</code></a> will be executed. If the <code>try</code> block exits due to an exception, the exception will continue propagating. A <code>catch</code> block may be combined with <code>try</code> and <code>finally</code> as well. In this case the <code>finally</code> block will run after <code>catch</code> has handled the error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L860-L881">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="quote" href="#quote"><code>quote</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">quote</code></pre><p><code>quote</code> creates multiple expression objects in a block without using the explicit <a href="#Core.Expr"><code>Expr</code></a> constructor. For example:</p><pre><code class="language-julia">ex = quote
    x = 1
    y = 2
    x + y
end</code></pre><p>Unlike the other means of quoting, <code>:( ... )</code>, this form introduces <code>QuoteNode</code> elements to the expression tree, which must be considered when directly manipulating the tree. For other purposes, <code>:( ... )</code> and <code>quote .. end</code> blocks are treated identically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L452-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="local" href="#local"><code>local</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">local</code></pre><p><code>local</code> introduces a new local variable. See the <a href="../../manual/variables-and-scoping/#scope-of-variables">manual section on variable scoping</a> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; function foo(n)
           x = 0
           for i = 1:n
               local x # introduce a loop-local x
               x = i
           end
           x
       end
foo (generic function with 1 method)

julia&gt; foo(10)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L232-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="global" href="#global"><code>global</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">global</code></pre><p><code>global x</code> makes <code>x</code> in the current scope and its inner scopes refer to the global variable of that name. See the <a href="../../manual/variables-and-scoping/#scope-of-variables">manual section on variable scoping</a> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; z = 3
3

julia&gt; function foo()
           global z = 6 # use the z variable defined outside foo
       end
foo (generic function with 1 method)

julia&gt; foo()
6

julia&gt; z
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L256-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="const" href="#const"><code>const</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">const</code></pre><p><code>const</code> is used to declare global variables whose values will not change. In almost all code (and particularly performance sensitive code) global variables should be declared constant in this way.</p><pre><code class="language-julia">const x = 5</code></pre><p>Multiple variables can be declared within a single <code>const</code>:</p><pre><code class="language-julia">const y, z = 7, 11</code></pre><p>Note that <code>const</code> only applies to one <code>=</code> operation, therefore <code>const x = y = 1</code> declares <code>x</code> to be constant but not <code>y</code>. On the other hand, <code>const x = const y = 1</code> declares both <code>x</code> and <code>y</code> constant.</p><p>Note that &quot;constant-ness&quot; does not extend into mutable containers; only the association between a variable and its value is constant. If <code>x</code> is an array or dictionary (for example) you can still modify, add, or remove elements.</p><p>In some cases changing the value of a <code>const</code> variable gives a warning instead of an error. However, this can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This feature is intended only for convenience during interactive use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L579-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="struct" href="#struct"><code>struct</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">struct</code></pre><p>The most commonly used kind of type in Julia is a struct, specified as a name and a set of fields.</p><pre><code class="language-julia">struct Point
    x
    y
end</code></pre><p>Fields can have type restrictions, which may be parameterized:</p><pre><code class="language-julia">struct Point{X}
    x::X
    y::Float64
end</code></pre><p>A struct can also declare an abstract super type via <code>&lt;:</code> syntax:</p><pre><code class="language-julia">struct Point &lt;: AbstractPoint
    x
    y
end</code></pre><p><code>struct</code>s are immutable by default; an instance of one of these types cannot be modified after construction. Use <a href="#mutable struct"><code>mutable struct</code></a> instead to declare a type whose instances can be modified.</p><p>See the manual section on <a href="base/@ref">Composite Types</a> for more details, such as how to define constructors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1141-L1178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="mutable struct" href="#mutable struct"><code>mutable struct</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">mutable struct</code></pre><p><code>mutable struct</code> is similar to <a href="#struct"><code>struct</code></a>, but additionally allows the fields of the type to be set after construction. See the manual section on <a href="base/@ref">Composite Types</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1181-L1187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="abstract type" href="#abstract type"><code>abstract type</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">abstract type</code></pre><p><code>abstract type</code> declares a type that cannot be instantiated, and serves only as a node in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. Abstract types form the conceptual hierarchy which makes Julia’s type system more than just a collection of object implementations. For example:</p><pre><code class="language-julia">abstract type Number end
abstract type Real &lt;: Number end</code></pre><p><a href="../numbers/#Core.Number"><code>Number</code></a> has no supertype, whereas <a href="../numbers/#Core.Real"><code>Real</code></a> is an abstract subtype of <code>Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L62-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="primitive type" href="#primitive type"><code>primitive type</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">primitive type</code></pre><p><code>primitive type</code> declares a concrete type whose data consists only of a series of bits. Classic examples of primitive types are integers and floating-point values. Some example built-in primitive type declarations:</p><pre><code class="language-julia">primitive type Char 32 end
primitive type Bool &lt;: Integer 8 end</code></pre><p>The number after the name indicates how many bits of storage the type requires. Currently, only sizes that are multiples of 8 bits are supported. The <a href="../numbers/#Core.Bool"><code>Bool</code></a> declaration shows how a primitive type can be optionally declared to be a subtype of some supertype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L160-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="where" href="#where"><code>where</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">where</code></pre><p>The <code>where</code> keyword creates a type that is an iterated union of other types, over all values of some variable. For example <code>Vector{T} where T&lt;:Real</code> includes all <a href="../arrays/#Base.Vector"><code>Vector</code></a>s where the element type is some kind of <code>Real</code> number.</p><p>The variable bound defaults to <a href="#Core.Any"><code>Any</code></a> if it is omitted:</p><pre><code class="language-julia">Vector{T} where T    # short for `where T&lt;:Any`</code></pre><p>Variables can also have lower bounds:</p><pre><code class="language-julia">Vector{T} where T&gt;:Int
Vector{T} where Int&lt;:T&lt;:Real</code></pre><p>There is also a concise syntax for nested <code>where</code> expressions. For example, this:</p><pre><code class="language-julia">Pair{T, S} where S&lt;:Array{T} where T&lt;:Number</code></pre><p>can be shortened to:</p><pre><code class="language-julia">Pair{T, S} where {T&lt;:Number, S&lt;:Array{T}}</code></pre><p>This form is often found on method signatures.</p><p>Note that in this form, the variables are listed outermost-first. This matches the order in which variables are substituted when a type is &quot;applied&quot; to parameter values using the syntax <code>T{p1, p2, ...}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1200-L1233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="..." href="#..."><code>...</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">...</code></pre><p>The &quot;splat&quot; operator, <code>...</code>, represents a sequence of arguments. <code>...</code> can be used in function definitions, to indicate that the function accepts an arbitrary number of arguments. <code>...</code> can also be used to apply a function to a sequence of arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; add(xs...) = reduce(+, xs)
add (generic function with 1 method)

julia&gt; add(1, 2, 3, 4, 5)
15

julia&gt; add([1, 2, 3]...)
6

julia&gt; add(7, 1:100..., 1000:1100...)
111107</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L951-L973">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id=";" href="#;"><code>;</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">;</code></pre><p><code>;</code> has a similar role in Julia as in many C-like languages, and is used to delimit the end of the previous statement.</p><p><code>;</code> is not necessary at the end of a line, but can be used to separate statements on a single line or to join statements into a single expression.</p><p>Adding <code>;</code> at the end of a line in the REPL will suppress printing the result of that expression.</p><p>In function declarations, and optionally in calls, <code>;</code> separates regular arguments from keywords.</p><p>While constructing arrays, if the arguments inside the square brackets are separated by <code>;</code> then their contents are vertically concatenated together.</p><p>In the standard REPL, typing <code>;</code> on an empty line will switch to shell mode.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; function foo()
           x = &quot;Hello, &quot;; x *= &quot;World!&quot;
           return x
       end
foo (generic function with 1 method)

julia&gt; bar() = (x = &quot;Hello, Mars!&quot;; return x)
bar (generic function with 1 method)

julia&gt; foo();

julia&gt; bar()
&quot;Hello, Mars!&quot;

julia&gt; function plot(x, y; style=&quot;solid&quot;, width=1, color=&quot;black&quot;)
           ###
       end

julia&gt; [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; ; # upon typing ;, the prompt changes (in place) to: shell&gt;
shell&gt; echo hello
hello</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L976-L1023">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="=" href="#="><code>=</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">=</code></pre><p><code>=</code> is the assignment operator.</p><ul><li>For variable <code>a</code> and expression <code>b</code>, <code>a = b</code> makes <code>a</code> refer to the value of <code>b</code>.</li><li>For functions <code>f(x)</code>, <code>f(x) = x</code> defines a new function constant <code>f</code>, or adds a new method to <code>f</code> if <code>f</code> is already defined; this usage is equivalent to <code>function f(x); x; end</code>.</li><li><code>a[i] = v</code> calls <a href="../collections/#Base.setindex!"><code>setindex!</code></a><code>(a,v,i)</code>.</li><li><code>a.b = c</code> calls <a href="#Base.setproperty!"><code>setproperty!</code></a><code>(a,:b,c)</code>.</li><li>Inside a function call, <code>f(a=b)</code> passes <code>b</code> as the value of keyword argument <code>a</code>.</li><li>Inside parentheses with commas, <code>(a=1,)</code> constructs a <a href="#Core.NamedTuple"><code>NamedTuple</code></a>.</li></ul><p><strong>Examples</strong></p><p>Assigning <code>a</code> to <code>b</code> does not create a copy of <code>b</code>; instead use <a href="#Base.copy"><code>copy</code></a> or <a href="#Base.deepcopy"><code>deepcopy</code></a>.</p><pre><code class="language-julia-repl">julia&gt; b = [1]; a = b; b[1] = 2; a
1-element Array{Int64, 1}:
 2

julia&gt; b = [1]; a = copy(b); b[1] = 2; a
1-element Array{Int64, 1}:
 1
</code></pre><p>Collections passed to functions are also not copied. Functions can modify (mutate) the contents of the objects their arguments refer to. (The names of functions which do this are conventionally suffixed with &#39;!&#39;.)</p><pre><code class="language-julia-repl">julia&gt; function f!(x); x[:] .+= 1; end
f! (generic function with 1 method)

julia&gt; a = [1]; f!(a); a
1-element Array{Int64, 1}:
 2
</code></pre><p>Assignment can operate on multiple variables in parallel, taking values from an iterable:</p><pre><code class="language-julia-repl">julia&gt; a, b = 4, 5
(4, 5)

julia&gt; a, b = 1:3
1:3

julia&gt; a, b
(1, 2)
</code></pre><p>Assignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:</p><pre><code class="language-julia-repl">julia&gt; a = [1]; b = [2]; c = [3]; a = b = c
1-element Array{Int64, 1}:
 3

julia&gt; b[1] = 2; a, b, c
([2], [2], [2])
</code></pre><p>Assignment at out-of-bounds indices does not grow a collection. If the collection is a <a href="../arrays/#Base.Vector"><code>Vector</code></a> it can instead be grown with <a href="../collections/#Base.push!"><code>push!</code></a> or <a href="../collections/#Base.append!"><code>append!</code></a>.</p><pre><code class="language-julia-repl">julia&gt; a = [1, 1]; a[3] = 2
ERROR: BoundsError: attempt to access 2-element Array{Int64, 1} at index [3]
[...]

julia&gt; push!(a, 2, 3)
4-element Array{Int64, 1}:
 1
 1
 2
 3
</code></pre><p>Assigning <code>[]</code> does not eliminate elements from a collection; instead use <a href="../collections/#Base.filter!"><code>filter!</code></a>.</p><pre><code class="language-julia-repl">julia&gt; a = collect(1:3); a[a .&lt;= 1] = []
ERROR: DimensionMismatch: tried to assign 0 elements to 1 destinations
[...]

julia&gt; filter!(x -&gt; x &gt; 1, a) # in-place &amp; thus more efficient than a = a[a .&gt; 1]
2-element Array{Int64, 1}:
 2
 3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L295-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="?:" href="#?:"><code>?:</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">a ? b : c</code></pre><p>Short form for conditionals; read &quot;if <code>a</code>, evaluate <code>b</code> otherwise evaluate <code>c</code>&quot;. Also known as the <a href="https://en.wikipedia.org/wiki/%3F:">ternary operator</a>.</p><p>This syntax is equivalent to <code>if a; b else c end</code>, but is often used to emphasize the value <code>b</code>-or-<code>c</code> which is being used as part of a larger expression, rather than the side effects that evaluating <code>b</code> or <code>c</code> may have.</p><p>See the manual section on <a href="../../manual/control-flow/#man-conditional-evaluation">control flow</a> for more details.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; x = 1; y = 2;

julia&gt; x &gt; y ? println(&quot;x is larger&quot;) : println(&quot;y is larger&quot;)
y is larger</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L733-L752">source</a></section></article><h2 id="Standard-Modules"><a class="docs-heading-anchor" href="#Standard-Modules">Standard Modules</a><a id="Standard-Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Modules" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Main</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Core" href="#Core"><code>Core</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Core</code></pre><p><code>Core</code> is the module that contains all identifiers considered &quot;built in&quot; to the language, i.e. part of the core language and not libraries. Every module implicitly specifies <code>using Core</code>, since you can&#39;t do anything without those definitions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2826-L2830">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base" href="#Base"><code>Base</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Base</code></pre><p>The base library of Julia. <code>Base</code> is a module that contains basic functionality (the contents of <code>base/</code>). All modules implicitly contain <code>using Base</code>, since this is needed in the vast majority of cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2844-L2848">source</a></section></article><h2 id="Base-Submodules"><a class="docs-heading-anchor" href="#Base-Submodules">Base Submodules</a><a id="Base-Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Base-Submodules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.Broadcast" href="#Base.Broadcast"><code>Base.Broadcast</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Base.Broadcast</code></pre><p>Module containing the broadcasting implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/broadcast.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Docs" href="#Base.Docs"><code>Base.Docs</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Docs</code></pre><p>The <code>Docs</code> module provides the <code>@doc</code> macro which can be used to set and retrieve documentation metadata for Julia objects.</p><p>Please see the manual section on <a href="../../manual/documentation/#man-documentation">documentation</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/Docs.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Iterators" href="#Base.Iterators"><code>Base.Iterators</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Methods for working with Iterators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/iterators.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Libc" href="#Base.Libc"><code>Base.Libc</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Interface to libc, the C standard library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/libc.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Meta" href="#Base.Meta"><code>Base.Meta</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Convenience functions for metaprogramming.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/meta.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.StackTraces" href="#Base.StackTraces"><code>Base.StackTraces</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Tools for collecting and manipulating stack traces. Mainly used for building errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/stacktraces.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys" href="#Base.Sys"><code>Base.Sys</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Provide methods for retrieving information about hardware and the operating system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Threads" href="#Base.Threads"><code>Base.Threads</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Multithreading support.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/threads.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.GC" href="#Base.GC"><code>Base.GC</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Base.GC</code></pre><p>Module with garbage collection utilities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/gcutils.jl#L70-L74">source</a></section></article><h2 id="All-Objects"><a class="docs-heading-anchor" href="#All-Objects">All Objects</a><a id="All-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#All-Objects" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Core.:===" href="#Core.:==="><code>Core.:===</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">===(x,y) -&gt; Bool
≡(x,y) -&gt; Bool</code></pre><p>Determine whether <code>x</code> and <code>y</code> are identical, in the sense that no program could distinguish them. First the types of <code>x</code> and <code>y</code> are compared. If those are identical, mutable objects are compared by address in memory and immutable objects (such as numbers) are compared by contents at the bit level. This function is sometimes called &quot;egal&quot;. It always returns a <code>Bool</code> value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1, 2]; b = [1, 2];

julia&gt; a == b
true

julia&gt; a === b
false

julia&gt; a === a
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L285-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.isa" href="#Core.isa"><code>Core.isa</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isa(x, type) -&gt; Bool</code></pre><p>Determine whether <code>x</code> is of the given <code>type</code>. Can also be used as an infix operator, e.g. <code>x isa type</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isa(1, Int)
true

julia&gt; isa(1, Matrix)
false

julia&gt; isa(1, Char)
false

julia&gt; isa(1, Number)
true

julia&gt; 1 isa Number
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1731-L1754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal" href="#Base.isequal"><code>Base.isequal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isequal(x, y)</code></pre><p>Similar to <a href="../math/#Base.:=="><code>==</code></a>, except for the treatment of floating point numbers and of missing values. <code>isequal</code> treats all floating-point <code>NaN</code> values as equal to each other, treats <code>-0.0</code> as unequal to <code>0.0</code>, and <a href="#Base.missing"><code>missing</code></a> as equal to <code>missing</code>. Always returns a <code>Bool</code> value.</p><p><code>isequal</code> is an equivalence relation - it is reflexive (<code>===</code> implies <code>isequal</code>), symmetric (<code>isequal(a, b)</code> implies <code>isequal(b, a)</code>) and transitive (<code>isequal(a, b)</code> and <code>isequal(b, c)</code> implies <code>isequal(a, c)</code>).</p><p><strong>Implementation</strong></p><p>The default implementation of <code>isequal</code> calls <code>==</code>, so a type that does not involve floating-point values generally only needs to define <code>==</code>.</p><p><code>isequal</code> is the comparison function used by hash tables (<code>Dict</code>). <code>isequal(x,y)</code> must imply that <code>hash(x) == hash(y)</code>.</p><p>This typically means that types for which a custom <code>==</code> or <code>isequal</code> method exists must implement a corresponding <a href="#Base.hash"><code>hash</code></a> method (and vice versa). Collections typically implement <code>isequal</code> by calling <code>isequal</code> recursively on all contents.</p><p>Furthermore, <code>isequal</code> is linked with <a href="#Base.isless"><code>isless</code></a>, and they work together to define a fixed total ordering, where exactly one of <code>isequal(x, y)</code>, <code>isless(x, y)</code>, or <code>isless(y, x)</code> must be <code>true</code> (and the other two <code>false</code>).</p><p>Scalar types generally do not need to implement <code>isequal</code> separate from <code>==</code>, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on <code>isnan</code>, <code>signbit</code>, and <code>==</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isequal([1., NaN], [1., NaN])
true

julia&gt; [1., NaN] == [1., NaN]
false

julia&gt; 0.0 == -0.0
true

julia&gt; isequal(0.0, -0.0)
false

julia&gt; missing == missing
missing

julia&gt; isequal(missing, missing)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L88-L139">source</a></section><section><div><pre><code class="language-none">isequal(x)</code></pre><p>Create a function that compares its argument to <code>x</code> using <a href="#Base.isequal"><code>isequal</code></a>, i.e. a function equivalent to <code>y -&gt; isequal(y, x)</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(isequal)}</code>, which can be used to implement specialized methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L1115-L1123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless" href="#Base.isless"><code>Base.isless</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isless(x, y)</code></pre><p>Test whether <code>x</code> is less than <code>y</code>, according to a fixed total order (defined together with <a href="#Base.isequal"><code>isequal</code></a>). <code>isless</code> is not defined on all pairs of values <code>(x, y)</code>. However, if it is defined, it is expected to satisfy the following:</p><ul><li>If <code>isless(x, y)</code> is defined, then so is <code>isless(y, x)</code> and <code>isequal(x, y)</code>, and exactly one of those three yields <code>true</code>.</li><li>The relation defined by <code>isless</code> is transitive, i.e., <code>isless(x, y) &amp;&amp; isless(y, z)</code> implies <code>isless(x, z)</code>.</li></ul><p>Values that are normally unordered, such as <code>NaN</code>, are ordered after regular values. <a href="#Base.missing"><code>missing</code></a> values are ordered last.</p><p>This is the default comparison used by <a href="../sort/#Base.sort"><code>sort</code></a>.</p><p><strong>Implementation</strong></p><p>Non-numeric types with a total order should implement this function. Numeric types only need to implement it if they have special values such as <code>NaN</code>. Types with a partial order should implement <a href="../math/#Base.:&lt;"><code>&lt;</code></a>. See the documentation on <a href="../sort/#Alternate-orderings">Alternate orderings</a> for how to define alternate ordering methods that can be used in sorting and related functions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isless(1, 3)
true

julia&gt; isless(&quot;Red&quot;, &quot;Blue&quot;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L149-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ifelse" href="#Base.ifelse"><code>Base.ifelse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ifelse(condition::Bool, x, y)</code></pre><p>Return <code>x</code> if <code>condition</code> is <code>true</code>, otherwise return <code>y</code>. This differs from <code>?</code> or <code>if</code> in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using <code>ifelse</code> instead of an <code>if</code> statement can eliminate the branch in generated code and provide higher performance in tight loops.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ifelse(1 &gt; 2, 1, 2)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L475-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.typeassert" href="#Core.typeassert"><code>Core.typeassert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">typeassert(x, type)</code></pre><p>Throw a <a href="#Core.TypeError"><code>TypeError</code></a> unless <code>x isa type</code>. The syntax <code>x::type</code> calls this function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; typeassert(2.5, Int)
ERROR: TypeError: in typeassert, expected Int64, got a value of type Float64
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2673-L2686">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.typeof" href="#Core.typeof"><code>Core.typeof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">typeof(x)</code></pre><p>Get the concrete type of <code>x</code>.</p><p>See also <a href="../collections/#Base.eltype"><code>eltype</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = 1//2;

julia&gt; typeof(a)
Rational{Int64}

julia&gt; M = [1 2; 3.5 4];

julia&gt; typeof(M)
Matrix{Float64} (alias for Array{Float64, 2})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2054-L2073">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.tuple" href="#Core.tuple"><code>Core.tuple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tuple(xs...)</code></pre><p>Construct a tuple of the given objects.</p><p>See also <a href="#Core.Tuple"><code>Tuple</code></a>, <a href="#Core.NamedTuple"><code>NamedTuple</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tuple(1, &#39;b&#39;, pi)
(1, &#39;b&#39;, π)

julia&gt; ans === (1, &#39;b&#39;, π)
true

julia&gt; Tuple(Real[1, 2, pi])  # takes a collection
(1, 2, π)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1922-L1940">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ntuple" href="#Base.ntuple"><code>Base.ntuple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ntuple(f::Function, n::Integer)</code></pre><p>Create a tuple of length <code>n</code>, computing each element as <code>f(i)</code>, where <code>i</code> is the index of the element.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ntuple(i -&gt; 2*i, 4)
(2, 4, 6, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/ntuple.jl#L5-L16">source</a></section><section><div><pre><code class="language-none">ntuple(f, ::Val{N})</code></pre><p>Create a tuple of length <code>N</code>, computing each element as <code>f(i)</code>, where <code>i</code> is the index of the element. By taking a <code>Val(N)</code> argument, it is possible that this version of ntuple may generate more efficient code than the version taking the length as an integer. But <code>ntuple(f, N)</code> is preferable to <code>ntuple(f, Val(N))</code> in cases where <code>N</code> cannot be determined at compile time.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ntuple(i -&gt; 2*i, Val(4))
(2, 4, 6, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/ntuple.jl#L52-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.objectid" href="#Base.objectid"><code>Base.objectid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">objectid(x) -&gt; UInt</code></pre><p>Get a hash value for <code>x</code> based on object identity. <code>objectid(x)==objectid(y)</code> if <code>x === y</code>.</p><p>See also <a href="#Base.hash"><code>hash</code></a>, <a href="../collections/#Base.IdDict"><code>IdDict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L333-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hash" href="#Base.hash"><code>Base.hash</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hash(x[, h::UInt]) -&gt; UInt</code></pre><p>Compute an integer hash code such that <code>isequal(x,y)</code> implies <code>hash(x)==hash(y)</code>. The optional second argument <code>h</code> is a hash code to be mixed with the result.</p><p>New types should implement the 2-argument form, typically by calling the 2-argument <code>hash</code> method recursively in order to mix hashes of the contents with each other (and with <code>h</code>). Typically, any type that implements <code>hash</code> should also implement its own <a href="../math/#Base.:=="><code>==</code></a> (hence <a href="#Base.isequal"><code>isequal</code></a>) to guarantee the property mentioned above. Types supporting subtraction (operator <code>-</code>) should also implement <a href="#Base.widen"><code>widen</code></a>, which is required to hash values inside heterogeneous arrays.</p><p>See also: <a href="#Base.objectid"><code>objectid</code></a>, <a href="../collections/#Base.Dict"><code>Dict</code></a>, <a href="../collections/#Base.Set"><code>Set</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/hashing.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.finalizer" href="#Base.finalizer"><code>Base.finalizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">finalizer(f, x)</code></pre><p>Register a function <code>f(x)</code> to be called when there are no program-accessible references to <code>x</code>, and return <code>x</code>. The type of <code>x</code> must be a <code>mutable struct</code>, otherwise the behavior of this function is unpredictable.</p><p><code>f</code> must not cause a task switch, which excludes most I/O operations such as <code>println</code>. Using the <code>@async</code> macro (to defer context switching to outside of the finalizer) or <code>ccall</code> to directly invoke IO functions in C may be helpful for debugging purposes.</p><p><strong>Examples</strong></p><pre><code class="language-julia">finalizer(my_mutable_struct) do x
    @async println(&quot;Finalizing $x.&quot;)
end

finalizer(my_mutable_struct) do x
    ccall(:jl_safe_printf, Cvoid, (Cstring, Cstring), &quot;Finalizing %s.&quot;, repr(x))
end</code></pre><p>A finalizer may be registered at object construction. In the following example note that we implicitly rely on the finalizer returning the newly created mutable struct <code>x</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">mutable struct MyMutableStruct
    bar
    function MyMutableStruct(bar)
        x = new(bar)
        f(t) = @async println(&quot;Finalizing $t.&quot;)
        finalizer(f, x)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/gcutils.jl#L7-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.finalize" href="#Base.finalize"><code>Base.finalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">finalize(x)</code></pre><p>Immediately run finalizers registered for object <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/gcutils.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy(x)</code></pre><p>Create a shallow copy of <code>x</code>: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.</p><p>See also <a href="../arrays/#Base.copy!"><code>copy!</code></a>, <a href="../c/#Base.copyto!"><code>copyto!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/array.jl#L358-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.deepcopy" href="#Base.deepcopy"><code>Base.deepcopy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deepcopy(x)</code></pre><p>Create a deep copy of <code>x</code>: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling <code>deepcopy</code> on an object should generally have the same effect as serializing and then deserializing it.</p><p>While it isn&#39;t normally necessary, user-defined types can override the default <code>deepcopy</code> behavior by defining a specialized version of the function <code>deepcopy_internal(x::T, dict::IdDict)</code> (which shouldn&#39;t otherwise be used), where <code>T</code> is the type to be specialized for, and <code>dict</code> keeps track of objects copied so far within the recursion. Within the definition, <code>deepcopy_internal</code> should be used in place of <code>deepcopy</code>, and the <code>dict</code> variable should be updated as appropriate before returning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/deepcopy.jl#L8-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty" href="#Base.getproperty"><code>Base.getproperty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getproperty(value, name::Symbol)
getproperty(value, name::Symbol, order::Symbol)</code></pre><p>The syntax <code>a.b</code> calls <code>getproperty(a, :b)</code>. The syntax <code>@atomic order a.b</code> calls <code>getproperty(a, :b, :order)</code> and the syntax <code>@atomic a.b</code> calls <code>getproperty(a, :b, :sequentially_consistent)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; struct MyType
           x
       end

julia&gt; function Base.getproperty(obj::MyType, sym::Symbol)
           if sym === :special
               return obj.x + 1
           else # fallback to getfield
               return getfield(obj, sym)
           end
       end

julia&gt; obj = MyType(1);

julia&gt; obj.special
2

julia&gt; obj.x
1</code></pre><p>See also <a href="#Core.getfield"><code>getfield</code></a>, <a href="#Base.propertynames"><code>propertynames</code></a> and <a href="#Base.setproperty!"><code>setproperty!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2689-L2723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setproperty!" href="#Base.setproperty!"><code>Base.setproperty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setproperty!(value, name::Symbol, x)
setproperty!(value, name::Symbol, x, order::Symbol)</code></pre><p>The syntax <code>a.b = c</code> calls <code>setproperty!(a, :b, c)</code>. The syntax <code>@atomic order a.b = c</code> calls <code>setproperty!(a, :b, c, :order)</code> and the syntax <code>@atomic a.b = c</code> calls <code>getproperty(a, :b, :sequentially_consistent)</code>.</p><p>See also <a href="#Core.setfield!"><code>setfield!</code></a>, <a href="#Base.propertynames"><code>propertynames</code></a> and <a href="#Base.getproperty"><code>getproperty</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2726-L2737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.propertynames" href="#Base.propertynames"><code>Base.propertynames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propertynames(x, private=false)</code></pre><p>Get a tuple or a vector of the properties (<code>x.property</code>) of an object <code>x</code>. This is typically the same as <a href="#Base.fieldnames"><code>fieldnames(typeof(x))</code></a>, but types that overload <a href="#Base.getproperty"><code>getproperty</code></a> should generally overload <code>propertynames</code> as well to get the properties of an instance of the type.</p><p><code>propertynames(x)</code> may return only &quot;public&quot; property names that are part of the documented interface of <code>x</code>.   If you want it to also return &quot;private&quot; fieldnames intended for internal use, pass <code>true</code> for the optional second argument. REPL tab completion on <code>x.</code> shows only the <code>private=false</code> properties.</p><p>See also: <a href="#Base.hasproperty"><code>hasproperty</code></a>, <a href="#Base.hasfield"><code>hasfield</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L1736-L1750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hasproperty" href="#Base.hasproperty"><code>Base.hasproperty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hasproperty(x, s::Symbol)</code></pre><p>Return a boolean indicating whether the object <code>x</code> has <code>s</code> as one of its own properties.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This function requires at least Julia 1.2.</p></div></div><p>See also: <a href="#Base.propertynames"><code>propertynames</code></a>, <a href="#Base.hasfield"><code>hasfield</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L1755-L1764">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.getfield" href="#Core.getfield"><code>Core.getfield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getfield(value, name::Symbol, [order::Symbol])
getfield(value, i::Int, [order::Symbol])</code></pre><p>Extract a field from a composite <code>value</code> by name or position. Optionally, an ordering can be defined for the operation. If the field was declared <code>@atomic</code>, the specification is strongly recommended to be compatible with the stores to that location. Otherwise, if not declared as <code>@atomic</code>, this parameter must be <code>:not_atomic</code> if specified. See also <a href="#Base.getproperty"><code>getproperty</code></a> and <a href="#Base.fieldnames"><code>fieldnames</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = 1//2
1//2

julia&gt; getfield(a, :num)
1

julia&gt; a.num
1

julia&gt; getfield(a, 1)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1943-L1968">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.setfield!" href="#Core.setfield!"><code>Core.setfield!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setfield!(value, name::Symbol, x, [order::Symbol])
setfield!(value, i::Int, x, [order::Symbol])</code></pre><p>Assign <code>x</code> to a named field in <code>value</code> of composite type. The <code>value</code> must be mutable and <code>x</code> must be a subtype of <code>fieldtype(typeof(value), name)</code>. Additionally, an ordering can be specified for this operation. If the field was declared <code>@atomic</code>, this specification is mandatory. Otherwise, if not declared as <code>@atomic</code>, it must be <code>:not_atomic</code> if specified. See also <a href="#Base.setproperty!"><code>setproperty!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; mutable struct MyMutableStruct
           field::Int
       end

julia&gt; a = MyMutableStruct(1);

julia&gt; setfield!(a, :field, 2);

julia&gt; getfield(a, :field)
2

julia&gt; a = 1//2
1//2

julia&gt; setfield!(a, :num, 3);
ERROR: setfield!: immutable struct of type Rational cannot be changed</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1971-L2001">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.isdefined" href="#Core.isdefined"><code>Core.isdefined</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isdefined(m::Module, s::Symbol, [order::Symbol])
isdefined(object, s::Symbol, [order::Symbol])
isdefined(object, index::Int, [order::Symbol])</code></pre><p>Tests whether a global variable or object field is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index. Optionally, an ordering can be defined for the operation. If the field was declared <code>@atomic</code>, the specification is strongly recommended to be compatible with the stores to that location. Otherwise, if not declared as <code>@atomic</code>, this parameter must be <code>:not_atomic</code> if specified.</p><p>To test whether an array element is defined, use <a href="../arrays/#Base.isassigned"><code>isassigned</code></a> instead.</p><p>See also <a href="#Base.@isdefined"><code>@isdefined</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isdefined(Base, :sum)
true

julia&gt; isdefined(Base, :NonExistentMethod)
false

julia&gt; a = 1//2;

julia&gt; isdefined(a, 2)
true

julia&gt; isdefined(a, 3)
false

julia&gt; isdefined(a, :num)
true

julia&gt; isdefined(a, :numerator)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2076-L2114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@isdefined" href="#Base.@isdefined"><code>Base.@isdefined</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@isdefined s -&gt; Bool</code></pre><p>Tests whether variable <code>s</code> is defined in the current scope.</p><p>See also <a href="#Core.isdefined"><code>isdefined</code></a> for field properties and <a href="../arrays/#Base.isassigned"><code>isassigned</code></a> for array indexes or <a href="../collections/#Base.haskey"><code>haskey</code></a> for other mappings.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @isdefined newvar
false

julia&gt; newvar = 1
1

julia&gt; @isdefined newvar
true

julia&gt; function f()
           println(@isdefined x)
           x = 3
           println(@isdefined x)
       end
f (generic function with 1 method)

julia&gt; f()
false
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L119-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convert(T, x)</code></pre><p>Convert <code>x</code> to a value of type <code>T</code>.</p><p>If <code>T</code> is an <a href="../numbers/#Core.Integer"><code>Integer</code></a> type, an <a href="#Core.InexactError"><code>InexactError</code></a> will be raised if <code>x</code> is not representable by <code>T</code>, for example if <code>x</code> is not integer-valued, or is outside the range supported by <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert(Int, 3.0)
3

julia&gt; convert(Int, 3.5)
ERROR: InexactError: Int64(3.5)
Stacktrace:
[...]</code></pre><p>If <code>T</code> is a <a href="../numbers/#Core.AbstractFloat"><code>AbstractFloat</code></a> type, then it will return the closest value to <code>x</code> representable by <code>T</code>.</p><pre><code class="language-julia-repl">julia&gt; x = 1/3
0.3333333333333333

julia&gt; convert(Float32, x)
0.33333334f0

julia&gt; convert(BigFloat, x)
0.333333333333333314829616256247390992939472198486328125</code></pre><p>If <code>T</code> is a collection type and <code>x</code> a collection, the result of <code>convert(T, x)</code> may alias all or part of <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; x = Int[1, 2, 3];

julia&gt; y = convert(Vector{Int}, x);

julia&gt; y === x
true</code></pre><p>See also: <a href="../math/#Base.round-Tuple{Type, Any}"><code>round</code></a>, <a href="../math/#Base.trunc"><code>trunc</code></a>, <a href="#Base.oftype"><code>oftype</code></a>, <a href="../arrays/#Base.reinterpret"><code>reinterpret</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L164-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.promote" href="#Base.promote"><code>Base.promote</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">promote(xs...)</code></pre><p>Convert all arguments to a common type, and return them all (as a tuple). If no arguments can be converted, an error is raised.</p><p>See also: [<code>promote_type</code>], [<code>promote_rule</code>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; promote(Int8(1), Float16(4.5), Float32(4.1))
(1.0f0, 4.5f0, 4.1f0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/promotion.jl#L317-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.oftype" href="#Base.oftype"><code>Base.oftype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">oftype(x, y)</code></pre><p>Convert <code>y</code> to the type of <code>x</code> (<code>convert(typeof(x), y)</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = 4;

julia&gt; y = 3.;

julia&gt; oftype(x, y)
3

julia&gt; oftype(y, x)
4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L373-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.widen" href="#Base.widen"><code>Base.widen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">widen(x)</code></pre><p>If <code>x</code> is a type, return a &quot;larger&quot; type, defined so that arithmetic operations <code>+</code> and <code>-</code> are guaranteed not to overflow nor lose precision for any combination of values that type <code>x</code> can hold.</p><p>For fixed-size integer types less than 128 bits, <code>widen</code> will return a type with twice the number of bits.</p><p>If <code>x</code> is a value, it is converted to <code>widen(typeof(x))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; widen(Int32)
Int64

julia&gt; widen(1.5f0)
1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L874-L894">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.identity" href="#Base.identity"><code>Base.identity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">identity(x)</code></pre><p>The identity function. Returns its argument.</p><p>See also: <a href="../numbers/#Base.one"><code>one</code></a>, <a href="../numbers/#Base.oneunit"><code>oneunit</code></a>, and <a href="../../stdlib/LinearAlgebra/#man-linalg"><code>LinearAlgebra</code></a>&#39;s <code>I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; identity(&quot;Well, what did you expect?&quot;)
&quot;Well, what did you expect?&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L513-L525">source</a></section></article><h2 id="Properties-of-Types"><a class="docs-heading-anchor" href="#Properties-of-Types">Properties of Types</a><a id="Properties-of-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Properties-of-Types" title="Permalink"></a></h2><h3 id="Type-relations"><a class="docs-heading-anchor" href="#Type-relations">Type relations</a><a id="Type-relations-1"></a><a class="docs-heading-anchor-permalink" href="#Type-relations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.supertype" href="#Base.supertype"><code>Base.supertype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supertype(T::DataType)</code></pre><p>Return the supertype of DataType <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; supertype(Int32)
Signed</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L32-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Type" href="#Core.Type"><code>Core.Type</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Core.Type{T}</code></pre><p><code>Core.Type</code> is an abstract type which has all type objects as its instances. The only instance of the singleton type <code>Core.Type{T}</code> is the object <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isa(Type{Float64}, Type)
true

julia&gt; isa(Float64, Type)
true

julia&gt; isa(Real, Type{Float64})
false

julia&gt; isa(Real, Type{Real})
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1306-L1327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.DataType" href="#Core.DataType"><code>Core.DataType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DataType &lt;: Type{T}</code></pre><p><code>DataType</code> represents explicitly declared types that have names, explicitly declared supertypes, and, optionally, parameters.  Every concrete value in the system is an instance of some <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; typeof(Real)
DataType

julia&gt; typeof(Int)
DataType

julia&gt; struct Point
           x::Int
           y
       end

julia&gt; typeof(Point)
DataType</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1330-L1353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.:&lt;:" href="#Core.:&lt;:"><code>Core.:&lt;:</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">&lt;:(T1, T2)</code></pre><p>Subtype operator: returns <code>true</code> if and only if all values of type <code>T1</code> are also of type <code>T2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Float64 &lt;: AbstractFloat
true

julia&gt; Vector{Int} &lt;: AbstractArray
true

julia&gt; Matrix{Float64} &lt;: Matrix{AbstractFloat}
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;:" href="#Base.:&gt;:"><code>Base.:&gt;:</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">&gt;:(T1, T2)</code></pre><p>Supertype operator, equivalent to <code>T2 &lt;: T1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.typejoin" href="#Base.typejoin"><code>Base.typejoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">typejoin(T, S)</code></pre><p>Return the closest common ancestor of <code>T</code> and <code>S</code>, i.e. the narrowest type from which they both inherit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/promotion.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.typeintersect" href="#Base.typeintersect"><code>Base.typeintersect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">typeintersect(T::Type, S::Type)</code></pre><p>Compute a type that contains the intersection of <code>T</code> and <code>S</code>. Usually this will be the smallest such type or one close to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L677-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.promote_type" href="#Base.promote_type"><code>Base.promote_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">promote_type(type1, type2)</code></pre><p>Promotion refers to converting values of mixed types to a single common type. <code>promote_type</code> represents the default promotion behavior in Julia when operators (usually mathematical) are given arguments of differing types. <code>promote_type</code> generally tries to return a type which can at least approximate most values of either input type without excessively widening.  Some loss is tolerated; for example, <code>promote_type(Int64, Float64)</code> returns <a href="../numbers/#Core.Float64"><code>Float64</code></a> even though strictly, not all <a href="../numbers/#Core.Int64"><code>Int64</code></a> values can be represented exactly as <code>Float64</code> values.</p><p>See also: <a href="#Base.promote"><code>promote</code></a>, <a href="#Base.promote_typejoin"><code>promote_typejoin</code></a>, <a href="#Base.promote_rule"><code>promote_rule</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; promote_type(Int64, Float64)
Float64

julia&gt; promote_type(Int32, Int64)
Int64

julia&gt; promote_type(Float32, BigInt)
BigFloat

julia&gt; promote_type(Int16, Float16)
Float16

julia&gt; promote_type(Int64, Float16)
Float16

julia&gt; promote_type(Int8, UInt16)
UInt16</code></pre><div class="admonition is-warning"><header class="admonition-header">Don&#39;t overload this directly</header><div class="admonition-body"><p>To overload promotion for your own types you should overload <a href="#Base.promote_rule"><code>promote_rule</code></a>. <code>promote_type</code> calls <code>promote_rule</code> internally to determine the type. Overloading <code>promote_type</code> directly can cause ambiguity errors.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/promotion.jl#L240-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.promote_rule" href="#Base.promote_rule"><code>Base.promote_rule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">promote_rule(type1, type2)</code></pre><p>Specifies what type should be used by <a href="#Base.promote"><code>promote</code></a> when given values of types <code>type1</code> and <code>type2</code>. This function should not be called directly, but should have definitions added to it for new types as appropriate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/promotion.jl#L301-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.promote_typejoin" href="#Base.promote_typejoin"><code>Base.promote_typejoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">promote_typejoin(T, S)</code></pre><p>Compute a type that contains both <code>T</code> and <code>S</code>, which could be either a parent of both types, or a <code>Union</code> if appropriate. Falls back to <a href="#Base.typejoin"><code>typejoin</code></a>.</p><p>See instead <a href="#Base.promote"><code>promote</code></a>, <a href="#Base.promote_type"><code>promote_type</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Base.promote_typejoin(Int, Float64)
Real

julia&gt; Base.promote_type(Int, Float64)
Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/promotion.jl#L143-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isdispatchtuple" href="#Base.isdispatchtuple"><code>Base.isdispatchtuple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isdispatchtuple(T)</code></pre><p>Determine whether type <code>T</code> is a tuple &quot;leaf type&quot;, meaning it could appear as a type signature in dispatch and has no subtypes (or supertypes) which could appear in a call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L595-L601">source</a></section></article><h3 id="Declared-structure"><a class="docs-heading-anchor" href="#Declared-structure">Declared structure</a><a id="Declared-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Declared-structure" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.ismutable" href="#Base.ismutable"><code>Base.ismutable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ismutable(v) -&gt; Bool</code></pre><p>Return <code>true</code> if and only if value <code>v</code> is mutable.  See <a href="base/@ref">Mutable Composite Types</a> for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of <code>DataType</code> is mutable.</p><p>See also <a href="#Base.isbits"><code>isbits</code></a>, <a href="#Base.isstructtype"><code>isstructtype</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ismutable(1)
false

julia&gt; ismutable([1,2])
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires at least Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L493-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isimmutable" href="#Base.isimmutable"><code>Base.isimmutable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isimmutable(v) -&gt; Bool</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Consider using <code>!ismutable(v)</code> instead, as <code>isimmutable(v)</code> will be replaced by <code>!ismutable(v)</code> in a future release. (Since Julia 1.5)</p></div></div><p>Return <code>true</code> iff value <code>v</code> is immutable.  See <a href="base/@ref">Mutable Composite Types</a> for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of <code>DataType</code> is mutable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isimmutable(1)
true

julia&gt; isimmutable([1,2])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/deprecated.jl#L188-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isabstracttype" href="#Base.isabstracttype"><code>Base.isabstracttype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isabstracttype(T)</code></pre><p>Determine whether type <code>T</code> was declared as an abstract type (i.e. using the <code>abstract</code> keyword).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isabstracttype(AbstractArray)
true

julia&gt; isabstracttype(Vector)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L647-L661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isprimitivetype" href="#Base.isprimitivetype"><code>Base.isprimitivetype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isprimitivetype(T) -&gt; Bool</code></pre><p>Determine whether type <code>T</code> was declared as a primitive type (i.e. using the <code>primitive</code> keyword).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L548-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.issingletontype" href="#Base.issingletontype"><code>Base.issingletontype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.issingletontype(T)</code></pre><p>Determine whether type <code>T</code> has exactly one possible instance; for example, a struct type with no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L669-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isstructtype" href="#Base.isstructtype"><code>Base.isstructtype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isstructtype(T) -&gt; Bool</code></pre><p>Determine whether type <code>T</code> was declared as a struct type (i.e. using the <code>struct</code> or <code>mutable struct</code> keyword).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L533-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nameof-Tuple{DataType}" href="#Base.nameof-Tuple{DataType}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nameof(t::DataType) -&gt; Symbol</code></pre><p>Get the name of a (potentially <code>UnionAll</code>-wrapped) <code>DataType</code> (without its parent module) as a symbol.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; module Foo
           struct S{T}
           end
       end
Foo

julia&gt; nameof(Foo.S{T} where T)
:S</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L220-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fieldnames" href="#Base.fieldnames"><code>Base.fieldnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fieldnames(x::DataType)</code></pre><p>Get a tuple with the names of the fields of a <code>DataType</code>.</p><p>See also <a href="#Base.propertynames"><code>propertynames</code></a>, <a href="#Base.hasfield"><code>hasfield</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fieldnames(Rational)
(:num, :den)

julia&gt; fieldnames(typeof(1+im))
(:re, :im)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L169-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fieldname" href="#Base.fieldname"><code>Base.fieldname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fieldname(x::DataType, i::Integer)</code></pre><p>Get the name of field <code>i</code> of a <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fieldname(Rational, 1)
:num

julia&gt; fieldname(Rational, 2)
:den</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L135-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hasfield" href="#Base.hasfield"><code>Base.hasfield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hasfield(T::Type, name::Symbol)</code></pre><p>Return a boolean indicating whether <code>T</code> has <code>name</code> as one of its own fields.</p><p>See also <a href="#Base.fieldnames"><code>fieldnames</code></a>, <a href="#Base.fieldcount"><code>fieldcount</code></a>, <a href="#Base.hasproperty"><code>hasproperty</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This function requires at least Julia 1.2.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; struct Foo
            bar::Int
       end

julia&gt; hasfield(Foo, :bar)
true

julia&gt; hasfield(Foo, :x)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L192-L214">source</a></section></article><h3 id="Memory-layout"><a class="docs-heading-anchor" href="#Memory-layout">Memory layout</a><a id="Memory-layout-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-layout" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.sizeof-Tuple{Type}" href="#Base.sizeof-Tuple{Type}"><code>Base.sizeof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sizeof(T::DataType)
sizeof(obj)</code></pre><p>Size, in bytes, of the canonical binary representation of the given <code>DataType</code> <code>T</code>, if any. Or the size, in bytes, of object <code>obj</code> if it is not a <code>DataType</code>.</p><p>See also <a href="#Base.summarysize"><code>summarysize</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sizeof(Float32)
4

julia&gt; sizeof(ComplexF64)
16

julia&gt; sizeof(1.0)
8

julia&gt; sizeof(collect(1.0:10.0))
80</code></pre><p>If <code>DataType</code> <code>T</code> does not have a specific size, an error is thrown.</p><pre><code class="language-julia-repl">julia&gt; sizeof(AbstractArray)
ERROR: Abstract type AbstractArray does not have a definite size.
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L440-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isconcretetype" href="#Base.isconcretetype"><code>Base.isconcretetype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isconcretetype(T)</code></pre><p>Determine whether type <code>T</code> is a concrete type, meaning it could have direct instances (values <code>x</code> such that <code>typeof(x) === T</code>).</p><p>See also: <a href="#Base.isbits"><code>isbits</code></a>, <a href="#Base.isabstracttype"><code>isabstracttype</code></a>, <a href="#Base.issingletontype"><code>issingletontype</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isconcretetype(Complex)
false

julia&gt; isconcretetype(Complex{Float32})
true

julia&gt; isconcretetype(Vector{Complex})
true

julia&gt; isconcretetype(Vector{Complex{Float32}})
true

julia&gt; isconcretetype(Union{})
false

julia&gt; isconcretetype(Union{Int,String})
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L616-L644">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isbits" href="#Base.isbits"><code>Base.isbits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isbits(x)</code></pre><p>Return <code>true</code> if <code>x</code> is an instance of an <a href="#Base.isbitstype"><code>isbitstype</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L588-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isbitstype" href="#Base.isbitstype"><code>Base.isbitstype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isbitstype(T)</code></pre><p>Return <code>true</code> if type <code>T</code> is a &quot;plain data&quot; type, meaning it is immutable and contains no references to other values, only <code>primitive</code> types and other <code>isbitstype</code> types. Typical examples are numeric types such as <a href="../numbers/#Core.UInt8"><code>UInt8</code></a>, <a href="../numbers/#Core.Float64"><code>Float64</code></a>, and <a href="../numbers/#Base.Complex"><code>Complex{Float64}</code></a>. This category of types is significant since they are valid as type parameters, may not track <a href="#Core.isdefined"><code>isdefined</code></a> / <a href="../arrays/#Base.isassigned"><code>isassigned</code></a> status, and have a defined layout that is compatible with C.</p><p>See also <a href="#Base.isbits"><code>isbits</code></a>, <a href="#Base.isprimitivetype"><code>isprimitivetype</code></a>, <a href="#Base.ismutable"><code>ismutable</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isbitstype(Complex{Float64})
true

julia&gt; isbitstype(Complex)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L563-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.fieldtype" href="#Core.fieldtype"><code>Core.fieldtype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fieldtype(T, name::Symbol | index::Int)</code></pre><p>Determine the declared type of a field (specified by name or index) in a composite DataType <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; struct Foo
           x::Int64
           y::String
       end

julia&gt; fieldtype(Foo, :x)
Int64

julia&gt; fieldtype(Foo, 2)
String</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L715-L733">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fieldtypes" href="#Base.fieldtypes"><code>Base.fieldtypes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fieldtypes(T::Type)</code></pre><p>The declared types of all fields in a composite DataType <code>T</code> as a tuple.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; struct Foo
           x::Int64
           y::String
       end

julia&gt; fieldtypes(Foo)
(Int64, String)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L812-L830">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fieldcount" href="#Base.fieldcount"><code>Base.fieldcount</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fieldcount(t::Type)</code></pre><p>Get the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L772-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fieldoffset" href="#Base.fieldoffset"><code>Base.fieldoffset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fieldoffset(type, i)</code></pre><p>The byte offset of field <code>i</code> of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:</p><pre><code class="language-julia-repl">julia&gt; structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];

julia&gt; structinfo(Base.Filesystem.StatStruct)
13-element Vector{Tuple{UInt64, Symbol, Type}}:
 (0x0000000000000000, :desc, Union{RawFD, String})
 (0x0000000000000008, :device, UInt64)
 (0x0000000000000010, :inode, UInt64)
 (0x0000000000000018, :mode, UInt64)
 (0x0000000000000020, :nlink, Int64)
 (0x0000000000000028, :uid, UInt64)
 (0x0000000000000030, :gid, UInt64)
 (0x0000000000000038, :rdev, UInt64)
 (0x0000000000000040, :size, Int64)
 (0x0000000000000048, :blksize, Int64)
 (0x0000000000000050, :blocks, Int64)
 (0x0000000000000058, :mtime, Float64)
 (0x0000000000000060, :ctime, Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L687-L712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.datatype_alignment" href="#Base.datatype_alignment"><code>Base.datatype_alignment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.datatype_alignment(dt::DataType) -&gt; Int</code></pre><p>Memory allocation minimum alignment for instances of this type. Can be called on any <code>isconcretetype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L356-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.datatype_haspadding" href="#Base.datatype_haspadding"><code>Base.datatype_haspadding</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.datatype_haspadding(dt::DataType) -&gt; Bool</code></pre><p>Return whether the fields of instances of this type are packed in memory, with no intervening padding bytes. Can be called on any <code>isconcretetype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L395-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.datatype_pointerfree" href="#Base.datatype_pointerfree"><code>Base.datatype_pointerfree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.datatype_pointerfree(dt::DataType) -&gt; Bool</code></pre><p>Return whether instances of this type can contain references to gc-managed memory. Can be called on any <code>isconcretetype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L421-L426">source</a></section></article><h3 id="Special-values"><a class="docs-heading-anchor" href="#Special-values">Special values</a><a id="Special-values-1"></a><a class="docs-heading-anchor-permalink" href="#Special-values" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.typemin" href="#Base.typemin"><code>Base.typemin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">typemin(T)</code></pre><p>The lowest value representable by the given (real) numeric DataType <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; typemin(Float16)
-Inf16

julia&gt; typemin(Float32)
-Inf32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/int.jl#L742-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.typemax" href="#Base.typemax"><code>Base.typemax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">typemax(T)</code></pre><p>The highest value representable by the given (real) numeric <code>DataType</code>.</p><p>See also: <a href="#Base.floatmax"><code>floatmax</code></a>, <a href="#Base.typemin"><code>typemin</code></a>, <a href="#Base.eps-Tuple{Type{&lt;:AbstractFloat}}"><code>eps</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; typemax(Int8)
127

julia&gt; typemax(UInt32)
0xffffffff

julia&gt; typemax(Float64)
Inf

julia&gt; floatmax(Float32)  # largest finite floating point number
3.4028235f38</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/int.jl#L758-L779">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floatmin" href="#Base.floatmin"><code>Base.floatmin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">floatmin(T = Float64)</code></pre><p>Return the smallest positive normal number representable by the floating-point type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; floatmin(Float16)
Float16(6.104e-5)

julia&gt; floatmin(Float32)
1.1754944f-38

julia&gt; floatmin()
2.2250738585072014e-308</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/float.jl#L834-L851">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floatmax" href="#Base.floatmax"><code>Base.floatmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">floatmax(T = Float64)</code></pre><p>Return the largest finite number representable by the floating-point type <code>T</code>.</p><p>See also: <a href="#Base.typemax"><code>typemax</code></a>, <a href="#Base.floatmin"><code>floatmin</code></a>, <a href="#Base.eps-Tuple{Type{&lt;:AbstractFloat}}"><code>eps</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; floatmax(Float16)
Float16(6.55e4)

julia&gt; floatmax(Float32)
3.4028235f38

julia&gt; floatmax()
1.7976931348623157e308

julia&gt; typemax(Float64)
Inf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/float.jl#L854-L875">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.maxintfloat" href="#Base.maxintfloat"><code>Base.maxintfloat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maxintfloat(T=Float64)</code></pre><p>The largest consecutive integer-valued floating-point number that is exactly represented in the given floating-point type <code>T</code> (which defaults to <code>Float64</code>).</p><p>That is, <code>maxintfloat</code> returns the smallest positive integer-valued floating-point number <code>n</code> such that <code>n+1</code> is <em>not</em> exactly representable in the type <code>T</code>.</p><p>When an <code>Integer</code>-type value is needed, use <code>Integer(maxintfloat(T))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/floatfuncs.jl#L19-L29">source</a></section><section><div><pre><code class="language-none">maxintfloat(T, S)</code></pre><p>The largest consecutive integer representable in the given floating-point type <code>T</code> that also does not exceed the maximum integer representable by the integer type <code>S</code>.  Equivalently, it is the minimum of <code>maxintfloat(T)</code> and <a href="#Base.typemax"><code>typemax(S)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/floatfuncs.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eps-Tuple{Type{&lt;:AbstractFloat}}" href="#Base.eps-Tuple{Type{&lt;:AbstractFloat}}"><code>Base.eps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eps(::Type{T}) where T&lt;:AbstractFloat
eps()</code></pre><p>Return the <em>machine epsilon</em> of the floating point type <code>T</code> (<code>T = Float64</code> by default). This is defined as the gap between 1 and the next largest value representable by <code>typeof(one(T))</code>, and is equivalent to <code>eps(one(T))</code>.  (Since <code>eps(T)</code> is a bound on the <em>relative error</em> of <code>T</code>, it is a &quot;dimensionless&quot; quantity like <a href="../numbers/#Base.one"><code>one</code></a>.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eps()
2.220446049250313e-16

julia&gt; eps(Float32)
1.1920929f-7

julia&gt; 1.0 + eps()
1.0000000000000002

julia&gt; 1.0 + eps()/2
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/float.jl#L881-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eps-Tuple{AbstractFloat}" href="#Base.eps-Tuple{AbstractFloat}"><code>Base.eps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eps(x::AbstractFloat)</code></pre><p>Return the <em>unit in last place</em> (ulp) of <code>x</code>. This is the distance between consecutive representable floating point values at <code>x</code>. In most cases, if the distance on either side of <code>x</code> is different, then the larger of the two is taken, that is</p><pre><code class="language-none">eps(x) == max(x-prevfloat(x), nextfloat(x)-x)</code></pre><p>The exceptions to this rule are the smallest and largest finite values (e.g. <code>nextfloat(-Inf)</code> and <code>prevfloat(Inf)</code> for <a href="../numbers/#Core.Float64"><code>Float64</code></a>), which round to the smaller of the values.</p><p>The rationale for this behavior is that <code>eps</code> bounds the floating point rounding error. Under the default <code>RoundNearest</code> rounding mode, if <span>$y$</span> is a real number and <span>$x$</span> is the nearest floating point number to <span>$y$</span>, then</p><p class="math-container">\[|y-x| \leq \operatorname{eps}(x)/2.\]</p><p>See also: <a href="../numbers/#Base.nextfloat"><code>nextfloat</code></a>, <a href="../numbers/#Base.issubnormal"><code>issubnormal</code></a>, <a href="#Base.floatmax"><code>floatmax</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eps(1.0)
2.220446049250313e-16

julia&gt; eps(prevfloat(2.0))
2.220446049250313e-16

julia&gt; eps(2.0)
4.440892098500626e-16

julia&gt; x = prevfloat(Inf)      # largest finite Float64
1.7976931348623157e308

julia&gt; x + eps(x)/2            # rounds up
Inf

julia&gt; x + prevfloat(eps(x)/2) # rounds down
1.7976931348623157e308</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/float.jl#L907-L950">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.instances" href="#Base.instances"><code>Base.instances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">instances(T::Type)</code></pre><p>Return a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see <code>@enum</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @enum Color red blue green

julia&gt; instances(Color)
(red, blue, green)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L835-L848">source</a></section></article><h2 id="Special-Types"><a class="docs-heading-anchor" href="#Special-Types">Special Types</a><a id="Special-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Core.Any" href="#Core.Any"><code>Core.Any</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Any::DataType</code></pre><p><code>Any</code> is the union of all types. It has the defining property <code>isa(x, Any) == true</code> for any <code>x</code>. <code>Any</code> therefore describes the entire universe of possible values. For example <code>Integer</code> is a subset of <code>Any</code> that includes <code>Int</code>, <code>Int8</code>, and other integer types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2491-L2497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Union" href="#Core.Union"><code>Core.Union</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Union{Types...}</code></pre><p>A type union is an abstract type which includes all instances of any of its argument types. The empty union <a href="#Union{}"><code>Union{}</code></a> is the bottom type of Julia.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 :: IntOrString
1

julia&gt; &quot;Hello!&quot; :: IntOrString
&quot;Hello!&quot;

julia&gt; 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got a value of type Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2515-L2535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Union{}" href="#Union{}"><code>Union{}</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">Union{}</code></pre><p><code>Union{}</code>, the empty <a href="#Core.Union"><code>Union</code></a> of types, is the type that has no values. That is, it has the defining property <code>isa(x, Union{}) == false</code> for any <code>x</code>. <code>Base.Bottom</code> is defined as its alias and the type of <code>Union{}</code> is <code>Core.TypeofBottom</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isa(nothing, Union{})
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2500-L2512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.UnionAll" href="#Core.UnionAll"><code>Core.UnionAll</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UnionAll</code></pre><p>A union of types over all values of a type parameter. <code>UnionAll</code> is used to describe parametric types where the values of some parameters are not known.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; typeof(Vector)
UnionAll

julia&gt; typeof(Vector{Int})
DataType</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2539-L2553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Tuple" href="#Core.Tuple"><code>Core.Tuple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Tuple{Types...}</code></pre><p>Tuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of a function&#39;s arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. Tuple types may have any number of parameters.</p><p>Tuple types are covariant in their parameters: <code>Tuple{Int}</code> is a subtype of <code>Tuple{Any}</code>. Therefore <code>Tuple{Any}</code> is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have field names; fields are only accessed by index.</p><p>See the manual section on <a href="base/@ref">Tuple Types</a>.</p><p>See also <a href="#Core.Vararg"><code>Vararg</code></a>, <a href="#Core.NTuple"><code>NTuple</code></a>, <a href="#Core.tuple"><code>tuple</code></a>, <a href="#Core.NamedTuple"><code>NamedTuple</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2622-L2636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.NTuple" href="#Core.NTuple"><code>Core.NTuple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NTuple{N, T}</code></pre><p>A compact way of representing the type for a tuple of length <code>N</code> where all elements are of type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isa((1, 2, 3, 4, 5, 6), NTuple{6, Int})
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/tuple.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.NamedTuple" href="#Core.NamedTuple"><code>Core.NamedTuple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NamedTuple</code></pre><p><code>NamedTuple</code>s are, as their name suggests, named <a href="#Core.Tuple"><code>Tuple</code></a>s. That is, they&#39;re a tuple-like collection of values, where each entry has a unique name, represented as a <a href="#Core.Symbol"><code>Symbol</code></a>. Like <code>Tuple</code>s, <code>NamedTuple</code>s are immutable; neither the names nor the values can be modified in place after construction.</p><p>Accessing the value associated with a name in a named tuple can be done using field access syntax, e.g. <code>x.a</code>, or using <a href="../collections/#Base.getindex"><code>getindex</code></a>, e.g. <code>x[:a]</code> or <code>x[(:a, :b)]</code>. A tuple of the names can be obtained using <a href="../collections/#Base.keys"><code>keys</code></a>, and a tuple of the values can be obtained using <a href="../collections/#Base.values"><code>values</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Iteration over <code>NamedTuple</code>s produces the <em>values</em> without the names. (See example below.) To iterate over the name-value pairs, use the <a href="../collections/#Base.pairs"><code>pairs</code></a> function.</p></div></div><p>The <a href="#Base.@NamedTuple"><code>@NamedTuple</code></a> macro can be used for conveniently declaring <code>NamedTuple</code> types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = (a=1, b=2)
(a = 1, b = 2)

julia&gt; x.a
1

julia&gt; x[:a]
1

julia&gt; x[(:a,)]
(a = 1,)

julia&gt; keys(x)
(:a, :b)

julia&gt; values(x)
(1, 2)

julia&gt; collect(x)
2-element Vector{Int64}:
 1
 2

julia&gt; collect(pairs(x))
2-element Vector{Pair{Symbol, Int64}}:
 :a =&gt; 1
 :b =&gt; 2</code></pre><p>In a similar fashion as to how one can define keyword arguments programmatically, a named tuple can be created by giving a pair <code>name::Symbol =&gt; value</code> or splatting an iterator yielding such pairs after a semicolon inside a tuple literal:</p><pre><code class="language-julia-repl">julia&gt; (; :a =&gt; 1)
(a = 1,)

julia&gt; keys = (:a, :b, :c); values = (1, 2, 3);

julia&gt; (; zip(keys, values)...)
(a = 1, b = 2, c = 3)</code></pre><p>As in keyword arguments, identifiers and dot expressions imply names:</p><pre><code class="language-julia-repl">julia&gt; x = 0
0

julia&gt; t = (; x)
(x = 0,)

julia&gt; (; t.x)
(x = 0,)</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Implicit names from identifiers and dot expressions are available as of Julia 1.5.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>Use of <code>getindex</code> methods with multiple <code>Symbol</code>s is available as of Julia 1.7.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/namedtuple.jl#L3-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@NamedTuple" href="#Base.@NamedTuple"><code>Base.@NamedTuple</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@NamedTuple{key1::Type1, key2::Type2, ...}
@NamedTuple begin key1::Type1; key2::Type2; ...; end</code></pre><p>This macro gives a more convenient syntax for declaring <code>NamedTuple</code> types. It returns a <code>NamedTuple</code> type with the given keys and types, equivalent to <code>NamedTuple{(:key1, :key2, ...), Tuple{Type1,Type2,...}}</code>. If the <code>::Type</code> declaration is omitted, it is taken to be <code>Any</code>.   The <code>begin ... end</code> form allows the declarations to be split across multiple lines (similar to a <code>struct</code> declaration), but is otherwise equivalent.</p><p>For example, the tuple <code>(a=3.1, b=&quot;hello&quot;)</code> has a type <code>NamedTuple{(:a, :b),Tuple{Float64,String}}</code>, which can also be declared via <code>@NamedTuple</code> as:</p><pre><code class="language-julia-repl">julia&gt; @NamedTuple{a::Float64, b::String}
NamedTuple{(:a, :b), Tuple{Float64, String}}

julia&gt; @NamedTuple begin
           a::Float64
           b::String
       end
NamedTuple{(:a, :b), Tuple{Float64, String}}</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This macro is available as of Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/namedtuple.jl#L382-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Val" href="#Base.Val"><code>Base.Val</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Val(c)</code></pre><p>Return <code>Val{c}()</code>, which contains no run-time data. Types like this can be used to pass the information between functions through the value <code>c</code>, which must be an <code>isbits</code> value or a <code>Symbol</code>. The intent of this construct is to be able to dispatch on constants directly (at compile time) without having to test the value of the constant at run time.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; f(::Val{true}) = &quot;Good&quot;
f (generic function with 1 method)

julia&gt; f(::Val{false}) = &quot;Bad&quot;
f (generic function with 2 methods)

julia&gt; f(Val(true))
&quot;Good&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L691-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Vararg" href="#Core.Vararg"><code>Core.Vararg</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Vararg{T,N}</code></pre><p>The last parameter of a tuple type <a href="#Core.Tuple"><code>Tuple</code></a> can be the special value <code>Vararg</code>, which denotes any number of trailing elements. <code>Vararg{T,N}</code> corresponds to exactly <code>N</code> elements of type <code>T</code>. Finally <code>Vararg{T}</code> corresponds to zero or more elements of type <code>T</code>. <code>Vararg</code> tuple types are used to represent the arguments accepted by varargs methods (see the section on <a href="base/@ref">Varargs Functions</a> in the manual.)</p><p>See also <a href="#Core.NTuple"><code>NTuple</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; mytupletype = Tuple{AbstractString, Vararg{Int}}
Tuple{AbstractString, Vararg{Int64}}

julia&gt; isa((&quot;1&quot;,), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1,2), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1,2,3.0), mytupletype)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2592-L2619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Nothing" href="#Core.Nothing"><code>Core.Nothing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Nothing</code></pre><p>A type with no fields that is the type of <a href="../constants/#Core.nothing"><code>nothing</code></a>.</p><p>See also: <a href="#Base.isnothing"><code>isnothing</code></a>, <a href="#Base.Some"><code>Some</code></a>, <a href="#Base.Missing"><code>Missing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1280-L1286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isnothing" href="#Base.isnothing"><code>Base.isnothing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnothing(x)</code></pre><p>Return <code>true</code> if <code>x === nothing</code>, and return <code>false</code> if not.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div><p>See also <a href="#Base.something"><code>something</code></a>, <a href="#Base.notnothing"><code>notnothing</code></a>, <a href="#Base.ismissing"><code>ismissing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/some.jl#L60-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.notnothing" href="#Base.notnothing"><code>Base.notnothing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">notnothing(x)</code></pre><p>Throw an error if <code>x === nothing</code>, and return <code>x</code> if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/some.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Some" href="#Base.Some"><code>Base.Some</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Some{T}</code></pre><p>A wrapper type used in <code>Union{Some{T}, Nothing}</code> to distinguish between the absence of a value (<a href="../constants/#Core.nothing"><code>nothing</code></a>) and the presence of a <code>nothing</code> value (i.e. <code>Some(nothing)</code>).</p><p>Use <a href="#Base.something"><code>something</code></a> to access the value wrapped by a <code>Some</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/some.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.something" href="#Base.something"><code>Base.something</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">something(x...)</code></pre><p>Return the first value in the arguments which is not equal to <a href="../constants/#Core.nothing"><code>nothing</code></a>, if any. Otherwise throw an error. Arguments of type <a href="#Base.Some"><code>Some</code></a> are unwrapped.</p><p>See also <a href="#Base.coalesce"><code>coalesce</code></a>, <a href="#Base.skipmissing"><code>skipmissing</code></a>, <a href="#Base.@something"><code>@something</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; something(nothing, 1)
1

julia&gt; something(Some(1), nothing)
1

julia&gt; something(missing, nothing)
missing

julia&gt; something(nothing, nothing)
ERROR: ArgumentError: No value arguments present</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/some.jl#L73-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@something" href="#Base.@something"><code>Base.@something</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@something(x...)</code></pre><p>Short-circuiting version of <a href="#Base.something"><code>something</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; f(x) = (println(&quot;f($x)&quot;); nothing);

julia&gt; a = 1;

julia&gt; a = @something a f(2) f(3) error(&quot;Unable to find default for `a`&quot;)
1

julia&gt; b = nothing;

julia&gt; b = @something b f(2) f(3) error(&quot;Unable to find default for `b`&quot;)
f(2)
f(3)
ERROR: Unable to find default for `b`
[...]

julia&gt; b = @something b f(2) f(3) Some(nothing)
f(2)
f(3)

julia&gt; b === nothing
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>This macro is available as of Julia 1.7.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/some.jl#L105-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Enums.Enum" href="#Base.Enums.Enum"><code>Base.Enums.Enum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Enum{T&lt;:Integer}</code></pre><p>The abstract supertype of all enumerated types defined with <a href="#Base.Enums.@enum"><code>@enum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/Enums.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Enums.@enum" href="#Base.Enums.@enum"><code>Base.Enums.@enum</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@enum EnumName[::BaseType] value1[=x] value2[=y]</code></pre><p>Create an <code>Enum{BaseType}</code> subtype with name <code>EnumName</code> and enum member values of <code>value1</code> and <code>value2</code> with optional assigned values of <code>x</code> and <code>y</code>, respectively. <code>EnumName</code> can be used just like other types and enum member values as regular values, such as</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @enum Fruit apple=1 orange=2 kiwi=3

julia&gt; f(x::Fruit) = &quot;I&#39;m a Fruit with value: $(Int(x))&quot;
f (generic function with 1 method)

julia&gt; f(apple)
&quot;I&#39;m a Fruit with value: 1&quot;

julia&gt; Fruit(1)
apple::Fruit = 1</code></pre><p>Values can also be specified inside a <code>begin</code> block, e.g.</p><pre><code class="language-julia">@enum EnumName begin
    value1
    value2
end</code></pre><p><code>BaseType</code>, which defaults to <a href="../numbers/#Core.Int32"><code>Int32</code></a>, must be a primitive subtype of <code>Integer</code>. Member values can be converted between the enum type and <code>BaseType</code>. <code>read</code> and <code>write</code> perform these conversions automatically. In case the enum is created with a non-default <code>BaseType</code>, <code>Integer(value1)</code> will return the integer <code>value1</code> with the type <code>BaseType</code>.</p><p>To list all the instances of an enum use <code>instances</code>, e.g.</p><pre><code class="language-julia-repl">julia&gt; instances(Fruit)
(apple, orange, kiwi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/Enums.jl#L87-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Expr" href="#Core.Expr"><code>Core.Expr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Expr(head::Symbol, args...)</code></pre><p>A type representing compound expressions in parsed julia code (ASTs). Each expression consists of a <code>head</code> <code>Symbol</code> identifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and subexpressions (e.g. the arguments of a call). The subexpressions are stored in a <code>Vector{Any}</code> field called <code>args</code>.</p><p>See the manual chapter on <a href="../../manual/metaprogramming/#Metaprogramming">Metaprogramming</a> and the developer documentation <a href="base/@ref">Julia ASTs</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Expr(:call, :+, 1, 2)
:(1 + 2)

julia&gt; dump(:(a ? b : c))
Expr
  head: Symbol if
  args: Array{Any}((3,))
    1: Symbol a
    2: Symbol b
    3: Symbol c</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L534-L559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Symbol" href="#Core.Symbol"><code>Core.Symbol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Symbol</code></pre><p>The type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or label to identify an entity (e.g. as a dictionary key). <code>Symbol</code>s can be entered using the <code>:</code> quote operator:</p><pre><code class="language-julia-repl">julia&gt; :name
:name

julia&gt; typeof(:name)
Symbol

julia&gt; x = 42
42

julia&gt; eval(:x)
42</code></pre><p><code>Symbol</code>s can also be constructed from strings or other values by calling the constructor <code>Symbol(x...)</code>.</p><p><code>Symbol</code>s are immutable and should be compared using <code>===</code>. The implementation re-uses the same object for all <code>Symbol</code>s with the same name, so comparison tends to be efficient (it can just compare pointers).</p><p>Unlike strings, <code>Symbol</code>s are &quot;atomic&quot; or &quot;scalar&quot; entities that do not support iteration over characters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1875-L1903">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Symbol-Tuple" href="#Core.Symbol-Tuple"><code>Core.Symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Symbol(x...) -&gt; Symbol</code></pre><p>Create a <a href="#Core.Symbol"><code>Symbol</code></a> by concatenating the string representations of the arguments together.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Symbol(&quot;my&quot;, &quot;name&quot;)
:myname

julia&gt; Symbol(&quot;day&quot;, 4)
:day4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1906-L1919">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Module" href="#Core.Module"><code>Core.Module</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Module</code></pre><p>A <code>Module</code> is a separate global variable workspace. See <a href="#module"><code>module</code></a> and the <a href="../../manual/modules/#modules">manual section about modules</a> for details.</p><pre><code class="language-none">Module(name::Symbol=:anonymous, std_imports=true, default_names=true)</code></pre><p>Return a module with the specified name. A <code>baremodule</code> corresponds to <code>Module(:ModuleName, false)</code></p><p>An empty module containing no names at all can be created with <code>Module(:ModuleName, false, false)</code>. This module will not import <code>Base</code> or <code>Core</code> and does not contain a reference to itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2812-L2823">source</a></section></article><h2 id="Generic-Functions"><a class="docs-heading-anchor" href="#Generic-Functions">Generic Functions</a><a id="Generic-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Core.Function" href="#Core.Function"><code>Core.Function</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Function</code></pre><p>Abstract type of all functions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isa(+, Function)
true

julia&gt; typeof(sin)
typeof(sin) (singleton type of function sin, subtype of Function)

julia&gt; ans &lt;: Function
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1356-L1372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hasmethod" href="#Base.hasmethod"><code>Base.hasmethod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hasmethod(f, t::Type{&lt;:Tuple}[, kwnames]; world=get_world_counter()) -&gt; Bool</code></pre><p>Determine whether the given generic function has a method matching the given <code>Tuple</code> of argument types with the upper bound of world age given by <code>world</code>.</p><p>If a tuple of keyword argument names <code>kwnames</code> is provided, this also checks whether the method of <code>f</code> matching <code>t</code> has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with <code>kwargs...</code>, any names given in <code>kwnames</code> are considered valid. Otherwise the provided names must be a subset of the method&#39;s keyword arguments.</p><p>See also <a href="#Core.applicable"><code>applicable</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>Providing keyword argument names requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; hasmethod(length, Tuple{Array})
true

julia&gt; f(; oranges=0) = oranges;

julia&gt; hasmethod(f, Tuple{}, (:oranges,))
true

julia&gt; hasmethod(f, Tuple{}, (:apples, :bananas))
false

julia&gt; g(; xs...) = 4;

julia&gt; hasmethod(g, Tuple{}, (:a, :b, :c, :d))  # g accepts arbitrary kwargs
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L1480-L1515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.applicable" href="#Core.applicable"><code>Core.applicable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applicable(f, args...) -&gt; Bool</code></pre><p>Determine whether the given generic function has a method applicable to the given arguments.</p><p>See also <a href="#Base.hasmethod"><code>hasmethod</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; function f(x, y)
           x + y
       end;

julia&gt; applicable(f, 1)
false

julia&gt; applicable(f, 1, 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1661-L1680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isambiguous" href="#Base.isambiguous"><code>Base.isambiguous</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.isambiguous(m1, m2; ambiguous_bottom=false) -&gt; Bool</code></pre><p>Determine whether two methods <code>m1</code> and <code>m2</code> may be ambiguous for some call signature. This test is performed in the context of other methods of the same function; in isolation, <code>m1</code> and <code>m2</code> might be ambiguous, but if a third method resolving the ambiguity has been defined, this returns <code>false</code>. Alternatively, in isolation <code>m1</code> and <code>m2</code> might be ordered, but if a third method cannot be sorted with them, they may cause an ambiguity together.</p><p>For parametric types, the <code>ambiguous_bottom</code> keyword argument controls whether <code>Union{}</code> counts as an ambiguous intersection of type parameters – when <code>true</code>, it is considered ambiguous, when <code>false</code> it is not.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; foo(x::Complex{&lt;:Integer}) = 1
foo (generic function with 1 method)

julia&gt; foo(x::Complex{&lt;:Rational}) = 2
foo (generic function with 2 methods)

julia&gt; m1, m2 = collect(methods(foo));

julia&gt; typeintersect(m1.sig, m2.sig)
Tuple{typeof(foo), Complex{Union{}}}

julia&gt; Base.isambiguous(m1, m2, ambiguous_bottom=true)
true

julia&gt; Base.isambiguous(m1, m2, ambiguous_bottom=false)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L1579-L1612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.invoke" href="#Core.invoke"><code>Core.invoke</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">invoke(f, argtypes::Type, args...; kwargs...)</code></pre><p>Invoke a method for the given generic function <code>f</code> matching the specified types <code>argtypes</code> on the specified arguments <code>args</code> and passing the keyword arguments <code>kwargs</code>. The arguments <code>args</code> must conform with the specified types in <code>argtypes</code>, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).</p><p>Be careful when using <code>invoke</code> for functions that you don&#39;t write.  What definition is used for given <code>argtypes</code> is an implementation detail unless the function is explicitly states that calling with certain <code>argtypes</code> is a part of public API.  For example, the change between <code>f1</code> and <code>f2</code> in the example below is usually considered compatible because the change is invisible by the caller with a normal (non-<code>invoke</code>) call.  However, the change is visible if you use <code>invoke</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; f(x::Real) = x^2;

julia&gt; f(x::Integer) = 1 + invoke(f, Tuple{Real}, x);

julia&gt; f(2)
5

julia&gt; f1(::Integer) = Integer
       f1(::Real) = Real;

julia&gt; f2(x::Real) = _f2(x)
       _f2(::Integer) = Integer
       _f2(_) = Real;

julia&gt; f1(1)
Integer

julia&gt; f2(1)
Integer

julia&gt; invoke(f1, Tuple{Real}, 1)
Real

julia&gt; invoke(f2, Tuple{Real}, 1)
Integer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1683-L1728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@invoke" href="#Base.@invoke"><code>Base.@invoke</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@invoke f(arg::T, ...; kwargs...)</code></pre><p>Provides a convenient way to call <a href="#Core.invoke"><code>invoke</code></a>; <code>@invoke f(arg1::T1, arg2::T2; kwargs...)</code> will be expanded into <code>invoke(f, Tuple{T1,T2}, arg1, arg2; kwargs...)</code>. When an argument&#39;s type annotation is omitted, it&#39;s specified as <code>Any</code> argument, e.g. <code>@invoke f(arg1::T, arg2)</code> will be expanded into <code>invoke(f, Tuple{T,Any}, arg1, arg2)</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>This macro requires Julia 1.7 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L1767-L1777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.invokelatest" href="#Base.invokelatest"><code>Base.invokelatest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">invokelatest(f, args...; kwargs...)</code></pre><p>Calls <code>f(args...; kwargs...)</code>, but guarantees that the most recent method of <code>f</code> will be executed.   This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function <code>f</code>. (The drawback is that <code>invokelatest</code> is somewhat slower than calling <code>f</code> directly, and the type of the result cannot be inferred by the compiler.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L716-L725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@invokelatest" href="#Base.@invokelatest"><code>Base.@invokelatest</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@invokelatest f(args...; kwargs...)</code></pre><p>Provides a convenient way to call <a href="#Base.invokelatest"><code>Base.invokelatest</code></a>. <code>@invokelatest f(args...; kwargs...)</code> will simply be expanded into <code>Base.invokelatest(f, args...; kwargs...)</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>This macro requires Julia 1.7 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L1787-L1796">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="new" href="#new"><code>new</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">new, or new{A,B,...}</code></pre><p>Special function available to inner constructors which creates a new object of the type. The form new{A,B,...} explicitly specifies values of parameters for parametric types. See the manual section on <a href="../../manual/constructors/#man-inner-constructor-methods">Inner Constructor Methods</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1190-L1197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:|&gt;" href="#Base.:|&gt;"><code>Base.:|&gt;</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">|&gt;(x, f)</code></pre><p>Applies a function to the preceding argument. This allows for easy function chaining.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; [1:5;] |&gt; (x-&gt;x.^2) |&gt; sum |&gt; inv
0.01818181818181818</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L900-L910">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘" href="#Base.:∘"><code>Base.:∘</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">f ∘ g</code></pre><p>Compose functions: i.e. <code>(f ∘ g)(args...; kwargs...)</code> means <code>f(g(args...; kwargs...))</code>. The <code>∘</code> symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing <code>\circ&lt;tab&gt;</code>.</p><p>Function composition also works in prefix form: <code>∘(f, g)</code> is the same as <code>f ∘ g</code>. The prefix form supports composition of multiple functions: <code>∘(f, g, h) = f ∘ g ∘ h</code> and splatting <code>∘(fs...)</code> for composing an iterable collection of functions.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>Multiple function composition requires at least Julia 1.4.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Composition of one function ∘(f) requires at least Julia 1.5.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>Using keyword arguments requires at least Julia 1.7.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; map(uppercase∘first, [&quot;apple&quot;, &quot;banana&quot;, &quot;carrot&quot;])
3-element Vector{Char}:
 &#39;A&#39;: ASCII/Unicode U+0041 (category Lu: Letter, uppercase)
 &#39;B&#39;: ASCII/Unicode U+0042 (category Lu: Letter, uppercase)
 &#39;C&#39;: ASCII/Unicode U+0043 (category Lu: Letter, uppercase)

julia&gt; fs = [
           x -&gt; 2x
           x -&gt; x/2
           x -&gt; x-1
           x -&gt; x+1
       ];

julia&gt; ∘(fs...)(3)
3.0</code></pre><p>See also <a href="#Base.ComposedFunction"><code>ComposedFunction</code></a>, <a href="../math/#Base.:!"><code>!f::Function</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L954-L992">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ComposedFunction" href="#Base.ComposedFunction"><code>Base.ComposedFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ComposedFunction{Outer,Inner} &lt;: Function</code></pre><p>Represents the composition of two callable objects <code>outer::Outer</code> and <code>inner::Inner</code>. That is</p><pre><code class="language-julia">ComposedFunction(outer, inner)(args...; kw...) === outer(inner(args...; kw...))</code></pre><p>The preferred way to construct instance of <code>ComposedFunction</code> is to use the composition operator <a href="#Base.:∘"><code>∘</code></a>:</p><pre><code class="language-julia-repl">julia&gt; sin ∘ cos === ComposedFunction(sin, cos)
true

julia&gt; typeof(sin∘cos)
ComposedFunction{typeof(sin), typeof(cos)}</code></pre><p>The composed pieces are stored in the fields of <code>ComposedFunction</code> and can be retrieved as follows:</p><pre><code class="language-julia-repl">julia&gt; composition = sin ∘ cos
sin ∘ cos

julia&gt; composition.outer === sin
true

julia&gt; composition.inner === cos
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>ComposedFunction requires at least Julia 1.6. In earlier versions <code>∘</code> returns an anonymous function instead.</p></div></div><p>See also <a href="#Base.:∘"><code>∘</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L995-L1025">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.splat" href="#Base.splat"><code>Base.splat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">splat(f)</code></pre><p>Defined as</p><pre><code class="language-julia">    splat(f) = args-&gt;f(args...)</code></pre><p>i.e. given a function returns a new function that takes one argument and splats its argument into the original function. This is useful as an adaptor to pass a multi-argument function in a context that expects a single argument, but passes a tuple as that single argument.</p><p><strong>Example usage:</strong></p><pre><code class="language-julia-repl">julia&gt; map(Base.splat(+), zip(1:3,4:6))
3-element Vector{Int64}:
 5
 7
 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L1202-L1222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Fix1" href="#Base.Fix1"><code>Base.Fix1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Fix1(f, x)</code></pre><p>A type representing a partially-applied version of the two-argument function <code>f</code>, with the first argument fixed to the value &quot;x&quot;. In other words, <code>Fix1(f, x)</code> behaves similarly to <code>y-&gt;f(x, y)</code>.</p><p>See also <a href="#Base.Fix2"><code>Fix2</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L1079-L1087">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Fix2" href="#Base.Fix2"><code>Base.Fix2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Fix2(f, x)</code></pre><p>A type representing a partially-applied version of the two-argument function <code>f</code>, with the second argument fixed to the value &quot;x&quot;. In other words, <code>Fix2(f, x)</code> behaves similarly to <code>y-&gt;f(y, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/operators.jl#L1098-L1104">source</a></section></article><h2 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Core.eval" href="#Core.eval"><code>Core.eval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Core.eval(m::Module, expr)</code></pre><p>Evaluate an expression in the given module and return the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.MainInclude.eval" href="#Base.MainInclude.eval"><code>Base.MainInclude.eval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval(expr)</code></pre><p>Evaluate an expression in the global scope of the containing module. Every <code>Module</code> (except those defined with <code>baremodule</code>) has its own 1-argument definition of <code>eval</code>, which evaluates expressions in that module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/client.jl#L481-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@eval" href="#Base.@eval"><code>Base.@eval</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@eval [mod,] ex</code></pre><p>Evaluate an expression with values interpolated into it using <code>eval</code>. If two arguments are provided, the first is the module to evaluate in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L220-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.evalfile" href="#Base.evalfile"><code>Base.evalfile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evalfile(path::AbstractString, args::Vector{String}=String[])</code></pre><p>Load the file using <a href="#Base.include"><code>include</code></a>, evaluate all expressions, and return the value of the last one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L1498-L1503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.esc" href="#Base.esc"><code>Base.esc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">esc(e)</code></pre><p>Only valid in the context of an <a href="#Core.Expr"><code>Expr</code></a> returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the <a href="../../manual/metaprogramming/#man-macros">Macros</a> section of the Metaprogramming chapter of the manual for more details and examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L494-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@inbounds" href="#Base.@inbounds"><code>Base.@inbounds</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@inbounds(blk)</code></pre><p>Eliminates array bounds checking within expressions.</p><p>In the example below the in-range check for referencing element <code>i</code> of array <code>A</code> is skipped to improve performance.</p><pre><code class="language-julia">function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i in eachindex(A)
        @inbounds r += A[i]
    end
    return r
end</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Using <code>@inbounds</code> may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually. Only use <code>@inbounds</code> when it is certain from the information locally available that all accesses are in bounds.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L551-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@boundscheck" href="#Base.@boundscheck"><code>Base.@boundscheck</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@boundscheck(blk)</code></pre><p>Annotates the expression <code>blk</code> as a bounds checking block, allowing it to be elided by <a href="#Base.@inbounds"><code>@inbounds</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function in which <code>@boundscheck</code> is written must be inlined into its caller in order for <code>@inbounds</code> to have effect.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @inline function g(A, i)
           @boundscheck checkbounds(A, i)
           return &quot;accessing ($A)[$i]&quot;
       end;

julia&gt; f1() = return g(1:2, -1);

julia&gt; f2() = @inbounds return g(1:2, -1);

julia&gt; f1()
ERROR: BoundsError: attempt to access 2-element UnitRange{Int64} at index [-1]
Stacktrace:
 [1] throw_boundserror(::UnitRange{Int64}, ::Tuple{Int64}) at ./abstractarray.jl:455
 [2] checkbounds at ./abstractarray.jl:420 [inlined]
 [3] g at ./none:2 [inlined]
 [4] f1() at ./none:1
 [5] top-level scope

julia&gt; f2()
&quot;accessing (1:2)[-1]&quot;</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>@boundscheck</code> annotation allows you, as a library writer, to opt-in to allowing <em>other code</em> to remove your bounds checks with <a href="#Base.@inbounds"><code>@inbounds</code></a>. As noted there, the caller must verify—using information they can access—that their accesses are valid before using <code>@inbounds</code>. For indexing into your <a href="../arrays/#Core.AbstractArray"><code>AbstractArray</code></a> subclasses, for example, this involves checking the indices against its <a href="../arrays/#Base.axes-Tuple{Any}"><code>axes</code></a>. Therefore, <code>@boundscheck</code> annotations should only be added to a <a href="../collections/#Base.getindex"><code>getindex</code></a> or <a href="../collections/#Base.setindex!"><code>setindex!</code></a> implementation after you are certain its behavior is correct.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L503-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@propagate_inbounds" href="#Base.@propagate_inbounds"><code>Base.@propagate_inbounds</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@propagate_inbounds</code></pre><p>Tells the compiler to inline a function while retaining the caller&#39;s inbounds context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L637-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@inline" href="#Base.@inline"><code>Base.@inline</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@inline</code></pre><p>Give a hint to the compiler that this function is worth inlining.</p><p>Small functions typically do not need the <code>@inline</code> annotation, as the compiler does it automatically. By using <code>@inline</code> on bigger functions, an extra nudge can be given to the compiler to inline it.</p><p><code>@inline</code> can be applied immediately before the definition or in its function body.</p><pre><code class="language-julia"># annotate long-form definition
@inline function longdef(x)
    ...
end

# annotate short-form definition
@inline shortdef(x) = ...

# annotate anonymous function that a `do` block creates
f() do
    @inline
    ...
end</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>The usage within a function body requires at least Julia 1.8.</p></div></div><hr/><pre><code class="language-none">@inline block</code></pre><p>Give a hint to the compiler that calls within <code>block</code> are worth inlining.</p><pre><code class="language-julia"># The compiler will try to inline `f`
@inline f(...)

# The compiler will try to inline `f`, `g` and `+`
@inline f(...) + g(...)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A callsite annotation always has the precedence over the annotation applied to the definition of the called function:</p><pre><code class="language-julia">@noinline function explicit_noinline(args...)
    # body
end

let
    @inline explicit_noinline(args...) # will be inlined
end</code></pre></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When there are nested callsite annotations, the innermost annotation has the precedence:</p><pre><code class="language-julia">@noinline let a0, b0 = ...
    a = @inline f(a0)  # the compiler will try to inline this call
    b = f(b0)          # the compiler will NOT try to inline this call
    return a, b
end</code></pre></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Although a callsite annotation will try to force inlining in regardless of the cost model, there are still chances it can&#39;t succeed in it. Especially, recursive calls can not be inlined even if they are annotated as <code>@inline</code>d.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>The callsite annotation requires at least Julia 1.8.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L183-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@noinline" href="#Base.@noinline"><code>Base.@noinline</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@noinline</code></pre><p>Give a hint to the compiler that it should not inline a function.</p><p>Small functions are typically inlined automatically. By using <code>@noinline</code> on small functions, auto-inlining can be prevented.</p><p><code>@noinline</code> can be applied immediately before the definition or in its function body.</p><pre><code class="language-julia"># annotate long-form definition
@noinline function longdef(x)
    ...
end

# annotate short-form definition
@noinline shortdef(x) = ...

# annotate anonymous function that a `do` block creates
f() do
    @noinline
    ...
end</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>The usage within a function body requires at least Julia 1.8.</p></div></div><hr/><pre><code class="language-none">@noinline block</code></pre><p>Give a hint to the compiler that it should not inline the calls within <code>block</code>.</p><pre><code class="language-julia"># The compiler will try to not inline `f`
@noinline f(...)

# The compiler will try to not inline `f`, `g` and `+`
@noinline f(...) + g(...)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A callsite annotation always has the precedence over the annotation applied to the definition of the called function:</p><pre><code class="language-julia">@inline function explicit_inline(args...)
    # body
end

let
    @noinline explicit_inline(args...) # will not be inlined
end</code></pre></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When there are nested callsite annotations, the innermost annotation has the precedence:</p><pre><code class="language-julia">@inline let a0, b0 = ...
    a = @noinline f(a0)  # the compiler will NOT try to inline this call
    b = f(b0)            # the compiler will try to inline this call
    return a, b
end</code></pre></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>The callsite annotation requires at least Julia 1.8.</p></div></div><hr/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the function is trivial (for example returning a constant) it might get inlined anyway.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L261-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@nospecialize" href="#Base.@nospecialize"><code>Base.@nospecialize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@nospecialize</code></pre><p>Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.</p><p>When used without arguments, it applies to all arguments of the parent scope. In local scope, this means all arguments of the containing function. In global (top-level) scope, this means all methods subsequently defined in the current module.</p><p>Specialization can reset back to the default by using <a href="#Base.@specialize"><code>@specialize</code></a>.</p><pre><code class="language-julia">function example_function(@nospecialize x)
    ...
end

function example_function(x, @nospecialize(y = 1))
    ...
end

function example_function(x, y, z)
    @nospecialize x y
    ...
end

@nospecialize
f(y) = [x for x in y]
@specialize</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L53-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@specialize" href="#Base.@specialize"><code>Base.@specialize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@specialize</code></pre><p>Reset the specialization hint for an argument back to the default. For details, see <a href="#Base.@nospecialize"><code>@nospecialize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.gensym" href="#Base.gensym"><code>Base.gensym</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gensym([tag])</code></pre><p>Generates a symbol which will not conflict with other variable names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@gensym" href="#Base.@gensym"><code>Base.@gensym</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@gensym</code></pre><p>Generates a gensym symbol for a variable. For example, <code>@gensym x y</code> is transformed into <code>x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="var&quot;name&quot;" href="#var&quot;name&quot;"><code>var&quot;name&quot;</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">var</code></pre><p>The syntax <code>var&quot;#example#&quot;</code> refers to a variable named <code>Symbol(&quot;#example#&quot;)</code>, even though <code>#example#</code> is not a valid Julia identifier name.</p><p>This can be useful for interoperability with programming languages which have different rules for the construction of valid identifiers. For example, to refer to the <code>R</code> variable <code>draw.segments</code>, you can use <code>var&quot;draw.segments&quot;</code> in your Julia code.</p><p>It is also used to <code>show</code> julia source code which has gone through macro hygiene or otherwise contains variable names which can&#39;t be parsed normally.</p><p>Note that this syntax requires parser support so it is expanded directly by the parser rather than being implemented as a normal string macro <code>@var_str</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This syntax requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1236-L1256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@goto" href="#Base.@goto"><code>Base.@goto</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@goto name</code></pre><p><code>@goto name</code> unconditionally jumps to the statement at the location <a href="#Base.@label"><code>@label name</code></a>.</p><p><code>@label</code> and <code>@goto</code> cannot create jumps to different top-level statements. Attempts cause an error. To still use <code>@goto</code>, enclose the <code>@label</code> and <code>@goto</code> in a block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L594-L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@label" href="#Base.@label"><code>Base.@label</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@label name</code></pre><p>Labels a statement with the symbolic label <code>name</code>. The label marks the end-point of an unconditional jump with <a href="#Base.@goto"><code>@goto name</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L584-L589">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.SimdLoop.@simd" href="#Base.SimdLoop.@simd"><code>Base.SimdLoop.@simd</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@simd</code></pre><p>Annotate a <code>for</code> loop to allow the compiler to take extra liberties to allow loop re-ordering</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This feature is experimental and could change or disappear in future versions of Julia. Incorrect use of the <code>@simd</code> macro may cause unexpected results.</p></div></div><p>The object iterated over in a <code>@simd for</code> loop should be a one-dimensional range. By using <code>@simd</code>, you are asserting several properties of the loop:</p><ul><li>It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.</li><li>Floating-point operations on reduction variables can be reordered, possibly causing different results than without <code>@simd</code>.</li></ul><p>In many cases, Julia is able to automatically vectorize inner for loops without the use of <code>@simd</code>. Using <code>@simd</code> gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:</p><ul><li>The loop must be an innermost loop</li><li>The loop body must be straight-line code. Therefore, <a href="#Base.@inbounds"><code>@inbounds</code></a> is   currently needed for all array accesses. The compiler can sometimes turn   short <code>&amp;&amp;</code>, <code>||</code>, and <code>?:</code> expressions into straight-line code if it is safe   to evaluate all operands unconditionally. Consider using the <a href="#Base.ifelse"><code>ifelse</code></a>   function instead of <code>?:</code> in the loop if it is safe to do so.</li><li>Accesses must have a stride pattern and cannot be &quot;gathers&quot; (random-index   reads) or &quot;scatters&quot; (random-index writes).</li><li>The stride should be unit stride.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>@simd</code> does not assert by default that the loop is completely free of loop-carried memory dependencies, which is an assumption that can easily be violated in generic code. If you are writing non-generic code, you can use <code>@simd ivdep for ... end</code> to also assert that:</p></div></div><ul><li>There exists no loop-carried memory dependencies</li><li>No iteration ever waits on a previous iteration to make forward progress.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/simdloop.jl#L90-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@polly" href="#Base.@polly"><code>Base.@polly</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@polly</code></pre><p>Tells the compiler to apply the polyhedral optimizer Polly to a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L650-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@generated" href="#Base.@generated"><code>Base.@generated</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@generated f</code></pre><p><code>@generated</code> is used to annotate a function which will be generated. In the body of the generated function, only types of arguments can be read (not the values). The function returns a quoted expression evaluated when the function is called. The <code>@generated</code> macro should not be used on functions mutating the global scope or depending on mutable elements.</p><p>See <a href="../../manual/metaprogramming/#Metaprogramming">Metaprogramming</a> for further details.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; @generated function bar(x)
           if x &lt;: Integer
               return :(x ^ 2)
           else
               return :(x)
           end
       end
bar (generic function with 1 method)

julia&gt; bar(4)
16

julia&gt; bar(&quot;baz&quot;)
&quot;baz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L807-L835">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@pure" href="#Base.@pure"><code>Base.@pure</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@pure ex</code></pre><p><code>@pure</code> gives the compiler a hint for the definition of a pure function, helping for type inference.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This macro is intended for internal compiler use and may be subject to changes.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In Julia 1.8 and higher, it is favorable to use <a href="base/@ref"><code>@assume_effects</code></a> instead of <code>@pure</code>. This is because <code>@assume_effects</code> allows a finer grained control over Julia&#39;s purity modeling and the effect system enables a wider range of optimizations.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L338-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@deprecate" href="#Base.@deprecate"><code>Base.@deprecate</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@deprecate old new [export_old=true]</code></pre><p>Deprecate method <code>old</code> and specify the replacement call <code>new</code>. Prevent <code>@deprecate</code> from exporting <code>old</code> by setting <code>export_old</code> to <code>false</code>. <code>@deprecate</code> defines a new method with the same signature as <code>old</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>As of Julia 1.5, functions defined by <code>@deprecate</code> do not print warning when <code>julia</code> is run without the <code>--depwarn=yes</code> flag set, as the default value of <code>--depwarn</code> option is <code>no</code>.  The warnings are printed from tests run by <code>Pkg.test()</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @deprecate old(x) new(x)
old (generic function with 1 method)

julia&gt; @deprecate old(x) new(x) false
old (generic function with 1 method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/deprecated.jl#L17-L37">source</a></section></article><h2 id="Missing-Values"><a class="docs-heading-anchor" href="#Missing-Values">Missing Values</a><a id="Missing-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-Values" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.Missing" href="#Base.Missing"><code>Base.Missing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Missing</code></pre><p>A type with no fields whose singleton instance <a href="#Base.missing"><code>missing</code></a> is used to represent missing values.</p><p>See also: <a href="#Base.skipmissing"><code>skipmissing</code></a>, <a href="#Base.nonmissingtype"><code>nonmissingtype</code></a>, <a href="#Core.Nothing"><code>Nothing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L815-L822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.missing" href="#Base.missing"><code>Base.missing</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">missing</code></pre><p>The singleton instance of type <a href="#Base.Missing"><code>Missing</code></a> representing a missing value.</p><p>See also: <a href="../numbers/#Base.NaN"><code>NaN</code></a>, <a href="#Base.skipmissing"><code>skipmissing</code></a>, <a href="#Base.nonmissingtype"><code>nonmissingtype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L825-L831">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.coalesce" href="#Base.coalesce"><code>Base.coalesce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coalesce(x...)</code></pre><p>Return the first value in the arguments which is not equal to <a href="#Base.missing"><code>missing</code></a>, if any. Otherwise return <code>missing</code>.</p><p>See also <a href="#Base.skipmissing"><code>skipmissing</code></a>, <a href="#Base.something"><code>something</code></a>, <a href="#Base.@coalesce"><code>@coalesce</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; coalesce(missing, 1)
1

julia&gt; coalesce(1, missing)
1

julia&gt; coalesce(nothing, 1)  # returns `nothing`

julia&gt; coalesce(missing, missing)
missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/missing.jl#L403-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@coalesce" href="#Base.@coalesce"><code>Base.@coalesce</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@coalesce(x...)</code></pre><p>Short-circuiting version of <a href="#Base.coalesce"><code>coalesce</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; f(x) = (println(&quot;f($x)&quot;); missing);

julia&gt; a = 1;

julia&gt; a = @coalesce a f(2) f(3) error(&quot;`a` is still missing&quot;)
1

julia&gt; b = missing;

julia&gt; b = @coalesce b f(2) f(3) error(&quot;`b` is still missing&quot;)
f(2)
f(3)
ERROR: `b` is still missing
[...]</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>This macro is available as of Julia 1.7.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/missing.jl#L433-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ismissing" href="#Base.ismissing"><code>Base.ismissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ismissing(x)</code></pre><p>Indicate whether <code>x</code> is <a href="#Base.missing"><code>missing</code></a>.</p><p>See also: <a href="#Base.skipmissing"><code>skipmissing</code></a>, <a href="#Base.isnothing"><code>isnothing</code></a>, <a href="../numbers/#Base.isnan"><code>isnan</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L834-L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.skipmissing" href="#Base.skipmissing"><code>Base.skipmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">skipmissing(itr)</code></pre><p>Return an iterator over the elements in <code>itr</code> skipping <a href="#Base.missing"><code>missing</code></a> values. The returned object can be indexed using indices of <code>itr</code> if the latter is indexable. Indices corresponding to missing values are not valid: they are skipped by <a href="../collections/#Base.keys"><code>keys</code></a> and <a href="../arrays/#Base.eachindex"><code>eachindex</code></a>, and a <code>MissingException</code> is thrown when trying to use them.</p><p>Use <a href="../collections/#Base.collect-Tuple{Any}"><code>collect</code></a> to obtain an <code>Array</code> containing the non-<code>missing</code> values in <code>itr</code>. Note that even if <code>itr</code> is a multidimensional array, the result will always be a <code>Vector</code> since it is not possible to remove missings while preserving dimensions of the input.</p><p>See also <a href="#Base.coalesce"><code>coalesce</code></a>, <a href="#Base.ismissing"><code>ismissing</code></a>, <a href="#Base.something"><code>something</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = skipmissing([1, missing, 2])
skipmissing(Union{Missing, Int64}[1, missing, 2])

julia&gt; sum(x)
3

julia&gt; x[1]
1

julia&gt; x[2]
ERROR: MissingException: the value at index (2,) is missing
[...]

julia&gt; argmax(x)
3

julia&gt; collect(keys(x))
2-element Vector{Int64}:
 1
 3

julia&gt; collect(skipmissing([1, missing, 2]))
2-element Vector{Int64}:
 1
 2

julia&gt; collect(skipmissing([1 missing; 2 missing]))
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/missing.jl#L191-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nonmissingtype" href="#Base.nonmissingtype"><code>Base.nonmissingtype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nonmissingtype(T::Type)</code></pre><p>If <code>T</code> is a union of types containing <code>Missing</code>, return a new type with <code>Missing</code> removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nonmissingtype(Union{Int64,Missing})
Int64

julia&gt; nonmissingtype(Any)
Any</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function is exported as of Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/missing.jl#L21-L38">source</a></section></article><h2 id="System"><a class="docs-heading-anchor" href="#System">System</a><a id="System-1"></a><a class="docs-heading-anchor-permalink" href="#System" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.run" href="#Base.run"><code>Base.run</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">run(command, args...; wait::Bool = true)</code></pre><p>Run a command object, constructed with backticks (see the <a href="base/@ref">Running External Programs</a> section in the manual). Throws an error if anything goes wrong, including the process exiting with a non-zero status (when <code>wait</code> is true).</p><p>The <code>args...</code> allow you to pass through file descriptors to the command, and are ordered like regular unix file descriptors (eg <code>stdin, stdout, stderr, FD(3), FD(4)...</code>).</p><p>If <code>wait</code> is false, the process runs asynchronously. You can later wait for it and check its exit status by calling <code>success</code> on the returned process object.</p><p>When <code>wait</code> is false, the process&#39; I/O streams are directed to <code>devnull</code>. When <code>wait</code> is true, I/O streams are shared with the parent process. Use <a href="#Base.pipeline-Tuple{Any, Any, Any, Vararg{Any}}"><code>pipeline</code></a> to control I/O redirection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/process.jl#L460-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.devnull" href="#Base.devnull"><code>Base.devnull</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">devnull</code></pre><p>Used in a stream redirect to discard all data written to it. Essentially equivalent to <code>/dev/null</code> on Unix or <code>NUL</code> on Windows. Usage:</p><pre><code class="language-julia">run(pipeline(`cat test.txt`, devnull))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1266-L1275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.success" href="#Base.success"><code>Base.success</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">success(command)</code></pre><p>Run a command object, constructed with backticks (see the <a href="base/@ref">Running External Programs</a> section in the manual), and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/process.jl#L529-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.process_running" href="#Base.process_running"><code>Base.process_running</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">process_running(p::Process)</code></pre><p>Determine whether a process is currently running.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/process.jl#L626-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.process_exited" href="#Base.process_exited"><code>Base.process_exited</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">process_exited(p::Process)</code></pre><p>Determine whether a process has exited.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/process.jl#L635-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kill-Tuple{Base.Process, Integer}" href="#Base.kill-Tuple{Base.Process, Integer}"><code>Base.kill</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kill(p::Process, signum=Base.SIGTERM)</code></pre><p>Send a signal to a process. The default is to terminate the process. Returns successfully if the process has already exited, but throws an error if killing the process failed for other reasons (e.g. insufficient permissions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/process.jl#L581-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.set_process_title" href="#Base.Sys.set_process_title"><code>Base.Sys.set_process_title</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.set_process_title(title::AbstractString)</code></pre><p>Set the process title. No-op on some operating systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L302-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.get_process_title" href="#Base.Sys.get_process_title"><code>Base.Sys.get_process_title</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.get_process_title()</code></pre><p>Get the process title. On some systems, will always return an empty string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L290-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ignorestatus" href="#Base.ignorestatus"><code>Base.ignorestatus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ignorestatus(command)</code></pre><p>Mark a command object so that running it will not throw an error if the result code is non-zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/cmd.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.detach" href="#Base.detach"><code>Base.detach</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">detach(command)</code></pre><p>Mark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/cmd.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cmd" href="#Base.Cmd"><code>Base.Cmd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)</code></pre><p>Construct a new <code>Cmd</code> object, representing an external program and arguments, from <code>cmd</code>, while changing the settings of the optional keyword arguments:</p><ul><li><code>ignorestatus::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then the <code>Cmd</code> will not throw an error if the return code is nonzero.</li><li><code>detach::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then the <code>Cmd</code> will be run in a new process group, allowing it to outlive the <code>julia</code> process and not have Ctrl-C passed to it.</li><li><code>windows_verbatim::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then on Windows the <code>Cmd</code> will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single &quot;command-line&quot; string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes <code>&quot;</code> in the command line, and <code>\</code> or <code>&quot;</code> are preceded by backslashes. <code>windows_verbatim=true</code> is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.</li><li><code>windows_hide::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then on Windows no new console window is displayed when the <code>Cmd</code> is executed. This has no effect if a console is already open or on non-Windows systems.</li><li><code>env</code>: Set environment variables to use when running the <code>Cmd</code>. <code>env</code> is either a dictionary mapping strings to strings, an array of strings of the form <code>&quot;var=val&quot;</code>, an array or tuple of <code>&quot;var&quot;=&gt;val</code> pairs. In order to modify (rather than replace) the existing environment, initialize <code>env</code> with <code>copy(ENV)</code> and then set <code>env[&quot;var&quot;]=val</code> as desired.  To add to an environment block within a <code>Cmd</code> object without replacing all elements, use <a href="#Base.addenv"><code>addenv()</code></a> which will return a <code>Cmd</code> object with the updated environment.</li><li><code>dir::AbstractString</code>: Specify a working directory for the command (instead of the current directory).</li></ul><p>For any keywords that are not specified, the current settings from <code>cmd</code> are used. Normally, to create a <code>Cmd</code> object in the first place, one uses backticks, e.g.</p><pre><code class="language-none">Cmd(`echo &quot;Hello world&quot;`, ignorestatus=true, detach=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/cmd.jl#L42-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setenv" href="#Base.setenv"><code>Base.setenv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setenv(command::Cmd, env; dir)</code></pre><p>Set environment variables to use when running the given <code>command</code>. <code>env</code> is either a dictionary mapping strings to strings, an array of strings of the form <code>&quot;var=val&quot;</code>, or zero or more <code>&quot;var&quot;=&gt;val</code> pair arguments. In order to modify (rather than replace) the existing environment, create <code>env</code> through <code>copy(ENV)</code> and then setting <code>env[&quot;var&quot;]=val</code> as desired, or use <a href="#Base.addenv"><code>addenv</code></a>.</p><p>The <code>dir</code> keyword argument can be used to specify a working directory for the command. <code>dir</code> defaults to the currently set <code>dir</code> for <code>command</code> (which is the current working directory if not specified already).</p><p>See also <a href="#Base.Cmd"><code>Cmd</code></a>, <a href="#Base.addenv"><code>addenv</code></a>, <a href="#Base.ENV"><code>ENV</code></a>, <a href="../file/#Base.Filesystem.pwd"><code>pwd</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/cmd.jl#L245-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.addenv" href="#Base.addenv"><code>Base.addenv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">addenv(command::Cmd, env...; inherit::Bool = true)</code></pre><p>Merge new environment mappings into the given <a href="#Base.Cmd"><code>Cmd</code></a> object, returning a new <code>Cmd</code> object. Duplicate keys are replaced.  If <code>command</code> does not contain any environment values set already, it inherits the current environment at time of <code>addenv()</code> call if <code>inherit</code> is <code>true</code>. Keys with value <code>nothing</code> are deleted from the env.</p><p>See also <a href="#Base.Cmd"><code>Cmd</code></a>, <a href="#Base.setenv"><code>setenv</code></a>, <a href="#Base.ENV"><code>ENV</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This function requires Julia 1.6 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/cmd.jl#L274-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.withenv" href="#Base.withenv"><code>Base.withenv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">withenv(f, kv::Pair...)</code></pre><p>Execute <code>f</code> in an environment that is temporarily modified (not replaced as in <code>setenv</code>) by zero or more <code>&quot;var&quot;=&gt;val</code> arguments <code>kv</code>. <code>withenv</code> is generally used via the <code>withenv(kv...) do ... end</code> syntax. A value of <code>nothing</code> can be used to temporarily unset an environment variable (if it is set). When <code>withenv</code> returns, the original environment has been restored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/env.jl#L157-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pipeline-Tuple{Any, Any, Any, Vararg{Any}}" href="#Base.pipeline-Tuple{Any, Any, Any, Vararg{Any}}"><code>Base.pipeline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pipeline(from, to, ...)</code></pre><p>Create a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other <code>pipeline</code> calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example, <code>pipeline(a,b,c)</code> is equivalent to <code>pipeline(pipeline(a,b),c)</code>. This provides a more concise way to specify multi-stage pipelines.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia">run(pipeline(`ls`, `grep xyz`))
run(pipeline(`ls`, &quot;out.txt&quot;))
run(pipeline(&quot;out.txt&quot;, `grep xyz`))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/cmd.jl#L400-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pipeline-Tuple{Base.AbstractCmd}" href="#Base.pipeline-Tuple{Base.AbstractCmd}"><code>Base.pipeline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pipeline(command; stdin, stdout, stderr, append=false)</code></pre><p>Redirect I/O to or from the given <code>command</code>. Keyword arguments specify which of the command&#39;s streams should be redirected. <code>append</code> controls whether file output appends to the file. This is a more general version of the 2-argument <code>pipeline</code> function. <code>pipeline(from, to)</code> is equivalent to <code>pipeline(from, stdout=to)</code> when <code>from</code> is a command, and to <code>pipeline(to, stdin=from)</code> when <code>from</code> is another kind of data source.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia">run(pipeline(`dothings`, stdout=&quot;out.txt&quot;, stderr=&quot;errs.txt&quot;))
run(pipeline(`update`, stdout=&quot;log.txt&quot;, append=true))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/cmd.jl#L365-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Libc.gethostname" href="#Base.Libc.gethostname"><code>Base.Libc.gethostname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gethostname() -&gt; AbstractString</code></pre><p>Get the local machine&#39;s host name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/libc.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Libc.getpid" href="#Base.Libc.getpid"><code>Base.Libc.getpid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getpid(process) -&gt; Int32</code></pre><p>Get the child process ID, if it still exists.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/process.jl#L604-L611">source</a></section><section><div><pre><code class="language-none">getpid() -&gt; Int32</code></pre><p>Get Julia&#39;s process ID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/libc.jl#L253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Libc.time-Tuple{}" href="#Base.Libc.time-Tuple{}"><code>Base.Libc.time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">time()</code></pre><p>Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/libc.jl#L244-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.time_ns" href="#Base.time_ns"><code>Base.time_ns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_ns()</code></pre><p>Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/Base.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@time" href="#Base.@time"><code>Base.@time</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@time expr
@time &quot;description&quot; expr</code></pre><p>A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression. Any time spent garbage collecting (gc), compiling new code, or recompiling invalidated code is shown as a percentage.</p><p>Optionally provide a description string to print before the time report.</p><p>In some cases the system will look inside the <code>@time</code> expression and compile some of the called code before execution of the top-level expression begins. When that happens, some compilation time will not be counted. To include this time you can run <code>@time @eval ...</code>.</p><p>See also <a href="base/@ref"><code>@showtime</code></a>, <a href="#Base.@timev"><code>@timev</code></a>, <a href="#Base.@timed"><code>@timed</code></a>, <a href="#Base.@elapsed"><code>@elapsed</code></a>, and <a href="#Base.@allocated"><code>@allocated</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For more serious benchmarking, consider the <code>@btime</code> macro from the BenchmarkTools.jl package which among other things evaluates the function multiple times in order to reduce noise.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>The option to add a description was introduced in Julia 1.8.</p><p>Recompilation time being shown separately from compilation time was introduced in Julia 1.8</p></div></div><pre><code class="language-julia-repl">julia&gt; x = rand(10,10);

julia&gt; @time x * x;
  0.606588 seconds (2.19 M allocations: 116.555 MiB, 3.75% gc time, 99.94% compilation time)

julia&gt; @time x * x;
  0.000009 seconds (1 allocation: 896 bytes)

julia&gt; @time begin
           sleep(0.3)
           1+1
       end
  0.301395 seconds (8 allocations: 336 bytes)
2

julia&gt; @time &quot;A one second sleep&quot; sleep(1)
A one second sleep: 1.005750 seconds (5 allocations: 144 bytes)

julia&gt; for loop in 1:3
            @time loop sleep(1)
        end
1: 1.006760 seconds (5 allocations: 144 bytes)
2: 1.001263 seconds (5 allocations: 144 bytes)
3: 1.003676 seconds (5 allocations: 144 bytes)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/timing.jl#L195-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@timev" href="#Base.@timev"><code>Base.@timev</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@timev expr
@timev &quot;description&quot; expr</code></pre><p>This is a verbose version of the <code>@time</code> macro. It first prints the same information as <code>@time</code>, then any non-zero memory allocation counters, and then returns the value of the expression.</p><p>Optionally provide a description string to print before the time report.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>The option to add a description was introduced in Julia 1.8.</p></div></div><p>See also <a href="#Base.@time"><code>@time</code></a>, <a href="#Base.@timed"><code>@timed</code></a>, <a href="#Base.@elapsed"><code>@elapsed</code></a>, and <a href="#Base.@allocated"><code>@allocated</code></a>.</p><pre><code class="language-julia-repl">julia&gt; x = rand(10,10);

julia&gt; @timev x * x;
  0.546770 seconds (2.20 M allocations: 116.632 MiB, 4.23% gc time, 99.94% compilation time)
elapsed time (ns): 546769547
gc time (ns):      23115606
bytes allocated:   122297811
pool allocs:       2197930
non-pool GC allocs:1327
malloc() calls:    36
realloc() calls:   5
GC pauses:         3

julia&gt; @timev x * x;
  0.000010 seconds (1 allocation: 896 bytes)
elapsed time (ns): 9848
bytes allocated:   896
pool allocs:       1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/timing.jl#L297-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@timed" href="#Base.@timed"><code>Base.@timed</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@timed</code></pre><p>A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.</p><p>In some cases the system will look inside the <code>@timed</code> expression and compile some of the called code before execution of the top-level expression begins. When that happens, some compilation time will not be counted. To include this time you can run <code>@timed @eval ...</code>.</p><p>See also <a href="#Base.@time"><code>@time</code></a>, <a href="#Base.@timev"><code>@timev</code></a>, <a href="#Base.@elapsed"><code>@elapsed</code></a>, and <a href="#Base.@allocated"><code>@allocated</code></a>.</p><pre><code class="language-julia-repl">julia&gt; stats = @timed rand(10^6);

julia&gt; stats.time
0.006634834

julia&gt; stats.bytes
8000256

julia&gt; stats.gctime
0.0055765

julia&gt; propertynames(stats.gcstats)
(:allocd, :malloc, :realloc, :poolalloc, :bigalloc, :freecall, :total_time, :pause, :full_sweep)

julia&gt; stats.gcstats.total_time
5576500</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The return type of this macro was changed from <code>Tuple</code> to <code>NamedTuple</code> in Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/timing.jl#L422-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@elapsed" href="#Base.@elapsed"><code>Base.@elapsed</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@elapsed</code></pre><p>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.</p><p>In some cases the system will look inside the <code>@elapsed</code> expression and compile some of the called code before execution of the top-level expression begins. When that happens, some compilation time will not be counted. To include this time you can run <code>@elapsed @eval ...</code>.</p><p>See also <a href="#Base.@time"><code>@time</code></a>, <a href="#Base.@timev"><code>@timev</code></a>, <a href="#Base.@timed"><code>@timed</code></a>, and <a href="#Base.@allocated"><code>@allocated</code></a>.</p><pre><code class="language-julia-repl">julia&gt; @elapsed sleep(0.3)
0.301391426</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/timing.jl#L360-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@allocated" href="#Base.@allocated"><code>Base.@allocated</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@allocated</code></pre><p>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression.</p><p>See also <a href="#Base.@time"><code>@time</code></a>, <a href="#Base.@timev"><code>@timev</code></a>, <a href="#Base.@timed"><code>@timed</code></a>, and <a href="#Base.@elapsed"><code>@elapsed</code></a>.</p><pre><code class="language-julia-repl">julia&gt; @allocated rand(10^6)
8000080</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/timing.jl#L396-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.EnvDict" href="#Base.EnvDict"><code>Base.EnvDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EnvDict() -&gt; EnvDict</code></pre><p>A singleton of this type provides a hash table interface to environment variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/env.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ENV" href="#Base.ENV"><code>Base.ENV</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">ENV</code></pre><p>Reference to the singleton <code>EnvDict</code>, providing a dictionary interface to system environment variables.</p><p>(On Windows, system environment variables are case-insensitive, and <code>ENV</code> correspondingly converts all keys to uppercase for display, iteration, and copying. Portable code should not rely on the ability to distinguish variables by case, and should beware that setting an ostensibly lowercase variable may result in an uppercase <code>ENV</code> key.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/env.jl#L66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.isunix" href="#Base.Sys.isunix"><code>Base.Sys.isunix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.isunix([os])</code></pre><p>Predicate for testing if the OS provides a Unix-like interface. See documentation in <a href="base/@ref">Handling Operating System Variation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L322-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.isapple" href="#Base.Sys.isapple"><code>Base.Sys.isapple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.isapple([os])</code></pre><p>Predicate for testing if the OS is a derivative of Apple Macintosh OS X or Darwin. See documentation in <a href="base/@ref">Handling Operating System Variation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L429-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.islinux" href="#Base.Sys.islinux"><code>Base.Sys.islinux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.islinux([os])</code></pre><p>Predicate for testing if the OS is a derivative of Linux. See documentation in <a href="base/@ref">Handling Operating System Variation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L344-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.isbsd" href="#Base.Sys.isbsd"><code>Base.Sys.isbsd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.isbsd([os])</code></pre><p>Predicate for testing if the OS is a derivative of BSD. See documentation in <a href="base/@ref">Handling Operating System Variation</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Darwin kernel descends from BSD, which means that <code>Sys.isbsd()</code> is <code>true</code> on macOS systems. To exclude macOS from a predicate, use <code>Sys.isbsd() &amp;&amp; !Sys.isapple()</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L352-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.isfreebsd" href="#Base.Sys.isfreebsd"><code>Base.Sys.isfreebsd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.isfreebsd([os])</code></pre><p>Predicate for testing if the OS is a derivative of FreeBSD. See documentation in <a href="base/@ref">Handling Operating System Variation</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Not to be confused with <code>Sys.isbsd()</code>, which is <code>true</code> on FreeBSD but also on other BSD-based systems. <code>Sys.isfreebsd()</code> refers only to FreeBSD.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L365-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.isopenbsd" href="#Base.Sys.isopenbsd"><code>Base.Sys.isopenbsd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.isopenbsd([os])</code></pre><p>Predicate for testing if the OS is a derivative of OpenBSD. See documentation in <a href="base/@ref">Handling Operating System Variation</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Not to be confused with <code>Sys.isbsd()</code>, which is <code>true</code> on OpenBSD but also on other BSD-based systems. <code>Sys.isopenbsd()</code> refers only to OpenBSD.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L379-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.isnetbsd" href="#Base.Sys.isnetbsd"><code>Base.Sys.isnetbsd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.isnetbsd([os])</code></pre><p>Predicate for testing if the OS is a derivative of NetBSD. See documentation in <a href="base/@ref">Handling Operating System Variation</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Not to be confused with <code>Sys.isbsd()</code>, which is <code>true</code> on NetBSD but also on other BSD-based systems. <code>Sys.isnetbsd()</code> refers only to NetBSD.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L393-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.isdragonfly" href="#Base.Sys.isdragonfly"><code>Base.Sys.isdragonfly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.isdragonfly([os])</code></pre><p>Predicate for testing if the OS is a derivative of DragonFly BSD. See documentation in <a href="base/@ref">Handling Operating System Variation</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Not to be confused with <code>Sys.isbsd()</code>, which is <code>true</code> on DragonFly but also on other BSD-based systems. <code>Sys.isdragonfly()</code> refers only to DragonFly.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L407-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.iswindows" href="#Base.Sys.iswindows"><code>Base.Sys.iswindows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.iswindows([os])</code></pre><p>Predicate for testing if the OS is a derivative of Microsoft Windows NT. See documentation in <a href="base/@ref">Handling Operating System Variation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L421-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.windows_version" href="#Base.Sys.windows_version"><code>Base.Sys.windows_version</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.windows_version()</code></pre><p>Return the version number for the Windows NT Kernel as a <code>VersionNumber</code>, i.e. <code>v&quot;major.minor.build&quot;</code>, or <code>v&quot;0.0.0&quot;</code> if this is not running on Windows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L461-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.free_memory" href="#Base.Sys.free_memory"><code>Base.Sys.free_memory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.free_memory()</code></pre><p>Get the total free memory in RAM in bytes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sys.total_memory" href="#Base.Sys.total_memory"><code>Base.Sys.total_memory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sys.total_memory()</code></pre><p>Get the total memory in RAM (including that which is currently used) in bytes. This amount may be constrained, e.g., by Linux control groups. For the unconstrained amount, see <code>Sys.physical_memory()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/sysinfo.jl#L274-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@static" href="#Base.@static"><code>Base.@static</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@static</code></pre><p>Partially evaluate an expression at parse time.</p><p>For example, <code>@static Sys.iswindows() ? foo : bar</code> will evaluate <code>Sys.iswindows()</code> and insert either <code>foo</code> or <code>bar</code> into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a <code>ccall</code> to a non-existent function. <code>@static if Sys.isapple() foo end</code> and <code>@static foo &lt;&amp;&amp;,||&gt; bar</code> are also valid syntax.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/osutils.jl#L3-L13">source</a></section></article><h2 id="Versioning"><a class="docs-heading-anchor" href="#Versioning">Versioning</a><a id="Versioning-1"></a><a class="docs-heading-anchor-permalink" href="#Versioning" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.VersionNumber" href="#Base.VersionNumber"><code>Base.VersionNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VersionNumber</code></pre><p>Version number type which follows the specifications of <a href="https://semver.org/">semantic versioning (semver)</a>, composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations.</p><p><code>VersionNumber</code> objects can be compared with all of the standard comparison operators (<code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, etc.), with the result following semver rules.</p><p>See also <a href="#Base.@v_str"><code>@v_str</code></a> to efficiently construct <code>VersionNumber</code> objects from semver-format literal strings, <a href="../constants/#Base.VERSION"><code>VERSION</code></a> for the <code>VersionNumber</code> of Julia itself, and <a href="../../manual/strings/#man-version-number-literals">Version Number Literals</a> in the manual.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = VersionNumber(1, 2, 3)
v&quot;1.2.3&quot;

julia&gt; a &gt;= v&quot;1.2&quot;
true

julia&gt; b = VersionNumber(&quot;2.0.1-rc1&quot;)
v&quot;2.0.1-rc1&quot;

julia&gt; b &gt;= v&quot;2.0.1&quot;
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/version.jl#L8-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@v_str" href="#Base.@v_str"><code>Base.@v_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@v_str</code></pre><p>String macro used to parse a string to a <a href="#Base.VersionNumber"><code>VersionNumber</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v&quot;1.2.3&quot;
v&quot;1.2.3&quot;

julia&gt; v&quot;2.0.1-rc1&quot;
v&quot;2.0.1-rc1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/version.jl#L146-L159">source</a></section></article><h2 id="Errors"><a class="docs-heading-anchor" href="#Errors">Errors</a><a id="Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Errors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.error" href="#Base.error"><code>Base.error</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">error(message::AbstractString)</code></pre><p>Raise an <code>ErrorException</code> with the given message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/error.jl#L30-L34">source</a></section><section><div><pre><code class="language-none">error(msg...)</code></pre><p>Raise an <code>ErrorException</code> with the given message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/error.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.throw" href="#Core.throw"><code>Core.throw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">throw(e)</code></pre><p>Throw an object as an exception.</p><p>See also: <a href="#Base.rethrow"><code>rethrow</code></a>, <a href="#Base.error"><code>error</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/error.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rethrow" href="#Base.rethrow"><code>Base.rethrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rethrow()</code></pre><p>Rethrow the current exception from within a <code>catch</code> block. The rethrown exception will continue propagation as if it had not been caught.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The alternative form <code>rethrow(e)</code> allows you to associate an alternative exception object <code>e</code> with the current backtrace. However this misrepresents the program state at the time of the error so you&#39;re encouraged to instead throw a new exception using <code>throw(e)</code>. In Julia 1.1 and above, using <code>throw(e)</code> will preserve the root cause exception on the stack, as described in <a href="#Base.current_exceptions"><code>current_exceptions</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/error.jl#L47-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.backtrace" href="#Base.backtrace"><code>Base.backtrace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">backtrace()</code></pre><p>Get a backtrace object for the current program point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/error.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.catch_backtrace" href="#Base.catch_backtrace"><code>Base.catch_backtrace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">catch_backtrace()</code></pre><p>Get the backtrace of the current exception, for use within <code>catch</code> blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/error.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.current_exceptions" href="#Base.current_exceptions"><code>Base.current_exceptions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">current_exceptions(task::Task=current_task(); [backtrace::Bool=true])</code></pre><p>Get the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as an <code>ExceptionStack</code> which is an AbstractVector of named tuples <code>(exception,backtrace)</code>. If <code>backtrace</code> is false, the backtrace in each pair will be set to <code>nothing</code>.</p><p>Explicitly passing <code>task</code> will return the current exception stack on an arbitrary task. This is useful for inspecting tasks which have failed due to uncaught exceptions.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>This function went by the experimental name <code>catch_stack()</code> in Julia 1.1–1.6, and had a plain Vector-of-tuples as a return type.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/error.jl#L132-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@assert" href="#Base.@assert"><code>Base.@assert</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@assert cond [text]</code></pre><p>Throw an <a href="#Core.AssertionError"><code>AssertionError</code></a> if <code>cond</code> is <code>false</code>. Preferred syntax for writing assertions. Message <code>text</code> is optionally displayed upon assertion failure.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>An assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @assert iseven(3) &quot;3 is an odd number!&quot;
ERROR: AssertionError: 3 is an odd number!

julia&gt; @assert isodd(3) &quot;What even are numbers?&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/error.jl#L197-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Experimental.register_error_hint" href="#Base.Experimental.register_error_hint"><code>Base.Experimental.register_error_hint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Experimental.register_error_hint(handler, exceptiontype)</code></pre><p>Register a &quot;hinting&quot; function <code>handler(io, exception)</code> that can suggest potential ways for users to circumvent errors.  <code>handler</code> should examine <code>exception</code> to see whether the conditions appropriate for a hint are met, and if so generate output to <code>io</code>. Packages should call <code>register_error_hint</code> from within their <code>__init__</code> function.</p><p>For specific exception types, <code>handler</code> is required to accept additional arguments:</p><ul><li><code>MethodError</code>: provide <code>handler(io, exc::MethodError, argtypes, kwargs)</code>, which splits the combined arguments into positional and keyword arguments.</li></ul><p>When issuing a hint, the output should typically start with <code>\n</code>.</p><p>If you define custom exception types, your <code>showerror</code> method can support hints by calling <a href="#Base.Experimental.show_error_hints"><code>Experimental.show_error_hints</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; module Hinter

       only_int(x::Int)      = 1
       any_number(x::Number) = 2

       function __init__()
           Base.Experimental.register_error_hint(MethodError) do io, exc, argtypes, kwargs
               if exc.f == only_int
                    # Color is not necessary, this is just to show it&#39;s possible.
                    print(io, &quot;\nDid you mean to call &quot;)
                    printstyled(io, &quot;`any_number`?&quot;, color=:cyan)
               end
           end
       end

       end</code></pre><p>Then if you call <code>Hinter.only_int</code> on something that isn&#39;t an <code>Int</code> (thereby triggering a <code>MethodError</code>), it issues the hint:</p><pre><code class="language-none">julia&gt; Hinter.only_int(1.0)
ERROR: MethodError: no method matching only_int(::Float64)
Did you mean to call `any_number`?
Closest candidates are:
    ...</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Custom error hints are available as of Julia 1.5.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This interface is experimental and subject to change or removal without notice. To insulate yourself against changes, consider putting any registrations inside an <code>if isdefined(Base.Experimental, :register_error_hint) ... end</code> block.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/experimental.jl#L212-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Experimental.show_error_hints" href="#Base.Experimental.show_error_hints"><code>Base.Experimental.show_error_hints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Experimental.show_error_hints(io, ex, args...)</code></pre><p>Invoke all handlers from <a href="#Base.Experimental.register_error_hint"><code>Experimental.register_error_hint</code></a> for the particular exception type <code>typeof(ex)</code>. <code>args</code> must contain any other arguments expected by the handler for that type.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Custom error hints are available as of Julia 1.5.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This interface is experimental and subject to change or removal without notice.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/experimental.jl#L278-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.ArgumentError" href="#Core.ArgumentError"><code>Core.ArgumentError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ArgumentError(msg)</code></pre><p>The arguments passed to a function are invalid. <code>msg</code> is a descriptive error message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2440-L2445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.AssertionError" href="#Core.AssertionError"><code>Core.AssertionError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AssertionError([msg])</code></pre><p>The asserted condition did not evaluate to <code>true</code>. Optional argument <code>msg</code> is a descriptive error string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @assert false &quot;this is not true&quot;
ERROR: AssertionError: this is not true</code></pre><p><code>AssertionError</code> is usually thrown from <a href="#Base.@assert"><code>@assert</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2456-L2469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.BoundsError" href="#Core.BoundsError"><code>Core.BoundsError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoundsError([a],[i])</code></pre><p>An indexing operation into an array, <code>a</code>, tried to access an out-of-bounds element at index <code>i</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = fill(1.0, 7);

julia&gt; A[8]
ERROR: BoundsError: attempt to access 7-element Vector{Float64} at index [8]


julia&gt; B = fill(1.0, (2,3));

julia&gt; B[2, 4]
ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [2, 4]


julia&gt; B[9]
ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [9]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1475-L1498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.CompositeException" href="#Base.CompositeException"><code>Base.CompositeException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CompositeException</code></pre><p>Wrap a <code>Vector</code> of exceptions thrown by a <a href="../parallel/#Core.Task"><code>Task</code></a> (e.g. generated from a remote worker over a channel or an asynchronously executing local I/O write or a remote worker under <code>pmap</code>) with information about the series of exceptions. For example, if a group of workers are executing several tasks, and multiple workers fail, the resulting <code>CompositeException</code> will contain a &quot;bundle&quot; of information from each worker indicating where and why the exception(s) occurred.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/task.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.DimensionMismatch" href="#Base.DimensionMismatch"><code>Base.DimensionMismatch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DimensionMismatch([msg])</code></pre><p>The objects called do not have matching dimensionality. Optional argument <code>msg</code> is a descriptive error string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/array.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.DivideError" href="#Core.DivideError"><code>Core.DivideError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DivideError()</code></pre><p>Integer division was attempted with a denominator value of 0.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 2/0
Inf

julia&gt; div(2, 0)
ERROR: DivideError: integer division error
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1757-L1772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.DomainError" href="#Core.DomainError"><code>Core.DomainError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DomainError(val)
DomainError(val, msg)</code></pre><p>The argument <code>val</code> to a function or constructor is outside the valid domain.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1516-L1530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.EOFError" href="#Base.EOFError"><code>Base.EOFError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EOFError()</code></pre><p>No more data was available to read from a file or stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/io.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.ErrorException" href="#Core.ErrorException"><code>Core.ErrorException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ErrorException(msg)</code></pre><p>Generic error type. The error message, in the <code>.msg</code> field, may provide more specific details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ex = ErrorException(&quot;I&#39;ve done a bad thing&quot;);

julia&gt; ex.msg
&quot;I&#39;ve done a bad thing&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1382-L1394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.InexactError" href="#Core.InexactError"><code>Core.InexactError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InexactError(name::Symbol, T, val)</code></pre><p>Cannot exactly convert <code>val</code> to type <code>T</code> in a method of function <code>name</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert(Float64, 1+2im)
ERROR: InexactError: Float64(1 + 2im)
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1501-L1513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.InterruptException" href="#Core.InterruptException"><code>Core.InterruptException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterruptException()</code></pre><p>The process was stopped by a terminal interrupt (CTRL+C).</p><p>Note that, in Julia script started without <code>-i</code> (interactive) option, <code>InterruptException</code> is not thrown by default.  Calling <a href="../c/#Base.exit_on_sigint"><code>Base.exit_on_sigint(false)</code></a> in the script can recover the behavior of the REPL.  Alternatively, a Julia script can be started with</p><pre><code class="language-sh">julia -e &quot;include(popfirst!(ARGS))&quot; script.jl</code></pre><p>to let <code>InterruptException</code> be thrown by CTRL+C during the execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1642-L1658">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.KeyError" href="#Base.KeyError"><code>Base.KeyError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KeyError(key)</code></pre><p>An indexing operation into an <code>AbstractDict</code> (<code>Dict</code>) or <code>Set</code> like object tried to access or delete a non-existent element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/abstractdict.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.LoadError" href="#Core.LoadError"><code>Core.LoadError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LoadError(file::AbstractString, line::Int, error)</code></pre><p>An error occurred while <a href="#Base.include"><code>include</code></a>ing, <a href="#Base.require"><code>require</code></a>ing, or <a href="#using"><code>using</code></a> a file. The error specifics should be available in the <code>.error</code> field.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>LoadErrors are no longer emitted by <code>@macroexpand</code>, <code>@macroexpand1</code>, and <code>macroexpand</code> as of Julia 1.7.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2472-L2480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.MethodError" href="#Core.MethodError"><code>Core.MethodError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MethodError(f, args)</code></pre><p>A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2448-L2453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.MissingException" href="#Base.MissingException"><code>Base.MissingException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MissingException(msg)</code></pre><p>Exception thrown when a <a href="#Base.missing"><code>missing</code></a> value is encountered in a situation where it is not supported. The error message, in the <code>msg</code> field may provide more specific details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/missing.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.OutOfMemoryError" href="#Core.OutOfMemoryError"><code>Core.OutOfMemoryError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OutOfMemoryError()</code></pre><p>An operation allocated too much memory for either the system or the garbage collector to handle properly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1467-L1472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.ReadOnlyMemoryError" href="#Core.ReadOnlyMemoryError"><code>Core.ReadOnlyMemoryError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReadOnlyMemoryError()</code></pre><p>An operation tried to write to memory that is read-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1375-L1379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.OverflowError" href="#Core.OverflowError"><code>Core.OverflowError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OverflowError(msg)</code></pre><p>The result of an expression is too large for the specified type and will cause a wraparound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1628-L1632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ProcessFailedException" href="#Base.ProcessFailedException"><code>Base.ProcessFailedException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProcessFailedException</code></pre><p>Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/process.jl#L539-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.StackOverflowError" href="#Core.StackOverflowError"><code>Core.StackOverflowError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StackOverflowError()</code></pre><p>The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1551-L1556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.SystemError" href="#Base.SystemError"><code>Base.SystemError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SystemError(prefix::AbstractString, [errno::Int32])</code></pre><p>A system call failed with an error code (in the <code>errno</code> global variable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/io.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.TypeError" href="#Core.TypeError"><code>Core.TypeError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TypeError(func::Symbol, context::AbstractString, expected::Type, got)</code></pre><p>A type assertion failure, or calling an intrinsic function with an incorrect argument type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1635-L1639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.UndefKeywordError" href="#Core.UndefKeywordError"><code>Core.UndefKeywordError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UndefKeywordError(var::Symbol)</code></pre><p>The required keyword argument <code>var</code> was not assigned in a function call.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; function my_func(;my_arg)
           return my_arg + 1
       end
my_func (generic function with 1 method)

julia&gt; my_func()
ERROR: UndefKeywordError: keyword argument my_arg not assigned
Stacktrace:
 [1] my_func() at ./REPL[1]:2
 [2] top-level scope at REPL[2]:1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1607-L1625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.UndefRefError" href="#Core.UndefRefError"><code>Core.UndefRefError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UndefRefError()</code></pre><p>The item or field is not defined for the given object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; struct MyType
           a::Vector{Int}
           MyType() = new()
       end

julia&gt; A = MyType()
MyType(#undef)

julia&gt; A.a
ERROR: UndefRefError: access to undefined reference
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1406-L1426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.UndefVarError" href="#Core.UndefVarError"><code>Core.UndefVarError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UndefVarError(var::Symbol)</code></pre><p>A symbol in the current scope is not defined.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a
ERROR: UndefVarError: a not defined

julia&gt; a = 1;

julia&gt; a
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1589-L1604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.StringIndexError" href="#Base.StringIndexError"><code>Base.StringIndexError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StringIndexError(str, i)</code></pre><p>An error occurred when trying to access <code>str</code> at index <code>i</code> that is not valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/strings/string.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.InitError" href="#Core.InitError"><code>Core.InitError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InitError(mod::Symbol, error)</code></pre><p>An error occurred when running a module&#39;s <code>__init__</code> function. The actual error thrown is available in the <code>.error</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2483-L2488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.retry" href="#Base.retry"><code>Base.retry</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">retry(f;  delays=ExponentialBackOff(), check=nothing) -&gt; Function</code></pre><p>Return an anonymous function that calls function <code>f</code>.  If an exception arises, <code>f</code> is repeatedly called again, each time <code>check</code> returns <code>true</code>, after waiting the number of seconds specified in <code>delays</code>.  <code>check</code> should input <code>delays</code>&#39;s current state and the <code>Exception</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>Before Julia 1.2 this signature was restricted to <code>f::Function</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">retry(f, delays=fill(5.0, 3))
retry(f, delays=rand(5:10, 2))
retry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))
retry(http_get, check=(s,e)-&gt;e.status == &quot;503&quot;)(url)
retry(read, check=(s,e)-&gt;isa(e, IOError))(io, 128; all=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/error.jl#L270-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ExponentialBackOff" href="#Base.ExponentialBackOff"><code>Base.ExponentialBackOff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)</code></pre><p>A <a href="../numbers/#Core.Float64"><code>Float64</code></a> iterator of length <code>n</code> whose elements exponentially increase at a rate in the interval <code>factor</code> * (1 ± <code>jitter</code>).  The first element is <code>first_delay</code> and all elements are clamped to <code>max_delay</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/error.jl#L251-L257">source</a></section></article><h2 id="Events"><a class="docs-heading-anchor" href="#Events">Events</a><a id="Events-1"></a><a class="docs-heading-anchor-permalink" href="#Events" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.Timer-Tuple{Function, Real}" href="#Base.Timer-Tuple{Function, Real}"><code>Base.Timer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Timer(callback::Function, delay; interval = 0)</code></pre><p>Create a timer that runs the function <code>callback</code> at each timer expiration.</p><p>Waiting tasks are woken and the function <code>callback</code> is called after an initial delay of <code>delay</code> seconds, and then repeating with the given <code>interval</code> in seconds. If <code>interval</code> is equal to <code>0</code>, the callback is only run once. The function <code>callback</code> is called with a single argument, the timer itself. Stop a timer by calling <code>close</code>. The <code>cb</code> may still be run one final time, if the timer has already expired.</p><p><strong>Examples</strong></p><p>Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.</p><pre><code class="language-julia-repl">julia&gt; begin
           i = 0
           cb(timer) = (global i += 1; println(i))
           t = Timer(cb, 2, interval=0.2)
           wait(t)
           sleep(0.5)
           close(t)
       end
1
2
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/asyncevent.jl#L245-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Timer" href="#Base.Timer"><code>Base.Timer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Timer(delay; interval = 0)</code></pre><p>Create a timer that wakes up tasks waiting for it (by calling <a href="../parallel/#Base.wait"><code>wait</code></a> on the timer object).</p><p>Waiting tasks are woken after an initial delay of at least <code>delay</code> seconds, and then repeating after at least <code>interval</code> seconds again elapse. If <code>interval</code> is equal to <code>0</code>, the timer is only triggered once. When the timer is closed (by <a href="../io-network/#Base.close"><code>close</code></a>) waiting tasks are woken with an error. Use <a href="../io-network/#Base.isopen"><code>isopen</code></a> to check whether a timer is still active.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>interval</code> is subject to accumulating time skew. If you need precise events at a particular absolute time, create a new timer at each expiration with the difference to the next time computed.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A <code>Timer</code> requires yield points to update its state. For instance, <code>isopen(t::Timer)</code> cannot be used to timeout a non-yielding while loop.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/asyncevent.jl#L69-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AsyncCondition" href="#Base.AsyncCondition"><code>Base.AsyncCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AsyncCondition()</code></pre><p>Create a async condition that wakes up tasks waiting for it (by calling <a href="../parallel/#Base.wait"><code>wait</code></a> on the object) when notified from C by a call to <code>uv_async_send</code>. Waiting tasks are woken with an error when the object is closed (by <a href="../io-network/#Base.close"><code>close</code></a>). Use <a href="../io-network/#Base.isopen"><code>isopen</code></a> to check whether it is still active.</p><p>This provides an implicit acquire &amp; release memory ordering between the sending and waiting threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/asyncevent.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AsyncCondition-Tuple{Function}" href="#Base.AsyncCondition-Tuple{Function}"><code>Base.AsyncCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AsyncCondition(callback::Function)</code></pre><p>Create a async condition that calls the given <code>callback</code> function. The <code>callback</code> is passed one argument, the async condition object itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/asyncevent.jl#L40-L45">source</a></section></article><h2 id="Reflection"><a class="docs-heading-anchor" href="#Reflection">Reflection</a><a id="Reflection-1"></a><a class="docs-heading-anchor-permalink" href="#Reflection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.nameof-Tuple{Module}" href="#Base.nameof-Tuple{Module}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nameof(m::Module) -&gt; Symbol</code></pre><p>Get the name of a <code>Module</code> as a <a href="#Core.Symbol"><code>Symbol</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nameof(Base.Broadcast)
:Broadcast</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parentmodule" href="#Base.parentmodule"><code>Base.parentmodule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parentmodule(m::Module) -&gt; Module</code></pre><p>Get a module&#39;s enclosing <code>Module</code>. <code>Main</code> is its own parent.</p><p>See also: <a href="#Base.names"><code>names</code></a>, <a href="#Base.nameof-Tuple{DataType}"><code>nameof</code></a>, <a href="#Base.fullname"><code>fullname</code></a>, <a href="#Base.@__MODULE__"><code>@__MODULE__</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; parentmodule(Main)
Main

julia&gt; parentmodule(Base.Broadcast)
Base</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L18-L33">source</a></section><section><div><pre><code class="language-none">parentmodule(t::DataType) -&gt; Module</code></pre><p>Determine the module containing the definition of a (potentially <code>UnionAll</code>-wrapped) <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; module Foo
           struct Int end
       end
Foo

julia&gt; parentmodule(Int)
Core

julia&gt; parentmodule(Foo.Int)
Foo</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L241-L259">source</a></section><section><div><pre><code class="language-none">parentmodule(f::Function) -&gt; Module</code></pre><p>Determine the module containing the (first) definition of a generic function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L1459-L1464">source</a></section><section><div><pre><code class="language-none">parentmodule(f::Function, types) -&gt; Module</code></pre><p>Determine the module containing a given definition of a generic function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L1467-L1471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pathof-Tuple{Module}" href="#Base.pathof-Tuple{Module}"><code>Base.pathof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pathof(m::Module)</code></pre><p>Return the path of the <code>m.jl</code> file that was used to <code>import</code> module <code>m</code>, or <code>nothing</code> if <code>m</code> was not imported from a package.</p><p>Use <a href="../file/#Base.Filesystem.dirname"><code>dirname</code></a> to get the directory part and <a href="../file/#Base.Filesystem.basename"><code>basename</code></a> to get the file name part of the path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L362-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pkgdir-Tuple{Module}" href="#Base.pkgdir-Tuple{Module}"><code>Base.pkgdir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pkgdir(m::Module[, paths::String...])</code></pre><p>Return the root directory of the package that imported module <code>m</code>, or <code>nothing</code> if <code>m</code> was not imported from a package. Optionally further path component strings can be provided to construct a path within the package root.</p><pre><code class="language-julia-repl">julia&gt; pkgdir(Foo)
&quot;/path/to/Foo.jl&quot;

julia&gt; pkgdir(Foo, &quot;src&quot;, &quot;file.jl&quot;)
&quot;/path/to/Foo.jl/src/file.jl&quot;</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>The optional argument <code>paths</code> requires at least Julia 1.7.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L383-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.moduleroot" href="#Base.moduleroot"><code>Base.moduleroot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">moduleroot(m::Module) -&gt; Module</code></pre><p>Find the root module of a given module. This is the first module in the chain of parent modules of <code>m</code> which is either a registered root module or which is its own parent module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="__module__" href="#__module__"><code>__module__</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">__module__</code></pre><p>The argument <code>__module__</code> is only visible inside the macro, and it provides information (in the form of a <code>Module</code> object) about the expansion context of the macro invocation. See the manual section on <a href="base/@ref">Macro invocation</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L214-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="__source__" href="#__source__"><code>__source__</code></a> — <span class="docstring-category">Keyword</span></header><section><div><pre><code class="language-julia">__source__</code></pre><p>The argument <code>__source__</code> is only visible inside the macro, and it provides information (in the form of a <code>LineNumberNode</code> object) about the parser location of the <code>@</code> sign from the macro invocation. See the manual section on <a href="base/@ref">Macro invocation</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L223-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@__MODULE__" href="#Base.@__MODULE__"><code>Base.@__MODULE__</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@__MODULE__ -&gt; Module</code></pre><p>Get the <code>Module</code> of the toplevel eval, which is the <code>Module</code> code is currently being read from.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@__FILE__" href="#Base.@__FILE__"><code>Base.@__FILE__</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@__FILE__ -&gt; AbstractString</code></pre><p>Expand to a string with the path to the file containing the macrocall, or an empty string if evaluated by <code>julia -e &lt;expr&gt;</code>. Return <code>nothing</code> if the macro was missing parser source information. Alternatively see <a href="../constants/#Base.PROGRAM_FILE"><code>PROGRAM_FILE</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L2178-L2185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@__DIR__" href="#Base.@__DIR__"><code>Base.@__DIR__</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@__DIR__ -&gt; AbstractString</code></pre><p>Expand to a string with the absolute path to the directory of the file containing the macrocall. Return the current working directory if run from a REPL or if evaluated by <code>julia -e &lt;expr&gt;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L2191-L2197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@__LINE__" href="#Base.@__LINE__"><code>Base.@__LINE__</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@__LINE__ -&gt; Int</code></pre><p>Expand to the line number of the location of the macrocall. Return <code>0</code> if the line number could not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/essentials.jl#L871-L876">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fullname" href="#Base.fullname"><code>Base.fullname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fullname(m::Module)</code></pre><p>Get the fully-qualified name of a module as a tuple of symbols. For example,</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fullname(Base.Iterators)
(:Base, :Iterators)

julia&gt; fullname(Main)
(:Main,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L62-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.names" href="#Base.names"><code>Base.names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">names(x::Module; all::Bool = false, imported::Bool = false)</code></pre><p>Get an array of the names exported by a <code>Module</code>, excluding deprecated names. If <code>all</code> is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If <code>imported</code> is true, then names explicitly imported from other modules are also included.</p><p>As a special case, all names defined in <code>Main</code> are considered &quot;exported&quot;, since it is not idiomatic to explicitly export names from <code>Main</code>.</p><p>See also: <a href="#Base.@locals"><code>@locals</code></a>, <a href="#Base.@__MODULE__"><code>@__MODULE__</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L88-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.nfields" href="#Core.nfields"><code>Core.nfields</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nfields(x) -&gt; Int</code></pre><p>Get the number of fields in the given object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = 1//2;

julia&gt; nfields(a)
2

julia&gt; b = 1
1

julia&gt; nfields(b)
0

julia&gt; ex = ErrorException(&quot;I&#39;ve done a bad thing&quot;);

julia&gt; nfields(ex)
1</code></pre><p>In these examples, <code>a</code> is a <a href="../numbers/#Base.Rational"><code>Rational</code></a>, which has two fields. <code>b</code> is an <code>Int</code>, which is a primitive bitstype with no fields at all. <code>ex</code> is an <a href="#Core.ErrorException"><code>ErrorException</code></a>, which has one field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L1559-L1586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isconst" href="#Base.isconst"><code>Base.isconst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isconst(m::Module, s::Symbol) -&gt; Bool</code></pre><p>Determine whether a global is declared <code>const</code> in a given module <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L263-L267">source</a></section><section><div><pre><code class="language-none">isconst(t::DataType, s::Union{Int,Symbol}) -&gt; Bool</code></pre><p>Determine whether a field <code>s</code> is declared <code>const</code> in a given type <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nameof-Tuple{Function}" href="#Base.nameof-Tuple{Function}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nameof(f::Function) -&gt; Symbol</code></pre><p>Get the name of a generic <code>Function</code> as a symbol. For anonymous functions, this is a compiler-generated name. For explicitly-declared subtypes of <code>Function</code>, it is the name of the function&#39;s type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L1437-L1443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.functionloc-Tuple{Any, Any}" href="#Base.functionloc-Tuple{Any, Any}"><code>Base.functionloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">functionloc(f::Function, types)</code></pre><p>Returns a tuple <code>(filename,line)</code> giving the location of a generic <code>Function</code> definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/methodshow.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.functionloc-Tuple{Method}" href="#Base.functionloc-Tuple{Method}"><code>Base.functionloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">functionloc(m::Method)</code></pre><p>Returns a tuple <code>(filename,line)</code> giving the location of a <code>Method</code> definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/methodshow.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@locals" href="#Base.@locals"><code>Base.@locals</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@locals()</code></pre><p>Construct a dictionary of the names (as symbols) and values of all local variables defined as of the call site.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This macro requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; let x = 1, y = 2
           Base.@locals
       end
Dict{Symbol, Any} with 2 entries:
  :y =&gt; 2
  :x =&gt; 1

julia&gt; function f(x)
           local y
           show(Base.@locals); println()
           for i = 1:1
               show(Base.@locals); println()
           end
           y = 2
           show(Base.@locals); println()
           nothing
       end;

julia&gt; f(42)
Dict{Symbol, Any}(:x =&gt; 42)
Dict{Symbol, Any}(:i =&gt; 1, :x =&gt; 42)
Dict{Symbol, Any}(:y =&gt; 2, :x =&gt; 42)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L294-L328">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.GC.gc" href="#Base.GC.gc"><code>Base.GC.gc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GC.gc([full=true])</code></pre><p>Perform garbage collection. The argument <code>full</code> determines the kind of collection: A full collection (default) sweeps all objects, which makes the next GC scan much slower, while an incremental collection may only sweep so-called young objects.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Excessive use will likely lead to poor performance.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/gcutils.jl#L82-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.GC.enable" href="#Base.GC.enable"><code>Base.GC.enable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GC.enable(on::Bool)</code></pre><p>Control whether garbage collection is enabled using a boolean argument (<code>true</code> for enabled, <code>false</code> for disabled). Return previous GC state.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Disabling garbage collection should be used only with caution, as it can cause memory use to grow without bound.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/gcutils.jl#L96-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.GC.@preserve" href="#Base.GC.@preserve"><code>Base.GC.@preserve</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">GC.@preserve x1 x2 ... xn expr</code></pre><p>Mark the objects <code>x1, x2, ...</code> as being <em>in use</em> during the evaluation of the expression <code>expr</code>. This is only required in unsafe code where <code>expr</code> <em>implicitly uses</em> memory or other resources owned by one of the <code>x</code>s.</p><p><em>Implicit use</em> of <code>x</code> covers any indirect use of resources logically owned by <code>x</code> which the compiler cannot see. Some examples:</p><ul><li>Accessing memory of an object directly via a <code>Ptr</code></li><li>Passing a pointer to <code>x</code> to <code>ccall</code></li><li>Using resources of <code>x</code> which would be cleaned up in the finalizer.</li></ul><p><code>@preserve</code> should generally not have any performance impact in typical use cases where it briefly extends object lifetime. In implementation, <code>@preserve</code> has effects such as protecting dynamically allocated objects from garbage collection.</p><p><strong>Examples</strong></p><p>When loading from a pointer with <code>unsafe_load</code>, the underlying object is implicitly used, for example <code>x</code> is implicitly used by <code>unsafe_load(p)</code> in the following:</p><pre><code class="language-julia-repl">julia&gt; let
           x = Ref{Int}(101)
           p = Base.unsafe_convert(Ptr{Int}, x)
           GC.@preserve x unsafe_load(p)
       end
101</code></pre><p>When passing pointers to <code>ccall</code>, the pointed-to object is implicitly used and should be preserved. (Note however that you should normally just pass <code>x</code> directly to <code>ccall</code> which counts as an explicit use.)</p><pre><code class="language-julia-repl">julia&gt; let
           x = &quot;Hello&quot;
           p = pointer(x)
           Int(GC.@preserve x @ccall strlen(p::Cstring)::Csize_t)
           # Preferred alternative
           Int(@ccall strlen(x::Cstring)::Csize_t)
       end
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/gcutils.jl#L129-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.GC.safepoint" href="#Base.GC.safepoint"><code>Base.GC.safepoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GC.safepoint()</code></pre><p>Inserts a point in the program where garbage collection may run. This can be useful in rare cases in multi-threaded programs where some threads are allocating memory (and hence may need to run GC) but other threads are doing only simple operations (no allocation, task switches, or I/O). Calling this function periodically in non-allocating threads allows garbage collection to run.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>This function is available as of Julia 1.4.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/gcutils.jl#L185-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Meta.lower" href="#Base.Meta.lower"><code>Base.Meta.lower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lower(m, x)</code></pre><p>Takes the expression <code>x</code> and returns an equivalent expression in lowered form for executing in module <code>m</code>. See also <a href="#Base.code_lowered"><code>code_lowered</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/meta.jl#L157-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Meta.@lower" href="#Base.Meta.@lower"><code>Base.Meta.@lower</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@lower [m] x</code></pre><p>Return lowered form of the expression <code>x</code> in module <code>m</code>. By default <code>m</code> is the module in which the macro is called. See also <a href="#Base.Meta.lower"><code>lower</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/meta.jl#L166-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Meta.parse-Tuple{AbstractString, Int64}" href="#Base.Meta.parse-Tuple{AbstractString, Int64}"><code>Base.Meta.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse(str, start; greedy=true, raise=true, depwarn=true)</code></pre><p>Parse the expression string and return an expression (which could later be passed to eval for execution). <code>start</code> is the code unit index into <code>str</code> of the first character to start parsing at (as with all string indexing, these are not character indices). If <code>greedy</code> is <code>true</code> (default), <code>parse</code> will try to consume as much input as it can; otherwise, it will stop as soon as it has parsed a valid expression. Incomplete but otherwise syntactically valid expressions will return <code>Expr(:incomplete, &quot;(error message)&quot;)</code>. If <code>raise</code> is <code>true</code> (default), syntax errors other than incomplete expressions will raise an error. If <code>raise</code> is <code>false</code>, <code>parse</code> will return an expression that will raise an error upon evaluation. If <code>depwarn</code> is <code>false</code>, deprecation warnings will be suppressed.</p><pre><code class="language-julia-repl">julia&gt; Meta.parse(&quot;(α, β) = 3, 5&quot;, 1) # start of string
(:((α, β) = (3, 5)), 16)

julia&gt; Meta.parse(&quot;(α, β) = 3, 5&quot;, 1, greedy=false)
(:((α, β)), 9)

julia&gt; Meta.parse(&quot;(α, β) = 3, 5&quot;, 16) # end of string
(nothing, 16)

julia&gt; Meta.parse(&quot;(α, β) = 3, 5&quot;, 11) # index of 3
(:((3, 5)), 16)

julia&gt; Meta.parse(&quot;(α, β) = 3, 5&quot;, 11, greedy=false)
(3, 13)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/meta.jl#L202-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Meta.parse-Tuple{AbstractString}" href="#Base.Meta.parse-Tuple{AbstractString}"><code>Base.Meta.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse(str; raise=true, depwarn=true)</code></pre><p>Parse the expression string greedily, returning a single expression. An error is thrown if there are additional characters after the first expression. If <code>raise</code> is <code>true</code> (default), syntax errors will raise an error; otherwise, <code>parse</code> will return an expression that will raise an error upon evaluation.  If <code>depwarn</code> is <code>false</code>, deprecation warnings will be suppressed.</p><pre><code class="language-julia-repl">julia&gt; Meta.parse(&quot;x = 3&quot;)
:(x = 3)

julia&gt; Meta.parse(&quot;x = &quot;)
:($(Expr(:incomplete, &quot;incomplete: premature end of input&quot;)))

julia&gt; Meta.parse(&quot;1.0.2&quot;)
ERROR: Base.Meta.ParseError(&quot;invalid numeric constant \&quot;1.0.\&quot;&quot;)
Stacktrace:
[...]

julia&gt; Meta.parse(&quot;1.0.2&quot;; raise = false)
:($(Expr(:error, &quot;invalid numeric constant \&quot;1.0.\&quot;&quot;)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/meta.jl#L242-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Meta.ParseError" href="#Base.Meta.ParseError"><code>Base.Meta.ParseError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParseError(msg)</code></pre><p>The expression passed to the <a href="#Base.Meta.parse-Tuple{AbstractString, Int64}"><code>parse</code></a> function could not be interpreted as a valid Julia expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/meta.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.QuoteNode" href="#Core.QuoteNode"><code>Core.QuoteNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuoteNode</code></pre><p>A quoted piece of code, that does not support interpolation. See the <a href="../../manual/metaprogramming/#man-quote-node">manual section about QuoteNodes</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/docs/basedocs.jl#L2851-L2855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.macroexpand" href="#Base.macroexpand"><code>Base.macroexpand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">macroexpand(m::Module, x; recursive=true)</code></pre><p>Take the expression <code>x</code> and return an equivalent expression with all macros removed (expanded) for executing in module <code>m</code>. The <code>recursive</code> keyword controls whether deeper levels of nested macros are also expanded. This is demonstrated in the example below:</p><pre><code class="language-julia-repl">julia&gt; module M
           macro m1()
               42
           end
           macro m2()
               :(@m1())
           end
       end
M

julia&gt; macroexpand(M, :(@m2()), recursive=true)
42

julia&gt; macroexpand(M, :(@m2()), recursive=false)
:(#= REPL[16]:6 =# M.@m1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L88-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@macroexpand" href="#Base.@macroexpand"><code>Base.@macroexpand</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@macroexpand</code></pre><p>Return equivalent expression with all macros removed (expanded).</p><p>There are differences between <code>@macroexpand</code> and <a href="#Base.macroexpand"><code>macroexpand</code></a>.</p><ul><li><p>While <a href="#Base.macroexpand"><code>macroexpand</code></a> takes a keyword argument <code>recursive</code>, <code>@macroexpand</code> is always recursive. For a non recursive macro version, see <a href="#Base.@macroexpand1"><code>@macroexpand1</code></a>.</p></li><li><p>While <a href="#Base.macroexpand"><code>macroexpand</code></a> has an explicit <code>module</code> argument, <code>@macroexpand</code> always expands with respect to the module in which it is called.</p></li></ul><p>This is best seen in the following example:</p><pre><code class="language-julia-repl">julia&gt; module M
           macro m()
               1
           end
           function f()
               (@macroexpand(@m),
                macroexpand(M, :(@m)),
                macroexpand(Main, :(@m))
               )
           end
       end
M

julia&gt; macro m()
           2
       end
@m (macro with 1 method)

julia&gt; M.f()
(1, 1, 2)</code></pre><p>With <code>@macroexpand</code> the expression expands where <code>@macroexpand</code> appears in the code (module <code>M</code> in the example). With <code>macroexpand</code> the expression expands in the module given as the first argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L121-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@macroexpand1" href="#Base.@macroexpand1"><code>Base.@macroexpand1</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@macroexpand1</code></pre><p>Non recursive version of <a href="#Base.@macroexpand"><code>@macroexpand</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/expr.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.code_lowered" href="#Base.code_lowered"><code>Base.code_lowered</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">code_lowered(f, types; generated=true, debuginfo=:default)</code></pre><p>Return an array of the lowered forms (IR) for the methods matching the given generic function and type signature.</p><p>If <code>generated</code> is <code>false</code>, the returned <code>CodeInfo</code> instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If <code>generated</code> is <code>true</code>, these <code>CodeInfo</code> instances will correspond to the method bodies yielded by expanding the generators.</p><p>The keyword <code>debuginfo</code> controls the amount of code metadata present in the output.</p><p>Note that an error will be thrown if <code>types</code> are not leaf types when <code>generated</code> is <code>true</code> and any of the corresponding methods are an <code>@generated</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L880-L895">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.code_typed" href="#Base.code_typed"><code>Base.code_typed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">code_typed(f, types; kw...)</code></pre><p>Returns an array of type-inferred lowered form (IR) for the methods matching the given generic function and type signature.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>optimize=true</code>: controls whether additional optimizations, such as inlining, are also applied.</li><li><code>debuginfo=:default</code>: controls the amount of code metadata present in the output,</li></ul><p>possible options are <code>:source</code> or <code>:none</code>.</p><p><strong>Internal Keyword Arguments</strong></p><p>This section should be considered internal, and is only for who understands Julia compiler internals.</p><ul><li><code>world=Base.get_world_counter()</code>: optional, controls the world age to use when looking up methods,</li></ul><p>use current world age if not specified.</p><ul><li><code>interp=Core.Compiler.NativeInterpreter(world)</code>: optional, controls the interpreter to use,</li></ul><p>use the native interpreter Julia uses if not specified.</p><p><strong>Example</strong></p><p>One can put the argument types in a tuple to get the corresponding <code>code_typed</code>.</p><pre><code class="language-julia">julia&gt; code_typed(+, (Float64, Float64))
1-element Vector{Any}:
 CodeInfo(
1 ─ %1 = Base.add_float(x, y)::Float64
└──      return %1
) =&gt; Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/reflection.jl#L1189-L1223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.precompile" href="#Base.precompile"><code>Base.precompile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">precompile(f, args::Tuple{Vararg{Any}})</code></pre><p>Compile the given function <code>f</code> for the argument tuple (of types) <code>args</code>, but do not execute it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/loading.jl#L2204-L2208">source</a></section></article><h2 id="Meta"><a class="docs-heading-anchor" href="#Meta">Meta</a><a id="Meta-1"></a><a class="docs-heading-anchor-permalink" href="#Meta" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.Meta.quot" href="#Base.Meta.quot"><code>Base.Meta.quot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Meta.quot(ex)::Expr</code></pre><p>Quote expression <code>ex</code> to produce an expression with head <code>quote</code>. This can for instance be used to represent objects of type <code>Expr</code> in the AST. See also the manual section about <a href="../../manual/metaprogramming/#man-quote-node">QuoteNode</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eval(Meta.quot(:x))
:x

julia&gt; dump(Meta.quot(:x))
Expr
  head: Symbol quote
  args: Array{Any}((1,))
    1: Symbol x

julia&gt; eval(Meta.quot(:(1+2)))
:(1 + 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/meta.jl#L24-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isexpr" href="#Base.isexpr"><code>Base.isexpr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Meta.isexpr(ex, head[, n])::Bool</code></pre><p>Return true if <code>ex</code> is an <code>Expr</code> with the given type <code>head</code> and optionally that the argument list is of length <code>n</code>. <code>head</code> may be a <code>Symbol</code> or collection of <code>Symbol</code>s. For example, to check that a macro was passed a function call expression, you might use <code>isexpr(ex, :call)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ex = :(f(x))
:(f(x))

julia&gt; Meta.isexpr(ex, :block)
false

julia&gt; Meta.isexpr(ex, :call)
true

julia&gt; Meta.isexpr(ex, [:block, :call]) # multiple possible heads
true

julia&gt; Meta.isexpr(ex, :call, 1)
false

julia&gt; Meta.isexpr(ex, :call, 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/meta.jl#L48-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isidentifier" href="#Base.isidentifier"><code>Base.isidentifier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> isidentifier(s) -&gt; Bool</code></pre><p>Return whether the symbol or string <code>s</code> contains characters that are parsed as a valid ordinary identifier (not a binary/unary operator) in Julia code; see also <a href="#Base.isoperator"><code>Base.isoperator</code></a>.</p><p>Internally Julia allows any sequence of characters in a <code>Symbol</code> (except <code>\0</code>s), and macros automatically use variable names containing <code>#</code> in order to avoid naming collision with the surrounding code. In order for the parser to recognize a variable, it uses a limited set of characters (greatly extended by Unicode). <code>isidentifier()</code> makes it possible to query the parser directly whether a symbol contains valid characters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Meta.isidentifier(:x), Meta.isidentifier(&quot;1x&quot;)
(true, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/show.jl#L1335-L1354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isoperator" href="#Base.isoperator"><code>Base.isoperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isoperator(s::Symbol)</code></pre><p>Return <code>true</code> if the symbol can be used as an operator, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Meta.isoperator(:+), Meta.isoperator(:f)
(true, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/show.jl#L1369-L1379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isunaryoperator" href="#Base.isunaryoperator"><code>Base.isunaryoperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isunaryoperator(s::Symbol)</code></pre><p>Return <code>true</code> if the symbol can be used as a unary (prefix) operator, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Meta.isunaryoperator(:-), Meta.isunaryoperator(:√), Meta.isunaryoperator(:f)
(true, true, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/show.jl#L1382-L1392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isbinaryoperator" href="#Base.isbinaryoperator"><code>Base.isbinaryoperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isbinaryoperator(s::Symbol)</code></pre><p>Return <code>true</code> if the symbol can be used as a binary (infix) operator, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Meta.isbinaryoperator(:-), Meta.isbinaryoperator(:√), Meta.isbinaryoperator(:f)
(true, false, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/show.jl#L1397-L1407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Meta.show_sexpr" href="#Base.Meta.show_sexpr"><code>Base.Meta.show_sexpr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Meta.show_sexpr([io::IO,], ex)</code></pre><p>Show expression <code>ex</code> as a lisp style S-expression.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Meta.show_sexpr(:(f(x, g(y,z))))
(:call, :f, :x, (:call, :g, :y, :z))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/meta.jl#L109-L119">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../manual/command-line-options/">« 命令行选项</a><a class="docs-footer-nextpage" href="../collections/">集合和数据结构 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2024 十月 24 周四 14:44">2024 十月 24 周四</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.8.5版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
