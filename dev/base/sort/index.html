<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>排序及相关函数 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/base/sort/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">一维和多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/">基本功能</a></li><li><a class="tocitem" href="../collections/">集合和数据结构</a></li><li><a class="tocitem" href="../math/">数学相关</a></li><li><a class="tocitem" href="../numbers/">标准数值类型</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../arrays/">数组</a></li><li><a class="tocitem" href="../parallel/">Tasks</a></li><li><a class="tocitem" href="../multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../constants/">常量</a></li><li><a class="tocitem" href="../file/">文件系统</a></li><li><a class="tocitem" href="../io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../punctuation/">运算符与记号</a></li><li class="is-active"><a class="tocitem" href>排序及相关函数</a><ul class="internal"><li><a class="tocitem" href="#排序函数"><span>排序函数</span></a></li><li><a class="tocitem" href="#排列顺序相关的函数"><span>排列顺序相关的函数</span></a></li><li><a class="tocitem" href="#排序算法"><span>排序算法</span></a></li><li><a class="tocitem" href="#Alternate-Orderings"><span>Alternate Orderings</span></a></li></ul></li><li><a class="tocitem" href="../iterators/">迭代相关</a></li><li><a class="tocitem" href="../reflection/">反射 与 自我检查</a></li><li><a class="tocitem" href="../c/">C 接口</a></li><li><a class="tocitem" href="../libc/">C 标准库</a></li><li><a class="tocitem" href="../stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/pkgimg/">Package Images</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../../devdocs/gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../../devdocs/precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../../devdocs/probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../../devdocs/build/linux/">Linux</a></li><li><a class="tocitem" href="../../devdocs/build/macos/">macOS</a></li><li><a class="tocitem" href="../../devdocs/build/windows/">Windows</a></li><li><a class="tocitem" href="../../devdocs/build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../../devdocs/build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../../devdocs/build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href>排序及相关函数</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>排序及相关函数</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/base-zh_cn/translate/#zh_CN/sortmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="排序及相关函数"><a class="docs-heading-anchor" href="#排序及相关函数">排序及相关函数</a><a id="排序及相关函数-1"></a><a class="docs-heading-anchor-permalink" href="#排序及相关函数" title="Permalink"></a></h1><p>Julia 拥有广泛而灵活的应用程序接口，可用于对已排序的数组值进行排序和交互。 默认情况下，Julia 会选择合理的算法并按升序排序：</p><pre><code class="language-julia-repl">julia&gt; sort([2,3,1])
3-element Vector{Int64}:
 1
 2
 3</code></pre><p>You can sort in reverse order as well:</p><pre><code class="language-julia-repl">julia&gt; sort([2,3,1], rev=true)
3-element Vector{Int64}:
 3
 2
 1</code></pre><p><code>sort</code> constructs a sorted copy leaving its input unchanged. Use the &quot;bang&quot; version of the sort function to mutate an existing array:</p><pre><code class="language-julia-repl">julia&gt; a = [2,3,1];

julia&gt; sort!(a);

julia&gt; a
3-element Vector{Int64}:
 1
 2
 3</code></pre><p>Instead of directly sorting an array, you can compute a permutation of the array&#39;s indices that puts the array into sorted order:</p><pre><code class="language-julia-repl">julia&gt; v = randn(5)
5-element Array{Float64,1}:
  0.297288
  0.382396
 -0.597634
 -0.0104452
 -0.839027

julia&gt; p = sortperm(v)
5-element Array{Int64,1}:
 5
 3
 4
 1
 2

julia&gt; v[p]
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</code></pre><p>Arrays can be sorted according to an arbitrary transformation of their values:</p><pre><code class="language-julia-repl">julia&gt; sort(v, by=abs)
5-element Array{Float64,1}:
 -0.0104452
  0.297288
  0.382396
 -0.597634
 -0.839027</code></pre><p>或者通过转换来进行逆序排序</p><pre><code class="language-julia-repl">julia&gt; sort(v, by=abs, rev=true)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
  0.382396
  0.297288
 -0.0104452</code></pre><p>如有必要，可以选择排序算法：</p><pre><code class="language-julia-repl">julia&gt; sort(v, alg=InsertionSort)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</code></pre><p>All the sorting and order related functions rely on a &quot;less than&quot; relation defining a <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">strict weak order</a> on the values to be manipulated. The <code>isless</code> function is invoked by default, but the relation can be specified via the <code>lt</code> keyword, a function that takes two array elements and returns <code>true</code> if and only if the first argument is &quot;less than&quot; the second. See <a href="#Base.sort!"><code>sort!</code></a> and <a href="#Alternate-Orderings">Alternate Orderings</a> for more information.</p><h2 id="排序函数"><a class="docs-heading-anchor" href="#排序函数">排序函数</a><a id="排序函数-1"></a><a class="docs-heading-anchor-permalink" href="#排序函数" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.sort!" href="#Base.sort!"><code>Base.sort!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort the vector <code>v</code> in place. A stable algorithm is used by default: the ordering of elements that compare equal is preserved. A specific algorithm can be selected via the <code>alg</code> keyword (see <a href="base/@ref">Sorting Algorithms</a> for available algorithms).</p><p>Elements are first transformed with the function <code>by</code> and then compared according to either the function <code>lt</code> or the ordering <code>order</code>. Finally, the resulting order is reversed if <code>rev=true</code> (this preserves forward stability: elements that compare equal are not reversed). The current implemention applies the <code>by</code> transformation before each comparison rather than once per element.</p><p>Passing an <code>lt</code> other than <code>isless</code> along with an <code>order</code> other than <a href="#Base.Order.Forward"><code>Base.Order.Forward</code></a> or <a href="#Base.Order.Reverse"><code>Base.Order.Reverse</code></a> is not permitted, otherwise all options are independent and can be used together in all possible combinations. Note that <code>order</code> can also include a &quot;by&quot; transformation, in which case it is applied after that defined with the <code>by</code> keyword. For more information on <code>order</code> values see the documentation on <a href="#Alternate-Orderings">Alternate Orderings</a>.</p><p>Relations between two elements are defined as follows (with &quot;less&quot; and &quot;greater&quot; exchanged when <code>rev=true</code>):</p><ul><li><code>x</code> is less than <code>y</code> if <code>lt(by(x), by(y))</code> (or <code>Base.Order.lt(order, by(x), by(y))</code>) yields true.</li><li><code>x</code> is greater than <code>y</code> if <code>y</code> is less than <code>x</code>.</li><li><code>x</code> and <code>y</code> are equivalent if neither is less than the other (&quot;incomparable&quot; is sometimes used as a synonym for &quot;equivalent&quot;).</li></ul><p>The result of <code>sort!</code> is sorted in the sense that every element is greater than or equivalent to the previous one.</p><p>The <code>lt</code> function must define a strict weak order, that is, it must be</p><ul><li>irreflexive: <code>lt(x, x)</code> always yields <code>false</code>,</li><li>asymmetric: if <code>lt(x, y)</code> yields <code>true</code> then <code>lt(y, x)</code> yields <code>false</code>,</li><li>transitive: <code>lt(x, y) &amp;&amp; lt(y, z)</code> implies <code>lt(x, z)</code>,</li><li>transitive in equivalence: <code>!lt(x, y) &amp;&amp; !lt(y, x)</code> and <code>!lt(y, z) &amp;&amp; !lt(z, y)</code> together imply <code>!lt(x, z) &amp;&amp; !lt(z, x)</code>. In words: if <code>x</code> and <code>y</code> are equivalent and <code>y</code> and <code>z</code> are equivalent then <code>x</code> and <code>z</code> must be equivalent.</li></ul><p>For example <code>&lt;</code> is a valid <code>lt</code> function for <code>Int</code> values but <code>≤</code> is not: it violates irreflexivity. For <code>Float64</code> values even <code>&lt;</code> is invalid as it violates the fourth condition: <code>1.0</code> and <code>NaN</code> are equivalent and so are <code>NaN</code> and <code>2.0</code> but <code>1.0</code> and <code>2.0</code> are not equivalent.</p><p>See also <a href="#Base.sort"><code>sort</code></a>, <a href="#Base.sortperm"><code>sortperm</code></a>, <a href="#Base.sortslices"><code>sortslices</code></a>, <a href="#Base.Sort.partialsort!"><code>partialsort!</code></a>, <a href="#Base.Sort.partialsortperm"><code>partialsortperm</code></a>, <a href="#Base.issorted"><code>issorted</code></a>, <a href="#Base.Sort.searchsorted"><code>searchsorted</code></a>, <a href="#Base.Sort.insorted"><code>insorted</code></a>, <a href="#Base.Order.ord"><code>Base.Order.ord</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, 1, 2]; sort!(v); v
3-element Vector{Int64}:
 1
 2
 3

julia&gt; v = [3, 1, 2]; sort!(v, rev = true); v
3-element Vector{Int64}:
 3
 2
 1

julia&gt; v = [(1, &quot;c&quot;), (3, &quot;a&quot;), (2, &quot;b&quot;)]; sort!(v, by = x -&gt; x[1]); v
3-element Vector{Tuple{Int64, String}}:
 (1, &quot;c&quot;)
 (2, &quot;b&quot;)
 (3, &quot;a&quot;)

julia&gt; v = [(1, &quot;c&quot;), (3, &quot;a&quot;), (2, &quot;b&quot;)]; sort!(v, by = x -&gt; x[2]); v
3-element Vector{Tuple{Int64, String}}:
 (3, &quot;a&quot;)
 (2, &quot;b&quot;)
 (1, &quot;c&quot;)

julia&gt; sort(0:3, by=x-&gt;x-2, order=Base.Order.By(abs)) # same as sort(0:3, by=abs(x-&gt;x-2))
4-element Vector{Int64}:
 2
 1
 3
 0

julia&gt; sort([2, NaN, 1, NaN, 3]) # correct sort with default lt=isless
5-element Vector{Float64}:
   1.0
   2.0
   3.0
 NaN
 NaN

julia&gt; sort([2, NaN, 1, NaN, 3], lt=&lt;) # wrong sort due to invalid lt. This behavior is undefined.
5-element Vector{Float64}:
   2.0
 NaN
   1.0
 NaN
   3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L1354-L1455">source</a></section><section><div><pre><code class="language-none">sort!(A; dims::Integer, alg::Algorithm=defalg(A), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort the multidimensional array <code>A</code> along dimension <code>dims</code>. See the one-dimensional version of <a href="#Base.sort!"><code>sort!</code></a> for a description of possible keyword arguments.</p><p>To sort slices of an array, refer to <a href="#Base.sortslices"><code>sortslices</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 3; 1 2]
2×2 Matrix{Int64}:
 4  3
 1  2

julia&gt; sort!(A, dims = 1); A
2×2 Matrix{Int64}:
 1  2
 4  3

julia&gt; sort!(A, dims = 2); A
2×2 Matrix{Int64}:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L1828-L1857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort" href="#Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Variant of <a href="#Base.sort!"><code>sort!</code></a> that returns a sorted copy of <code>v</code> leaving <code>v</code> itself unmodified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, 1, 2];

julia&gt; sort(v)
3-element Vector{Int64}:
 1
 2
 3

julia&gt; v
3-element Vector{Int64}:
 3
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L1467-L1488">source</a></section><section><div><pre><code class="language-none">sort(A; dims::Integer, alg::Algorithm=defalg(A), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort a multidimensional array <code>A</code> along the given dimension. See <a href="#Base.sort!"><code>sort!</code></a> for a description of possible keyword arguments.</p><p>To sort slices of an array, refer to <a href="#Base.sortslices"><code>sortslices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 3; 1 2]
2×2 Matrix{Int64}:
 4  3
 1  2

julia&gt; sort(A, dims = 1)
2×2 Matrix{Int64}:
 1  2
 4  3

julia&gt; sort(A, dims = 2)
2×2 Matrix{Int64}:
 3  4
 1  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L1756-L1782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sortperm" href="#Base.sortperm"><code>Base.sortperm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sortperm(A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, [dims::Integer])</code></pre><p>Return a permutation vector or array <code>I</code> that puts <code>A[I]</code> in sorted order along the given dimension. If <code>A</code> has more than one dimension, then the <code>dims</code> keyword argument must be specified. The order is specified using the same keywords as <a href="#Base.sort!"><code>sort!</code></a>. The permutation is guaranteed to be stable even if the sorting algorithm is unstable: the indices of equal elements will appear in ascending order.</p><p>See also <a href="#Base.Sort.sortperm!"><code>sortperm!</code></a>, <a href="#Base.Sort.partialsortperm"><code>partialsortperm</code></a>, <a href="../arrays/#Base.invperm"><code>invperm</code></a>, <a href="../collections/#Base.indexin"><code>indexin</code></a>. To sort slices of an array, refer to <a href="#Base.sortslices"><code>sortslices</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.9</header><div class="admonition-body"><p>The method accepting <code>dims</code> requires at least Julia 1.9.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, 1, 2];

julia&gt; p = sortperm(v)
3-element Vector{Int64}:
 2
 3
 1

julia&gt; v[p]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; A = [8 7; 5 6]
2×2 Matrix{Int64}:
 8  7
 5  6

julia&gt; sortperm(A, dims = 1)
2×2 Matrix{Int64}:
 2  4
 1  3

julia&gt; sortperm(A, dims = 2)
2×2 Matrix{Int64}:
 3  1
 2  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L1590-L1636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.InsertionSort" href="#Base.Sort.InsertionSort"><code>Base.Sort.InsertionSort</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">InsertionSort</code></pre><p>Use the insertion sort algorithm.</p><p>Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output vector.</p><p>Characteristics:</p><ul><li><em>stable</em>: preserves the ordering of elements that compare equal</li></ul><p>(e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters that ignores case).</p><ul><li><em>in-place</em> in memory.</li><li><em>quadratic performance</em> in the number of elements to be sorted:</li></ul><p>it is well-suited to small collections but should not be used for large ones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L759-L773">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.MergeSort" href="#Base.Sort.MergeSort"><code>Base.Sort.MergeSort</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">MergeSort</code></pre><p>Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.</p><p>Characteristics:</p><ul><li><em>stable</em>: preserves the ordering of elements that compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters that ignores case).</li><li><em>not in-place</em> in memory.</li><li><em>divide-and-conquer</em> sort strategy.</li><li><em>good performance</em> for large collections but typically not quite as fast as <a href="#Base.Sort.QuickSort"><code>QuickSort</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L2034-L2051">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.QuickSort" href="#Base.Sort.QuickSort"><code>Base.Sort.QuickSort</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">QuickSort</code></pre><p>Indicate that a sorting function should use the quick sort algorithm, which is <em>not</em> stable.</p><p>Characteristics:</p><ul><li><em>not stable</em>: does not preserve the ordering of elements that compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters that ignores case).</li><li><em>in-place</em> in memory.</li><li><em>divide-and-conquer</em>: sort strategy similar to <a href="#Base.Sort.MergeSort"><code>MergeSort</code></a>.</li><li><em>good performance</em> for large collections.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L2018-L2031">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.PartialQuickSort" href="#Base.Sort.PartialQuickSort"><code>Base.Sort.PartialQuickSort</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PartialQuickSort{T &lt;: Union{Integer,OrdinalRange}}</code></pre><p>Indicate that a sorting function should use the partial quick sort algorithm. <code>PartialQuickSort(k)</code> is like <code>QuickSort</code>, but is only required to find and sort the elements that would end up in <code>v[k]</code> were <code>v</code> fully sorted.</p><p>Characteristics:</p><ul><li><em>not stable</em>: does not preserve the ordering of elements that compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters that ignores case).</li><li><em>in-place</em> in memory.</li><li><em>divide-and-conquer</em>: sort strategy similar to <a href="#Base.Sort.MergeSort"><code>MergeSort</code></a>.</li></ul><p>Note that <code>PartialQuickSort(k)</code> does not necessarily sort the whole array. For example,</p><pre><code class="language-julia-repl">julia&gt; x = rand(100);

julia&gt; k = 50:100;

julia&gt; s1 = sort(x; alg=QuickSort);

julia&gt; s2 = sort(x; alg=PartialQuickSort(k));

julia&gt; map(issorted, (s1, s2))
(true, false)

julia&gt; map(x-&gt;issorted(x[k]), (s1, s2))
(true, true)

julia&gt; s1[k] == s2[k]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L1979-L2013">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.sortperm!" href="#Base.Sort.sortperm!"><code>Base.Sort.sortperm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sortperm!(ix, A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, [dims::Integer])</code></pre><p>Like <a href="#Base.sortperm"><code>sortperm</code></a>, but accepts a preallocated index vector or array <code>ix</code> with the same <code>axes</code> as <code>A</code>. <code>ix</code> is initialized to contain the values <code>LinearIndices(A)</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Behavior can be unexpected when any mutated argument shares memory with any other argument.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.9</header><div class="admonition-body"><p>The method accepting <code>dims</code> requires at least Julia 1.9.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, 1, 2]; p = zeros(Int, 3);

julia&gt; sortperm!(p, v); p
3-element Vector{Int64}:
 2
 3
 1

julia&gt; v[p]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; A = [8 7; 5 6]; p = zeros(Int,2, 2);

julia&gt; sortperm!(p, A; dims=1); p
2×2 Matrix{Int64}:
 2  4
 1  3

julia&gt; sortperm!(p, A; dims=2); p
2×2 Matrix{Int64}:
 3  1
 2  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L1668-L1707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sortslices" href="#Base.sortslices"><code>Base.sortslices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort slices of an array <code>A</code>. The required keyword argument <code>dims</code> must be either an integer or a tuple of integers. It specifies the dimension(s) over which the slices are sorted.</p><p>E.g., if <code>A</code> is a matrix, <code>dims=1</code> will sort rows, <code>dims=2</code> will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.</p><p>For the remaining keyword arguments, see the documentation of <a href="#Base.sort!"><code>sort!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows
3×3 Matrix{Int64}:
 -1   6  4
  7   3  5
  9  -2  8

julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt=(x,y)-&gt;isless(x[2],y[2]))
3×3 Matrix{Int64}:
  9  -2  8
  7   3  5
 -1   6  4

julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev=true)
3×3 Matrix{Int64}:
  9  -2  8
  7   3  5
 -1   6  4

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns
3×3 Matrix{Int64}:
  3   5  7
 -1  -4  6
 -2   8  9

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort, lt=(x,y)-&gt;isless(x[2],y[2]))
3×3 Matrix{Int64}:
  5   3  7
 -4  -1  6
  8  -2  9

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev=true)
3×3 Matrix{Int64}:
 7   5   3
 6  -4  -1
 9   8  -2</code></pre><p><strong>Higher dimensions</strong></p><p><code>sortslices</code> extends naturally to higher dimensions. E.g., if <code>A</code> is a a 2x2x2 array, <code>sortslices(A, dims=3)</code> will sort slices within the 3rd dimension, passing the 2x2 slices <code>A[:, :, 1]</code> and <code>A[:, :, 2]</code> to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the <code>by</code> or <code>lt</code> keyword argument to specify such an order.</p><p>If <code>dims</code> is a tuple, the order of the dimensions in <code>dims</code> is relevant and specifies the linear order of the slices. E.g., if <code>A</code> is three dimensional and <code>dims</code> is <code>(1, 2)</code>, the orderings of the first two dimensions are re-arranged such that the slices (of the remaining third dimension) are sorted. If <code>dims</code> is <code>(2, 1)</code> instead, the same slices will be taken, but the result order will be row-major instead.</p><p><strong>Higher dimensional examples</strong></p><pre><code class="language-none">julia&gt; A = permutedims(reshape([4 3; 2 1; &#39;A&#39; &#39;B&#39;; &#39;C&#39; &#39;D&#39;], (2, 2, 2)), (1, 3, 2))
2×2×2 Array{Any, 3}:
[:, :, 1] =
 4  3
 2  1

[:, :, 2] =
 &#39;A&#39;  &#39;B&#39;
 &#39;C&#39;  &#39;D&#39;

julia&gt; sortslices(A, dims=(1,2))
2×2×2 Array{Any, 3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 &#39;D&#39;  &#39;B&#39;
 &#39;C&#39;  &#39;A&#39;

julia&gt; sortslices(A, dims=(2,1))
2×2×2 Array{Any, 3}:
[:, :, 1] =
 1  2
 3  4

[:, :, 2] =
 &#39;D&#39;  &#39;C&#39;
 &#39;B&#39;  &#39;A&#39;

julia&gt; sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x-&gt;x[1,1])
1×1×5 Array{Int64, 3}:
[:, :, 1] =
 1

[:, :, 2] =
 2

[:, :, 3] =
 3

[:, :, 4] =
 4

[:, :, 5] =
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/multidimensional.jl#L1787-L1903">source</a></section></article><h2 id="排列顺序相关的函数"><a class="docs-heading-anchor" href="#排列顺序相关的函数">排列顺序相关的函数</a><a id="排列顺序相关的函数-1"></a><a class="docs-heading-anchor-permalink" href="#排列顺序相关的函数" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.issorted" href="#Base.issorted"><code>Base.issorted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issorted(v, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Test whether a collection is in sorted order. The keywords modify what order is considered sorted, as described in the <a href="#Base.sort!"><code>sort!</code></a> documentation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; issorted([1, 2, 3])
true

julia&gt; issorted([(1, &quot;b&quot;), (2, &quot;a&quot;)], by = x -&gt; x[1])
true

julia&gt; issorted([(1, &quot;b&quot;), (2, &quot;a&quot;)], by = x -&gt; x[2])
false

julia&gt; issorted([(1, &quot;b&quot;), (2, &quot;a&quot;)], by = x -&gt; x[2], rev=true)
true

julia&gt; issorted([1, 2, -2, 3], by=abs)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L64-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.searchsorted" href="#Base.Sort.searchsorted"><code>Base.Sort.searchsorted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">searchsorted(v, x; by=identity, lt=isless, rev=false)</code></pre><p>Return the range of indices in <code>v</code> where values are equivalent to <code>x</code>, or an empty range located at the insertion point if <code>v</code> does not contain values equivalent to <code>x</code>. The vector <code>v</code> must be sorted according to the order defined by the keywords. Refer to <a href="#Base.sort!"><code>sort!</code></a> for the meaning of the keywords and the definition of equivalence. Note that the <code>by</code> function is applied to the searched value <code>x</code> as well as the values in <code>v</code>.</p><p>The range is generally found using binary search, but there are optimized implementations for some inputs.</p><p>See also: <a href="#Base.Sort.searchsortedfirst"><code>searchsortedfirst</code></a>, <a href="#Base.sort!"><code>sort!</code></a>, <a href="#Base.Sort.insorted"><code>insorted</code></a>, <a href="../arrays/#Base.findall-Tuple{Any}"><code>findall</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 4) # single match
3:3

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 5) # multiple matches
4:5

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
3:2

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
7:6

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
1:0

julia&gt; searchsorted([1=&gt;&quot;one&quot;, 2=&gt;&quot;two&quot;, 2=&gt;&quot;two&quot;, 4=&gt;&quot;four&quot;], 2=&gt;&quot;two&quot;, by=first) # compare the keys of the pairs
2:3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L297-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.searchsortedfirst" href="#Base.Sort.searchsortedfirst"><code>Base.Sort.searchsortedfirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">searchsortedfirst(v, x; by=identity, lt=isless, rev=false)</code></pre><p>Return the index of the first value in <code>v</code> greater than or equivalent to <code>x</code>. If <code>x</code> is greater than all values in <code>v</code>, return <code>lastindex(v) + 1</code>.</p><p>The vector <code>v</code> must be sorted according to the order defined by the keywords. <code>insert!</code>ing <code>x</code> at the returned index will maintain the sorted order. Refer to <a href="#Base.sort!"><code>sort!</code></a> for the meaning of the keywords and the definition of &quot;greater than&quot; and equivalence. Note that the <code>by</code> function is applied to the searched value <code>x</code> as well as the values in <code>v</code>.</p><p>The index is generally found using binary search, but there are optimized implementations for some inputs.</p><p>See also: <a href="#Base.Sort.searchsortedlast"><code>searchsortedlast</code></a>, <a href="#Base.Sort.searchsorted"><code>searchsorted</code></a>, <a href="../arrays/#Base.findfirst-Tuple{Any}"><code>findfirst</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 4) # single match
3

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 5) # multiple matches
4

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
3

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
7

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
1

julia&gt; searchsortedfirst([1=&gt;&quot;one&quot;, 2=&gt;&quot;two&quot;, 4=&gt;&quot;four&quot;], 3=&gt;&quot;three&quot;, by=first) # compare the keys of the pairs
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L334-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.searchsortedlast" href="#Base.Sort.searchsortedlast"><code>Base.Sort.searchsortedlast</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">searchsortedlast(v, x; by=identity, lt=isless, rev=false)</code></pre><p>Return the index of the last value in <code>v</code> less than or equivalent to <code>x</code>. If <code>x</code> is less than all values in <code>v</code> the function returns <code>firstindex(v) - 1</code>.</p><p>The vector <code>v</code> must be sorted according to the order defined by the keywords. Refer to <a href="#Base.sort!"><code>sort!</code></a> for the meaning of the keywords and the definition of &quot;less than&quot; and equivalence. Note that the <code>by</code> function is applied to the searched value <code>x</code> as well as the values in <code>v</code>.</p><p>The index is generally found using binary search, but there are optimized implementations for some inputs</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 4) # single match
3

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 5) # multiple matches
5

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
2

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
6

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
0

julia&gt; searchsortedlast([1=&gt;&quot;one&quot;, 2=&gt;&quot;two&quot;, 4=&gt;&quot;four&quot;], 3=&gt;&quot;three&quot;, by=first) # compare the keys of the pairs
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L373-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.insorted" href="#Base.Sort.insorted"><code>Base.Sort.insorted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insorted(x, v; by=identity, lt=isless, rev=false) -&gt; Bool</code></pre><p>Determine whether a vector <code>v</code> contains any value equivalent to <code>x</code>. The vector <code>v</code> must be sorted according to the order defined by the keywords. Refer to <a href="#Base.sort!"><code>sort!</code></a> for the meaning of the keywords and the definition of equivalence. Note that the <code>by</code> function is applied to the searched value <code>x</code> as well as the values in <code>v</code>.</p><p>The check is generally done using binary search, but there are optimized implementations for some inputs.</p><p>See also <a href="../collections/#Base.in"><code>in</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; insorted(4, [1, 2, 4, 5, 5, 7]) # single match
true

julia&gt; insorted(5, [1, 2, 4, 5, 5, 7]) # multiple matches
true

julia&gt; insorted(3, [1, 2, 4, 5, 5, 7]) # no match
false

julia&gt; insorted(9, [1, 2, 4, 5, 5, 7]) # no match
false

julia&gt; insorted(0, [1, 2, 4, 5, 5, 7]) # no match
false

julia&gt; insorted(2=&gt;&quot;TWO&quot;, [1=&gt;&quot;one&quot;, 2=&gt;&quot;two&quot;, 4=&gt;&quot;four&quot;], by=first) # compare the keys of the pairs
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p><code>insorted</code> was added in Julia 1.6.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L409-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.partialsort!" href="#Base.Sort.partialsort!"><code>Base.Sort.partialsort!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partialsort!(v, k; by=identity, lt=isless, rev=false)</code></pre><p>Partially sort the vector <code>v</code> in place so that the value at index <code>k</code> (or range of adjacent values if <code>k</code> is a range) occurs at the position where it would appear if the array were fully sorted. If <code>k</code> is a single index, that value is returned; if <code>k</code> is a range, an array of values at those indices is returned. Note that <code>partialsort!</code> may not fully sort the input array.</p><p>For the keyword arguments, see the documentation of <a href="#Base.sort!"><code>sort!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1, 2, 4, 3, 4]
5-element Vector{Int64}:
 1
 2
 4
 3
 4

julia&gt; partialsort!(a, 4)
4

julia&gt; a
5-element Vector{Int64}:
 1
 2
 3
 4
 4

julia&gt; a = [1, 2, 4, 3, 4]
5-element Vector{Int64}:
 1
 2
 4
 3
 4

julia&gt; partialsort!(a, 4, rev=true)
2

julia&gt; a
5-element Vector{Int64}:
 4
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L100-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.partialsort" href="#Base.Sort.partialsort"><code>Base.Sort.partialsort</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partialsort(v, k, by=identity, lt=isless, rev=false)</code></pre><p>Variant of <a href="#Base.Sort.partialsort!"><code>partialsort!</code></a> that copies <code>v</code> before partially sorting it, thereby returning the same thing as <code>partialsort!</code> but leaving <code>v</code> unmodified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.partialsortperm" href="#Base.Sort.partialsortperm"><code>Base.Sort.partialsortperm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partialsortperm(v, k; by=ientity, lt=isless, rev=false)</code></pre><p>Return a partial permutation <code>I</code> of the vector <code>v</code>, so that <code>v[I]</code> returns values of a fully sorted version of <code>v</code> at index <code>k</code>. If <code>k</code> is a range, a vector of indices is returned; if <code>k</code> is an integer, a single index is returned. The order is specified using the same keywords as <code>sort!</code>. The permutation is stable: the indices of equal elements will appear in ascending order.</p><p>This function is equivalent to, but more efficient than, calling <code>sortperm(...)[k]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, 1, 2, 1];

julia&gt; v[partialsortperm(v, 1)]
1

julia&gt; p = partialsortperm(v, 1:3)
3-element view(::Vector{Int64}, 1:3) with eltype Int64:
 2
 4
 3

julia&gt; v[p]
3-element Vector{Int64}:
 1
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L1493-L1523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Sort.partialsortperm!" href="#Base.Sort.partialsortperm!"><code>Base.Sort.partialsortperm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partialsortperm!(ix, v, k; by=identity, lt=isless, rev=false)</code></pre><p>Like <a href="#Base.Sort.partialsortperm"><code>partialsortperm</code></a>, but accepts a preallocated index vector <code>ix</code> the same size as <code>v</code>, which is used to store (a permutation of) the indices of <code>v</code>.</p><p><code>ix</code> is initialized to contain the indices of <code>v</code>.</p><p>(Typically, the indices of <code>v</code> will be <code>1:length(v)</code>, although if <code>v</code> has an alternative array type with non-one-based indices, such as an <code>OffsetArray</code>, <code>ix</code> must share those same indices)</p><p>Upon return, <code>ix</code> is guaranteed to have the indices <code>k</code> in their sorted positions, such that</p><pre><code class="language-julia">partialsortperm!(ix, v, k);
v[ix[k]] == partialsort(v, k)</code></pre><p>The return value is the <code>k</code>th element of <code>ix</code> if <code>k</code> is an integer, or view into <code>ix</code> if <code>k</code> is a range.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Behavior can be unexpected when any mutated argument shares memory with any other argument.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, 1, 2, 1];

julia&gt; ix = Vector{Int}(undef, 4);

julia&gt; partialsortperm!(ix, v, 1)
2

julia&gt; ix = [1:4;];

julia&gt; partialsortperm!(ix, v, 2:3)
2-element view(::Vector{Int64}, 2:3) with eltype Int64:
 4
 3</code></pre><pre><code class="language-none"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/sort.jl#L1527-L1566">source</a></section></article><h2 id="排序算法"><a class="docs-heading-anchor" href="#排序算法">排序算法</a><a id="排序算法-1"></a><a class="docs-heading-anchor-permalink" href="#排序算法" title="Permalink"></a></h2><p>目前，Julia Base 中有四种可用的排序算法：</p><ul><li><a href="#Base.Sort.InsertionSort"><code>InsertionSort</code></a></li><li><a href="#Base.Sort.QuickSort"><code>QuickSort</code></a></li><li><a href="#Base.Sort.PartialQuickSort"><code>PartialQuickSort(k)</code></a></li><li><a href="#Base.Sort.MergeSort"><code>MergeSort</code></a></li></ul><p>By default, the <code>sort</code> family of functions uses stable sorting algorithms that are fast on most inputs. The exact algorithm choice is an implementation detail to allow for future performance improvements. Currently, a hybrid of <code>RadixSort</code>, <code>ScratchQuickSort</code>, <code>InsertionSort</code>, and <code>CountingSort</code> is used based on input type, size, and composition. Implementation details are subject to change but currently available in the extended help of <code>??Base.DEFAULT_STABLE</code> and the docstrings of internal sorting algorithms listed there.</p><p>You can explicitly specify your preferred algorithm with the <code>alg</code> keyword (e.g. <code>sort!(v, alg=PartialQuickSort(10:20))</code>) or reconfigure the default sorting algorithm for custom types by adding a specialized method to the <code>Base.Sort.defalg</code> function. For example, <a href="https://github.com/JuliaStrings/InlineStrings.jl/blob/v1.3.2/src/InlineStrings.jl#L903">InlineStrings.jl</a> defines the following method:</p><pre><code class="language-julia">Base.Sort.defalg(::AbstractArray{&lt;:Union{SmallInlineStrings, Missing}}) = InlineStringSort</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.9</header><div class="admonition-body"><p>The default sorting algorithm (returned by <code>Base.Sort.defalg</code>) is guaranteed to be stable since Julia 1.9. Previous versions had unstable edge cases when sorting numeric arrays.</p></div></div><h2 id="Alternate-Orderings"><a class="docs-heading-anchor" href="#Alternate-Orderings">Alternate Orderings</a><a id="Alternate-Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Alternate-Orderings" title="Permalink"></a></h2><p>By default, <code>sort</code>, <code>searchsorted</code>, and related functions use <a href="../base/#Base.isless"><code>isless</code></a> to compare two elements in order to determine which should come first. The <a href="#Base.Order.Ordering"><code>Base.Order.Ordering</code></a> abstract type provides a mechanism for defining alternate orderings on the same set of elements: when calling a sorting function like <code>sort!</code>, an instance of <code>Ordering</code> can be provided with the keyword argument <code>order</code>.</p><p>Instances of <code>Ordering</code> define an order through the <a href="#Base.Order.lt"><code>Base.Order.lt</code></a> function, which works as a generalization of <code>isless</code>. This function&#39;s behavior on custom <code>Ordering</code>s must satisfy all the conditions of a <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">strict weak order</a>. See <a href="#Base.sort!"><code>sort!</code></a> for details and examples of valid and invalid <code>lt</code> functions.</p><article class="docstring"><header><a class="docstring-binding" id="Base.Order.Ordering" href="#Base.Order.Ordering"><code>Base.Order.Ordering</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Base.Order.Ordering</code></pre><p>Abstract type which represents a total order on some set of elements.</p><p>Use <a href="#Base.Order.lt"><code>Base.Order.lt</code></a> to compare two elements according to the ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/ordering.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Order.lt" href="#Base.Order.lt"><code>Base.Order.lt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lt(o::Ordering, a, b)</code></pre><p>Test whether <code>a</code> is less than <code>b</code> according to the ordering <code>o</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/ordering.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Order.ord" href="#Base.Order.ord"><code>Base.Order.ord</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ord(lt, by, rev::Union{Bool, Nothing}, order::Ordering=Forward)</code></pre><p>Construct an <a href="#Base.Order.Ordering"><code>Ordering</code></a> object from the same arguments used by <a href="#Base.sort!"><code>sort!</code></a>. Elements are first transformed by the function <code>by</code> (which may be <a href="../base/#Base.identity"><code>identity</code></a>) and are then compared according to either the function <code>lt</code> or an existing ordering <code>order</code>. <code>lt</code> should be <a href="../base/#Base.isless"><code>isless</code></a> or a function that obeys the same rules as the <code>lt</code> parameter of <a href="#Base.sort!"><code>sort!</code></a>. Finally, the resulting order is reversed if <code>rev=true</code>.</p><p>Passing an <code>lt</code> other than <code>isless</code> along with an <code>order</code> other than <a href="#Base.Order.Forward"><code>Base.Order.Forward</code></a> or <a href="#Base.Order.Reverse"><code>Base.Order.Reverse</code></a> is not permitted, otherwise all options are independent and can be used together in all possible combinations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/ordering.jl#L141-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Order.Forward" href="#Base.Order.Forward"><code>Base.Order.Forward</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Base.Order.Forward</code></pre><p>Default ordering according to <a href="../base/#Base.isless"><code>isless</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/ordering.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Order.ReverseOrdering" href="#Base.Order.ReverseOrdering"><code>Base.Order.ReverseOrdering</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReverseOrdering(fwd::Ordering=Forward)</code></pre><p>A wrapper which reverses an ordering.</p><p>For a given <code>Ordering</code> <code>o</code>, the following holds for all  <code>a</code>, <code>b</code>:</p><pre><code class="language-none">lt(ReverseOrdering(o), a, b) == lt(o, b, a)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/ordering.jl#L32-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Order.Reverse" href="#Base.Order.Reverse"><code>Base.Order.Reverse</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Base.Order.Reverse</code></pre><p>Reverse ordering according to <a href="../base/#Base.isless"><code>isless</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/ordering.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Order.By" href="#Base.Order.By"><code>Base.Order.By</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">By(by, order::Ordering=Forward)</code></pre><p><code>Ordering</code> which applies <code>order</code> to elements after they have been transformed by the function <code>by</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/ordering.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Order.Lt" href="#Base.Order.Lt"><code>Base.Order.Lt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lt(lt)</code></pre><p><code>Ordering</code> that calls <code>lt(a, b)</code> to compare elements. <code>lt</code> must obey the same rules as the <code>lt</code> parameter of <a href="#Base.sort!"><code>sort!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/ordering.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Order.Perm" href="#Base.Order.Perm"><code>Base.Order.Perm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Perm(order::Ordering, data::AbstractVector)</code></pre><p><code>Ordering</code> on the indices of <code>data</code> where <code>i</code> is less than <code>j</code> if <code>data[i]</code> is less than <code>data[j]</code> according to <code>order</code>. In the case that <code>data[i]</code> and <code>data[j]</code> are equal, <code>i</code> and <code>j</code> are compared by numeric value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/4976d05258ec9aeed40c6c6f73a7f8bbd977d9c6/base/ordering.jl#L97-L103">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../punctuation/">« 运算符与记号</a><a class="docs-footer-nextpage" href="../iterators/">迭代相关 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2024 十二月 14 周六 11:09">2024 十二月 14 周六</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.10.7版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
