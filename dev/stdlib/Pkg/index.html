<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Pkg · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/stdlib/Pkg/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../Base64/">Base64</a></li><li><a class="tocitem" href="../CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../Dates/">日期</a></li><li><a class="tocitem" href="../DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../Distributed/">分布式计算</a></li><li><a class="tocitem" href="../FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../InteractiveUtils/">交互式组件</a></li><li><a class="tocitem" href="../LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../Libdl/">动态链接器</a></li><li><a class="tocitem" href="../LinearAlgebra/">线性代数</a></li><li><a class="tocitem" href="../Logging/">日志记录</a></li><li><a class="tocitem" href="../Markdown/">Markdown</a></li><li><a class="tocitem" href="../Mmap/">内存映射 I/O</a></li><li class="is-active"><a class="tocitem" href>Pkg</a><ul class="internal"><li><a class="tocitem" href="#介绍"><span>介绍</span></a></li><li><a class="tocitem" href="#词汇表"><span>词汇表</span></a></li><li><a class="tocitem" href="#入门"><span>入门</span></a></li><li><a class="tocitem" href="#Creating-your-own-projects"><span>Creating your own projects</span></a></li><li><a class="tocitem" href="#垃圾收集旧的、不再使用的包"><span>垃圾收集旧的、不再使用的包</span></a></li><li><a class="tocitem" href="#Creating-your-own-packages"><span>Creating your own packages</span></a></li><li><a class="tocitem" href="#预编译项目"><span>预编译项目</span></a></li><li><a class="tocitem" href="#预览模式"><span>预览模式</span></a></li><li><a class="tocitem" href="#使用别人的项目"><span>使用别人的项目</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../Printf/">Printf</a></li><li><a class="tocitem" href="../Profile/">性能分析</a></li><li><a class="tocitem" href="../REPL/">Julia REPL</a></li><li><a class="tocitem" href="../Random/">随机数</a></li><li><a class="tocitem" href="../SHA/">SHA</a></li><li><a class="tocitem" href="../Serialization/">序列化</a></li><li><a class="tocitem" href="../SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../Sockets/">套接字</a></li><li><a class="tocitem" href="../SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../Statistics/">统计</a></li><li><a class="tocitem" href="../Test/">单元测试</a></li><li><a class="tocitem" href="../UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Standard Library</a></li><li class="is-active"><a href>Pkg</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Pkg</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/stdlib-zh_cn/translate/#zh_CN/Pkgmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Pkg"><a class="docs-heading-anchor" href="#Pkg">Pkg</a><a id="Pkg-1"></a><a class="docs-heading-anchor-permalink" href="#Pkg" title="Permalink"></a></h1><h2 id="介绍"><a class="docs-heading-anchor" href="#介绍">介绍</a><a id="介绍-1"></a><a class="docs-heading-anchor-permalink" href="#介绍" title="Permalink"></a></h2><p>Pkg 是 Julia 1.0 及后续新版本的标准包管理器。与那些安装和管理单个全局软件包集的传统包管理器不同，Pkg 是围绕「环境」设计的。每个项目都有一套独立与其他项目的软件包集合。同一个软件包也可以在多个项目中通过名字共享。项目环境的软件包信息是保存在 <em>清单文件</em> 里的。清单文件确切的描述了每一个依赖软件包和它的版本。清单文件可以检入项目存储库并在版本控制中进行跟踪，从而显着提高项目的可重复性。如果你曾经试图运行一段时间未曾使用过的代码，但发现其完全无法工作，而这只是因为你更新或卸载了项目使用的一些软件包，那么你会理解这种方法的意图。在 Pkg 中，由于每个项目都维护着各自独立的软件包集，你再也不会遇到这个问题了。 此外，如果你签出项目到新系统中，搭建出其清单文件所描述的环境将会非常地简单，并且你可以立即启动和并运行该项目，因为我们知道项目依赖项是好的。</p><p>由于项目包环境是彼此独立地进行管理和更新的， Pkg 显著地缓解了「依赖地狱」问题。你如果想在新项目中使用最新、最棒的包，但在另一个项目中却卡在了使用旧版本的包，那也没问题——因为它们的环境是彼此分离的，不同项目可以使用装在系统的不同位置的不同版本的包。每个版本的包的位置都是规范的，所以当多个环境使用的包版本相同时，它们可以共享同一安装包，这就避免不必要的重复安装。不被任何环境使用的老旧版本的包，会被包管理器定期「垃圾收集」掉。</p><p>Pkg 对本地环境的处理方法可能让曾经使用过 Python 的 <code>virtualenv</code> 或 Ruby 的 <code>bundler</code> 的人感到熟悉。在 Julia 中，我们不仅没有通过破解语言的代码加载机制来支持环境，而且还有 Julia 本身就理解它们的好处。此外，Julia 环境是「可堆叠的」：你可以将一个环境叠加在另一个环境上，从而可以访问主环境之外的其它包。这使得更容易在提供主环境的项目上工作，同时依然访问所有你常用的开发工具，如分析器、调试器等，这只需在加载路径中更后地包含具有这些开发环境的路径。</p><p>Last but not least, Pkg is designed to support federated package registries. This means that it allows multiple registries managed by different parties to interact seamlessly. In particular, this includes private registries which can live behind corporate firewalls. You can install and update your own packages from a private registry with exactly the same tools and workflows that you use to install and manage official Julia packages. If you urgently need to apply a hotfix for a public package that’s critical to your company’s product, you can tag a private version of it in your company’s internal registry and get a fix to your developers and ops teams quickly and easily without having to wait for an upstream patch to be accepted and published. Once an official fix is published, however, you can just upgrade your dependencies and you&#39;ll be back on an official release again.</p><h2 id="词汇表"><a class="docs-heading-anchor" href="#词汇表">词汇表</a><a id="词汇表-1"></a><a class="docs-heading-anchor-permalink" href="#词汇表" title="Permalink"></a></h2><p><strong>项目（Project）：</strong>一个具有标准布局的源代码树，包括了用来放置主要的 Julia 代码的 <code>src</code> 目录、用来放置测试的 <code>test</code> 目录、用来放置文档的 <code>docs</code> 目录和可选的用来放置构建脚本及其输出的 <code>deps</code> 目录。项目通常有一个项目文件和一个可选的清单文件：</p><ul><li><p><strong>项目文件（Project file）：</strong>一个在项目根目录下的文件，叫做 <code>Project.toml</code>（或 <code>JuliaProject.toml</code>），用来描述项目的元数据，包括项目的名称、UUID（针对包）、作者、许可证和它所依赖的包和库的名称及 UUID。</p></li><li><p><strong>清单文件（Manifest file）：</strong>一个在项目根目录下的文件，叫做 <code>Manifest.toml</code>（或 <code>JuliaManifest.toml</code>），用来描述完整的依赖关系图、每个包的确切版本以及项目使用的库。</p></li></ul><p><strong>包（Package）：</strong>一个提供可重用功能的项目，其它 Julia 项目可以同 <code>import X</code> 或 <code>using X</code> 使用它。一个包应该包含一个具有 <code>uuid</code> 条目（此条目给出该包 UUID）的项目文件。此 UUID 用于在依赖它的项目中标识该包。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>由于历史原因，可以在 REPL 或脚本的顶级中加载没有项目文件或 UUID 的包。但是，无法在具有项目文件或 UUID 的项目中加载没有它们的包。一旦你曾从项目文件加载包，所有包就都需要项目文件和 UUID。</p></div></div><p><strong>应用（application）：</strong>一个提供独立功能的项目，不打算被其它 Julia 项目重用。例如，Web 应用、命令行工具或者科学论文附带的模拟或分析代码。应用可以有 UUID 但也可以没有。应用还可以为其所依赖的包提供全局配置选项。另一方面，包不可能提供全局配置，因为这可能与主应用的配置相冲突。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><strong>项目 <em>vs.</em> 包 <em>vs.</em> 应用：</strong></p><ol><li><strong>项目</strong>是一个总称：包和应用都是一种项目。</li><li><strong>包</strong>应该有 UUID，而应用可以有也可以没有。</li><li><strong>应用</strong>可以提供全局的配置，而包不行。</li></ol></div></div><p><strong>Library (future work):</strong> a compiled binary dependency (not written in Julia) packaged to be used by a Julia project. These are currently typically built in- place by a <code>deps/build.jl</code> script in a project’s source tree, but in the future we plan to make libraries first-class entities directly installed and upgraded by the package manager.</p><p><strong>环境（Environment）：</strong>项目文件和清单文件的组合，项目文件与依赖关系图相结合后提供了顶级名称映射，而清单文件提供了包到它们入口点的映射。有关的详细信息，请参阅手册中代码加载的相关章节。</p><ul><li><p><strong>显式环境（Explicit environment）：</strong>在同一目录下具有显式的项目文件和可选的与其对应的清单文件。如果清单文件不存在，那么隐含的依赖关系图和位置映射为空。</p></li><li><p><strong>隐式环境（Implicit environment）：</strong>作为目录提供的环境（没有项目文件或清单文件），此目录包含包且包含的包具有形式为 <code>X.jl</code>、<code>X.jl/src/X.jl</code> 或 <code>X/src/X.jl</code> 的入口点，这些包的入口点隐含了顶级名称映射。依赖关系图隐含在这些包所在目录的项目文件里，例如 <code>X.jl/Project.toml</code> 或 <code>X/Project.toml</code>。如果 <code>X</code> 存在对应的项目文件，则其依赖关系就是其项目文件的依赖关系。入口点本身就隐含了位置映射。</p></li></ul><p><strong>Registry:</strong> a source tree with a standard layout recording metadata about a registered set of packages, the tagged versions of them which are available, and which versions of packages are compatible or incompatible with each other. A registry is indexed by package name and UUID, and has a directory for each registered package providing the following metadata about it:</p><ul><li>name——例如 <code>DataFrames</code></li><li>UUID——例如 <code>a93c6f00-e57d-5684-b7b6-d8193f3e46c0</code></li><li>authors——例如 <code>Jane Q. Developer &lt;jane@example.com&gt;</code></li><li>license——例如 MIT，BSD3 或 GPLv2</li><li>repository——例如 <code>https://github.com/JuliaData/DataFrames.jl.git</code></li><li>description——一个总结包功能的文本块</li><li>keywords——例如 <code>data</code>，<code>tabular</code>，<code>analysis</code>，<code>statistics</code></li><li>versions——所有已注册版本的标签列表</li></ul><p>每个包的已注册版本都会提供以下信息：</p><ul><li>its semantic version number – e.g. <code>v1.2.3</code></li><li>its git tree SHA-1 hash – e.g. <code>7ffb18ea3245ef98e368b02b81e8a86543a11103</code></li><li>a map from names to UUIDs of dependencies</li><li>which versions of other packages it is compatible/incompatible with</li></ul><p>Dependencies and compatibility are stored in a compressed but human-readable format using ranges of package versions.</p><p><strong>Depot:</strong> a directory on a system where various package-related resources live, including:</p><ul><li><code>environments</code>: shared named environments (e.g. <code>v0.7</code>, <code>devtools</code>)</li><li><code>clones</code>: bare clones of package repositories</li><li><code>compiled</code>: cached compiled package images (<code>.ji</code> files)</li><li><code>config</code>: global configuration files (e.g. <code>startup.jl</code>)</li><li><code>dev</code>: default directory for package development</li><li><code>logs</code>: log files (e.g. <code>manifest_usage.toml</code>, <code>repl_history.jl</code>)</li><li><code>packages</code>: installed package versions</li><li><code>registries</code>: clones of registries (e.g. <code>General</code>)</li></ul><p><strong>Load path:</strong> a stack of environments where package identities, their dependencies, and entry-points are searched for. The load path is controlled in Julia by the <code>LOAD_PATH</code> global variable which is populated at startup based on the value of the <code>JULIA_LOAD_PATH</code> environment variable. The first entry is your primary environment, often the current project, while later entries provide additional packages one may want to use from the REPL or top-level scripts.</p><p><strong>Depot path:</strong> a stack of depot locations where the package manager, as well as Julia&#39;s code loading mechanisms, look for registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. The depot path is controlled by the Julia <code>DEPOT_PATH</code> global variable which is populated at startup based on the value of the <code>JULIA_DEPOT_PATH</code> environment variable. The first entry is the “user depot” and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.</p><h2 id="入门"><a class="docs-heading-anchor" href="#入门">入门</a><a id="入门-1"></a><a class="docs-heading-anchor-permalink" href="#入门" title="Permalink"></a></h2><p>在 Julia REPL 中使用 <code>]</code> 键即可进入 Pkg 模式。</p><pre><code class="language-none">(v0.7) pkg&gt;</code></pre><p>提示符括号内的部分显示当前项目的名称。由于我们尚未创建自己的项目，我们正处于默认项目中，其位于 <code>~/.julia/environments/v0.7</code>（或任何你恰巧在运行的 Julia 版本）。</p><p>要返回 <code>julia&gt;</code> 提示符，请在输入行为空时按退格键或直接按 Ctrl+C。可通过调用 <code>pkg&gt;help</code> 获得帮助。如果你所处的环境无法访问 PEPL，你仍可以通过字符串宏 <code>pkg</code>（其在 <code>using Pkg</code> 后可用）使用 REPL 模式的命令。命令 <code>pkg&quot;cms&quot;</code> 将等价于在 RPEL 模式中执行 <code>cmd</code>。</p><p>此处的文档介绍了如何使用 REPL 的 Pkg 模式。使用 Pkg API（通过调用 <code>Pkg.</code> 函数）的文档正在编写中。</p><h3 id="添加包"><a class="docs-heading-anchor" href="#添加包">添加包</a><a id="添加包-1"></a><a class="docs-heading-anchor-permalink" href="#添加包" title="Permalink"></a></h3><p>有两种方法可以添加包，分别是使用 <code>add</code> 命令和 <code>dev</code> 命令。最常用的是 <code>add</code>，我们首先介绍它的用法。</p><h4 id="添加已注册的包"><a class="docs-heading-anchor" href="#添加已注册的包">添加已注册的包</a><a id="添加已注册的包-1"></a><a class="docs-heading-anchor-permalink" href="#添加已注册的包" title="Permalink"></a></h4><p>在 REPL 的 Pkg 模式中，添加包可以使用 <code>add</code> 命令，其后接包的名称，例如：</p><pre><code class="language-none">(v0.7) pkg&gt; add Example
   Cloning default registries into /Users/kristoffer/.julia/registries
   Cloning registry General from &quot;https://github.com/JuliaRegistries/General.git&quot;
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] + Example v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] + Example v0.5.1
  [8dfed614] + Test</code></pre><p>在这里，我们将包 Example 添加到当前项目中。此例中，我们使用的是全新的 Julia 安装，并且这是我们第一次使用 Pkg 添加包。默认情况下，Pkg 会克隆 Julia 的 General 注册表，并使用此注册表来查找需要包含在当前环境中的包。状态更新在左侧显示了简短形式的包 UUID，接着是包名称和版本号。因为标准库（例如 <code>Test</code>）随 Julia 一起提供，所以它们没有版本号。项目状态包含你自己添加的包，在此例中为 <code>Example</code>：</p><pre><code class="language-none">(v0.7) pkg&gt; st
    Status `Project.toml`
  [7876af07] Example v0.5.1</code></pre><p>此外，清单状态包含了显式添加的包的依赖项。</p><pre><code class="language-none">(v0.7) pkg&gt; st --manifest
    Status `Manifest.toml`
  [7876af07] Example v0.5.1
  [8dfed614] Test</code></pre><p>可以在一次命令中添加多个包，例如 <code>pkg&gt; add A B C</code>。</p><p>在包已添加进项目中后，可在 Julia 中加载它：</p><pre><code class="language-none">julia&gt; using Example

julia&gt; Example.hello(&quot;User&quot;)
&quot;Hello, User&quot;</code></pre><p>可以通过在 <code>@</code> 符号后附加版本号来安装特定版本，例如在包名称后附加 <code>@v0.4</code>：</p><pre><code class="language-none">(v0.7) pkg&gt; add Example@0.4
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] + Example v0.4.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] + Example v0.4.1</code></pre><p>如果 <code>Example</code> 的主分支（或某个提交 SHA）有尚未包含在已注册版本中的修补程序，我们可以通过在包名称后附加 <code>#branch</code>（或 <code>#commit</code>）来显式跟踪该分支（或提交）：</p><pre><code class="language-none">(v0.7) pkg&gt; add Example#master
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)</code></pre><p>状态输出现在显示我们正在跟踪 <code>Example</code> 的 <code>master</code> 分支。在更新包时，我们将从该分支中拉取更新。</p><p>要返回到跟踪 <code>Example</code> 的注册表版本，请使用 <code>free</code> 命令：</p><pre><code class="language-none">(v0.7) pkg&gt; free Example
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1+ #master )https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1</code></pre><h4 id="添加未注册包"><a class="docs-heading-anchor" href="#添加未注册包">添加未注册包</a><a id="添加未注册包-1"></a><a class="docs-heading-anchor-permalink" href="#添加未注册包" title="Permalink"></a></h4><p>如果某个包不在注册表中，通过将其存储库的 URL 传给 <code>add</code> 而不是包名称，仍然可以添加它。</p><pre><code class="language-none">(v0.7) pkg&gt; add https://github.com/fredrikekre/ImportMacros.jl
  Updating git-repo `https://github.com/fredrikekre/ImportMacros.jl`
 Resolving package versions...
Downloaded MacroTools ─ v0.4.1
  Updating `~/.julia/environments/v0.7/Project.toml`
  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)
  [1914dd2f] + MacroTools v0.4.1</code></pre><p>可以看到，未注册包的依赖项（此处为 <code>MacroTools</code>）已被添加。对于未注册包，我们可以使用 <code>#</code> 来给定一个分支（或 commit SHA）来进行跟踪，就像已注册包一样。</p><h4 id="添加本地包"><a class="docs-heading-anchor" href="#添加本地包">添加本地包</a><a id="添加本地包-1"></a><a class="docs-heading-anchor-permalink" href="#添加本地包" title="Permalink"></a></h4><p>我们可以将一个 git 存储库的本地路径传给 <code>add</code> 而不是其 URL，其效果类似于传 URL。该本地存储库（的某个分支）会被跟踪，并在包更新时从已拉取的本地存储库中获取更新。请注意，本地包存储库中的文件更改不会在包加载时立即反映出来。为了拉取更改，必须提交该更改并更新包。</p><h4 id="开发包"><a class="docs-heading-anchor" href="#开发包">开发包</a><a id="开发包-1"></a><a class="docs-heading-anchor-permalink" href="#开发包" title="Permalink"></a></h4><p>仅使用 <code>add</code> 会让你的清单始终为「可再现状态」，换句话说，只要所使用的存储库和注册表仍然可以访问，就可以检索出项目中所有依赖项的确切状态。这样做的好处是你可以将你的项目（<code>Project.toml</code> 和 <code>Manifest.toml</code>）发送该其他人，然后他们可以该项目「实例化」到与你本地项目相同的状态。但是，当你在开发包时，在某个路径上以当前状态加载包会更方便。因此，命令 <code>dev</code> 有存在必要。</p><p>让我们来尝试 <code>dev</code> 一个已注册的包：</p><pre><code class="language-none">(v0.7) pkg&gt; dev Example
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]</code></pre><p><code>dev</code> 命令会获取包的完整克隆到 <code>~/.julia/dev/</code> 目录下（可通过设置环境变量 <code>JULIA_PKG_DEVDIR</code> 来更改此路径）。在导入 <code>Example</code> 时，julia 现在将从 <code>~/.julia/dev/Example</code> 导入它，并且该路径下文件的所有本地更改都将反映在加载的代码中。在使用 <code>add</code> 时，我们说我们跟踪了包存储库，在这里则说我们跟踪了路径本身。请注意，包管理器永远不会触碰已跟踪路径上的任何文件。因此，需要你自己拉取更新、更改分支等。如果我们尝试 <code>dev</code> 包的某个已经存在于 <code>~/.julia/dev/</code> 里的分支，则包管理器只会使用已存在的路径。例如：</p><pre><code class="language-none">(v0.7) pkg&gt; dev Example
  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`
[ Info: Path `/Users/kristoffer/.julia/dev/Example` exists and looks like the correct package, using existing path instead of cloning</code></pre><p>请注意，info 信息表明它正在使用现有路径。一般来说，包管理器不会触碰正在跟踪的路径文件。</p><p>如果在本地路径上使用 <code>dev</code>，则该包的路径会被记录并在该包加载时使用之。除非该路径以绝对路径的形式给出，否则它会以相对于项目文件的形式记录下来。</p><p>要停止跟踪路径并再次使用已注册版本，请使用 <code>free</code></p><pre><code class="language-none">(v0.7) pkg&gt; free Example
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1</code></pre><p>值得提及的是，通过使用 <code>dev</code>，你的项目现在具有其内在状态。其状态取决于该路径中文件的当前内容，并且在不知道所跟踪路径中所有包的确切内容的情况下，其他人无法「实例化」清单。</p><p>Note that if you add a dependency to a package that tracks a local path, the Manifest (which contains the whole dependency graph) will become out of sync with the actual dependency graph. This means that the package will not be able to load that dependency since it is not recorded in the Manifest. To update sync the Manifest, use the REPL command <code>resolve</code>.</p><h3 id="删除包"><a class="docs-heading-anchor" href="#删除包">删除包</a><a id="删除包-1"></a><a class="docs-heading-anchor-permalink" href="#删除包" title="Permalink"></a></h3><p>通过使用 <code>pkg&gt; rm Package</code>，可从当前项目中删除包。这只会删除已存在于项目中的包，要删除仅作为依赖项的包，请使用 <code>pkg&gt; rm --manifest DepPackage</code>。请注意，这会删除所有依赖于 <code>DepPackage</code> 的包。</p><h3 id="更新包"><a class="docs-heading-anchor" href="#更新包">更新包</a><a id="更新包-1"></a><a class="docs-heading-anchor-permalink" href="#更新包" title="Permalink"></a></h3><p>当项目正在使用的包发布新版本时，最好进行更新。简单地调用 <code>up</code> 会尝试将项目的<em>所有</em>依赖项更新到最新的兼容版本。有时这并不是你想要的。通过将依赖项子集作为参数传给 <code>up</code>，你可以指定要升级的依赖项，例如</p><pre><code class="language-none">(v0.7) pkg&gt; up Example</code></pre><p>所有其他包直接依赖项的版本会保持不变。如果你为了降低项目中断的风险，只想要更新包的次版本号，你可以加上 <code>--minor</code> 标志，例如：</p><pre><code class="language-none">(v0.7) pkg&gt; up --minor Example</code></pre><p>跟踪存储库的包在进行次要更新时不会被更新，而跟踪路径的包永远不会被包管理器所触及。</p><h3 id="Pinning-a-package"><a class="docs-heading-anchor" href="#Pinning-a-package">Pinning a package</a><a id="Pinning-a-package-1"></a><a class="docs-heading-anchor-permalink" href="#Pinning-a-package" title="Permalink"></a></h3><p>A pinned package will never be updated. A package can be pinned using <code>pin</code> as for example</p><pre><code class="language-none">(v0.7) pkg&gt; pin Example
 Resolving package versions...
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲</code></pre><p>Note the pin symbol <code>⚲</code> showing that the package is pinned. Removing the pin is done using <code>free</code></p><pre><code class="language-none">(v0.7) pkg&gt; free Example
  Updating `~/.julia/environments/v0.7/Project.toml`
  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1
  Updating `~/.julia/environments/v0.7/Manifest.toml`
  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1</code></pre><h3 id="测试包"><a class="docs-heading-anchor" href="#测试包">测试包</a><a id="测试包-1"></a><a class="docs-heading-anchor-permalink" href="#测试包" title="Permalink"></a></h3><p>包的测试可通过 <code>test</code> 命令来运行：</p><pre><code class="language-none">(v0.7) pkg&gt; test Example
   Testing Example
   Testing Example tests passed</code></pre><h3 id="构建包"><a class="docs-heading-anchor" href="#构建包">构建包</a><a id="构建包-1"></a><a class="docs-heading-anchor-permalink" href="#构建包" title="Permalink"></a></h3><p>第一次安装某个包时，会自动执行该包的构建步骤。构建过程的输出会被重定向到文件中。要显式执行包的构建步骤，请使用 <code>build</code> 命令：</p><pre><code class="language-none">(v0.7) pkg&gt; build MbedTLS
  Building MbedTLS → `~/.julia/packages/MbedTLS/h1Vu/deps/build.log`

shell&gt; cat ~/.julia/packages/MbedTLS/h1Vu/deps/build.log
┌ Warning: `wait(t::Task)` is deprecated, use `fetch(t)` instead.
│   caller = macro expansion at OutputCollector.jl:63 [inlined]
└ @ Core OutputCollector.jl:63
...
[ Info: using prebuilt binaries</code></pre><h2 id="Creating-your-own-projects"><a class="docs-heading-anchor" href="#Creating-your-own-projects">Creating your own projects</a><a id="Creating-your-own-projects-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-your-own-projects" title="Permalink"></a></h2><p>So far we have added packages to the default project at <code>~/.julia/environments/v0.7</code>, it is, however, easy to create other, independent, projects. It should be pointed out if two projects uses the same package at the same version, the content of this package is not duplicated. In order to create a new project, create a directory for it and then activate that directory to make it the &quot;active project&quot; which package operations manipulate:</p><pre><code class="language-none">shell&gt; mkdir MyProject

shell&gt; cd MyProject
/Users/kristoffer/MyProject

(v0.7) pkg&gt; activate .

(MyProject) pkg&gt; st
    Status `Project.toml`</code></pre><p>Note that the REPL prompt changed when the new project is activated. Since this is a newly created project, the status command show it contains no packages, and in fact, it has no project or manifest file until we add a package to it:</p><pre><code class="language-none">shell&gt; ls -l
total 0

(MyProject) pkg&gt; add Example
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
 Resolving package versions...
  Updating `Project.toml`
  [7876af07] + Example v0.5.1
  Updating `Manifest.toml`
  [7876af07] + Example v0.5.1
  [8dfed614] + Test

shell&gt; ls -l
total 8
-rw-r--r-- 1 stefan staff 207 Jul  3 16:35 Manifest.toml
-rw-r--r-- 1 stefan staff  56 Jul  3 16:35 Project.toml

shell&gt; cat Project.toml
[deps]
Example = &quot;7876af07-990d-54b4-ab0e-23690620f79a&quot;

shell&gt; cat Manifest.toml
[[Example]]
deps = [&quot;Test&quot;]
git-tree-sha1 = &quot;8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8&quot;
uuid = &quot;7876af07-990d-54b4-ab0e-23690620f79a&quot;
version = &quot;0.5.1&quot;

[[Test]]
uuid = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;</code></pre><p>This new environment is completely separate from the one we used earlier.</p><h2 id="垃圾收集旧的、不再使用的包"><a class="docs-heading-anchor" href="#垃圾收集旧的、不再使用的包">垃圾收集旧的、不再使用的包</a><a id="垃圾收集旧的、不再使用的包-1"></a><a class="docs-heading-anchor-permalink" href="#垃圾收集旧的、不再使用的包" title="Permalink"></a></h2><p>随着包的更新和项目被删除，曾经使用的已安装的包将不可避免地变旧，并且不被用于任何现有项目。Pkg 会记录所有已使用项目的日志，这样便可通过遍历日志，明确知道哪些项目仍然存在以及这些项目使用了哪些包，剩下的包则会被删除。命令 <code>gc</code> 可执行此操作：</p><pre><code class="language-none">(v0.7) pkg&gt; gc
    Active manifests at:
        `/Users/kristoffer/BinaryProvider/Manifest.toml`
        ...
        `/Users/kristoffer/Compat.jl/Manifest.toml`
   Deleted /Users/kristoffer/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB
   Deleted /Users/kristoffer/.julia/packages/Cassette/BXVB: 795.557 KiB
   ...
   Deleted /Users/kristoffer/.julia/packages/WeakRefStrings/YrK6: 27.328 KiB
   Deleted 36 package installations: 113.205 MiB</code></pre><p>请注意，只有在 <code>~/.julia/packages</code> 中的包才会被删除。</p><h2 id="Creating-your-own-packages"><a class="docs-heading-anchor" href="#Creating-your-own-packages">Creating your own packages</a><a id="Creating-your-own-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-your-own-packages" title="Permalink"></a></h2><p>A package is a project with a <code>name</code>, <code>uuid</code> and <code>version</code> entry in the <code>Project.toml</code> file <code>src/PackageName.jl</code> file that defines the module <code>PackageName</code>. This file is executed when the package is loaded.</p><h3 id="Generating-files-for-a-package"><a class="docs-heading-anchor" href="#Generating-files-for-a-package">Generating files for a package</a><a id="Generating-files-for-a-package-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-files-for-a-package" title="Permalink"></a></h3><p>To generate files for a new package, use <code>pkg&gt; generate</code>.</p><pre><code class="language-none">(v0.7) pkg&gt; generate HelloWorld</code></pre><p>This creates a new project <code>HelloWorld</code> with the following files (visualized with the external <a href="https://linux.die.net/man/1/tree"><code>tree</code> command</a>):</p><pre><code class="language-jl">shell&gt; cd HelloWorld

shell&gt; tree .
.
├── Project.toml
└── src
    └── HelloWorld.jl

1 directory, 2 files</code></pre><p>The <code>Project.toml</code> file contains the name of the package, its unique UUID, its version, the author and eventual dependencies:</p><pre><code class="language-toml">name = &quot;HelloWorld&quot;
uuid = &quot;b4cd1eb8-1e24-11e8-3319-93036a3eb9f3&quot;
version = &quot;0.1.0&quot;
author = [&quot;Some One &lt;someone@email.com&gt;&quot;]

[deps]</code></pre><p>The content of <code>src/HelloWorld.jl</code> is:</p><pre><code class="language-jl">module HelloWorld

greet() = print(&quot;Hello World!&quot;)

end # module</code></pre><p>We can now activate the project and load the package:</p><pre><code class="language-jl">pkg&gt; activate .

julia&gt; import HelloWorld

julia&gt; HelloWorld.greet()
Hello World!</code></pre><h3 id="Adding-dependencies-to-the-project"><a class="docs-heading-anchor" href="#Adding-dependencies-to-the-project">Adding dependencies to the project</a><a id="Adding-dependencies-to-the-project-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-dependencies-to-the-project" title="Permalink"></a></h3><p>Let’s say we want to use the standard library package <code>Random</code> and the registered package <code>JSON</code> in our project. We simply <code>add</code> these packages (note how the prompt now shows the name of the newly generated project, since we are inside the <code>HelloWorld</code> project directory):</p><pre><code class="language-none">(HelloWorld) pkg&gt; add Random JSON
 Resolving package versions...
  Updating &quot;~/Documents/HelloWorld/Project.toml&quot;
 [682c06a0] + JSON v0.17.1
 [9a3f8284] + Random
  Updating &quot;~/Documents/HelloWorld/Manifest.toml&quot;
 [34da2185] + Compat v0.57.0
 [682c06a0] + JSON v0.17.1
 [4d1e1d77] + Nullables v0.0.4
 ...</code></pre><p>Both <code>Random</code> and <code>JSON</code> got added to the project’s <code>Project.toml</code> file, and the resulting dependencies got added to the <code>Manifest.toml</code> file. The resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforce on its dependencies.</p><p>We can now use both <code>Random</code> and <code>JSON</code> in our project. Changing <code>src/HelloWorld.jl</code> to</p><pre><code class="language-none">module HelloWorld

import Random
import JSON

greet() = print(&quot;Hello World!&quot;)
greet_alien() = print(&quot;Hello &quot;, Random.randstring(8))

end # module</code></pre><p>and reloading the package, the new <code>greet_alien</code> function that uses <code>Random</code> can be used:</p><pre><code class="language-none">julia&gt; HelloWorld.greet_alien()
Hello aT157rHV</code></pre><h3 id="Adding-a-build-step-to-the-package."><a class="docs-heading-anchor" href="#Adding-a-build-step-to-the-package.">Adding a build step to the package.</a><a id="Adding-a-build-step-to-the-package.-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-build-step-to-the-package." title="Permalink"></a></h3><p>The build step is executed the first time a package is installed or when explicitly invoked with <code>build</code>. A package is built by executing the file <code>deps/build.jl</code>.</p><pre><code class="language-none">shell&gt; cat deps/build.log
I am being built...

(HelloWorld) pkg&gt; build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...

shell&gt; cat deps/build.log
I am being built...</code></pre><p>If the build step fails, the output of the build step is printed to the console</p><pre><code class="language-none">shell&gt; cat deps/build.jl
error(&quot;Ooops&quot;)

(HelloWorld) pkg&gt; build
  Building HelloWorld → `deps/build.log`
 Resolving package versions...
┌ Error: Error building `HelloWorld`:
│ ERROR: LoadError: Ooops
│ Stacktrace:
│  [1] error(::String) at ./error.jl:33
│  [2] top-level scope at none:0
│  [3] include at ./boot.jl:317 [inlined]
│  [4] include_relative(::Module, ::String) at ./loading.jl:1071
│  [5] include(::Module, ::String) at ./sysimg.jl:29
│  [6] include(::String) at ./client.jl:393
│  [7] top-level scope at none:0
│ in expression starting at /Users/kristoffer/.julia/dev/Pkg/HelloWorld/deps/build.jl:1
└ @ Pkg.Operations Operations.jl:938</code></pre><h3 id="Adding-tests-to-the-package"><a class="docs-heading-anchor" href="#Adding-tests-to-the-package">Adding tests to the package</a><a id="Adding-tests-to-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-tests-to-the-package" title="Permalink"></a></h3><p>When a package is tested the file <code>test/runtests.jl</code> is executed.</p><pre><code class="language-none">shell&gt; cat test/runtests.jl
println(&quot;Testing...&quot;)
(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
Testing...
   Testing HelloWorld tests passed</code></pre><h4 id="Test-specific-dependencies"><a class="docs-heading-anchor" href="#Test-specific-dependencies">Test-specific dependencies</a><a id="Test-specific-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Test-specific-dependencies" title="Permalink"></a></h4><p>Sometimes one might want to use some packages only at testing time but not enforce a dependency on them when the package is used. This is possible by adding dependencies to <code>[extras]</code> and a <code>test</code> target in <code>[targets]</code> to the Project file. Here we add the <code>Test</code> standard library as a test-only dependency by adding the following to the Project file:</p><pre><code class="language-none">[extras]
Test = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;

[targets]
test = [&quot;Test&quot;]</code></pre><p>We can now use <code>Test</code> in the test script and we can see that it gets installed on testing:</p><pre><code class="language-none">shell&gt; cat test/runtests.jl
using Test
@test 1 == 1

(HelloWorld) pkg&gt; test
   Testing HelloWorld
 Resolving package versions...
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
  [8dfed614] + Test
  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`
  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]
   Testing HelloWorld tests passed```</code></pre><h3 id="Compatibility"><a class="docs-heading-anchor" href="#Compatibility">Compatibility</a><a id="Compatibility-1"></a><a class="docs-heading-anchor-permalink" href="#Compatibility" title="Permalink"></a></h3><p>Compatibility refers to the ability to restrict what version of the dependencies that your project is compatible with. If the compatibility for a dependency is not given, the project is assumed to be compatible with all versions of that dependency.</p><p>Compatibility for a dependency is entered in the <code>Project.toml</code> file as for example:</p><pre><code class="language-toml">[compat]
Example = &quot;0.4.3&quot;</code></pre><p>After a compatibility entry is put into the project file, <code>up</code> can be used to apply it.</p><p>The format of the version specifier is described in detail below.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>There is currently no way to give compatibility from the Pkg REPL mode so for now, one has to manually edit the project file.</p></div></div><h4 id="Version-specifier-format"><a class="docs-heading-anchor" href="#Version-specifier-format">Version specifier format</a><a id="Version-specifier-format-1"></a><a class="docs-heading-anchor-permalink" href="#Version-specifier-format" title="Permalink"></a></h4><p>Similar to other package managers, the Julia package manager respects <a href="https://semver.org/">semantic versioning</a> (semver). As an example, a version specifier is given as e.g. <code>1.2.3</code> is therefore assumed to be compatible with the versions <code>[1.2.3 - 2.0.0)</code> where <code>)</code> is a non-inclusive upper bound. More specifically, a version specifier is either given as a <strong>caret specifier</strong>, e.g. <code>^1.2.3</code>  or a <strong>tilde specifier</strong> <code>~1.2.3</code>. Caret specifiers are the default and hence <code>1.2.3 == ^1.2.3</code>. The difference between a caret and tilde is described in the next section. The intersection of multiple version specifiers can be formed by comma separating indiviual version specifiers.</p><h5 id="Caret-specifiers"><a class="docs-heading-anchor" href="#Caret-specifiers">Caret specifiers</a><a id="Caret-specifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Caret-specifiers" title="Permalink"></a></h5><p>A caret specifier allows upgrade that would be compatible according to semver. An updated dependency is considered compatible if the new version does not modify the left-most non zero digit in the version specifier.</p><p>Some examples are shown below.</p><pre><code class="language-none">^1.2.3 = [1.2.3, 2.0.0)
^1.2 = [1.2.0, 2.0.0)
^1 =  [1.0.0, 2.0.0)
^0.2.3 = [0.2.3, 0.3.0)
^0.0.3 = [0.0.3, 0.0.4)
^0.0 = [0.0.0, 0.1.0)
^0 = [0.0.0, 1.0.0)</code></pre><p>While the semver specification says that all versions with a major version of 0 are incompatible with each other, we have made that choice that a version given as <code>0.a.b</code> is considered compatible with <code>0.a.c</code> if <code>a != 0</code> and  <code>c &gt;= b</code>.</p><h5 id="Tilde-specifiers"><a class="docs-heading-anchor" href="#Tilde-specifiers">Tilde specifiers</a><a id="Tilde-specifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Tilde-specifiers" title="Permalink"></a></h5><p>A tilde specifier provides more limited upgrade possibilities. With a tilde, only the last specified digit is allowed to increment by one. This gives the following example.</p><pre><code class="language-none">~1.2.3 = [1.2.3, 1.2.4)
~1.2 = [1.2.0, 1.3.0)
~1 = [1.0.0, 2.0.0)</code></pre><h4 id="Inequality-specifiers"><a class="docs-heading-anchor" href="#Inequality-specifiers">Inequality specifiers</a><a id="Inequality-specifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Inequality-specifiers" title="Permalink"></a></h4><p>Inequalities can also be used to specify version ranges:</p><pre><code class="language-none">&gt;= 1.2.3 = [1.2.3,  ∞)
≥ 1.2.3 = [1.2.3,  ∞)
= 1.2.3 = [1.2.3, 1.2.3]
&lt; 1.2.3 = [0.0.0, 1.2.2]</code></pre><h2 id="预编译项目"><a class="docs-heading-anchor" href="#预编译项目">预编译项目</a><a id="预编译项目-1"></a><a class="docs-heading-anchor-permalink" href="#预编译项目" title="Permalink"></a></h2><p>REPL 命令 <code>precompile</code> 可用于预编译项目中的所有依赖。例如，这样做可以</p><pre><code class="language-none">(HelloWorld) pkg&gt; update; precompile</code></pre><p>更新依赖项，然后预编译它们。</p><h2 id="预览模式"><a class="docs-heading-anchor" href="#预览模式">预览模式</a><a id="预览模式-1"></a><a class="docs-heading-anchor-permalink" href="#预览模式" title="Permalink"></a></h2><p>如果你只想查看某个命令运行的效果，但不想更改包的状态，则可以 <code>preview</code> 该命令。例如：</p><pre><code class="language-none">(HelloWorld) pkg&gt; preview add Plots</code></pre><p>或</p><pre><code class="language-none">(HelloWorld) pkg&gt; preview up</code></pre><p>将向你展示添加 <code>Plots</code>、或者进行完全升级分别会对你的项目产生的影响。但是，这没有安装任何东西，也不会触及你的 <code>Project.toml</code> 和 <code>Manifest.toml</code>。</p><h2 id="使用别人的项目"><a class="docs-heading-anchor" href="#使用别人的项目">使用别人的项目</a><a id="使用别人的项目-1"></a><a class="docs-heading-anchor-permalink" href="#使用别人的项目" title="Permalink"></a></h2><p>只需使用诸如 <code>git clone</code> 来克隆项目，接着 <code>cd</code> 到项目目录并调用</p><pre><code class="language-none">(v0.7) pkg&gt; activate .

(SomeProject) pkg&gt; instantiate</code></pre><p>如果该项目包含了清单，则会以与该清单给定的相同状态安装包。否则，它将解析为与项目兼容的最新版本的依赖项。</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>This section describes the &quot;API mode&quot; of interacting with Pkg.jl which is recommended for non-interactive usage, in i.e. scripts. In the REPL mode packages (with associated version, UUID, URL etc) are parsed from strings, for example, <code>&quot;Package#master&quot;</code>,<code>&quot;Package@v0.1&quot;</code>, <code>&quot;www.mypkg.com/MyPkg#my/feature&quot;</code>. It is possible to use strings as arguments for simple commands in the API mode (like <code>Pkg.add([&quot;PackageA&quot;, &quot;PackageB&quot;])</code>, more complicated commands, that e.g. specify URLs or version range, uses a more structured format over strings. This is done by creating an instance of a <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> which are passed in to functions.</p><article class="docstring"><header><a class="docstring-binding" id="Pkg.PackageSpec" href="#Pkg.PackageSpec"><code>Pkg.PackageSpec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">PackageSpec(name::String, [uuid::UUID, version::VersionNumber])
PackageSpec(; name, url, path, subdir, rev, version, mode, level)</code></pre><p>A <code>PackageSpec</code> is a representation of a package with various metadata. This includes:</p><ul><li>The <code>name</code> of the package.</li><li>The package&#39;s unique <code>uuid</code>.</li><li>A <code>version</code> (for example when adding a package). When upgrading, can also be an instance of</li></ul><p>the enum <a href="#Pkg.UpgradeLevel"><code>UpgradeLevel</code></a>.</p><ul><li>A <code>url</code> and an optional git <code>rev</code>ision. <code>rev</code> can be a branch name or a git commit SHA1.</li><li>A local <code>path</code>. This is equivalent to using the <code>url</code> argument but can be more descriptive.</li><li>A <code>subdir</code> which can be used when adding a package that is not in the root of a repository.</li><li>A <code>mode</code>, which is an instance of the enum <a href="#Pkg.PackageMode"><code>PackageMode</code></a>, with possible values <code>PKGMODE_PROJECT</code></li></ul><p>(the default) or <code>PKGMODE_MANIFEST</code>. Used in e.g. <a href="#Pkg.rm"><code>Pkg.rm</code></a>.</p><p>Most functions in Pkg take a <code>Vector</code> of <code>PackageSpec</code> and do the operation on all the packages in the vector.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Many functions that take a <code>PackageSpec</code> or a <code>Vector{PackageSpec}</code> can be called with a more concise notation with <code>NamedTuple</code>s. For example, <code>Pkg.add</code> can be called either as the explicit or concise versions as:</p><table><tr><th style="text-align: left">Explicit</th><th style="text-align: left">Concise</th></tr><tr><td style="text-align: left"><code>Pkg.add(PackageSpec(name=&quot;Package))</code></td><td style="text-align: left"><code>Pkg.add(name = &quot;Package&quot;)</code></td></tr><tr><td style="text-align: left"><code>Pkg.add(PackageSpec(url=&quot;www.myhost.com/MyPkg&quot;)))</code></td><td style="text-align: left"><code>Pkg.add(name = &quot;Package&quot;)</code></td></tr><tr><td style="text-align: left"><code>Pkg.add([PackageSpec(name=&quot;Package&quot;), PackageSpec(path=&quot;/MyPkg&quot;])</code></td><td style="text-align: left"><code>Pkg.add([(;name=&quot;Package&quot;), (;path=&quot;MyPkg&quot;)])</code></td></tr></table></div></div><p>Below is a comparison between the REPL version and the API version:</p><table><tr><th style="text-align: left"><code>REPL</code></th><th style="text-align: left"><code>API</code></th></tr><tr><td style="text-align: left"><code>Package</code></td><td style="text-align: left"><code>PackageSpec(&quot;Package&quot;)</code></td></tr><tr><td style="text-align: left"><code>Package@0.2</code></td><td style="text-align: left"><code>PackageSpec(name=&quot;Package&quot;, version=&quot;0.2&quot;)</code></td></tr><tr><td style="text-align: left"><code>Package=a67d...</code></td><td style="text-align: left"><code>PackageSpec(name=&quot;Package&quot;, uuid=&quot;a67d...&quot;)</code></td></tr><tr><td style="text-align: left"><code>Package#master</code></td><td style="text-align: left"><code>PackageSpec(name=&quot;Package&quot;, rev=&quot;master&quot;)</code></td></tr><tr><td style="text-align: left"><code>local/path#feature</code></td><td style="text-align: left"><code>PackageSpec(path=&quot;local/path&quot;; rev=&quot;feature&quot;)</code></td></tr><tr><td style="text-align: left"><code>www.mypkg.com</code></td><td style="text-align: left"><code>PackageSpec(url=&quot;www.mypkg.com&quot;)</code></td></tr><tr><td style="text-align: left"><code>--manifest Package</code></td><td style="text-align: left"><code>PackageSpec(name=&quot;Package&quot;, mode=PKGSPEC_MANIFEST)</code></td></tr><tr><td style="text-align: left"><code>--major Package</code></td><td style="text-align: left"><code>PackageSpec(name=&quot;Package&quot;, version=PKGLEVEL_MAJOR)</code></td></tr></table></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.PackageMode" href="#Pkg.PackageMode"><code>Pkg.PackageMode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PackageMode</code></pre><p>An enum with the instances</p><ul><li><code>PKGMODE_MANIFEST</code></li><li><code>PKGMODE_PROJECT</code></li></ul><p>Determines if operations should be made on a project or manifest level. Used as an argument to  <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> or as an argument to <a href="#Pkg.rm"><code>Pkg.rm</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.UpgradeLevel" href="#Pkg.UpgradeLevel"><code>Pkg.UpgradeLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UpgradeLevel</code></pre><p>An enum with the instances</p><ul><li><code>UPLEVEL_FIXED</code></li><li><code>UPLEVEL_PATCH</code></li><li><code>UPLEVEL_MINOR</code></li><li><code>UPLEVEL_MAJOR</code></li></ul><p>Determines how much a package is allowed to be updated. Used as an argument to  <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> or as an argument to <a href="#Pkg.update"><code>Pkg.update</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.add" href="#Pkg.add"><code>Pkg.add</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.add(pkg::Union{String, Vector{String}}; preserve=PRESERVE_TIERED)
Pkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}}; preserve=PRESERVE_TIERED)</code></pre><p>Add a package to the current project. This package will be available by using the <code>import</code> and <code>using</code> keywords in the Julia REPL, and if the current project is a package, also inside that package.</p><p><strong>Resolution Tiers</strong></p><p><code>Pkg</code> resolves the set of packages in your environment using a tiered algorithm. The <code>preserve</code> keyword argument allows you to key into a specific tier in the resolve algorithm. The following table describes the argument values for <code>preserve</code> (in order of strictness):</p><table><tr><th style="text-align: left">Value</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>PRESERVE_ALL</code></td><td style="text-align: left">Preserve the state of all existing dependencies (including recursive dependencies)</td></tr><tr><td style="text-align: left"><code>PRESERVE_DIRECT</code></td><td style="text-align: left">Preserve the state of all existing direct dependencies</td></tr><tr><td style="text-align: left"><code>PRESERVE_SEMVER</code></td><td style="text-align: left">Preserve semver-compatible versions of direct dependencies</td></tr><tr><td style="text-align: left"><code>PRESERVE_NONE</code></td><td style="text-align: left">Do not attempt to preserve any version information</td></tr><tr><td style="text-align: left"><code>PRESERVE_TIERED</code></td><td style="text-align: left">Use the tier which will preserve the most version information (this is the default)</td></tr></table><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.add(&quot;Example&quot;) # Add a package from registry
Pkg.add(&quot;Example&quot;; preserve=Pkg.PRESERVE_ALL) # Add the `Example` package and preserve existing dependencies
Pkg.add(name=&quot;Example&quot;, version=&quot;0.3&quot;) # Specify version; latest release in the 0.3 series
Pkg.add(name=&quot;Example&quot;, version=&quot;0.3.1&quot;) # Specify version; exact release
Pkg.add(url=&quot;https://github.com/JuliaLang/Example.jl&quot;, rev=&quot;master&quot;) # From url to remote gitrepo
Pkg.add(url=&quot;/remote/mycompany/juliapackages/OurPackage&quot;) # From path to local gitrepo
Pkg.add(url=&quot;https://github.com/Company/MonoRepo&quot;, subdir=&quot;juliapkgs/Package.jl)&quot;) # With subdir</code></pre><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.develop" href="#Pkg.develop"><code>Pkg.develop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.develop(pkg::Union{String, Vector{String}}; io::IO=stderr)
Pkg.develop(pkgs::Union{Packagespec, Vector{Packagespec}}; io::IO=stderr)</code></pre><p>Make a package available for development by tracking it by path. If <code>pkg</code> is given with only a name or by a URL, the package will be downloaded to the location specified by the environment variable <code>JULIA_PKG_DEVDIR</code>, with <code>.julia/dev</code> as the default.</p><p>If <code>pkg</code> is given as a local path, the package at that path will be tracked.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># By name
Pkg.develop(&quot;Example&quot;)

# By url
Pkg.develop(url=&quot;https://github.com/JuliaLang/Compat.jl&quot;)

# By path
Pkg.develop(path=&quot;MyJuliaPackages/Package.jl&quot;)</code></pre><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.activate" href="#Pkg.activate"><code>Pkg.activate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.activate([s::String]; shared::Bool=false, io::IO=stderr)
Pkg.activate(; temp::Bool=false, shared::Bool=false, io::IO=stderr)</code></pre><p>Activate the environment at <code>s</code>. The active environment is the environment that is modified by executing package commands. The logic for what path is activated is as follows:</p><ul><li>If <code>shared</code> is <code>true</code>, the first existing environment named <code>s</code> from the depots in the depot stack will be activated. If no such environment exists, create and activate that environment in the first depot.</li><li>If <code>s</code> is an existing path, then activate the environment at that path.</li><li>If <code>s</code> is a package in the current project and <code>s</code> is tracking a path, then activate the environment at the tracked path.</li><li>Otherwise, <code>s</code> is interpreted as a non-existing path, which is then activated.</li></ul><p>If no argument is given to <code>activate</code>, then activate the home project. The home project is specified by either the <code>--project</code> command line option to the julia executable, or the <code>JULIA_PROJECT</code> environment variable.</p><p><strong>Examples</strong></p><pre><code class="language-none">Pkg.activate()
Pkg.activate(&quot;local/path&quot;)
Pkg.activate(&quot;MyDependency&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.rm" href="#Pkg.rm"><code>Pkg.rm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.rm(pkg::Union{String, Vector{String}})
Pkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Remove a package from the current project. If the <code>mode</code> of <code>pkg</code> is <code>PKGMODE_MANIFEST</code> also remove it from the manifest including all recursive dependencies of <code>pkg</code>.</p><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>, <a href="#Pkg.PackageMode"><code>PackageMode</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.update" href="#Pkg.update"><code>Pkg.update</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT)
Pkg.update(pkg::Union{String, Vector{String}})
Pkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Update a package <code>pkg</code>. If no posistional argument is given, update all packages in the manifest if <code>mode</code> is <code>PKGMODE_MANIFEST</code> and packages in both manifest and project if <code>mode</code> is <code>PKGMODE_PROJECT</code>. If no positional argument is given, <code>level</code> can be used to control by how much packages are allowed to be upgraded (major, minor, patch, fixed).</p><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>, <a href="#Pkg.PackageMode"><code>PackageMode</code></a>, <a href="#Pkg.UpgradeLevel"><code>UpgradeLevel</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.test" href="#Pkg.test"><code>Pkg.test</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.test(; kwargs...)
Pkg.test(pkg::Union{String, Vector{String}; kwargs...)
Pkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; kwargs...)</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>coverage::Bool=false</code>: enable or disable generation of coverage statistics.</li><li><code>julia_args::Union{Cmd, Vector{String}}</code>: options to be passed the test process.</li><li><code>test_args::Union{Cmd, Vector{String}}</code>: test arguments (<code>ARGS</code>) available in the test process.</li></ul><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p><code>julia_args</code> and <code>test_args</code> requires at least Julia 1.3.</p></div></div><p>Run the tests for package <code>pkg</code>, or for the current project (which thus needs to be a package) if no positional argument is given to <code>Pkg.test</code>. A package is tested by running its <code>test/runtests.jl</code> file.</p><p>The tests are run by generating a temporary environment with only <code>pkg</code> and its (recursive) dependencies in it. If a manifest exists, the versions in that manifest are used, otherwise a feasible set of packages is resolved and installed.</p><p>During the tests, test-specific dependencies are active, which are given in the project file as e.g.</p><pre><code class="language-none">[extras]
Test = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;

[targets]
test = [&quot;Test&quot;]</code></pre><p>The tests are executed in a new process with <code>check-bounds=yes</code> and by default <code>startup-file=no</code>. If using the startup file (<code>~/.julia/config/startup.jl</code>) is desired, start julia with <code>--startup-file=yes</code>. Inlining of functions during testing can be disabled (for better coverage accuracy) by starting julia with <code>--inline=no</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.build" href="#Pkg.build"><code>Pkg.build</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.build(; verbose = false, io::IO=stderr)
Pkg.build(pkg::Union{String, Vector{String}}; verbose = false, io::IO=stderr)
Pkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}}; verbose = false, io::IO=stderr)</code></pre><p>Run the build script in <code>deps/build.jl</code> for <code>pkg</code> and all of its dependencies in depth-first recursive order. If no argument is given to <code>build</code>, the current project is built, which thus needs to be a package. This function is called automatically on any package that gets installed for the first time. <code>verbose = true</code> prints the build output to <code>stdout</code>/<code>stderr</code> instead of redirecting to the <code>build.log</code> file.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.pin" href="#Pkg.pin"><code>Pkg.pin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.pin(pkg::Union{String, Vector{String}}; io::IO=stderr)
Pkg.pin(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr)</code></pre><p>Pin a package to the current version (or the one given in the <code>PackageSpec</code>) or to a certain git revision. A pinned package is never updated.</p><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.pin(&quot;Example&quot;)
Pkg.pin(name=&quot;Example&quot;, version=&quot;0.3.1&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.free" href="#Pkg.free"><code>Pkg.free</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.free(pkg::Union{String, Vector{String}}; io::IO=stderr)
Pkg.free(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr)</code></pre><p>If <code>pkg</code> is pinned, remove the pin. If <code>pkg</code> is tracking a path, e.g. after <a href="#Pkg.develop"><code>Pkg.develop</code></a>, go back to tracking registered versions.</p><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.free(&quot;Package&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.instantiate" href="#Pkg.instantiate"><code>Pkg.instantiate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.instantiate(; verbose = false, io::IO=stderr)</code></pre><p>If a <code>Manifest.toml</code> file exists in the active project, download all the packages declared in that manifest. Otherwise, resolve a set of feasible packages from the <code>Project.toml</code> files and install them. <code>verbose = true</code> prints the build output to <code>stdout</code>/<code>stderr</code> instead of redirecting to the <code>build.log</code> file. If no <code>Project.toml</code> exist in the current active project, create one with all the dependencies in the manifest and instantiate the resulting project.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.resolve" href="#Pkg.resolve"><code>Pkg.resolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pkg.resolve(; io::IO=stderr)</code></pre><p>Update the current manifest with potential changes to the dependency graph from packages that are tracking a path.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Pkg.setprotocol!" href="#Pkg.setprotocol!"><code>Pkg.setprotocol!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setprotocol!(;
    domain::AbstractString = &quot;github.com&quot;,
    protocol::Union{Nothing, AbstractString}=nothing
)</code></pre><p>Set the protocol used to access hosted packages when <code>add</code>ing a url or <code>develop</code>ing a package. Defaults to delegating the choice to the package developer (<code>protocol === nothing</code>). Other choices for <code>protocol</code> are <code>&quot;https&quot;</code> or <code>&quot;git&quot;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Pkg.setprotocol!(domain = &quot;github.com&quot;, protocol = &quot;ssh&quot;)

julia&gt; Pkg.setprotocol!(domain = &quot;gitlab.mycompany.com&quot;)</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Mmap/">« 内存映射 I/O</a><a class="docs-footer-nextpage" href="../Printf/">Printf »</a><div class="flexbox-break"></div><p class="footer-message">📢📢📢Julia中文社区现已加入“开源软件供应链点亮计划”，如果你想改善Julia中文文档的翻译，那就赶快来 <a href="https://summer.iscas.ac.cn/#/org/prodetail/210370191">报名</a> 吧！</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2021 八月 12 周四 18:36">2021 八月 12 周四</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.6.2版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
