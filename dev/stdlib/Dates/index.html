<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>日期 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/stdlib/Dates/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">Asynchronous Programming</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-options/">命令行选项</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../Base64/">Base64</a></li><li><a class="tocitem" href="../CRC32c/">CRC32c</a></li><li class="is-active"><a class="tocitem" href>日期</a><ul class="internal"><li><a class="tocitem" href="#构造函数"><span>构造函数</span></a></li><li><a class="tocitem" href="#Durations/Comparisons"><span>Durations/Comparisons</span></a></li><li><a class="tocitem" href="#Accessor-Functions"><span>Accessor Functions</span></a></li><li><a class="tocitem" href="#Query-Functions"><span>Query Functions</span></a></li><li><a class="tocitem" href="#TimeType-Period-Arithmetic"><span>TimeType-Period Arithmetic</span></a></li><li><a class="tocitem" href="#Adjuster-Functions"><span>Adjuster Functions</span></a></li><li><a class="tocitem" href="#Period-Types"><span>Period Types</span></a></li><li><a class="tocitem" href="#Rounding"><span>Rounding</span></a></li><li class="toplevel"><a class="tocitem" href="#stdlib-dates-api"><span>API reference</span></a></li><li><a class="tocitem" href="#Dates-and-Time-Types"><span>Dates and Time Types</span></a></li><li><a class="tocitem" href="#Dates-Functions"><span>Dates Functions</span></a></li></ul></li><li><a class="tocitem" href="../DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../Future/">Future</a></li><li><a class="tocitem" href="../InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../Libdl/">动态链接器</a></li><li><a class="tocitem" href="../LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../Logging/">日志记录</a></li><li><a class="tocitem" href="../Markdown/">Markdown</a></li><li><a class="tocitem" href="../Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../Printf/">Printf</a></li><li><a class="tocitem" href="../Profile/">性能分析</a></li><li><a class="tocitem" href="../REPL/">Julia REPL</a></li><li><a class="tocitem" href="../Random/">随机数</a></li><li><a class="tocitem" href="../SHA/">SHA</a></li><li><a class="tocitem" href="../Serialization/">序列化</a></li><li><a class="tocitem" href="../SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../Sockets/">套接字</a></li><li><a class="tocitem" href="../SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../Statistics/">统计</a></li><li><a class="tocitem" href="../TOML/">TOML</a></li><li><a class="tocitem" href="../Test/">单元测试</a></li><li><a class="tocitem" href="../UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Standard Library</a></li><li class="is-active"><a href>日期</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>日期</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/stdlib-zh_cn/translate/#zh_CN/Datesmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="日期"><a class="docs-heading-anchor" href="#日期">日期</a><a id="日期-1"></a><a class="docs-heading-anchor-permalink" href="#日期" title="Permalink"></a></h1><p><code>Dates</code> 模块提供了两种类型来处理日期：<a href="#Dates.Date"><code>Date</code></a> 和 <a href="#Dates.DateTime"><code>DateTime</code></a>，分别精确到日和毫秒；两者都是抽象类型 <a href="#Dates.TimeType"><code>TimeType</code></a> 的子类型。区分类型的动机很简单：不必处理更高精度所带来的复杂性时，一些操作在代码和思维推理上都更加简单。例如，由于 <a href="#Dates.Date"><code>Date</code></a> 类型仅精确到日（即没有时、分或秒），因此避免了时区、夏令时和闰秒等不必要的通常考虑。</p><p><a href="#Dates.Date"><code>Date</code></a> 和 <a href="#Dates.DateTime"><code>DateTime</code></a> 类型都是基本不可变类型 <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a> 的包装类。这两种类型的单个 <code>instant</code> 字段实际上属于 <code>UTInstant{P}</code> 类型。这种类型表示的是一种基于世界时间（UT）持续增长的机器时间 <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>。<a href="#Dates.DateTime"><code>DateTime</code></a> 类型并不考虑时区（用 Python 的话讲，它是 <em>naive</em> 的），与 Java 8 中的 <em>LocalDateTime</em> 类似。如果需要附加时区功能，可以通过 <a href="https://github.com/JuliaTime/TimeZones.jl/">TimeZones.jl 包</a> 实现，其汇编了来自 <a href="http://www.iana.org/time-zones">IANA 时区数据库</a> 的数据。<a href="#Dates.Date"><code>Date</code></a> 和 <a href="#Dates.DateTime"><code>DateTime</code></a> 都基于 <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> 标准，遵循公历（格里高利历）。 值得注意的是，ISO 8601 标准对公元前的日期需要特别处理。通常来说，公元前的最后一天是公元前 1 年的 12 月 31 日，接下来的一天是公元 1 年的 1 月 1 日，公元 0 年是不存在的。但是，在 ISO 8601 标准中，公元前 1 年被表示为 0 年，即 <code>0001-01-01</code> 的前一天是 <code>0000-12-31</code>，而 <code>-0001</code>（没错，年数为-1）的那一年则实际上是公元前 2 年，<code>-0002</code> 则表示公元前 3 年，以此类推。</p><h2 id="构造函数"><a class="docs-heading-anchor" href="#构造函数">构造函数</a><a id="构造函数-1"></a><a class="docs-heading-anchor-permalink" href="#构造函数" title="Permalink"></a></h2><p><a href="#Dates.Date"><code>Date</code></a> 和 <a href="#Dates.DateTime"><code>DateTime</code></a> 类型可以通过整数或 <a href="#Dates.Period"><code>Period</code></a> 类型，解析，或调整器来构造（稍后会详细介绍）：</p><pre><code class="language-julia-repl">julia&gt; DateTime(2013)
2013-01-01T00:00:00

julia&gt; DateTime(2013,7)
2013-07-01T00:00:00

julia&gt; DateTime(2013,7,1)
2013-07-01T00:00:00

julia&gt; DateTime(2013,7,1,12)
2013-07-01T12:00:00

julia&gt; DateTime(2013,7,1,12,30)
2013-07-01T12:30:00

julia&gt; DateTime(2013,7,1,12,30,59)
2013-07-01T12:30:59

julia&gt; DateTime(2013,7,1,12,30,59,1)
2013-07-01T12:30:59.001

julia&gt; Date(2013)
2013-01-01

julia&gt; Date(2013,7)
2013-07-01

julia&gt; Date(2013,7,1)
2013-07-01

julia&gt; Date(Dates.Year(2013),Dates.Month(7),Dates.Day(1))
2013-07-01

julia&gt; Date(Dates.Month(7),Dates.Year(2013))
2013-07-01</code></pre><p><a href="#Dates.Date"><code>Date</code></a> or <a href="#Dates.DateTime"><code>DateTime</code></a> parsing is accomplished by the use of format strings. Format strings work by the notion of defining <em>delimited</em> or <em>fixed-width</em> &quot;slots&quot; that contain a period to parse and passing the text to parse and format string to a <a href="#Dates.Date"><code>Date</code></a> or <a href="#Dates.DateTime"><code>DateTime</code></a> constructor, of the form <code>Date(&quot;2015-01-01&quot;,dateformat&quot;y-m-d&quot;)</code> or <code>DateTime(&quot;20150101&quot;,dateformat&quot;yyyymmdd&quot;)</code>.</p><p>有分隔的插入点是通过指定解析器在两个时段之间的分隔符来进行标记的。例如，<code>&quot;y-m-d&quot;</code> 会告诉解析器，一个诸如 <code>&quot;2014-07-16&quot;</code> 的时间字符串，应该在第一个和第二个插入点之间查找 <code>-</code> 字符。<code>y</code>，<code>m</code> 和 <code>d</code> 字符则告诉解析器每一个插入点对应的时段名称。</p><p>As in the case of constructors above such as <code>Date(2013)</code>, delimited <code>DateFormat</code>s allow for missing parts of dates and times so long as the preceding parts are given. The other parts are given the usual default values.  For example, <code>Date(&quot;1981-03&quot;, dateformat&quot;y-m-d&quot;)</code> returns <code>1981-03-01</code>, whilst <code>Date(&quot;31/12&quot;, dateformat&quot;d/m/y&quot;)</code> gives <code>0001-12-31</code>.  (Note that the default year is 1 AD/CE.) Consequently, an empty string will always return <code>0001-01-01</code> for <code>Date</code>s, and <code>0001-01-01T00:00:00.000</code> for <code>DateTime</code>s.</p><p>Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So <code>dateformat&quot;yyyymmdd&quot;</code> would correspond to a date string like <code>&quot;20140716&quot;</code>. The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition <code>&quot;yyyymm&quot;</code> from one period character to the next.</p><p>Support for text-form month parsing is also supported through the <code>u</code> and <code>U</code> characters, for abbreviated and full-length month names, respectively. By default, only English month names are supported, so <code>u</code> corresponds to &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, etc. And <code>U</code> corresponds to &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, etc. Similar to other name=&gt;value mapping functions <a href="#Dates.dayname"><code>dayname</code></a> and <a href="#Dates.monthname"><code>monthname</code></a>, custom locales can be loaded by passing in the <code>locale=&gt;Dict{String,Int}</code> mapping to the <code>MONTHTOVALUEABBR</code> and <code>MONTHTOVALUE</code> dicts for abbreviated and full-name month names, respectively.</p><p>The above examples used the <code>dateformat&quot;&quot;</code> string macro. This macro creates a <code>DateFormat</code> object once when the macro is expanded and uses the same <code>DateFormat</code> object even if a code snippet is run multiple times.</p><pre><code class="language-julia-repl">julia&gt; for i = 1:10^5
           Date(&quot;2015-01-01&quot;, dateformat&quot;y-m-d&quot;)
       end</code></pre><p>Or you can create the DateFormat object explicitly:</p><pre><code class="language-julia-repl">julia&gt; df = DateFormat(&quot;y-m-d&quot;);

julia&gt; dt = Date(&quot;2015-01-01&quot;,df)
2015-01-01

julia&gt; dt2 = Date(&quot;2015-01-02&quot;,df)
2015-01-02</code></pre><p>Alternatively, use broadcasting:</p><pre><code class="language-julia-repl">julia&gt; years = [&quot;2015&quot;, &quot;2016&quot;];

julia&gt; Date.(years, DateFormat(&quot;yyyy&quot;))
2-element Vector{Date}:
 2015-01-01
 2016-01-01</code></pre><p>For convenience, you may pass the format string directly (e.g., <code>Date(&quot;2015-01-01&quot;,&quot;y-m-d&quot;)</code>), although this form incurs performance costs if you are parsing the same format repeatedly, as it internally creates a new <code>DateFormat</code> object each time.</p><p>As well as via the constructors, a <code>Date</code> or <code>DateTime</code> can be constructed from strings using the <a href="../../base/numbers/#Base.parse"><code>parse</code></a> and <a href="../../base/numbers/#Base.tryparse"><code>tryparse</code></a> functions, but with an optional third argument of type <code>DateFormat</code> specifying the format; for example, <code>parse(Date, &quot;06.23.2013&quot;, dateformat&quot;m.d.y&quot;)</code>, or <code>tryparse(DateTime, &quot;1999-12-31T23:59:59&quot;)</code> which uses the default format. The notable difference between the functions is that with <a href="../../base/numbers/#Base.tryparse"><code>tryparse</code></a>, an error is not thrown if the string is in an invalid format; instead <code>nothing</code> is returned.  Note however that as with the constructors above, empty date and time parts assume default values and consequently an empty string (<code>&quot;&quot;</code>) is valid for <em>any</em> <code>DateFormat</code>, giving for example a <code>Date</code> of <code>0001-01-01</code>.  Code relying on <code>parse</code> or <code>tryparse</code> for <code>Date</code> and <code>DateTime</code> parsing should therefore also check whether parsed strings are empty before using the result.</p><p>A full suite of parsing and formatting tests and examples is available in <a href="https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl"><code>stdlib/Dates/test/io.jl</code></a>.</p><h2 id="Durations/Comparisons"><a class="docs-heading-anchor" href="#Durations/Comparisons">Durations/Comparisons</a><a id="Durations/Comparisons-1"></a><a class="docs-heading-anchor-permalink" href="#Durations/Comparisons" title="Permalink"></a></h2><p>Finding the length of time between two <a href="#Dates.Date"><code>Date</code></a> or <a href="#Dates.DateTime"><code>DateTime</code></a> is straightforward given their underlying representation as <code>UTInstant{Day}</code> and <code>UTInstant{Millisecond}</code>, respectively. The difference between <a href="#Dates.Date"><code>Date</code></a> is returned in the number of <a href="#Dates.Day-Tuple{TimeType}"><code>Day</code></a>, and <a href="#Dates.DateTime"><code>DateTime</code></a> in the number of <a href="#Dates.Millisecond-Tuple{DateTime}"><code>Millisecond</code></a>. Similarly, comparing <a href="#Dates.TimeType"><code>TimeType</code></a> is a simple matter of comparing the underlying machine instants (which in turn compares the internal <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a> values).</p><pre><code class="language-julia-repl">julia&gt; dt = Date(2012,2,29)
2012-02-29

julia&gt; dt2 = Date(2000,2,1)
2000-02-01

julia&gt; dump(dt)
Date
  instant: Dates.UTInstant{Day}
    periods: Day
      value: Int64 734562

julia&gt; dump(dt2)
Date
  instant: Dates.UTInstant{Day}
    periods: Day
      value: Int64 730151

julia&gt; dt &gt; dt2
true

julia&gt; dt != dt2
true

julia&gt; dt + dt2
ERROR: MethodError: no method matching +(::Date, ::Date)
[...]

julia&gt; dt * dt2
ERROR: MethodError: no method matching *(::Date, ::Date)
[...]

julia&gt; dt / dt2
ERROR: MethodError: no method matching /(::Date, ::Date)

julia&gt; dt - dt2
4411 days

julia&gt; dt2 - dt
-4411 days

julia&gt; dt = DateTime(2012,2,29)
2012-02-29T00:00:00

julia&gt; dt2 = DateTime(2000,2,1)
2000-02-01T00:00:00

julia&gt; dt - dt2
381110400000 milliseconds</code></pre><h2 id="Accessor-Functions"><a class="docs-heading-anchor" href="#Accessor-Functions">Accessor Functions</a><a id="Accessor-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Accessor-Functions" title="Permalink"></a></h2><p>Because the <a href="#Dates.Date"><code>Date</code></a> and <a href="#Dates.DateTime"><code>DateTime</code></a> types are stored as single <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a> values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:</p><pre><code class="language-julia-repl">julia&gt; t = Date(2014, 1, 31)
2014-01-31

julia&gt; Dates.year(t)
2014

julia&gt; Dates.month(t)
1

julia&gt; Dates.week(t)
5

julia&gt; Dates.day(t)
31</code></pre><p>While propercase return the same value in the corresponding <a href="#Dates.Period"><code>Period</code></a> type:</p><pre><code class="language-julia-repl">julia&gt; Dates.Year(t)
2014 years

julia&gt; Dates.Day(t)
31 days</code></pre><p>Compound methods are provided because it is more efficient to access multiple fields at the same time than individually:</p><pre><code class="language-julia-repl">julia&gt; Dates.yearmonth(t)
(2014, 1)

julia&gt; Dates.monthday(t)
(1, 31)

julia&gt; Dates.yearmonthday(t)
(2014, 1, 31)</code></pre><p>One may also access the underlying <code>UTInstant</code> or integer value:</p><pre><code class="language-julia-repl">julia&gt; dump(t)
Date
  instant: Dates.UTInstant{Day}
    periods: Day
      value: Int64 735264

julia&gt; t.instant
Dates.UTInstant{Day}(Day(735264))

julia&gt; Dates.value(t)
735264</code></pre><h2 id="Query-Functions"><a class="docs-heading-anchor" href="#Query-Functions">Query Functions</a><a id="Query-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Query-Functions" title="Permalink"></a></h2><p>Query functions provide calendrical information about a <a href="#Dates.TimeType"><code>TimeType</code></a>. They include information about the day of the week:</p><pre><code class="language-julia-repl">julia&gt; t = Date(2014, 1, 31)
2014-01-31

julia&gt; Dates.dayofweek(t)
5

julia&gt; Dates.dayname(t)
&quot;Friday&quot;

julia&gt; Dates.dayofweekofmonth(t) # 5th Friday of January
5</code></pre><p>Month of the year:</p><pre><code class="language-julia-repl">julia&gt; Dates.monthname(t)
&quot;January&quot;

julia&gt; Dates.daysinmonth(t)
31</code></pre><p>As well as information about the <a href="#Dates.TimeType"><code>TimeType</code></a>&#39;s year and quarter:</p><pre><code class="language-julia-repl">julia&gt; Dates.isleapyear(t)
false

julia&gt; Dates.dayofyear(t)
31

julia&gt; Dates.quarterofyear(t)
1

julia&gt; Dates.dayofquarter(t)
31</code></pre><p>The <a href="#Dates.dayname"><code>dayname</code></a> and <a href="#Dates.monthname"><code>monthname</code></a> methods can also take an optional <code>locale</code> keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely <a href="#Dates.dayabbr"><code>dayabbr</code></a> and <a href="#Dates.monthabbr"><code>monthabbr</code></a>. First the mapping is loaded into the <code>LOCALES</code> variable:</p><pre><code class="language-julia-repl">julia&gt; french_months = [&quot;janvier&quot;, &quot;février&quot;, &quot;mars&quot;, &quot;avril&quot;, &quot;mai&quot;, &quot;juin&quot;,
                        &quot;juillet&quot;, &quot;août&quot;, &quot;septembre&quot;, &quot;octobre&quot;, &quot;novembre&quot;, &quot;décembre&quot;];

julia&gt; french_monts_abbrev = [&quot;janv&quot;,&quot;févr&quot;,&quot;mars&quot;,&quot;avril&quot;,&quot;mai&quot;,&quot;juin&quot;,
                              &quot;juil&quot;,&quot;août&quot;,&quot;sept&quot;,&quot;oct&quot;,&quot;nov&quot;,&quot;déc&quot;];

julia&gt; french_days = [&quot;lundi&quot;,&quot;mardi&quot;,&quot;mercredi&quot;,&quot;jeudi&quot;,&quot;vendredi&quot;,&quot;samedi&quot;,&quot;dimanche&quot;];

julia&gt; Dates.LOCALES[&quot;french&quot;] = Dates.DateLocale(french_months, french_monts_abbrev, french_days, [&quot;&quot;]);</code></pre><p>The above mentioned functions can then be used to perform the queries:</p><pre><code class="language-julia-repl">julia&gt; Dates.dayname(t;locale=&quot;french&quot;)
&quot;vendredi&quot;

julia&gt; Dates.monthname(t;locale=&quot;french&quot;)
&quot;janvier&quot;

julia&gt; Dates.monthabbr(t;locale=&quot;french&quot;)
&quot;janv&quot;</code></pre><p>Since the abbreviated versions of the days are not loaded, trying to use the function <code>dayabbr</code> will error.</p><pre><code class="language-julia-repl">julia&gt; Dates.dayabbr(t;locale=&quot;french&quot;)
ERROR: BoundsError: attempt to access 1-element Vector{String} at index [5]
Stacktrace:
[...]</code></pre><h2 id="TimeType-Period-Arithmetic"><a class="docs-heading-anchor" href="#TimeType-Period-Arithmetic">TimeType-Period Arithmetic</a><a id="TimeType-Period-Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#TimeType-Period-Arithmetic" title="Permalink"></a></h2><p>It&#39;s good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some <a href="https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/">tricky issues</a> to deal with (though much less so for day-precision types).</p><p>The <code>Dates</code> module approach tries to follow the simple principle of trying to change as little as possible when doing <a href="#Dates.Period"><code>Period</code></a> arithmetic. This approach is also often known as <em>calendrical</em> arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let&#39;s take a classic example: add 1 month to January 31st, 2014. What&#39;s the answer? Javascript will say <a href="https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/">March 3</a> (assumes 31 days). PHP says <a href="https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month">March 2</a> (assumes 30 days). The fact is, there is no right answer. In the <code>Dates</code> module, it gives the result of February 28th. How does it figure that out? Consider the classic 7-7-7 gambling game in casinos.</p><p>Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31. When you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31. Then the day number is checked if it is greater than the last valid day of the new month; if it is (as in the case above), the day number is adjusted down to the last valid day (28). What are the ramifications with this approach? Go ahead and add another month to our date, <code>2014-02-28 + Month(1) == 2014-03-28</code>. What? Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so we first increment the month slot by 1, 2014-03-28, and boom, we&#39;re done because that&#39;s a valid date. On the other hand, if we were to add 2 months to our original date, 2014-01-31, then we end up with 2014-03-31, as expected. The other ramification of this approach is a loss in associativity when a specific ordering is forced (i.e. adding things in different orders results in different outcomes). For example:</p><pre><code class="language-julia-repl">julia&gt; (Date(2014,1,29)+Dates.Day(1)) + Dates.Month(1)
2014-02-28

julia&gt; (Date(2014,1,29)+Dates.Month(1)) + Dates.Day(1)
2014-03-01</code></pre><p>What&#39;s going on there? In the first line, we&#39;re adding 1 day to January 29th, which results in 2014-01-30; then we add 1 month, so we get 2014-02-30, which then adjusts down to 2014-02-28. In the second example, we add 1 month <em>first</em>, where we get 2014-02-29, which adjusts down to 2014-02-28, and <em>then</em> add 1 day, which results in 2014-03-01. One design principle that helps in this case is that, in the presence of multiple Periods, the operations will be ordered by the Periods&#39; <em>types</em>, not their value or positional order; this means <code>Year</code> will always be added first, then <code>Month</code>, then <code>Week</code>, etc. Hence the following <em>does</em> result in associativity and Just Works:</p><pre><code class="language-julia-repl">julia&gt; Date(2014,1,29) + Dates.Day(1) + Dates.Month(1)
2014-03-01

julia&gt; Date(2014,1,29) + Dates.Month(1) + Dates.Day(1)
2014-03-01</code></pre><p>Tricky? Perhaps. What is an innocent <code>Dates</code> user to do? The bottom line is to be aware that explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that&#39;s pretty much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the &quot;joys&quot; of dealing with daylight savings, leap seconds, etc.).</p><p>As a bonus, all period arithmetic objects work directly with ranges:</p><pre><code class="language-julia-repl">julia&gt; dr = Date(2014,1,29):Day(1):Date(2014,2,3)
Date(&quot;2014-01-29&quot;):Day(1):Date(&quot;2014-02-03&quot;)

julia&gt; collect(dr)
6-element Vector{Date}:
 2014-01-29
 2014-01-30
 2014-01-31
 2014-02-01
 2014-02-02
 2014-02-03

julia&gt; dr = Date(2014,1,29):Dates.Month(1):Date(2014,07,29)
Date(&quot;2014-01-29&quot;):Month(1):Date(&quot;2014-07-29&quot;)

julia&gt; collect(dr)
7-element Vector{Date}:
 2014-01-29
 2014-02-28
 2014-03-29
 2014-04-29
 2014-05-29
 2014-06-29
 2014-07-29</code></pre><h2 id="Adjuster-Functions"><a class="docs-heading-anchor" href="#Adjuster-Functions">Adjuster Functions</a><a id="Adjuster-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Adjuster-Functions" title="Permalink"></a></h2><p>As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a <em>calendrical</em> or <em>temporal</em> nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as &quot;Memorial Day = Last Monday of May&quot;, or &quot;Thanksgiving = 4th Thursday of November&quot;. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.</p><p>The <code>Dates</code> module provides the <em>adjuster</em> API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single <a href="#Dates.TimeType"><code>TimeType</code></a> as input and return or <em>adjust to</em> the first or last of the desired period relative to the input.</p><pre><code class="language-julia-repl">julia&gt; Dates.firstdayofweek(Date(2014,7,16)) # Adjusts the input to the Monday of the input&#39;s week
2014-07-14

julia&gt; Dates.lastdayofmonth(Date(2014,7,16)) # Adjusts to the last day of the input&#39;s month
2014-07-31

julia&gt; Dates.lastdayofquarter(Date(2014,7,16)) # Adjusts to the last day of the input&#39;s quarter
2014-09-30</code></pre><p>The next two higher-order methods, <a href="#Dates.tonext-Tuple{TimeType, Int64}"><code>tonext</code></a>, and <a href="#Dates.toprev-Tuple{TimeType, Int64}"><code>toprev</code></a>, generalize working with temporal expressions by taking a <code>DateFunction</code> as first argument, along with a starting <a href="#Dates.TimeType"><code>TimeType</code></a>. A <code>DateFunction</code> is just a function, usually anonymous, that takes a single <a href="#Dates.TimeType"><code>TimeType</code></a> as input and returns a <a href="../../base/numbers/#Core.Bool"><code>Bool</code></a>, <code>true</code> indicating a satisfied adjustment criterion. For example:</p><pre><code class="language-julia-repl">julia&gt; istuesday = x-&gt;Dates.dayofweek(x) == Dates.Tuesday; # Returns true if the day of the week of x is Tuesday

julia&gt; Dates.tonext(istuesday, Date(2014,7,13)) # 2014-07-13 is a Sunday
2014-07-15

julia&gt; Dates.tonext(Date(2014,7,13), Dates.Tuesday) # Convenience method provided for day of the week adjustments
2014-07-15</code></pre><p>This is useful with the do-block syntax for more complex temporal expressions:</p><pre><code class="language-julia-repl">julia&gt; Dates.tonext(Date(2014,7,13)) do x
           # Return true on the 4th Thursday of November (Thanksgiving)
           Dates.dayofweek(x) == Dates.Thursday &amp;&amp;
           Dates.dayofweekofmonth(x) == 4 &amp;&amp;
           Dates.month(x) == Dates.November
       end
2014-11-27</code></pre><p>The <a href="../../base/collections/#Base.filter"><code>Base.filter</code></a> method can be used to obtain all valid dates/moments in a specified range:</p><pre><code class="language-julia-repl"># Pittsburgh street cleaning; Every 2nd Tuesday from April to November
# Date range from January 1st, 2014 to January 1st, 2015
julia&gt; dr = Dates.Date(2014):Day(1):Dates.Date(2015);

julia&gt; filter(dr) do x
           Dates.dayofweek(x) == Dates.Tue &amp;&amp;
           Dates.April &lt;= Dates.month(x) &lt;= Dates.Nov &amp;&amp;
           Dates.dayofweekofmonth(x) == 2
       end
8-element Vector{Date}:
 2014-04-08
 2014-05-13
 2014-06-10
 2014-07-08
 2014-08-12
 2014-09-09
 2014-10-14
 2014-11-11</code></pre><p>Additional examples and tests are available in <a href="https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl"><code>stdlib/Dates/test/adjusters.jl</code></a>.</p><h2 id="Period-Types"><a class="docs-heading-anchor" href="#Period-Types">Period Types</a><a id="Period-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Period-Types" title="Permalink"></a></h2><p>Periods are a human view of discrete, sometimes irregular durations of time. Consider 1 month; it could represent, in days, a value of 28, 29, 30, or 31 depending on the year and month context. Or a year could represent 365 or 366 days in the case of a leap year. <a href="#Dates.Period"><code>Period</code></a> types are simple <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a> wrappers and are constructed by wrapping any <code>Int64</code> convertible type, i.e. <code>Year(1)</code> or <code>Month(3.0)</code>. Arithmetic between <a href="#Dates.Period"><code>Period</code></a> of the same type behave like integers, and limited <code>Period-Real</code> arithmetic is available.  You can extract the underlying integer with <a href="#Dates.value"><code>Dates.value</code></a>.</p><pre><code class="language-julia-repl">julia&gt; y1 = Dates.Year(1)
1 year

julia&gt; y2 = Dates.Year(2)
2 years

julia&gt; y3 = Dates.Year(10)
10 years

julia&gt; y1 + y2
3 years

julia&gt; div(y3,y2)
5

julia&gt; y3 - y2
8 years

julia&gt; y3 % y2
0 years

julia&gt; div(y3,3) # mirrors integer division
3 years

julia&gt; Dates.value(Dates.Millisecond(10))
10</code></pre><h2 id="Rounding"><a class="docs-heading-anchor" href="#Rounding">Rounding</a><a id="Rounding-1"></a><a class="docs-heading-anchor-permalink" href="#Rounding" title="Permalink"></a></h2><p><a href="#Dates.Date"><code>Date</code></a> and <a href="#Dates.DateTime"><code>DateTime</code></a> values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with <a href="../../base/math/#Base.floor"><code>floor</code></a>, <a href="../../base/math/#Base.ceil"><code>ceil</code></a>, or <a href="../../base/math/#Base.round-Tuple{Type, Any}"><code>round</code></a>:</p><pre><code class="language-julia-repl">julia&gt; floor(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia&gt; ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:45:00

julia&gt; round(DateTime(2016, 8, 6, 20, 15), Dates.Day)
2016-08-07T00:00:00</code></pre><p>Unlike the numeric <a href="../../base/math/#Base.round-Tuple{Type, Any}"><code>round</code></a> method, which breaks ties toward the even number by default, the <a href="#Dates.TimeType"><code>TimeType</code></a><a href="../../base/math/#Base.round-Tuple{Type, Any}"><code>round</code></a> method uses the <code>RoundNearestTiesUp</code> rounding mode. (It&#39;s difficult to guess what breaking ties to nearest &quot;even&quot; <a href="#Dates.TimeType"><code>TimeType</code></a> would entail.) Further details on the available <code>RoundingMode</code> s can be found in the <a href="#stdlib-dates-api">API reference</a>.</p><p>Rounding should generally behave as expected, but there are a few cases in which the expected behaviour is not obvious.</p><h3 id="Rounding-Epoch"><a class="docs-heading-anchor" href="#Rounding-Epoch">Rounding Epoch</a><a id="Rounding-Epoch-1"></a><a class="docs-heading-anchor-permalink" href="#Rounding-Epoch" title="Permalink"></a></h3><p>In many cases, the resolution specified for rounding (e.g., <code>Dates.Second(30)</code>) divides evenly into the next largest period (in this case, <code>Dates.Minute(1)</code>). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a <a href="#Dates.DateTime"><code>DateTime</code></a> to the nearest 10 hours?</p><pre><code class="language-julia-repl">julia&gt; round(DateTime(2016, 7, 17, 11, 55), Dates.Hour(10))
2016-07-17T12:00:00</code></pre><p>That may seem confusing, given that the hour (12) is not divisible by 10. The reason that <code>2016-07-17T12:00:00</code> was chosen is that it is 17,676,660 hours after <code>0000-01-01T00:00:00</code>, and 17,676,660 is divisible by 10.</p><p>As Julia <a href="#Dates.Date"><code>Date</code></a> and <a href="#Dates.DateTime"><code>DateTime</code></a> values are represented according to the ISO 8601 standard, <code>0000-01-01T00:00:00</code> was chosen as base (or &quot;rounding epoch&quot;) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia&#39;s internal representation of <a href="#Dates.Date"><code>Date</code></a> s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, <code>0000-01-01T00:00:00</code> was chosen as the rounding epoch instead of the <code>0000-12-31T00:00:00</code> used internally to minimize confusion.)</p><p>The only exception to the use of <code>0000-01-01T00:00:00</code> as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use <code>0000-01-03T00:00:00</code> (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.</p><p>Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest <code>P(2)</code>, where <code>P</code> is a <a href="#Dates.Period"><code>Period</code></a> type? In some cases (specifically, when <code>P &lt;: Dates.TimePeriod</code>) the answer is clear:</p><pre><code class="language-julia-repl">julia&gt; round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Hour(2))
2016-07-17T08:00:00

julia&gt; round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Minute(2))
2016-07-17T08:56:00</code></pre><p>This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:</p><pre><code class="language-julia-repl">julia&gt; round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Month(2))
2016-07-01T00:00:00</code></pre><p>Why round to the first day in July, even though it is month 7 (an odd number)? The key is that months are 1-indexed (the first month is assigned 1), unlike hours, minutes, seconds, and milliseconds (the first of which are assigned 0).</p><p>This means that rounding a <a href="#Dates.DateTime"><code>DateTime</code></a> to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a <a href="#Dates.DateTime"><code>DateTime</code></a> with an even value in that field, while rounding a <a href="#Dates.DateTime"><code>DateTime</code></a> to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.</p><p>See the <a href="#stdlib-dates-api">API reference</a> for additional information on methods exported from the <code>Dates</code> module.</p><h1 id="stdlib-dates-api"><a class="docs-heading-anchor" href="#stdlib-dates-api">API reference</a><a id="stdlib-dates-api-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-dates-api" title="Permalink"></a></h1><h2 id="Dates-and-Time-Types"><a class="docs-heading-anchor" href="#Dates-and-Time-Types">Dates and Time Types</a><a id="Dates-and-Time-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Dates-and-Time-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Dates.Period" href="#Dates.Period"><code>Dates.Period</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Period
Year
Quarter
Month
Week
Day
Hour
Minute
Second
Millisecond
Microsecond
Nanosecond</code></pre><p><code>Period</code> types represent discrete, human representations of time.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.CompoundPeriod" href="#Dates.CompoundPeriod"><code>Dates.CompoundPeriod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CompoundPeriod</code></pre><p>A <code>CompoundPeriod</code> is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, &quot;a year and a  day&quot; is not a fixed number of days, but can be expressed using a <code>CompoundPeriod</code>. In fact, a <code>CompoundPeriod</code> is automatically generated by addition of different period types, e.g. <code>Year(1) + Day(1)</code> produces a <code>CompoundPeriod</code> result.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Instant" href="#Dates.Instant"><code>Dates.Instant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Instant</code></pre><p><code>Instant</code> types represent integer-based, machine representations of time as continuous timelines starting from an epoch.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.UTInstant" href="#Dates.UTInstant"><code>Dates.UTInstant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UTInstant{T}</code></pre><p>The <code>UTInstant</code> represents a machine timeline based on UT time (1 day = one revolution of the earth). The <code>T</code> is a <code>Period</code> parameter that indicates the resolution or precision of the instant.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.TimeType" href="#Dates.TimeType"><code>Dates.TimeType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TimeType</code></pre><p><code>TimeType</code> types wrap <code>Instant</code> machine instances to provide human representations of the machine instant. <code>Time</code>, <code>DateTime</code> and <code>Date</code> are subtypes of <code>TimeType</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.DateTime" href="#Dates.DateTime"><code>Dates.DateTime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateTime</code></pre><p><code>DateTime</code> wraps a <code>UTInstant{Millisecond}</code> and interprets it according to the proleptic Gregorian calendar.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Date" href="#Dates.Date"><code>Dates.Date</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Date</code></pre><p><code>Date</code> wraps a <code>UTInstant{Day}</code> and interprets it according to the proleptic Gregorian calendar.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Time" href="#Dates.Time"><code>Dates.Time</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Time</code></pre><p><code>Time</code> wraps a <code>Nanosecond</code> and represents a specific moment in a 24-hour day.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.TimeZone" href="#Dates.TimeZone"><code>Dates.TimeZone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TimeZone</code></pre><p>Geographic zone generally based on longitude determining what the time is at a certain location. Some time zones observe daylight savings (eg EST -&gt; EDT). For implementations and more support, see the <a href="https://github.com/JuliaTime/TimeZones.jl"><code>TimeZones.jl</code></a> package</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.UTC" href="#Dates.UTC"><code>Dates.UTC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UTC</code></pre><p><code>UTC</code>, or Coordinated Universal Time, is the <a href="#Dates.TimeZone"><code>TimeZone</code></a> from which all others are measured. It is associated with the time at 0° longitude. It is not adjusted for daylight savings.</p></div></section></article><h2 id="Dates-Functions"><a class="docs-heading-anchor" href="#Dates-Functions">Dates Functions</a><a id="Dates-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Dates-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Dates.DateTime-NTuple{7, Int64}" href="#Dates.DateTime-NTuple{7, Int64}"><code>Dates.DateTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DateTime(y, [m, d, h, mi, s, ms]) -&gt; DateTime</code></pre><p>Construct a <code>DateTime</code> type by parts. Arguments must be convertible to <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.DateTime-Tuple{Period}" href="#Dates.DateTime-Tuple{Period}"><code>Dates.DateTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DateTime(periods::Period...) -&gt; DateTime</code></pre><p>Construct a <code>DateTime</code> type by <code>Period</code> type parts. Arguments may be in any order. DateTime parts not provided will default to the value of <code>Dates.default(period)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.DateTime-Tuple{Function, Vararg{Any, N} where N}" href="#Dates.DateTime-Tuple{Function, Vararg{Any, N} where N}"><code>Dates.DateTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DateTime(f::Function, y[, m, d, h, mi, s]; step=Day(1), limit=10000) -&gt; DateTime</code></pre><p>Create a <code>DateTime</code> through the adjuster API. The starting point will be constructed from the provided <code>y, m, d...</code> arguments, and will be adjusted until <code>f::Function</code> returns <code>true</code>. The step size in adjusting can be provided manually through the <code>step</code> keyword. <code>limit</code> provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that <code>f::Function</code> is never satisfied).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; DateTime(dt -&gt; Dates.second(dt) == 40, 2010, 10, 20, 10; step = Dates.Second(1))
2010-10-20T10:00:40

julia&gt; DateTime(dt -&gt; Dates.hour(dt) == 20, 2010, 10, 20, 10; step = Dates.Hour(1), limit = 5)
ERROR: ArgumentError: Adjustment limit reached: 5 iterations
Stacktrace:
[...]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.DateTime-Tuple{TimeType}" href="#Dates.DateTime-Tuple{TimeType}"><code>Dates.DateTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DateTime(dt::Date) -&gt; DateTime</code></pre><p>Convert a <code>Date</code> to a <code>DateTime</code>. The hour, minute, second, and millisecond parts of the new <code>DateTime</code> are assumed to be zero.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.DateTime-Tuple{AbstractString, AbstractString}" href="#Dates.DateTime-Tuple{AbstractString, AbstractString}"><code>Dates.DateTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DateTime(dt::AbstractString, format::AbstractString; locale=&quot;english&quot;) -&gt; DateTime</code></pre><p>Construct a <code>DateTime</code> by parsing the <code>dt</code> date time string following the pattern given in the <code>format</code> string (see <a href="#Dates.DateFormat"><code>DateFormat</code></a>  for syntax).</p><p>This method creates a <code>DateFormat</code> object each time it is called. If you are parsing many date time strings of the same format, consider creating a <a href="#Dates.DateFormat"><code>DateFormat</code></a> object once and using that as the second argument instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.format-Tuple{TimeType, AbstractString}" href="#Dates.format-Tuple{TimeType, AbstractString}"><code>Dates.format</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">format(dt::TimeType, format::AbstractString; locale=&quot;english&quot;) -&gt; AbstractString</code></pre><p>Construct a string by using a <code>TimeType</code> object and applying the provided <code>format</code>. The following character codes can be used to construct the <code>format</code> string:</p><table><tr><th style="text-align: left">Code</th><th style="text-align: left">Examples</th><th style="text-align: left">Comment</th></tr><tr><td style="text-align: left"><code>y</code></td><td style="text-align: left">6</td><td style="text-align: left">Numeric year with a fixed width</td></tr><tr><td style="text-align: left"><code>Y</code></td><td style="text-align: left">1996</td><td style="text-align: left">Numeric year with a minimum width</td></tr><tr><td style="text-align: left"><code>m</code></td><td style="text-align: left">1, 12</td><td style="text-align: left">Numeric month with a minimum width</td></tr><tr><td style="text-align: left"><code>u</code></td><td style="text-align: left">Jan</td><td style="text-align: left">Month name shortened to 3-chars according to the <code>locale</code></td></tr><tr><td style="text-align: left"><code>U</code></td><td style="text-align: left">January</td><td style="text-align: left">Full month name according to the <code>locale</code> keyword</td></tr><tr><td style="text-align: left"><code>d</code></td><td style="text-align: left">1, 31</td><td style="text-align: left">Day of the month with a minimum width</td></tr><tr><td style="text-align: left"><code>H</code></td><td style="text-align: left">0, 23</td><td style="text-align: left">Hour (24-hour clock) with a minimum width</td></tr><tr><td style="text-align: left"><code>M</code></td><td style="text-align: left">0, 59</td><td style="text-align: left">Minute with a minimum width</td></tr><tr><td style="text-align: left"><code>S</code></td><td style="text-align: left">0, 59</td><td style="text-align: left">Second with a minimum width</td></tr><tr><td style="text-align: left"><code>s</code></td><td style="text-align: left">000, 500</td><td style="text-align: left">Millisecond with a minimum width of 3</td></tr><tr><td style="text-align: left"><code>e</code></td><td style="text-align: left">Mon, Tue</td><td style="text-align: left">Abbreviated days of the week</td></tr><tr><td style="text-align: left"><code>E</code></td><td style="text-align: left">Monday</td><td style="text-align: left">Full day of week name</td></tr></table><p>The number of sequential code characters indicate the width of the code. A format of <code>yyyy-mm</code> specifies that the code <code>y</code> should have a width of four while <code>m</code> a width of two. Codes that yield numeric digits have an associated mode: fixed-width or minimum-width. The fixed-width mode left-pads the value with zeros when it is shorter than the specified width and truncates the value when longer. Minimum-width mode works the same as fixed-width except that it does not truncate values longer than the width.</p><p>When creating a <code>format</code> you can use any non-code characters as a separator. For example to generate the string &quot;1996-01-15T00:00:00&quot; you could use <code>format</code>: &quot;yyyy-mm-ddTHH:MM:SS&quot;. Note that if you need to use a code character as a literal you can use the escape character backslash. The string &quot;1996y01m&quot; can be produced with the format &quot;yyyy\ymm\m&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.DateFormat" href="#Dates.DateFormat"><code>Dates.DateFormat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateFormat(format::AbstractString, locale=&quot;english&quot;) -&gt; DateFormat</code></pre><p>Construct a date formatting object that can be used for parsing date strings or formatting a date object as a string. The following character codes can be used to construct the <code>format</code> string:</p><table><tr><th style="text-align: left">Code</th><th style="text-align: left">Matches</th><th style="text-align: left">Comment</th></tr><tr><td style="text-align: left"><code>y</code></td><td style="text-align: left">1996, 96</td><td style="text-align: left">Returns year of 1996, 0096</td></tr><tr><td style="text-align: left"><code>Y</code></td><td style="text-align: left">1996, 96</td><td style="text-align: left">Returns year of 1996, 0096. Equivalent to <code>y</code></td></tr><tr><td style="text-align: left"><code>m</code></td><td style="text-align: left">1, 01</td><td style="text-align: left">Matches 1 or 2-digit months</td></tr><tr><td style="text-align: left"><code>u</code></td><td style="text-align: left">Jan</td><td style="text-align: left">Matches abbreviated months according to the <code>locale</code> keyword</td></tr><tr><td style="text-align: left"><code>U</code></td><td style="text-align: left">January</td><td style="text-align: left">Matches full month names according to the <code>locale</code> keyword</td></tr><tr><td style="text-align: left"><code>d</code></td><td style="text-align: left">1, 01</td><td style="text-align: left">Matches 1 or 2-digit days</td></tr><tr><td style="text-align: left"><code>H</code></td><td style="text-align: left">00</td><td style="text-align: left">Matches hours (24-hour clock)</td></tr><tr><td style="text-align: left"><code>I</code></td><td style="text-align: left">00</td><td style="text-align: left">For outputting hours with 12-hour clock</td></tr><tr><td style="text-align: left"><code>M</code></td><td style="text-align: left">00</td><td style="text-align: left">Matches minutes</td></tr><tr><td style="text-align: left"><code>S</code></td><td style="text-align: left">00</td><td style="text-align: left">Matches seconds</td></tr><tr><td style="text-align: left"><code>s</code></td><td style="text-align: left">.500</td><td style="text-align: left">Matches milliseconds</td></tr><tr><td style="text-align: left"><code>e</code></td><td style="text-align: left">Mon, Tues</td><td style="text-align: left">Matches abbreviated days of the week</td></tr><tr><td style="text-align: left"><code>E</code></td><td style="text-align: left">Monday</td><td style="text-align: left">Matches full name days of the week</td></tr><tr><td style="text-align: left"><code>p</code></td><td style="text-align: left">AM</td><td style="text-align: left">Matches AM/PM (case-insensitive)</td></tr><tr><td style="text-align: left"><code>yyyymmdd</code></td><td style="text-align: left">19960101</td><td style="text-align: left">Matches fixed-width year, month, and day</td></tr></table><p>Characters not listed above are normally treated as delimiters between date and time slots. For example a <code>dt</code> string of &quot;1996-01-15T00:00:00.0&quot; would have a <code>format</code> string like &quot;y-m-dTH:M:S.s&quot;. If you need to use a code character as a delimiter you can escape it using backslash. The date &quot;1995y01m&quot; would have the format &quot;y\ym\m&quot;.</p><p>Note that 12:00AM corresponds 00:00 (midnight), and 12:00PM corresponds to 12:00 (noon). When parsing a time with a <code>p</code> specifier, any hour (either <code>H</code> or <code>I</code>) is interpreted as as a 12-hour clock, so the <code>I</code> code is mainly useful for output.</p><p>Creating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try the <code>dateformat&quot;&quot;</code> string macro. Using this macro creates the DateFormat object once at macro expansion time and reuses it later. see <a href="#Dates.@dateformat_str"><code>@dateformat_str</code></a>.</p><p>See <a href="#Dates.DateTime"><code>DateTime</code></a> and <a href="#Dates.format-Tuple{TimeType, AbstractString}"><code>format</code></a> for how to use a DateFormat object to parse and write Date strings respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.@dateformat_str" href="#Dates.@dateformat_str"><code>Dates.@dateformat_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">dateformat&quot;Y-m-d H:M:S&quot;</code></pre><p>Create a <a href="#Dates.DateFormat"><code>DateFormat</code></a> object. Similar to <code>DateFormat(&quot;Y-m-d H:M:S&quot;)</code> but creates the DateFormat object once during macro expansion.</p><p>See <a href="#Dates.DateFormat"><code>DateFormat</code></a> for details about format specifiers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.DateTime-Tuple{AbstractString, DateFormat}" href="#Dates.DateTime-Tuple{AbstractString, DateFormat}"><code>Dates.DateTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DateTime(dt::AbstractString, df::DateFormat=ISODateTimeFormat) -&gt; DateTime</code></pre><p>Construct a <code>DateTime</code> by parsing the <code>dt</code> date time string following the pattern given in the <a href="#Dates.DateFormat"><code>DateFormat</code></a> object, or dateformat&quot;yyyy-mm-ddTHH:MM:SS.s&quot; if omitted.</p><p>Similar to <code>DateTime(::AbstractString, ::AbstractString)</code> but more efficient when repeatedly parsing similarly formatted date time strings with a pre-created <code>DateFormat</code> object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Date-Tuple{Int64, Int64, Int64}" href="#Dates.Date-Tuple{Int64, Int64, Int64}"><code>Dates.Date</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Date(y, [m, d]) -&gt; Date</code></pre><p>Construct a <code>Date</code> type by parts. Arguments must be convertible to <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Date-Tuple{Period}" href="#Dates.Date-Tuple{Period}"><code>Dates.Date</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Date(period::Period...) -&gt; Date</code></pre><p>Construct a <code>Date</code> type by <code>Period</code> type parts. Arguments may be in any order. <code>Date</code> parts not provided will default to the value of <code>Dates.default(period)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Date-Tuple{Function, Any, Any, Any}" href="#Dates.Date-Tuple{Function, Any, Any, Any}"><code>Dates.Date</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Date(f::Function, y[, m, d]; step=Day(1), limit=10000) -&gt; Date</code></pre><p>Create a <code>Date</code> through the adjuster API. The starting point will be constructed from the provided <code>y, m, d</code> arguments, and will be adjusted until <code>f::Function</code> returns <code>true</code>. The step size in adjusting can be provided manually through the <code>step</code> keyword. <code>limit</code> provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that <code>f::Function</code> is never satisfied).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Date(date -&gt; Dates.week(date) == 20, 2010, 01, 01)
2010-05-17

julia&gt; Date(date -&gt; Dates.year(date) == 2010, 2000, 01, 01)
2010-01-01

julia&gt; Date(date -&gt; Dates.month(date) == 10, 2000, 01, 01; limit = 5)
ERROR: ArgumentError: Adjustment limit reached: 5 iterations
Stacktrace:
[...]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Date-Tuple{TimeType}" href="#Dates.Date-Tuple{TimeType}"><code>Dates.Date</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Date(dt::DateTime) -&gt; Date</code></pre><p>Convert a <code>DateTime</code> to a <code>Date</code>. The hour, minute, second, and millisecond parts of the <code>DateTime</code> are truncated, so only the year, month and day parts are used in construction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Date-Tuple{AbstractString, AbstractString}" href="#Dates.Date-Tuple{AbstractString, AbstractString}"><code>Dates.Date</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Date(d::AbstractString, format::AbstractString; locale=&quot;english&quot;) -&gt; Date</code></pre><p>Construct a <code>Date</code> by parsing the <code>d</code> date string following the pattern given in the <code>format</code> string (see <a href="#Dates.DateFormat"><code>DateFormat</code></a> for syntax).</p><p>This method creates a <code>DateFormat</code> object each time it is called. If you are parsing many date strings of the same format, consider creating a <a href="#Dates.DateFormat"><code>DateFormat</code></a> object once and using that as the second argument instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Date-Tuple{AbstractString, DateFormat}" href="#Dates.Date-Tuple{AbstractString, DateFormat}"><code>Dates.Date</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Date(d::AbstractString, df::DateFormat=ISODateFormat) -&gt; Date</code></pre><p>Construct a <code>Date</code> by parsing the <code>d</code> date string following the pattern given in the <a href="#Dates.DateFormat"><code>DateFormat</code></a> object, or dateformat&quot;yyyy-mm-dd&quot; if omitted.</p><p>Similar to <code>Date(::AbstractString, ::AbstractString)</code> but more efficient when repeatedly parsing similarly formatted date strings with a pre-created <code>DateFormat</code> object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Time-NTuple{5, Int64}" href="#Dates.Time-NTuple{5, Int64}"><code>Dates.Time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Time(h, [mi, s, ms, us, ns]) -&gt; Time</code></pre><p>Construct a <code>Time</code> type by parts. Arguments must be convertible to <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Time-Tuple{TimePeriod}" href="#Dates.Time-Tuple{TimePeriod}"><code>Dates.Time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Time(period::TimePeriod...) -&gt; Time</code></pre><p>Construct a <code>Time</code> type by <code>Period</code> type parts. Arguments may be in any order. <code>Time</code> parts not provided will default to the value of <code>Dates.default(period)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Time-Tuple{Function, Vararg{Any, N} where N}" href="#Dates.Time-Tuple{Function, Vararg{Any, N} where N}"><code>Dates.Time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Time(f::Function, h, mi=0; step::Period=Second(1), limit::Int=10000)
Time(f::Function, h, mi, s; step::Period=Millisecond(1), limit::Int=10000)
Time(f::Function, h, mi, s, ms; step::Period=Microsecond(1), limit::Int=10000)
Time(f::Function, h, mi, s, ms, us; step::Period=Nanosecond(1), limit::Int=10000)</code></pre><p>Create a <code>Time</code> through the adjuster API. The starting point will be constructed from the provided <code>h, mi, s, ms, us</code> arguments, and will be adjusted until <code>f::Function</code> returns <code>true</code>. The step size in adjusting can be provided manually through the <code>step</code> keyword. <code>limit</code> provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that <code>f::Function</code> is never satisfied). Note that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second arguments are provided, the default step will be <code>Millisecond(1)</code> instead of <code>Second(1)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.Time(t -&gt; Dates.minute(t) == 30, 20)
20:30:00

julia&gt; Dates.Time(t -&gt; Dates.minute(t) == 0, 20)
20:00:00

julia&gt; Dates.Time(t -&gt; Dates.hour(t) == 10, 3; limit = 5)
ERROR: ArgumentError: Adjustment limit reached: 5 iterations
Stacktrace:
[...]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Time-Tuple{DateTime}" href="#Dates.Time-Tuple{DateTime}"><code>Dates.Time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Time(dt::DateTime) -&gt; Time</code></pre><p>Convert a <code>DateTime</code> to a <code>Time</code>. The hour, minute, second, and millisecond parts of the <code>DateTime</code> are used to create the new <code>Time</code>. Microsecond and nanoseconds are zero by default.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Time-Tuple{AbstractString, AbstractString}" href="#Dates.Time-Tuple{AbstractString, AbstractString}"><code>Dates.Time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Time(t::AbstractString, format::AbstractString; locale=&quot;english&quot;) -&gt; Time</code></pre><p>Construct a <code>Time</code> by parsing the <code>t</code> time string following the pattern given in the <code>format</code> string (see <a href="#Dates.DateFormat"><code>DateFormat</code></a> for syntax).</p><p>This method creates a <code>DateFormat</code> object each time it is called. If you are parsing many time strings of the same format, consider creating a <a href="#Dates.DateFormat"><code>DateFormat</code></a> object once and using that as the second argument instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Time-Tuple{AbstractString, DateFormat}" href="#Dates.Time-Tuple{AbstractString, DateFormat}"><code>Dates.Time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Time(t::AbstractString, df::DateFormat=ISOTimeFormat) -&gt; Time</code></pre><p>Construct a <code>Time</code> by parsing the <code>t</code> date time string following the pattern given in the <a href="#Dates.DateFormat"><code>DateFormat</code></a> object, or dateformat&quot;HH:MM:SS.s&quot; if omitted.</p><p>Similar to <code>Time(::AbstractString, ::AbstractString)</code> but more efficient when repeatedly parsing similarly formatted time strings with a pre-created <code>DateFormat</code> object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.now-Tuple{}" href="#Dates.now-Tuple{}"><code>Dates.now</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">now() -&gt; DateTime</code></pre><p>Return a <code>DateTime</code> corresponding to the user&#39;s system time including the system timezone locale.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.now-Tuple{Type{UTC}}" href="#Dates.now-Tuple{Type{UTC}}"><code>Dates.now</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">now(::Type{UTC}) -&gt; DateTime</code></pre><p>Return a <code>DateTime</code> corresponding to the user&#39;s system time as UTC/GMT.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eps-Tuple{Union{Type{Date}, Type{DateTime}, Type{Time}, TimeType}}" href="#Base.eps-Tuple{Union{Type{Date}, Type{DateTime}, Type{Time}, TimeType}}"><code>Base.eps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eps(::Type{DateTime}) -&gt; Millisecond
eps(::Type{Date}) -&gt; Day
eps(::Type{Time}) -&gt; Nanosecond
eps(::TimeType) -&gt; Period</code></pre><p>Return the smallest unit value supported by the <code>TimeType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eps(DateTime)
1 millisecond

julia&gt; eps(Date)
1 day

julia&gt; eps(Time)
1 nanosecond</code></pre></div></section></article><h3 id="Accessor-Functions-2"><a class="docs-heading-anchor" href="#Accessor-Functions-2">Accessor Functions</a><a class="docs-heading-anchor-permalink" href="#Accessor-Functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Dates.year" href="#Dates.year"><code>Dates.year</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">year(dt::TimeType) -&gt; Int64</code></pre><p>The year of a <code>Date</code> or <code>DateTime</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.month" href="#Dates.month"><code>Dates.month</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">month(dt::TimeType) -&gt; Int64</code></pre><p>The month of a <code>Date</code> or <code>DateTime</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.week" href="#Dates.week"><code>Dates.week</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">week(dt::TimeType) -&gt; Int64</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/ISO_week_date">ISO week date</a> of a <code>Date</code> or <code>DateTime</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>. Note that the first week of a year is the week that contains the first Thursday of the year, which can result in dates prior to January 4th being in the last week of the previous year. For example, <code>week(Date(2005, 1, 1))</code> is the 53rd week of 2004.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.week(Date(1989, 6, 22))
25

julia&gt; Dates.week(Date(2005, 1, 1))
53

julia&gt; Dates.week(Date(2004, 12, 31))
53</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.day" href="#Dates.day"><code>Dates.day</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">day(dt::TimeType) -&gt; Int64</code></pre><p>The day of month of a <code>Date</code> or <code>DateTime</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.hour" href="#Dates.hour"><code>Dates.hour</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hour(dt::DateTime) -&gt; Int64</code></pre><p>The hour of day of a <code>DateTime</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section><section><div><pre><code class="language-none">hour(t::Time) -&gt; Int64</code></pre><p>The hour of a <code>Time</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.minute" href="#Dates.minute"><code>Dates.minute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minute(dt::DateTime) -&gt; Int64</code></pre><p>The minute of a <code>DateTime</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section><section><div><pre><code class="language-none">minute(t::Time) -&gt; Int64</code></pre><p>The minute of a <code>Time</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.second" href="#Dates.second"><code>Dates.second</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">second(dt::DateTime) -&gt; Int64</code></pre><p>The second of a <code>DateTime</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section><section><div><pre><code class="language-none">second(t::Time) -&gt; Int64</code></pre><p>The second of a <code>Time</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.millisecond" href="#Dates.millisecond"><code>Dates.millisecond</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">millisecond(dt::DateTime) -&gt; Int64</code></pre><p>The millisecond of a <code>DateTime</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section><section><div><pre><code class="language-none">millisecond(t::Time) -&gt; Int64</code></pre><p>The millisecond of a <code>Time</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.microsecond" href="#Dates.microsecond"><code>Dates.microsecond</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">microsecond(t::Time) -&gt; Int64</code></pre><p>The microsecond of a <code>Time</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.nanosecond" href="#Dates.nanosecond"><code>Dates.nanosecond</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nanosecond(t::Time) -&gt; Int64</code></pre><p>The nanosecond of a <code>Time</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Year-Tuple{TimeType}" href="#Dates.Year-Tuple{TimeType}"><code>Dates.Year</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Year(v)</code></pre><p>Construct a <code>Year</code> object with the given <code>v</code> value. Input must be losslessly convertible to an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Month-Tuple{TimeType}" href="#Dates.Month-Tuple{TimeType}"><code>Dates.Month</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Month(v)</code></pre><p>Construct a <code>Month</code> object with the given <code>v</code> value. Input must be losslessly convertible to an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Week-Tuple{TimeType}" href="#Dates.Week-Tuple{TimeType}"><code>Dates.Week</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Week(v)</code></pre><p>Construct a <code>Week</code> object with the given <code>v</code> value. Input must be losslessly convertible to an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Day-Tuple{TimeType}" href="#Dates.Day-Tuple{TimeType}"><code>Dates.Day</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Day(v)</code></pre><p>Construct a <code>Day</code> object with the given <code>v</code> value. Input must be losslessly convertible to an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Hour-Tuple{DateTime}" href="#Dates.Hour-Tuple{DateTime}"><code>Dates.Hour</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Hour(dt::DateTime) -&gt; Hour</code></pre><p>The hour part of a DateTime as a <code>Hour</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Minute-Tuple{DateTime}" href="#Dates.Minute-Tuple{DateTime}"><code>Dates.Minute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Minute(dt::DateTime) -&gt; Minute</code></pre><p>The minute part of a DateTime as a <code>Minute</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Second-Tuple{DateTime}" href="#Dates.Second-Tuple{DateTime}"><code>Dates.Second</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Second(dt::DateTime) -&gt; Second</code></pre><p>The second part of a DateTime as a <code>Second</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Millisecond-Tuple{DateTime}" href="#Dates.Millisecond-Tuple{DateTime}"><code>Dates.Millisecond</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Millisecond(dt::DateTime) -&gt; Millisecond</code></pre><p>The millisecond part of a DateTime as a <code>Millisecond</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Microsecond-Tuple{Time}" href="#Dates.Microsecond-Tuple{Time}"><code>Dates.Microsecond</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Microsecond(dt::Time) -&gt; Microsecond</code></pre><p>The microsecond part of a Time as a <code>Microsecond</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.Nanosecond-Tuple{Time}" href="#Dates.Nanosecond-Tuple{Time}"><code>Dates.Nanosecond</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Nanosecond(dt::Time) -&gt; Nanosecond</code></pre><p>The nanosecond part of a Time as a <code>Nanosecond</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.yearmonth" href="#Dates.yearmonth"><code>Dates.yearmonth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">yearmonth(dt::TimeType) -&gt; (Int64, Int64)</code></pre><p>Simultaneously return the year and month parts of a <code>Date</code> or <code>DateTime</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.monthday" href="#Dates.monthday"><code>Dates.monthday</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">monthday(dt::TimeType) -&gt; (Int64, Int64)</code></pre><p>Simultaneously return the month and day parts of a <code>Date</code> or <code>DateTime</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.yearmonthday" href="#Dates.yearmonthday"><code>Dates.yearmonthday</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">yearmonthday(dt::TimeType) -&gt; (Int64, Int64, Int64)</code></pre><p>Simultaneously return the year, month and day parts of a <code>Date</code> or <code>DateTime</code>.</p></div></section></article><h3 id="Query-Functions-2"><a class="docs-heading-anchor" href="#Query-Functions-2">Query Functions</a><a class="docs-heading-anchor-permalink" href="#Query-Functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Dates.dayname" href="#Dates.dayname"><code>Dates.dayname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dayname(dt::TimeType; locale=&quot;english&quot;) -&gt; String
dayname(day::Integer; locale=&quot;english&quot;) -&gt; String</code></pre><p>Return the full day name corresponding to the day of the week of the <code>Date</code> or <code>DateTime</code> in the given <code>locale</code>. Also accepts <code>Integer</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.dayname(Date(&quot;2000-01-01&quot;))
&quot;Saturday&quot;

julia&gt; Dates.dayname(4)
&quot;Thursday&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.dayabbr" href="#Dates.dayabbr"><code>Dates.dayabbr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dayabbr(dt::TimeType; locale=&quot;english&quot;) -&gt; String
dayabbr(day::Integer; locale=&quot;english&quot;) -&gt; String</code></pre><p>Return the abbreviated name corresponding to the day of the week of the <code>Date</code> or <code>DateTime</code> in the given <code>locale</code>. Also accepts <code>Integer</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.dayabbr(Date(&quot;2000-01-01&quot;))
&quot;Sat&quot;

julia&gt; Dates.dayabbr(3)
&quot;Wed&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.dayofweek" href="#Dates.dayofweek"><code>Dates.dayofweek</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dayofweek(dt::TimeType) -&gt; Int64</code></pre><p>Return the day of the week as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a> with <code>1 = Monday, 2 = Tuesday, etc.</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.dayofweek(Date(&quot;2000-01-01&quot;))
6</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.dayofmonth" href="#Dates.dayofmonth"><code>Dates.dayofmonth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dayofmonth(dt::TimeType) -&gt; Int64</code></pre><p>The day of month of a <code>Date</code> or <code>DateTime</code> as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.dayofweekofmonth" href="#Dates.dayofweekofmonth"><code>Dates.dayofweekofmonth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dayofweekofmonth(dt::TimeType) -&gt; Int</code></pre><p>For the day of week of <code>dt</code>, return which number it is in <code>dt</code>&#39;s month. So if the day of the week of <code>dt</code> is Monday, then <code>1 = First Monday of the month, 2 = Second Monday of the month, etc.</code> In the range 1:5.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.dayofweekofmonth(Date(&quot;2000-02-01&quot;))
1

julia&gt; Dates.dayofweekofmonth(Date(&quot;2000-02-08&quot;))
2

julia&gt; Dates.dayofweekofmonth(Date(&quot;2000-02-15&quot;))
3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.daysofweekinmonth" href="#Dates.daysofweekinmonth"><code>Dates.daysofweekinmonth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">daysofweekinmonth(dt::TimeType) -&gt; Int</code></pre><p>For the day of week of <code>dt</code>, return the total number of that day of the week in <code>dt</code>&#39;s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including <code>dayofweekofmonth(dt) == daysofweekinmonth(dt)</code> in the adjuster function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.daysofweekinmonth(Date(&quot;2005-01-01&quot;))
5

julia&gt; Dates.daysofweekinmonth(Date(&quot;2005-01-04&quot;))
4</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.monthname" href="#Dates.monthname"><code>Dates.monthname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">monthname(dt::TimeType; locale=&quot;english&quot;) -&gt; String
monthname(month::Integer, locale=&quot;english&quot;) -&gt; String</code></pre><p>Return the full name of the month of the <code>Date</code> or <code>DateTime</code> or <code>Integer</code> in the given <code>locale</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.monthname(Date(&quot;2005-01-04&quot;))
&quot;January&quot;

julia&gt; Dates.monthname(2)
&quot;February&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.monthabbr" href="#Dates.monthabbr"><code>Dates.monthabbr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">monthabbr(dt::TimeType; locale=&quot;english&quot;) -&gt; String
monthabbr(month::Integer, locale=&quot;english&quot;) -&gt; String</code></pre><p>Return the abbreviated month name of the <code>Date</code> or <code>DateTime</code> or <code>Integer</code> in the given <code>locale</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.monthabbr(Date(&quot;2005-01-04&quot;))
&quot;Jan&quot;

julia&gt; monthabbr(2)
&quot;Feb&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.daysinmonth" href="#Dates.daysinmonth"><code>Dates.daysinmonth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">daysinmonth(dt::TimeType) -&gt; Int</code></pre><p>Return the number of days in the month of <code>dt</code>. Value will be 28, 29, 30, or 31.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.daysinmonth(Date(&quot;2000-01&quot;))
31

julia&gt; Dates.daysinmonth(Date(&quot;2001-02&quot;))
28

julia&gt; Dates.daysinmonth(Date(&quot;2000-02&quot;))
29</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.isleapyear" href="#Dates.isleapyear"><code>Dates.isleapyear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isleapyear(dt::TimeType) -&gt; Bool</code></pre><p>Return <code>true</code> if the year of <code>dt</code> is a leap year.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.isleapyear(Date(&quot;2004&quot;))
true

julia&gt; Dates.isleapyear(Date(&quot;2005&quot;))
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.dayofyear" href="#Dates.dayofyear"><code>Dates.dayofyear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dayofyear(dt::TimeType) -&gt; Int</code></pre><p>Return the day of the year for <code>dt</code> with January 1st being day 1.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.daysinyear" href="#Dates.daysinyear"><code>Dates.daysinyear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">daysinyear(dt::TimeType) -&gt; Int</code></pre><p>Return 366 if the year of <code>dt</code> is a leap year, otherwise return 365.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.daysinyear(1999)
365

julia&gt; Dates.daysinyear(2000)
366</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.quarterofyear" href="#Dates.quarterofyear"><code>Dates.quarterofyear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quarterofyear(dt::TimeType) -&gt; Int</code></pre><p>Return the quarter that <code>dt</code> resides in. Range of value is 1:4.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.dayofquarter" href="#Dates.dayofquarter"><code>Dates.dayofquarter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dayofquarter(dt::TimeType) -&gt; Int</code></pre><p>Return the day of the current quarter of <code>dt</code>. Range of value is 1:92.</p></div></section></article><h3 id="Adjuster-Functions-2"><a class="docs-heading-anchor" href="#Adjuster-Functions-2">Adjuster Functions</a><a class="docs-heading-anchor-permalink" href="#Adjuster-Functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.trunc-Tuple{TimeType, Type{Period}}" href="#Base.trunc-Tuple{TimeType, Type{Period}}"><code>Base.trunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trunc(dt::TimeType, ::Type{Period}) -&gt; TimeType</code></pre><p>Truncates the value of <code>dt</code> according to the provided <code>Period</code> type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; trunc(Dates.DateTime(&quot;1996-01-01T12:30:00&quot;), Dates.Day)
1996-01-01T00:00:00</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.firstdayofweek" href="#Dates.firstdayofweek"><code>Dates.firstdayofweek</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">firstdayofweek(dt::TimeType) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the Monday of its week.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.firstdayofweek(DateTime(&quot;1996-01-05T12:30:00&quot;))
1996-01-01T00:00:00</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.lastdayofweek" href="#Dates.lastdayofweek"><code>Dates.lastdayofweek</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lastdayofweek(dt::TimeType) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the Sunday of its week.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.lastdayofweek(DateTime(&quot;1996-01-05T12:30:00&quot;))
1996-01-07T00:00:00</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.firstdayofmonth" href="#Dates.firstdayofmonth"><code>Dates.firstdayofmonth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">firstdayofmonth(dt::TimeType) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the first day of its month.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.firstdayofmonth(DateTime(&quot;1996-05-20&quot;))
1996-05-01T00:00:00</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.lastdayofmonth" href="#Dates.lastdayofmonth"><code>Dates.lastdayofmonth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lastdayofmonth(dt::TimeType) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the last day of its month.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.lastdayofmonth(DateTime(&quot;1996-05-20&quot;))
1996-05-31T00:00:00</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.firstdayofyear" href="#Dates.firstdayofyear"><code>Dates.firstdayofyear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">firstdayofyear(dt::TimeType) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the first day of its year.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.firstdayofyear(DateTime(&quot;1996-05-20&quot;))
1996-01-01T00:00:00</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.lastdayofyear" href="#Dates.lastdayofyear"><code>Dates.lastdayofyear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lastdayofyear(dt::TimeType) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the last day of its year.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.lastdayofyear(DateTime(&quot;1996-05-20&quot;))
1996-12-31T00:00:00</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.firstdayofquarter" href="#Dates.firstdayofquarter"><code>Dates.firstdayofquarter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">firstdayofquarter(dt::TimeType) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the first day of its quarter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.firstdayofquarter(DateTime(&quot;1996-05-20&quot;))
1996-04-01T00:00:00

julia&gt; Dates.firstdayofquarter(DateTime(&quot;1996-08-20&quot;))
1996-07-01T00:00:00</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.lastdayofquarter" href="#Dates.lastdayofquarter"><code>Dates.lastdayofquarter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lastdayofquarter(dt::TimeType) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the last day of its quarter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.lastdayofquarter(DateTime(&quot;1996-05-20&quot;))
1996-06-30T00:00:00

julia&gt; Dates.lastdayofquarter(DateTime(&quot;1996-08-20&quot;))
1996-09-30T00:00:00</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.tonext-Tuple{TimeType, Int64}" href="#Dates.tonext-Tuple{TimeType, Int64}"><code>Dates.tonext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tonext(dt::TimeType, dow::Int; same::Bool=false) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the next day of week corresponding to <code>dow</code> with <code>1 = Monday, 2 = Tuesday, etc</code>. Setting <code>same=true</code> allows the current <code>dt</code> to be considered as the next <code>dow</code>, allowing for no adjustment to occur.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.toprev-Tuple{TimeType, Int64}" href="#Dates.toprev-Tuple{TimeType, Int64}"><code>Dates.toprev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">toprev(dt::TimeType, dow::Int; same::Bool=false) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the previous day of week corresponding to <code>dow</code> with <code>1 = Monday, 2 = Tuesday, etc</code>. Setting <code>same=true</code> allows the current <code>dt</code> to be considered as the previous <code>dow</code>, allowing for no adjustment to occur.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.tofirst" href="#Dates.tofirst"><code>Dates.tofirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tofirst(dt::TimeType, dow::Int; of=Month) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the first <code>dow</code> of its month. Alternatively, <code>of=Year</code> will adjust to the first <code>dow</code> of the year.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.tolast" href="#Dates.tolast"><code>Dates.tolast</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tolast(dt::TimeType, dow::Int; of=Month) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> to the last <code>dow</code> of its month. Alternatively, <code>of=Year</code> will adjust to the last <code>dow</code> of the year.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.tonext-Tuple{Function, TimeType}" href="#Dates.tonext-Tuple{Function, TimeType}"><code>Dates.tonext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tonext(func::Function, dt::TimeType; step=Day(1), limit=10000, same=false) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> by iterating at most <code>limit</code> iterations by <code>step</code> increments until <code>func</code> returns <code>true</code>. <code>func</code> must take a single <code>TimeType</code> argument and return a <a href="../../base/numbers/#Core.Bool"><code>Bool</code></a>. <code>same</code> allows <code>dt</code> to be considered in satisfying <code>func</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.toprev-Tuple{Function, TimeType}" href="#Dates.toprev-Tuple{Function, TimeType}"><code>Dates.toprev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">toprev(func::Function, dt::TimeType; step=Day(-1), limit=10000, same=false) -&gt; TimeType</code></pre><p>Adjusts <code>dt</code> by iterating at most <code>limit</code> iterations by <code>step</code> increments until <code>func</code> returns <code>true</code>. <code>func</code> must take a single <code>TimeType</code> argument and return a <a href="../../base/numbers/#Core.Bool"><code>Bool</code></a>. <code>same</code> allows <code>dt</code> to be considered in satisfying <code>func</code>.</p></div></section></article><h3 id="Periods"><a class="docs-heading-anchor" href="#Periods">Periods</a><a id="Periods-1"></a><a class="docs-heading-anchor-permalink" href="#Periods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Dates.Period-Tuple{Any}" href="#Dates.Period-Tuple{Any}"><code>Dates.Period</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Year(v)
Quarter(v)
Month(v)
Week(v)
Day(v)
Hour(v)
Minute(v)
Second(v)
Millisecond(v)
Microsecond(v)
Nanosecond(v)</code></pre><p>Construct a <code>Period</code> type with the given <code>v</code> value. Input must be losslessly convertible to an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.CompoundPeriod-Tuple{Vector{var&quot;#s387&quot;} where var&quot;#s387&quot;&lt;:Period}" href="#Dates.CompoundPeriod-Tuple{Vector{var&quot;#s387&quot;} where var&quot;#s387&quot;&lt;:Period}"><code>Dates.CompoundPeriod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CompoundPeriod(periods) -&gt; CompoundPeriod</code></pre><p>Construct a <code>CompoundPeriod</code> from a <code>Vector</code> of <code>Period</code>s. All <code>Period</code>s of the same type will be added together.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dates.CompoundPeriod(Dates.Hour(12), Dates.Hour(13))
25 hours

julia&gt; Dates.CompoundPeriod(Dates.Hour(-1), Dates.Minute(1))
-1 hour, 1 minute

julia&gt; Dates.CompoundPeriod(Dates.Month(1), Dates.Week(-2))
1 month, -2 weeks

julia&gt; Dates.CompoundPeriod(Dates.Minute(50000))
50000 minutes</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.value" href="#Dates.value"><code>Dates.value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Dates.value(x::Period) -&gt; Int64</code></pre><p>For a given period, return the value associated with that period.  For example, <code>value(Millisecond(10))</code> returns 10 as an integer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.default" href="#Dates.default"><code>Dates.default</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default(p::Period) -&gt; Period</code></pre><p>Returns a sensible &quot;default&quot; value for the input Period by returning <code>T(1)</code> for Year, Month, and Day, and <code>T(0)</code> for Hour, Minute, Second, and Millisecond.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Dates.periods</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Rounding-Functions"><a class="docs-heading-anchor" href="#Rounding-Functions">Rounding Functions</a><a id="Rounding-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Rounding-Functions" title="Permalink"></a></h3><p><code>Date</code> and <code>DateTime</code> values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with <code>floor</code>, <code>ceil</code>, or <code>round</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Base.floor-Tuple{TimeType, Period}" href="#Base.floor-Tuple{TimeType, Period}"><code>Base.floor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">floor(dt::TimeType, p::Period) -&gt; TimeType</code></pre><p>Return the nearest <code>Date</code> or <code>DateTime</code> less than or equal to <code>dt</code> at resolution <code>p</code>.</p><p>For convenience, <code>p</code> may be a type instead of a value: <code>floor(dt, Dates.Hour)</code> is a shortcut for <code>floor(dt, Dates.Hour(1))</code>.</p><pre><code class="language-julia-repl">julia&gt; floor(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia&gt; floor(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia&gt; floor(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-06T00:00:00</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ceil-Tuple{TimeType, Period}" href="#Base.ceil-Tuple{TimeType, Period}"><code>Base.ceil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ceil(dt::TimeType, p::Period) -&gt; TimeType</code></pre><p>Return the nearest <code>Date</code> or <code>DateTime</code> greater than or equal to <code>dt</code> at resolution <code>p</code>.</p><p>For convenience, <code>p</code> may be a type instead of a value: <code>ceil(dt, Dates.Hour)</code> is a shortcut for <code>ceil(dt, Dates.Hour(1))</code>.</p><pre><code class="language-julia-repl">julia&gt; ceil(Date(1985, 8, 16), Dates.Month)
1985-09-01

julia&gt; ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:45:00

julia&gt; ceil(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.round-Tuple{TimeType, Period, RoundingMode{:NearestTiesUp}}" href="#Base.round-Tuple{TimeType, Period, RoundingMode{:NearestTiesUp}}"><code>Base.round</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">round(dt::TimeType, p::Period, [r::RoundingMode]) -&gt; TimeType</code></pre><p>Return the <code>Date</code> or <code>DateTime</code> nearest to <code>dt</code> at resolution <code>p</code>. By default (<code>RoundNearestTiesUp</code>), ties (e.g., rounding 9:30 to the nearest hour) will be rounded up.</p><p>For convenience, <code>p</code> may be a type instead of a value: <code>round(dt, Dates.Hour)</code> is a shortcut for <code>round(dt, Dates.Hour(1))</code>.</p><pre><code class="language-julia-repl">julia&gt; round(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia&gt; round(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia&gt; round(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00</code></pre><p>Valid rounding modes for <code>round(::TimeType, ::Period, ::RoundingMode)</code> are <code>RoundNearestTiesUp</code> (default), <code>RoundDown</code> (<code>floor</code>), and <code>RoundUp</code> (<code>ceil</code>).</p></div></section></article><p>Most <code>Period</code> values can also be rounded to a specified resolution:</p><article class="docstring"><header><a class="docstring-binding" id="Base.floor-Union{Tuple{T}, Tuple{Union{Day, Week, TimePeriod}, T}} where T&lt;:Union{Day, Week, TimePeriod}" href="#Base.floor-Union{Tuple{T}, Tuple{Union{Day, Week, TimePeriod}, T}} where T&lt;:Union{Day, Week, TimePeriod}"><code>Base.floor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">floor(x::Period, precision::T) where T &lt;: Union{TimePeriod, Week, Day} -&gt; T</code></pre><p>Round <code>x</code> down to the nearest multiple of <code>precision</code>. If <code>x</code> and <code>precision</code> are different subtypes of <code>Period</code>, the return value will have the same type as <code>precision</code>.</p><p>For convenience, <code>precision</code> may be a type instead of a value: <code>floor(x, Dates.Hour)</code> is a shortcut for <code>floor(x, Dates.Hour(1))</code>.</p><pre><code class="language-julia-repl">julia&gt; floor(Dates.Day(16), Dates.Week)
2 weeks

julia&gt; floor(Dates.Minute(44), Dates.Minute(15))
30 minutes

julia&gt; floor(Dates.Hour(36), Dates.Day)
1 day</code></pre><p>Rounding to a <code>precision</code> of <code>Month</code>s or <code>Year</code>s is not supported, as these <code>Period</code>s are of inconsistent length.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ceil-Tuple{Union{Day, Week, TimePeriod}, Union{Day, Week, TimePeriod}}" href="#Base.ceil-Tuple{Union{Day, Week, TimePeriod}, Union{Day, Week, TimePeriod}}"><code>Base.ceil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ceil(x::Period, precision::T) where T &lt;: Union{TimePeriod, Week, Day} -&gt; T</code></pre><p>Round <code>x</code> up to the nearest multiple of <code>precision</code>. If <code>x</code> and <code>precision</code> are different subtypes of <code>Period</code>, the return value will have the same type as <code>precision</code>.</p><p>For convenience, <code>precision</code> may be a type instead of a value: <code>ceil(x, Dates.Hour)</code> is a shortcut for <code>ceil(x, Dates.Hour(1))</code>.</p><pre><code class="language-julia-repl">julia&gt; ceil(Dates.Day(16), Dates.Week)
3 weeks

julia&gt; ceil(Dates.Minute(44), Dates.Minute(15))
45 minutes

julia&gt; ceil(Dates.Hour(36), Dates.Day)
2 days</code></pre><p>Rounding to a <code>precision</code> of <code>Month</code>s or <code>Year</code>s is not supported, as these <code>Period</code>s are of inconsistent length.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.round-Tuple{Union{Day, Week, TimePeriod}, Union{Day, Week, TimePeriod}, RoundingMode{:NearestTiesUp}}" href="#Base.round-Tuple{Union{Day, Week, TimePeriod}, Union{Day, Week, TimePeriod}, RoundingMode{:NearestTiesUp}}"><code>Base.round</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">round(x::Period, precision::T, [r::RoundingMode]) where T &lt;: Union{TimePeriod, Week, Day} -&gt; T</code></pre><p>Round <code>x</code> to the nearest multiple of <code>precision</code>. If <code>x</code> and <code>precision</code> are different subtypes of <code>Period</code>, the return value will have the same type as <code>precision</code>. By default (<code>RoundNearestTiesUp</code>), ties (e.g., rounding 90 minutes to the nearest hour) will be rounded up.</p><p>For convenience, <code>precision</code> may be a type instead of a value: <code>round(x, Dates.Hour)</code> is a shortcut for <code>round(x, Dates.Hour(1))</code>.</p><pre><code class="language-julia-repl">julia&gt; round(Dates.Day(16), Dates.Week)
2 weeks

julia&gt; round(Dates.Minute(44), Dates.Minute(15))
45 minutes

julia&gt; round(Dates.Hour(36), Dates.Day)
2 days</code></pre><p>Valid rounding modes for <code>round(::Period, ::T, ::RoundingMode)</code> are <code>RoundNearestTiesUp</code> (default), <code>RoundDown</code> (<code>floor</code>), and <code>RoundUp</code> (<code>ceil</code>).</p><p>Rounding to a <code>precision</code> of <code>Month</code>s or <code>Year</code>s is not supported, as these <code>Period</code>s are of inconsistent length.</p></div></section></article><p>The following functions are not exported:</p><article class="docstring"><header><a class="docstring-binding" id="Dates.floorceil" href="#Dates.floorceil"><code>Dates.floorceil</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">floorceil(dt::TimeType, p::Period) -&gt; (TimeType, TimeType)</code></pre><p>Simultaneously return the <code>floor</code> and <code>ceil</code> of a <code>Date</code> or <code>DateTime</code> at resolution <code>p</code>. More efficient than calling both <code>floor</code> and <code>ceil</code> individually.</p></div></section><section><div><pre><code class="language-none">floorceil(x::Period, precision::T) where T &lt;: Union{TimePeriod, Week, Day} -&gt; (T, T)</code></pre><p>Simultaneously return the <code>floor</code> and <code>ceil</code> of <code>Period</code> at resolution <code>p</code>.  More efficient than calling both <code>floor</code> and <code>ceil</code> individually.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.epochdays2date" href="#Dates.epochdays2date"><code>Dates.epochdays2date</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">epochdays2date(days) -&gt; Date</code></pre><p>Take the number of days since the rounding epoch (<code>0000-01-01T00:00:00</code>) and return the corresponding <code>Date</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.epochms2datetime" href="#Dates.epochms2datetime"><code>Dates.epochms2datetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">epochms2datetime(milliseconds) -&gt; DateTime</code></pre><p>Take the number of milliseconds since the rounding epoch (<code>0000-01-01T00:00:00</code>) and return the corresponding <code>DateTime</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.date2epochdays" href="#Dates.date2epochdays"><code>Dates.date2epochdays</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">date2epochdays(dt::Date) -&gt; Int64</code></pre><p>Take the given <code>Date</code> and return the number of days since the rounding epoch (<code>0000-01-01T00:00:00</code>) as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.datetime2epochms" href="#Dates.datetime2epochms"><code>Dates.datetime2epochms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">datetime2epochms(dt::DateTime) -&gt; Int64</code></pre><p>Take the given <code>DateTime</code> and return the number of milliseconds since the rounding epoch (<code>0000-01-01T00:00:00</code>) as an <a href="../../base/numbers/#Core.Int64"><code>Int64</code></a>.</p></div></section></article><h3 id="Conversion-Functions"><a class="docs-heading-anchor" href="#Conversion-Functions">Conversion Functions</a><a id="Conversion-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Dates.today" href="#Dates.today"><code>Dates.today</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">today() -&gt; Date</code></pre><p>Return the date portion of <code>now()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.unix2datetime" href="#Dates.unix2datetime"><code>Dates.unix2datetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unix2datetime(x) -&gt; DateTime</code></pre><p>Take the number of seconds since unix epoch <code>1970-01-01T00:00:00</code> and convert to the corresponding <code>DateTime</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.datetime2unix" href="#Dates.datetime2unix"><code>Dates.datetime2unix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">datetime2unix(dt::DateTime) -&gt; Float64</code></pre><p>Take the given <code>DateTime</code> and return the number of seconds since the unix epoch <code>1970-01-01T00:00:00</code> as a <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.julian2datetime" href="#Dates.julian2datetime"><code>Dates.julian2datetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">julian2datetime(julian_days) -&gt; DateTime</code></pre><p>Take the number of Julian calendar days since epoch <code>-4713-11-24T12:00:00</code> and return the corresponding <code>DateTime</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.datetime2julian" href="#Dates.datetime2julian"><code>Dates.datetime2julian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">datetime2julian(dt::DateTime) -&gt; Float64</code></pre><p>Take the given <code>DateTime</code> and return the number of Julian calendar days since the julian epoch <code>-4713-11-24T12:00:00</code> as a <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.rata2datetime" href="#Dates.rata2datetime"><code>Dates.rata2datetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rata2datetime(days) -&gt; DateTime</code></pre><p>Take the number of Rata Die days since epoch <code>0000-12-31T00:00:00</code> and return the corresponding <code>DateTime</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Dates.datetime2rata" href="#Dates.datetime2rata"><code>Dates.datetime2rata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">datetime2rata(dt::TimeType) -&gt; Int64</code></pre><p>Return the number of Rata Die days since epoch from the given <code>Date</code> or <code>DateTime</code>.</p></div></section></article><h3 id="Constants"><a class="docs-heading-anchor" href="#Constants">Constants</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></h3><p>Days of the Week:</p><table><tr><th style="text-align: left">Variable</th><th style="text-align: left">Abbr.</th><th style="text-align: left">Value (Int)</th></tr><tr><td style="text-align: left"><code>Monday</code></td><td style="text-align: left"><code>Mon</code></td><td style="text-align: left">1</td></tr><tr><td style="text-align: left"><code>Tuesday</code></td><td style="text-align: left"><code>Tue</code></td><td style="text-align: left">2</td></tr><tr><td style="text-align: left"><code>Wednesday</code></td><td style="text-align: left"><code>Wed</code></td><td style="text-align: left">3</td></tr><tr><td style="text-align: left"><code>Thursday</code></td><td style="text-align: left"><code>Thu</code></td><td style="text-align: left">4</td></tr><tr><td style="text-align: left"><code>Friday</code></td><td style="text-align: left"><code>Fri</code></td><td style="text-align: left">5</td></tr><tr><td style="text-align: left"><code>Saturday</code></td><td style="text-align: left"><code>Sat</code></td><td style="text-align: left">6</td></tr><tr><td style="text-align: left"><code>Sunday</code></td><td style="text-align: left"><code>Sun</code></td><td style="text-align: left">7</td></tr></table><p>Months of the Year:</p><table><tr><th style="text-align: left">Variable</th><th style="text-align: left">Abbr.</th><th style="text-align: left">Value (Int)</th></tr><tr><td style="text-align: left"><code>January</code></td><td style="text-align: left"><code>Jan</code></td><td style="text-align: left">1</td></tr><tr><td style="text-align: left"><code>February</code></td><td style="text-align: left"><code>Feb</code></td><td style="text-align: left">2</td></tr><tr><td style="text-align: left"><code>March</code></td><td style="text-align: left"><code>Mar</code></td><td style="text-align: left">3</td></tr><tr><td style="text-align: left"><code>April</code></td><td style="text-align: left"><code>Apr</code></td><td style="text-align: left">4</td></tr><tr><td style="text-align: left"><code>May</code></td><td style="text-align: left"><code>May</code></td><td style="text-align: left">5</td></tr><tr><td style="text-align: left"><code>June</code></td><td style="text-align: left"><code>Jun</code></td><td style="text-align: left">6</td></tr><tr><td style="text-align: left"><code>July</code></td><td style="text-align: left"><code>Jul</code></td><td style="text-align: left">7</td></tr><tr><td style="text-align: left"><code>August</code></td><td style="text-align: left"><code>Aug</code></td><td style="text-align: left">8</td></tr><tr><td style="text-align: left"><code>September</code></td><td style="text-align: left"><code>Sep</code></td><td style="text-align: left">9</td></tr><tr><td style="text-align: left"><code>October</code></td><td style="text-align: left"><code>Oct</code></td><td style="text-align: left">10</td></tr><tr><td style="text-align: left"><code>November</code></td><td style="text-align: left"><code>Nov</code></td><td style="text-align: left">11</td></tr><tr><td style="text-align: left"><code>December</code></td><td style="text-align: left"><code>Dec</code></td><td style="text-align: left">12</td></tr></table><h4 id="Common-Date-Formatters"><a class="docs-heading-anchor" href="#Common-Date-Formatters">Common Date Formatters</a><a id="Common-Date-Formatters-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Date-Formatters" title="Permalink"></a></h4><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ISODateTimeFormat</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ISODateFormat</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ISOTimeFormat</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>RFC1123Format</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a &quot;UT second&quot;, as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that <a href="#Dates.Date"><code>Date</code></a> and <a href="#Dates.DateTime"><code>DateTime</code></a> are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called <a href="https://en.wikipedia.org/wiki/Universal_Time">UT</a> or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../CRC32c/">« CRC32c</a><a class="docs-footer-nextpage" href="../DelimitedFiles/">分隔符文件 »</a><div class="flexbox-break"></div><p class="footer-message">📢📢📢Julia中文社区现已加入“开源软件供应链点亮计划”，如果你想改善Julia中文文档的翻译，那就赶快来 <a href="https://summer.iscas.ac.cn/#/org/prodetail/210370191">报名</a> 吧！</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2021 八月 13 周五 15:24">2021 八月 13 周五</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.6.2版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
