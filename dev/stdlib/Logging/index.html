<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>日志记录 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/stdlib/Logging/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-options/">命令行选项</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../Base64/">Base64</a></li><li><a class="tocitem" href="../CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../Dates/">日期</a></li><li><a class="tocitem" href="../DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../Future/">Future</a></li><li><a class="tocitem" href="../InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../Libdl/">动态链接器</a></li><li><a class="tocitem" href="../LinearAlgebra/">Linear Algebra</a></li><li class="is-active"><a class="tocitem" href>日志记录</a><ul class="internal"><li><a class="tocitem" href="#日志事件结构"><span>日志事件结构</span></a></li><li><a class="tocitem" href="#Processing-log-events"><span>Processing log events</span></a></li><li><a class="tocitem" href="#Testing-log-events"><span>Testing log events</span></a></li><li><a class="tocitem" href="#Environment-variables"><span>Environment variables</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../Markdown/">Markdown</a></li><li><a class="tocitem" href="../Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../Printf/">Printf</a></li><li><a class="tocitem" href="../Profile/">性能分析</a></li><li><a class="tocitem" href="../REPL/">Julia REPL</a></li><li><a class="tocitem" href="../Random/">随机数</a></li><li><a class="tocitem" href="../SHA/">SHA</a></li><li><a class="tocitem" href="../Serialization/">序列化</a></li><li><a class="tocitem" href="../SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../Sockets/">套接字</a></li><li><a class="tocitem" href="../SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../Statistics/">统计</a></li><li><a class="tocitem" href="../TOML/">TOML</a></li><li><a class="tocitem" href="../Test/">单元测试</a></li><li><a class="tocitem" href="../UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Standard Library</a></li><li class="is-active"><a href>日志记录</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>日志记录</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/stdlib-zh_cn/translate/#zh_CN/Loggingmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="日志记录"><a class="docs-heading-anchor" href="#日志记录">日志记录</a><a id="日志记录-1"></a><a class="docs-heading-anchor-permalink" href="#日志记录" title="Permalink"></a></h1><p><a href="#Logging.Logging"><code>Logging</code></a> 模块提供了一个将历史和计算进度记录为事件的日志。事件通过在源代码里插入日志语句产生，例如：</p><pre><code class="language-julia">@warn &quot;Abandon printf debugging, all ye who enter here!&quot;
┌ Warning: Abandon printf debugging, all ye who enter here!
└ @ Main REPL[1]:1</code></pre><p>The system provides several advantages over peppering your source code with calls to <code>println()</code>.  First, it allows you to control the visibility and presentation of messages without editing the source code.  For example, in contrast to the <code>@warn</code> above</p><pre><code class="language-julia">@debug &quot;The sum of some values $(sum(rand(100)))&quot;</code></pre><p>will produce no output by default.  Furthermore, it&#39;s very cheap to leave debug statements like this in the source code because the system avoids evaluating the message if it would later be ignored.  In this case <code>sum(rand(100))</code> and the associated string processing will never be executed unless debug logging is enabled.</p><p>Second, the logging tools allow you to attach arbitrary data to each event as a set of key–value pairs. This allows you to capture local variables and other program state for later analysis. For example, to attach the local array variable <code>A</code> and the sum of a vector <code>v</code> as the key <code>s</code> you can use</p><pre><code class="language-julia">A = ones(Int, 4, 4)
v = ones(100)
@info &quot;Some variables&quot;  A  s=sum(v)

# output
┌ Info: Some variables
│   A =
│    4×4 Matrix{Int64}:
│     1  1  1  1
│     1  1  1  1
│     1  1  1  1
│     1  1  1  1
└   s = 100.0</code></pre><p>所有的日志宏如 <code>@debug</code>, <code>@info</code>, <code>@warn</code> 和 <code>@error</code> 有着共同的特征， 这些共同特征在更通用的宏 <a href="#Logging.@logmsg"><code>@logmsg</code></a> 的文档里有细致说明。</p><h2 id="日志事件结构"><a class="docs-heading-anchor" href="#日志事件结构">日志事件结构</a><a id="日志事件结构-1"></a><a class="docs-heading-anchor-permalink" href="#日志事件结构" title="Permalink"></a></h2><p>Each event generates several pieces of data, some provided by the user and some automatically extracted. Let&#39;s examine the user-defined data first:</p><ul><li><p>The <em>log level</em> is a broad category for the message that is used for early filtering. There are several standard levels of type <a href="#Logging.LogLevel"><code>LogLevel</code></a>; user-defined levels are also possible. Each is distinct in purpose:</p><ul><li><a href="#Logging.Debug"><code>Logging.Debug</code></a> (log level -1000) is information intended for the developer of the program. These events are disabled by default.</li><li><a href="#Logging.Info"><code>Logging.Info</code></a> (log level 0) is for general information to the user. Think of it as an alternative to using <code>println</code> directly.</li><li><a href="#Logging.Warn"><code>Logging.Warn</code></a> (log level 1000) means something is wrong and action is likely required but that for now the program is still working.</li><li><a href="#Logging.Error"><code>Logging.Error</code></a> (log level 2000) means something is wrong and it is unlikely to be recovered, at least by this part of the code. Often this log-level is unneeded as throwing an exception can convey all the required information.</li></ul></li><li><p>The <em>message</em>  is an object describing the event. By convention <code>AbstractString</code>s passed as messages are assumed to be in markdown format. Other types will be displayed using <code>print(io, obj)</code> or <code>string(obj)</code> for text-based output and possibly <code>show(io,mime,obj)</code> for other multimedia displays used in the installed logger.</p></li><li><p>Optional <em>key–value pairs</em> allow arbitrary data to be attached to each event. Some keys have conventional meaning that can affect the way an event is interpreted (see <a href="#Logging.@logmsg"><code>@logmsg</code></a>).</p></li></ul><p>The system also generates some standard information for each event:</p><ul><li>The <code>module</code> in which the logging macro was expanded.</li><li>The <code>file</code> and <code>line</code> where the logging macro occurs in the source code.</li><li>A message <code>id</code> that is a unique, fixed identifier for the <em>source code statement</em> where the logging macro appears. This identifier is designed to be fairly stable even if the source code of the file changes, as long as the logging statement itself remains the same.</li><li>A <code>group</code> for the event, which is set to the base name of the file by default, without extension.  This can be used to group messages into categories more finely than the log level (for example, all deprecation warnings have group <code>:depwarn</code>), or into logical groupings across or within modules.</li></ul><p>Notice that some useful information such as the event time is not included by default. This is because such information can be expensive to extract and is also <em>dynamically</em> available to the current logger. It&#39;s simple to define a <a href="#AbstractLogger-interface">custom logger</a> to augment event data with the time, backtrace, values of global variables and other useful information as required.</p><h2 id="Processing-log-events"><a class="docs-heading-anchor" href="#Processing-log-events">Processing log events</a><a id="Processing-log-events-1"></a><a class="docs-heading-anchor-permalink" href="#Processing-log-events" title="Permalink"></a></h2><p>As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:</p><ul><li><em>Creating</em> log events is the concern of the module author who needs to decide where events are triggered and which information to include.</li><li><em>Processing</em> of log events — that is, display, filtering, aggregation and recording — is the concern of the application author who needs to bring multiple modules together into a cooperating application.</li></ul><h3 id="Loggers"><a class="docs-heading-anchor" href="#Loggers">Loggers</a><a id="Loggers-1"></a><a class="docs-heading-anchor-permalink" href="#Loggers" title="Permalink"></a></h3><p>Processing of events is performed by a <em>logger</em>, which is the first piece of user configurable code to see the event. All loggers must be subtypes of <a href="#Logging.AbstractLogger"><code>AbstractLogger</code></a>.</p><p>When an event is triggered, the appropriate logger is found by looking for a task-local logger with the global logger as fallback.  The idea here is that the application code knows how log events should be processed and exists somewhere at the top of the call stack. So we should look up through the call stack to discover the logger — that is, the logger should be <em>dynamically scoped</em>. (This is a point of contrast with logging frameworks where the logger is <em>lexically scoped</em>; provided explicitly by the module author or as a simple global variable. In such a system it&#39;s awkward to control logging while composing functionality from multiple modules.)</p><p>The global logger may be set with <a href="#Logging.global_logger"><code>global_logger</code></a>, and task-local loggers controlled using <a href="#Logging.with_logger"><code>with_logger</code></a>.  Newly spawned tasks inherit the logger of the parent task.</p><p>There are three logger types provided by the library.  <a href="#Logging.ConsoleLogger"><code>ConsoleLogger</code></a> is the default logger you see when starting the REPL.  It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering.  <a href="#Logging.NullLogger"><code>NullLogger</code></a> is a convenient way to drop all messages where necessary; it is the logging equivalent of the <a href="../../base/base/#Base.devnull"><code>devnull</code></a> stream.  <a href="#Logging.SimpleLogger"><code>SimpleLogger</code></a> is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.</p><p>Custom loggers should come with overloads for the functions described in the <a href="#AbstractLogger-interface">reference section</a>.</p><h3 id="Early-filtering-and-message-handling"><a class="docs-heading-anchor" href="#Early-filtering-and-message-handling">Early filtering and message handling</a><a id="Early-filtering-and-message-handling-1"></a><a class="docs-heading-anchor-permalink" href="#Early-filtering-and-message-handling" title="Permalink"></a></h3><p>When an event occurs, a few steps of early filtering occur to avoid generating messages that will be discarded:</p><ol><li>The message log level is checked against a global minimum level (set via <a href="#Logging.disable_logging"><code>disable_logging</code></a>).  This is a crude but extremely cheap global setting.</li><li>The current logger state is looked up and the message level checked against the logger&#39;s cached minimum level, as found by calling <a href="#Logging.min_enabled_level"><code>Logging.min_enabled_level</code></a>. This behavior can be overridden via environment variables (more on this later).</li><li>The <a href="#Logging.shouldlog"><code>Logging.shouldlog</code></a> function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically.  Most usefully, <code>shouldlog</code> is passed an event <code>id</code> which can be used to discard events early based on a cached predicate.</li></ol><p>If all these checks pass, the message and key–value pairs are evaluated in full and passed to the current logger via the <a href="#Logging.handle_message"><code>Logging.handle_message</code></a> function. <code>handle_message()</code> may perform additional filtering as required and display the event to the screen, save it to a file, etc.</p><p>Exceptions that occur while generating the log event are captured and logged by default.  This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system.  This behavior can be customized per logger type by extending <a href="#Logging.catch_exceptions"><code>Logging.catch_exceptions</code></a>.</p><h2 id="Testing-log-events"><a class="docs-heading-anchor" href="#Testing-log-events">Testing log events</a><a id="Testing-log-events-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-log-events" title="Permalink"></a></h2><p>Log events are a side effect of running normal code, but you might find yourself wanting to test particular informational messages and warnings. The <code>Test</code> module provides a <a href="../Test/#Test.@test_logs"><code>@test_logs</code></a> macro that can be used to pattern match against the log event stream.</p><h2 id="Environment-variables"><a class="docs-heading-anchor" href="#Environment-variables">Environment variables</a><a id="Environment-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Environment-variables" title="Permalink"></a></h2><p>Message filtering can be influenced through the <code>JULIA_DEBUG</code> environment variable, and serves as an easy way to enable debug logging for a file or module. For example, loading julia with <code>JULIA_DEBUG=loading</code> will activate <code>@debug</code> log messages in <code>loading.jl</code>:</p><pre><code class="language-none">$ JULIA_DEBUG=loading julia -e &#39;using OhMyREPL&#39;
┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji due to it containing an invalid cache header
└ @ Base loading.jl:1328
[ Info: Recompiling stale cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji for module OhMyREPL
┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/Tokenize.ji due to it containing an invalid cache header
└ @ Base loading.jl:1328
...</code></pre><p>Similarly, the environment variable can be used to enable debug logging of modules, such as <code>Pkg</code>, or module roots (see <a href="../../base/base/#Base.moduleroot"><code>Base.moduleroot</code></a>). To enable all debug logging, use the special value <code>all</code>.</p><p>To turn debug logging on from the REPL, set <code>ENV[&quot;JULIA_DEBUG&quot;]</code> to the name of the module of interest. Functions defined in the REPL belong to module <code>Main</code>; logging for them can be enabled like this:</p><pre><code class="language-julia-repl">julia&gt; foo() = @debug &quot;foo&quot;
foo (generic function with 1 method)

julia&gt; foo()

julia&gt; ENV[&quot;JULIA_DEBUG&quot;] = Main
Main

julia&gt; foo()
┌ Debug: foo
└ @ Main REPL[1]:1
</code></pre><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Example:-Writing-log-events-to-a-file"><a class="docs-heading-anchor" href="#Example:-Writing-log-events-to-a-file">Example: Writing log events to a file</a><a id="Example:-Writing-log-events-to-a-file-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Writing-log-events-to-a-file" title="Permalink"></a></h3><p>Sometimes it can be useful to write log events to a file. Here is an example of how to use a task-local and global logger to write information to a text file:</p><pre><code class="language-julia-repl"># Load the logging module
julia&gt; using Logging

# Open a textfile for writing
julia&gt; io = open(&quot;log.txt&quot;, &quot;w+&quot;)
IOStream(&lt;file log.txt&gt;)

# Create a simple logger
julia&gt; logger = SimpleLogger(io)
SimpleLogger(IOStream(&lt;file log.txt&gt;), Info, Dict{Any,Int64}())

# Log a task-specific message
julia&gt; with_logger(logger) do
           @info(&quot;a context specific log message&quot;)
       end

# Write all buffered messages to the file
julia&gt; flush(io)

# Set the global logger to logger
julia&gt; global_logger(logger)
SimpleLogger(IOStream(&lt;file log.txt&gt;), Info, Dict{Any,Int64}())

# This message will now also be written to the file
julia&gt; @info(&quot;a global log message&quot;)

# Close the file
julia&gt; close(io)</code></pre><h3 id="Example:-Enable-debug-level-messages"><a class="docs-heading-anchor" href="#Example:-Enable-debug-level-messages">Example: Enable debug-level messages</a><a id="Example:-Enable-debug-level-messages-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Enable-debug-level-messages" title="Permalink"></a></h3><p>Here is an example of creating a <a href="#Logging.ConsoleLogger"><code>ConsoleLogger</code></a> that lets through any messages with log level higher than, or equal, to <a href="#Logging.Debug"><code>Logging.Debug</code></a>.</p><pre><code class="language-julia-repl">julia&gt; using Logging

# Create a ConsoleLogger that prints any log messages with level &gt;= Debug to stderr
julia&gt; debuglogger = ConsoleLogger(stderr, Logging.Debug)

# Enable debuglogger for a task
julia&gt; with_logger(debuglogger) do
           @debug &quot;a context specific log message&quot;
       end

# Set the global logger
julia&gt; global_logger(debuglogger)</code></pre><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><h3 id="Logging-module"><a class="docs-heading-anchor" href="#Logging-module">Logging module</a><a id="Logging-module-1"></a><a class="docs-heading-anchor-permalink" href="#Logging-module" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Logging.Logging" href="#Logging.Logging"><code>Logging.Logging</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Utilities for capturing, filtering and presenting streams of log events. Normally you don&#39;t need to import <code>Logging</code> to create log events; for this the standard logging macros such as <code>@info</code> are already exported by <code>Base</code> and available by default.</p></div></section></article><h3 id="Creating-events"><a class="docs-heading-anchor" href="#Creating-events">Creating events</a><a id="Creating-events-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-events" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Logging.@logmsg" href="#Logging.@logmsg"><code>Logging.@logmsg</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@debug message  [key=value | value ...]
@info  message  [key=value | value ...]
@warn  message  [key=value | value ...]
@error message  [key=value | value ...]

@logmsg level message [key=value | value ...]</code></pre><p>Create a log record with an informational <code>message</code>.  For convenience, four logging macros <code>@debug</code>, <code>@info</code>, <code>@warn</code> and <code>@error</code> are defined which log at the standard severity levels <code>Debug</code>, <code>Info</code>, <code>Warn</code> and <code>Error</code>.  <code>@logmsg</code> allows <code>level</code> to be set programmatically to any <code>LogLevel</code> or custom log level types.</p><p><code>message</code> should be an expression which evaluates to a string which is a human readable description of the log event.  By convention, this string will be formatted as markdown when presented.</p><p>The optional list of <code>key=value</code> pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record.  If only a <code>value</code> expression is supplied, a key representing the expression will be generated using <a href="../../base/base/#Core.Symbol"><code>Symbol</code></a>. For example, <code>x</code> becomes <code>x=x</code>, and <code>foo(10)</code> becomes <code>Symbol(&quot;foo(10)&quot;)=foo(10)</code>.  For splatting a list of key value pairs, use the normal splatting syntax, <code>@info &quot;blah&quot; kws...</code>.</p><p>There are some keys which allow automatically generated log data to be overridden:</p><ul><li><code>_module=mod</code> can be used to specify a different originating module from the source location of the message.</li><li><code>_group=symbol</code> can be used to override the message group (this is normally derived from the base name of the source file).</li><li><code>_id=symbol</code> can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.</li><li><code>_file=string</code> and <code>_line=integer</code> can be used to override the apparent source location of a log message.</li></ul><p>There&#39;s also some key value pairs which have conventional meaning:</p><ul><li><code>maxlog=integer</code> should be used as a hint to the backend that the message should be displayed no more than <code>maxlog</code> times.</li><li><code>exception=ex</code> should be used to transport an exception with a log message, often used with <code>@error</code>. An associated backtrace <code>bt</code> may be attached using the tuple <code>exception=(ex,bt)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">@debug &quot;Verbose debugging information.  Invisible by default&quot;
@info  &quot;An informational message&quot;
@warn  &quot;Something was odd.  You should pay attention&quot;
@error &quot;A non fatal error occurred&quot;

x = 10
@info &quot;Some variables attached to the message&quot; x a=42.0

@debug begin
    sA = sum(A)
    &quot;sum(A) = $sA is an expensive operation, evaluated only when `shouldlog` returns true&quot;
end

for i=1:10000
    @info &quot;With the default backend, you will only see (i = $i) ten times&quot;  maxlog=10
    @debug &quot;Algorithm1&quot; i progress=i/10000
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L263-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.LogLevel" href="#Logging.LogLevel"><code>Logging.LogLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogLevel(level)</code></pre><p>Severity/verbosity of a log record.</p><p>The log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Logging.LogLevel(0) == Logging.Info
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L109-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.Debug" href="#Logging.Debug"><code>Logging.Debug</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Debug</code></pre><p>Alias for <a href="#Logging.LogLevel"><code>LogLevel(-1000)</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.Info" href="#Logging.Info"><code>Logging.Info</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Info</code></pre><p>Alias for <a href="#Logging.LogLevel"><code>LogLevel(0)</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.Warn" href="#Logging.Warn"><code>Logging.Warn</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Warn</code></pre><p>Alias for <a href="#Logging.LogLevel"><code>LogLevel(1000)</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.Error" href="#Logging.Error"><code>Logging.Error</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Error</code></pre><p>Alias for <a href="#Logging.LogLevel"><code>LogLevel(2000)</code></a>.</p></div></section></article><h3 id="AbstractLogger-interface"><a class="docs-heading-anchor" href="#AbstractLogger-interface">Processing events with AbstractLogger</a><a id="AbstractLogger-interface-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractLogger-interface" title="Permalink"></a></h3><p>Event processing is controlled by overriding functions associated with <code>AbstractLogger</code>:</p><table><tr><th style="text-align: left">Methods to implement</th><th style="text-align: left"></th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><a href="#Logging.handle_message"><code>Logging.handle_message</code></a></td><td style="text-align: left"></td><td style="text-align: left">Handle a log event</td></tr><tr><td style="text-align: left"><a href="#Logging.shouldlog"><code>Logging.shouldlog</code></a></td><td style="text-align: left"></td><td style="text-align: left">Early filtering of events</td></tr><tr><td style="text-align: left"><a href="#Logging.min_enabled_level"><code>Logging.min_enabled_level</code></a></td><td style="text-align: left"></td><td style="text-align: left">Lower bound for log level of accepted events</td></tr><tr><td style="text-align: left"><strong>Optional methods</strong></td><td style="text-align: left"><strong>Default definition</strong></td><td style="text-align: left"><strong>Brief description</strong></td></tr><tr><td style="text-align: left"><a href="#Logging.catch_exceptions"><code>Logging.catch_exceptions</code></a></td><td style="text-align: left"><code>true</code></td><td style="text-align: left">Catch exceptions during event evaluation</td></tr></table><article class="docstring"><header><a class="docstring-binding" id="Logging.AbstractLogger" href="#Logging.AbstractLogger"><code>Logging.AbstractLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A logger controls how log records are filtered and dispatched.  When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.handle_message" href="#Logging.handle_message"><code>Logging.handle_message</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">handle_message(logger, level, message, _module, group, id, file, line; key1=val1, ...)</code></pre><p>Log a message to <code>logger</code> at <code>level</code>.  The logical location at which the message was generated is given by module <code>_module</code> and <code>group</code>; the source location by <code>file</code> and <code>line</code>. <code>id</code> is an arbitrary unique value (typically a <a href="../../base/base/#Core.Symbol"><code>Symbol</code></a>) to be used as a key to identify the log statement when filtering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L31-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.shouldlog" href="#Logging.shouldlog"><code>Logging.shouldlog</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shouldlog(logger, level, _module, group, id)</code></pre><p>Return true when <code>logger</code> accepts a message at <code>level</code>, generated for <code>_module</code>, <code>group</code> and with unique log identifier <code>id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.min_enabled_level" href="#Logging.min_enabled_level"><code>Logging.min_enabled_level</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">min_enabled_level(logger)</code></pre><p>Return the minimum enabled level for <code>logger</code> for early filtering.  That is, the log level below or equal to which all messages are filtered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.catch_exceptions" href="#Logging.catch_exceptions"><code>Logging.catch_exceptions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">catch_exceptions(logger)</code></pre><p>Return true if the logger should catch exceptions which happen during log record construction.  By default, messages are caught</p><p>By default all exceptions are caught to prevent log message generation from crashing the program.  This lets users confidently toggle little-used functionality - such as debug logging - in a production system.</p><p>If you want to use logging as an audit trail you should disable this for your logger type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L58-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.disable_logging" href="#Logging.disable_logging"><code>Logging.disable_logging</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">disable_logging(level)</code></pre><p>Disable all log messages at log levels equal to or less than <code>level</code>.  This is a <em>global</em> setting, intended to make debug logging extremely cheap when disabled.</p><p><strong>Examples</strong></p><pre><code class="language-julia">Logging.disable_logging(Logging.Info) # Disable debug and info</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L520-L531">source</a></section></article><h3 id="Using-Loggers"><a class="docs-heading-anchor" href="#Using-Loggers">Using Loggers</a><a id="Using-Loggers-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Loggers" title="Permalink"></a></h3><p>Logger installation and inspection:</p><article class="docstring"><header><a class="docstring-binding" id="Logging.global_logger" href="#Logging.global_logger"><code>Logging.global_logger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">global_logger()</code></pre><p>Return the global logger, used to receive messages when no specific logger exists for the current task.</p><pre><code class="language-none">global_logger(logger)</code></pre><p>Set the global logger to <code>logger</code>, and return the previous global logger.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L586-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.with_logger" href="#Logging.with_logger"><code>Logging.with_logger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">with_logger(function, logger)</code></pre><p>Execute <code>function</code>, directing all log messages to <code>logger</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">function test(x)
    @info &quot;x = $x&quot;
end

with_logger(logger) do
    test(1)
    test([1,2])
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L604-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.current_logger" href="#Logging.current_logger"><code>Logging.current_logger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">current_logger()</code></pre><p>Return the logger for the current task, or the global logger if none is attached to the task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L626-L631">source</a></section></article><p>Loggers that are supplied with the system:</p><article class="docstring"><header><a class="docstring-binding" id="Logging.NullLogger" href="#Logging.NullLogger"><code>Logging.NullLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NullLogger()</code></pre><p>Logger which disables all messages and produces no output - the logger equivalent of /dev/null.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.ConsoleLogger" href="#Logging.ConsoleLogger"><code>Logging.ConsoleLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConsoleLogger([stream,] min_level=Info; meta_formatter=default_metafmt,
              show_limited=true, right_justify=0)</code></pre><p>Logger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.</p><p>Log levels less than <code>min_level</code> are filtered out.</p><p>Message formatting can be controlled by setting keyword arguments:</p><ul><li><code>meta_formatter</code> is a function which takes the log event metadata <code>(level, _module, group, id, file, line)</code> and returns a color (as would be passed to printstyled), prefix and suffix for the log message.  The default is to prefix with the log level and a suffix containing the module, file and line location.</li><li><code>show_limited</code> limits the printing of large data structures to something which can fit on the screen by setting the <code>:limit</code> <code>IOContext</code> key during formatting.</li><li><code>right_justify</code> is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Logging.SimpleLogger" href="#Logging.SimpleLogger"><code>Logging.SimpleLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleLogger([stream,] min_level=Info)</code></pre><p>Simplistic logger for logging all messages with level greater than or equal to <code>min_level</code> to <code>stream</code>. If stream is closed then messages with log level greater or equal to <code>Warn</code> will be logged to <code>stderr</code> and below to <code>stdout</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/logging.jl#L639-L645">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../LinearAlgebra/">« Linear Algebra</a><a class="docs-footer-nextpage" href="../Markdown/">Markdown »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2024 十月 24 周四 14:44">2024 十月 24 周四</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.8.5版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
