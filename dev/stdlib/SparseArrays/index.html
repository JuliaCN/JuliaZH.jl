<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>稀疏数组 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/stdlib/SparseArrays/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-options/">命令行选项</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../Base64/">Base64</a></li><li><a class="tocitem" href="../CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../Dates/">日期</a></li><li><a class="tocitem" href="../DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../Future/">Future</a></li><li><a class="tocitem" href="../InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../Libdl/">动态链接器</a></li><li><a class="tocitem" href="../LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../Logging/">日志记录</a></li><li><a class="tocitem" href="../Markdown/">Markdown</a></li><li><a class="tocitem" href="../Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../Printf/">Printf</a></li><li><a class="tocitem" href="../Profile/">性能分析</a></li><li><a class="tocitem" href="../REPL/">Julia REPL</a></li><li><a class="tocitem" href="../Random/">随机数</a></li><li><a class="tocitem" href="../SHA/">SHA</a></li><li><a class="tocitem" href="../Serialization/">序列化</a></li><li><a class="tocitem" href="../SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../Sockets/">套接字</a></li><li class="is-active"><a class="tocitem" href>稀疏数组</a><ul class="internal"><li><a class="tocitem" href="#man-csc"><span>压缩稀疏列（CSC）稀疏矩阵存储</span></a></li><li><a class="tocitem" href="#稀疏向量储存"><span>稀疏向量储存</span></a></li><li><a class="tocitem" href="#稀疏向量与矩阵构造函数"><span>稀疏向量与矩阵构造函数</span></a></li><li><a class="tocitem" href="#稀疏矩阵的操作"><span>稀疏矩阵的操作</span></a></li><li><a class="tocitem" href="#Correspondence-of-dense-and-sparse-methods"><span>Correspondence of dense and sparse methods</span></a></li><li class="toplevel"><a class="tocitem" href="#stdlib-sparse-arrays"><span>Sparse Arrays</span></a></li></ul></li><li><a class="tocitem" href="../Statistics/">统计</a></li><li><a class="tocitem" href="../TOML/">TOML</a></li><li><a class="tocitem" href="../Test/">单元测试</a></li><li><a class="tocitem" href="../UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Standard Library</a></li><li class="is-active"><a href>稀疏数组</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>稀疏数组</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/stdlib-zh_cn/translate/#zh_CN/SparseArraysmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="稀疏数组"><a class="docs-heading-anchor" href="#稀疏数组">稀疏数组</a><a id="稀疏数组-1"></a><a class="docs-heading-anchor-permalink" href="#稀疏数组" title="Permalink"></a></h1><p>Julia 在 <code>SparseArrays</code> 标准库模块中提供了对稀疏向量和<a href="https://en.wikipedia.org/wiki/Sparse_matrix">稀疏矩阵</a>的支持。与稠密数组相比，包含足够多零值的稀疏数组在以特殊的数据结构存储时可以节省大量的空间和运算时间。</p><h2 id="man-csc"><a class="docs-heading-anchor" href="#man-csc">压缩稀疏列（CSC）稀疏矩阵存储</a><a id="man-csc-1"></a><a class="docs-heading-anchor-permalink" href="#man-csc" title="Permalink"></a></h2><p>在 Julia 中，稀疏矩阵是按照<a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29">压缩稀疏列（CSC）格式</a>存储的。Julia 稀疏矩阵具有 <a href="#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC{Tv,Ti}</code></a> 类型，其中 <code>Tv</code> 是存储值的类型，<code>Ti</code> 是存储列指针和行索引的整型类型。<code>SparseMatrixCSC</code> 的内部表示如下所示：</p><pre><code class="language-julia">struct SparseMatrixCSC{Tv,Ti&lt;:Integer} &lt;: AbstractSparseMatrixCSC{Tv,Ti}
    m::Int                  # Number of rows
    n::Int                  # Number of columns
    colptr::Vector{Ti}      # Column j is in colptr[j]:(colptr[j+1]-1)
    rowval::Vector{Ti}      # Row indices of stored values
    nzval::Vector{Tv}       # Stored values, typically nonzeros
end</code></pre><p>压缩稀疏列存储格式使得访问稀疏矩阵的列元素非常简单快速，而访问稀疏矩阵的行会非常缓慢。在 CSC 稀疏矩阵中执行类似插入新元素的操作也会非常慢。这是由于在稀疏矩阵中插入新元素时，在插入点之后的所有元素都要向后移动一位。</p><p>All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.</p><p>如果你有来自不同应用或库的 CSC 格式数据，并且想要将它导入 Julia，确保使用基于 1 的索引。每个列中的行索引都要是有序的。如果你的 <code>SparseMatrixCSC</code> 对象包含无序的行索引，一个快速将它们排序的方法是做一次二重转置。</p><p>In some applications, it is convenient to store explicit zero values in a <code>SparseMatrixCSC</code>. These <em>are</em> accepted by functions in <code>Base</code> (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The <a href="#SparseArrays.nnz"><code>nnz</code></a> function returns the number of elements explicitly stored in the sparse data structure, including non-structural zeros. In order to count the exact number of numerical nonzeros, use <a href="../../base/collections/#Base.count"><code>count(!iszero, x)</code></a>, which inspects every stored element of a sparse matrix. <a href="#SparseArrays.dropzeros"><code>dropzeros</code></a>, and the in-place <a href="#SparseArrays.dropzeros!"><code>dropzeros!</code></a>, can be used to remove stored zeros from the sparse matrix.</p><pre><code class="language-julia-repl">julia&gt; A = sparse([1, 1, 2, 3], [1, 3, 2, 3], [0, 1, 2, 0])
3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:
 0  ⋅  1
 ⋅  2  ⋅
 ⋅  ⋅  0

julia&gt; dropzeros(A)
3×3 SparseMatrixCSC{Int64, Int64} with 2 stored entries:
 ⋅  ⋅  1
 ⋅  2  ⋅
 ⋅  ⋅  ⋅</code></pre><h2 id="稀疏向量储存"><a class="docs-heading-anchor" href="#稀疏向量储存">稀疏向量储存</a><a id="稀疏向量储存-1"></a><a class="docs-heading-anchor-permalink" href="#稀疏向量储存" title="Permalink"></a></h2><p>Sparse vectors are stored in a close analog to compressed sparse column format for sparse matrices. In Julia, sparse vectors have the type <a href="#SparseArrays.SparseVector"><code>SparseVector{Tv,Ti}</code></a> where <code>Tv</code> is the type of the stored values and <code>Ti</code> the integer type for the indices. The internal representation is as follows:</p><pre><code class="language-julia">struct SparseVector{Tv,Ti&lt;:Integer} &lt;: AbstractSparseVector{Tv,Ti}
    n::Int              # Length of the sparse vector
    nzind::Vector{Ti}   # Indices of stored values
    nzval::Vector{Tv}   # Stored values, typically nonzeros
end</code></pre><p>对于 <a href="#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>， <code>SparseVector</code> 类型也能包含显示存储的，零值。（见 <a href="#man-csc">稀疏矩阵存储</a>。）</p><h2 id="稀疏向量与矩阵构造函数"><a class="docs-heading-anchor" href="#稀疏向量与矩阵构造函数">稀疏向量与矩阵构造函数</a><a id="稀疏向量与矩阵构造函数-1"></a><a class="docs-heading-anchor-permalink" href="#稀疏向量与矩阵构造函数" title="Permalink"></a></h2><p>创建一个稀疏矩阵的最简单的方法是使用一个与 Julia 提供的用来处理稠密矩阵的<a href="../../base/arrays/#Base.zeros"><code>zeros</code></a> 等价的函数。要产生一个稀疏矩阵，你可以用同样的名字加上 <code>sp</code> 前缀：</p><pre><code class="language-julia-repl">julia&gt; spzeros(3)
3-element SparseVector{Float64, Int64} with 0 stored entries</code></pre><p><a href="#SparseArrays.sparse"><code>sparse</code></a> 函数通常是一个构建稀疏矩阵的便捷方法。例如，要构建一个稀疏矩阵，我们可以输入一个列索引向量 <code>I</code>，一个行索引向量 <code>J</code>，一个储存值的向量 <code>V</code>（这也叫作 <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">COO（坐标） 格式</a>）。 然后 <code>sparse(I,J,V)</code> 创建一个满足 <code>S[I[k], J[k]] = V[k]</code> 的稀疏矩阵。等价的稀疏向量构建函数是 <a href="#SparseArrays.sparsevec"><code>sparsevec</code></a>，它接受（行）索引向量 <code>I</code> 和储存值的向量 <code>V</code> 并创建一个满足 <code>R[I[k]] = V[k]</code> 的向量 <code>R</code>。</p><pre><code class="language-julia-repl">julia&gt; I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];

julia&gt; S = sparse(I,J,V)
5×18 SparseMatrixCSC{Int64, Int64} with 4 stored entries:
⠀⠈⠀⡀⠀⠀⠀⠀⠠
⠀⠀⠀⠀⠁⠀⠀⠀⠀

julia&gt; R = sparsevec(I,V)
5-element SparseVector{Int64, Int64} with 4 stored entries:
  [1]  =  1
  [3]  =  -5
  [4]  =  2
  [5]  =  3</code></pre><p>The inverse of the <a href="#SparseArrays.sparse"><code>sparse</code></a> and <a href="#SparseArrays.sparsevec"><code>sparsevec</code></a> functions is <a href="#SparseArrays.findnz"><code>findnz</code></a>, which retrieves the inputs used to create the sparse array. <a href="../../base/arrays/#Base.findall-Tuple{Any}"><code>findall(!iszero, x)</code></a> returns the cartesian indices of non-zero entries in <code>x</code> (including stored entries equal to zero).</p><pre><code class="language-julia-repl">julia&gt; findnz(S)
([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])

julia&gt; findall(!iszero, S)
4-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 4)
 CartesianIndex(4, 7)
 CartesianIndex(5, 9)
 CartesianIndex(3, 18)

julia&gt; findnz(R)
([1, 3, 4, 5], [1, -5, 2, 3])

julia&gt; findall(!iszero, R)
4-element Vector{Int64}:
 1
 3
 4
 5</code></pre><p>另一个创建稀疏数组的方法是使用  <a href="#SparseArrays.sparse"><code>sparse</code></a> 函数将一个稠密数组转化为稀疏数组：</p><pre><code class="language-julia-repl">julia&gt; sparse(Matrix(1.0I, 5, 5))
5×5 SparseMatrixCSC{Float64, Int64} with 5 stored entries:
 1.0   ⋅    ⋅    ⋅    ⋅
  ⋅   1.0   ⋅    ⋅    ⋅
  ⋅    ⋅   1.0   ⋅    ⋅
  ⋅    ⋅    ⋅   1.0   ⋅
  ⋅    ⋅    ⋅    ⋅   1.0

julia&gt; sparse([1.0, 0.0, 1.0])
3-element SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0</code></pre><p>You can go in the other direction using the <a href="../../base/arrays/#Core.Array"><code>Array</code></a> constructor. The <a href="#SparseArrays.issparse"><code>issparse</code></a> function can be used to query if a matrix is sparse.</p><pre><code class="language-julia-repl">julia&gt; issparse(spzeros(5))
true</code></pre><h2 id="稀疏矩阵的操作"><a class="docs-heading-anchor" href="#稀疏矩阵的操作">稀疏矩阵的操作</a><a id="稀疏矩阵的操作-1"></a><a class="docs-heading-anchor-permalink" href="#稀疏矩阵的操作" title="Permalink"></a></h2><p>Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into <code>(I,J,V)</code> format using <a href="#SparseArrays.findnz"><code>findnz</code></a>, manipulate the values or the structure in the dense vectors <code>(I,J,V)</code>, and then reconstruct the sparse matrix.</p><h2 id="Correspondence-of-dense-and-sparse-methods"><a class="docs-heading-anchor" href="#Correspondence-of-dense-and-sparse-methods">Correspondence of dense and sparse methods</a><a id="Correspondence-of-dense-and-sparse-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Correspondence-of-dense-and-sparse-methods" title="Permalink"></a></h2><p>The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix <code>S</code>, or that the resulting sparse matrix has density <code>d</code>, i.e. each matrix element has a probability <code>d</code> of being non-zero.</p><p>Details can be found in the <a href="#stdlib-sparse-arrays">Sparse Vectors and Matrices</a> section of the standard library reference.</p><table><tr><th style="text-align: left">构造函数</th><th style="text-align: left">密度</th><th style="text-align: left">说明</th></tr><tr><td style="text-align: left"><a href="#SparseArrays.spzeros"><code>spzeros(m,n)</code></a></td><td style="text-align: left"><a href="../../base/arrays/#Base.zeros"><code>zeros(m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> matrix of zeros. (<a href="#SparseArrays.spzeros"><code>spzeros(m,n)</code></a> is empty.)</td></tr><tr><td style="text-align: left"><a href="#SparseArrays.sparse"><code>sparse(I,n,n)</code></a></td><td style="text-align: left"><a href="../../base/arrays/#Base.Matrix"><code>Matrix(I,n,n)</code></a></td><td style="text-align: left">Creates a <em>n</em>-by-<em>n</em> identity matrix.</td></tr><tr><td style="text-align: left"><a href="#SparseArrays.sparse"><code>sparse(A)</code></a></td><td style="text-align: left"><a href="../../base/arrays/#Core.Array"><code>Array(S)</code></a></td><td style="text-align: left">Interconverts between dense and sparse formats.</td></tr><tr><td style="text-align: left"><a href="#SparseArrays.sprand"><code>sprand(m,n,d)</code></a></td><td style="text-align: left"><a href="../Random/#Base.rand"><code>rand(m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed uniformly on the half-open interval <span>$[0, 1)$</span>.</td></tr><tr><td style="text-align: left"><a href="#SparseArrays.sprandn"><code>sprandn(m,n,d)</code></a></td><td style="text-align: left"><a href="../Random/#Base.randn"><code>randn(m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.</td></tr><tr><td style="text-align: left"><a href="#SparseArrays.sprandn"><code>sprandn(rng,m,n,d)</code></a></td><td style="text-align: left"><a href="../Random/#Base.randn"><code>randn(rng,m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements generated with the <code>rng</code> random number generator</td></tr></table><h1 id="stdlib-sparse-arrays"><a class="docs-heading-anchor" href="#stdlib-sparse-arrays">Sparse Arrays</a><a id="stdlib-sparse-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-sparse-arrays" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.AbstractSparseArray" href="#SparseArrays.AbstractSparseArray"><code>SparseArrays.AbstractSparseArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractSparseArray{Tv,Ti,N}</code></pre><p>Supertype for <code>N</code>-dimensional sparse arrays (or array-like types) with elements of type <code>Tv</code> and index type <code>Ti</code>. <a href="#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>, <a href="#SparseArrays.SparseVector"><code>SparseVector</code></a> and <code>SuiteSparse.CHOLMOD.Sparse</code> are subtypes of this.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.AbstractSparseVector" href="#SparseArrays.AbstractSparseVector"><code>SparseArrays.AbstractSparseVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractSparseVector{Tv,Ti}</code></pre><p>Supertype for one-dimensional sparse arrays (or array-like types) with elements of type <code>Tv</code> and index type <code>Ti</code>. Alias for <code>AbstractSparseArray{Tv,Ti,1}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.AbstractSparseMatrix" href="#SparseArrays.AbstractSparseMatrix"><code>SparseArrays.AbstractSparseMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractSparseMatrix{Tv,Ti}</code></pre><p>Supertype for two-dimensional sparse arrays (or array-like types) with elements of type <code>Tv</code> and index type <code>Ti</code>. Alias for <code>AbstractSparseArray{Tv,Ti,2}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.SparseVector" href="#SparseArrays.SparseVector"><code>SparseArrays.SparseVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SparseVector{Tv,Ti&lt;:Integer} &lt;: AbstractSparseVector{Tv,Ti}</code></pre><p>Vector type for storing sparse vectors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.SparseMatrixCSC" href="#SparseArrays.SparseMatrixCSC"><code>SparseArrays.SparseMatrixCSC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SparseMatrixCSC{Tv,Ti&lt;:Integer} &lt;: AbstractSparseMatrixCSC{Tv,Ti}</code></pre><p>Matrix type for storing sparse matrices in the <a href="#man-csc">Compressed Sparse Column</a> format. The standard way of constructing SparseMatrixCSC is through the <a href="#SparseArrays.sparse"><code>sparse</code></a> function. See also <a href="#SparseArrays.spzeros"><code>spzeros</code></a>, <a href="#SparseArrays.spdiagm"><code>spdiagm</code></a> and <a href="#SparseArrays.sprand"><code>sprand</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparse" href="#SparseArrays.sparse"><code>SparseArrays.sparse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sparse(A)</code></pre><p>Convert an AbstractMatrix <code>A</code> into a sparse matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Matrix(1.0I, 3, 3)
3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; sparse(A)
3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
 1.0   ⋅    ⋅
  ⋅   1.0   ⋅
  ⋅    ⋅   1.0</code></pre></div></section><section><div><pre><code class="language-none">sparse(I, J, V,[ m, n, combine])</code></pre><p>Create a sparse matrix <code>S</code> of dimensions <code>m x n</code> such that <code>S[I[k], J[k]] = V[k]</code>. The <code>combine</code> function is used to combine duplicates. If <code>m</code> and <code>n</code> are not specified, they are set to <code>maximum(I)</code> and <code>maximum(J)</code> respectively. If the <code>combine</code> function is not supplied, <code>combine</code> defaults to <code>+</code> unless the elements of <code>V</code> are Booleans in which case <code>combine</code> defaults to <code>|</code>. All elements of <code>I</code> must satisfy <code>1 &lt;= I[k] &lt;= m</code>, and all elements of <code>J</code> must satisfy <code>1 &lt;= J[k] &lt;= n</code>. Numerical zeros in (<code>I</code>, <code>J</code>, <code>V</code>) are retained as structural nonzeros; to drop numerical zeros, use <a href="#SparseArrays.dropzeros!"><code>dropzeros!</code></a>.</p><p>For additional documentation and an expert driver, see <code>SparseArrays.sparse!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Is = [1; 2; 3];

julia&gt; Js = [1; 2; 3];

julia&gt; Vs = [1; 2; 3];

julia&gt; sparse(Is, Js, Vs)
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 1  ⋅  ⋅
 ⋅  2  ⋅
 ⋅  ⋅  3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparsevec" href="#SparseArrays.sparsevec"><code>SparseArrays.sparsevec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sparsevec(I, V, [m, combine])</code></pre><p>Create a sparse vector <code>S</code> of length <code>m</code> such that <code>S[I[k]] = V[k]</code>. Duplicates are combined using the <code>combine</code> function, which defaults to <code>+</code> if no <code>combine</code> argument is provided, unless the elements of <code>V</code> are Booleans in which case <code>combine</code> defaults to <code>|</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];

julia&gt; sparsevec(II, V)
5-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  0.5
  [5]  =  0.2

julia&gt; sparsevec(II, V, 8, -)
8-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  -0.1
  [5]  =  0.2

julia&gt; sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])
3-element SparseVector{Bool, Int64} with 3 stored entries:
  [1]  =  1
  [2]  =  0
  [3]  =  1</code></pre></div></section><section><div><pre><code class="language-none">sparsevec(d::Dict, [m])</code></pre><p>Create a sparse vector of length <code>m</code> where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sparsevec(Dict(1 =&gt; 3, 2 =&gt; 2))
2-element SparseVector{Int64, Int64} with 2 stored entries:
  [1]  =  3
  [2]  =  2</code></pre></div></section><section><div><pre><code class="language-none">sparsevec(A)</code></pre><p>Convert a vector <code>A</code> into a sparse vector of length <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])
6-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  2.0
  [5]  =  3.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.issparse" href="#SparseArrays.issparse"><code>SparseArrays.issparse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issparse(S)</code></pre><p>Returns <code>true</code> if <code>S</code> is sparse, and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sv = sparsevec([1, 4], [2.3, 2.2], 10)
10-element SparseVector{Float64, Int64} with 2 stored entries:
  [1 ]  =  2.3
  [4 ]  =  2.2

julia&gt; issparse(sv)
true

julia&gt; issparse(Array(sv))
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nnz" href="#SparseArrays.nnz"><code>SparseArrays.nnz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nnz(A)</code></pre><p>Returns the number of stored (filled) elements in a sparse array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 2  ⋅  ⋅
 ⋅  2  ⋅
 ⋅  ⋅  2

julia&gt; nnz(A)
3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.findnz" href="#SparseArrays.findnz"><code>SparseArrays.findnz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findnz(A::SparseMatrixCSC)</code></pre><p>Return a tuple <code>(I, J, V)</code> where <code>I</code> and <code>J</code> are the row and column indices of the stored (&quot;structurally non-zero&quot;) values in sparse matrix <code>A</code>, and <code>V</code> is a vector of the values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = sparse([1 2 0; 0 0 3; 0 4 0])
3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:
 1  2  ⋅
 ⋅  ⋅  3
 ⋅  4  ⋅

julia&gt; findnz(A)
([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.spzeros" href="#SparseArrays.spzeros"><code>SparseArrays.spzeros</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spzeros([type,]m[,n])</code></pre><p>Create a sparse vector of length <code>m</code> or sparse matrix of size <code>m x n</code>. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> if not specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; spzeros(3, 3)
3×3 SparseMatrixCSC{Float64, Int64} with 0 stored entries:
  ⋅    ⋅    ⋅
  ⋅    ⋅    ⋅
  ⋅    ⋅    ⋅

julia&gt; spzeros(Float32, 4)
4-element SparseVector{Float32, Int64} with 0 stored entries</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.spdiagm" href="#SparseArrays.spdiagm"><code>SparseArrays.spdiagm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spdiagm(kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)
spdiagm(m::Integer, n::Integer, kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)</code></pre><p>Construct a sparse diagonal matrix from <code>Pair</code>s of vectors and diagonals. Each vector <code>kv.second</code> will be placed on the <code>kv.first</code> diagonal.  By default, the matrix is square and its size is inferred from <code>kv</code>, but a non-square size <code>m</code>×<code>n</code> (padded with zeros as needed) can be specified by passing <code>m,n</code> as the first arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; spdiagm(-1 =&gt; [1,2,3,4], 1 =&gt; [4,3,2,1])
5×5 SparseMatrixCSC{Int64, Int64} with 8 stored entries:
 ⋅  4  ⋅  ⋅  ⋅
 1  ⋅  3  ⋅  ⋅
 ⋅  2  ⋅  2  ⋅
 ⋅  ⋅  3  ⋅  1
 ⋅  ⋅  ⋅  4  ⋅</code></pre></div></section><section><div><pre><code class="language-none">spdiagm(v::AbstractVector)
spdiagm(m::Integer, n::Integer, v::AbstractVector)</code></pre><p>Construct a sparse matrix with elements of the vector as diagonal elements. By default (no given <code>m</code> and <code>n</code>), the matrix is square and its size is given by <code>length(v)</code>, but a non-square size <code>m</code>×<code>n</code> can be specified by passing <code>m</code> and <code>n</code> as the first arguments.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>These functions require at least Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; spdiagm([1,2,3])
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 1  ⋅  ⋅
 ⋅  2  ⋅
 ⋅  ⋅  3

julia&gt; spdiagm(sparse([1,0,3]))
3×3 SparseMatrixCSC{Int64, Int64} with 2 stored entries:
 1  ⋅  ⋅
 ⋅  ⋅  ⋅
 ⋅  ⋅  3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.blockdiag" href="#SparseArrays.blockdiag"><code>SparseArrays.blockdiag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">blockdiag(A...)</code></pre><p>Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; blockdiag(sparse(2I, 3, 3), sparse(4I, 2, 2))
5×5 SparseMatrixCSC{Int64, Int64} with 5 stored entries:
 2  ⋅  ⋅  ⋅  ⋅
 ⋅  2  ⋅  ⋅  ⋅
 ⋅  ⋅  2  ⋅  ⋅
 ⋅  ⋅  ⋅  4  ⋅
 ⋅  ⋅  ⋅  ⋅  4</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sprand" href="#SparseArrays.sprand"><code>SparseArrays.sprand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sprand([rng],[type],m,[n],p::AbstractFloat,[rfn])</code></pre><p>Create a random length <code>m</code> sparse vector or <code>m</code> by <code>n</code> sparse matrix, in which the probability of any element being nonzero is independently given by <code>p</code> (and hence the mean density of nonzeros is also exactly <code>p</code>). Nonzero values are sampled from the distribution specified by <code>rfn</code> and have the type <code>type</code>. The uniform distribution is used in case <code>rfn</code> is not specified. The optional <code>rng</code> argument specifies a random number generator, see <a href="stdlib/@ref">Random Numbers</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sprand(Bool, 2, 2, 0.5)
2×2 SparseMatrixCSC{Bool, Int64} with 2 stored entries:
 1  1
 ⋅  ⋅

julia&gt; sprand(Float64, 3, 0.75)
3-element SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  0.795547
  [2]  =  0.49425</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sprandn" href="#SparseArrays.sprandn"><code>SparseArrays.sprandn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sprandn([rng][,Type],m[,n],p::AbstractFloat)</code></pre><p>Create a random sparse vector of length <code>m</code> or sparse matrix of size <code>m</code> by <code>n</code> with the specified (independent) probability <code>p</code> of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional <code>rng</code> argument specifies a random number generator, see <a href="stdlib/@ref">Random Numbers</a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Specifying the output element type <code>Type</code> requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sprandn(2, 2, 0.75)
2×2 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
 -1.20577     ⋅
  0.311817  -0.234641</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nonzeros" href="#SparseArrays.nonzeros"><code>SparseArrays.nonzeros</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nonzeros(A)</code></pre><p>Return a vector of the structural nonzero values in sparse array <code>A</code>. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of <code>A</code>, and any modifications to the returned vector will mutate <code>A</code> as well. See <a href="#SparseArrays.rowvals"><code>rowvals</code></a> and <a href="#SparseArrays.nzrange"><code>nzrange</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 2  ⋅  ⋅
 ⋅  2  ⋅
 ⋅  ⋅  2

julia&gt; nonzeros(A)
3-element Vector{Int64}:
 2
 2
 2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.rowvals" href="#SparseArrays.rowvals"><code>SparseArrays.rowvals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rowvals(A::AbstractSparseMatrixCSC)</code></pre><p>Return a vector of the row indices of <code>A</code>. Any modifications to the returned vector will mutate <code>A</code> as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also <a href="#SparseArrays.nonzeros"><code>nonzeros</code></a> and <a href="#SparseArrays.nzrange"><code>nzrange</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 2  ⋅  ⋅
 ⋅  2  ⋅
 ⋅  ⋅  2

julia&gt; rowvals(A)
3-element Vector{Int64}:
 1
 2
 3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nzrange" href="#SparseArrays.nzrange"><code>SparseArrays.nzrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nzrange(A::AbstractSparseMatrixCSC, col::Integer)</code></pre><p>Return the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with <a href="#SparseArrays.nonzeros"><code>nonzeros</code></a> and <a href="#SparseArrays.rowvals"><code>rowvals</code></a>, this allows for convenient iterating over a sparse matrix :</p><pre><code class="language-none">A = sparse(I,J,V)
rows = rowvals(A)
vals = nonzeros(A)
m, n = size(A)
for j = 1:n
   for i in nzrange(A, j)
      row = rows[i]
      val = vals[i]
      # perform sparse wizardry...
   end
end</code></pre></div></section><section><div><pre><code class="language-none">nzrange(x::SparseVectorUnion, col)</code></pre><p>Give the range of indices to the structural nonzero values of a sparse vector. The column index <code>col</code> is ignored (assumed to be <code>1</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.droptol!" href="#SparseArrays.droptol!"><code>SparseArrays.droptol!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">droptol!(A::AbstractSparseMatrixCSC, tol)</code></pre><p>Removes stored values from <code>A</code> whose absolute value is less than or equal to <code>tol</code>.</p></div></section><section><div><pre><code class="language-none">droptol!(x::SparseVector, tol)</code></pre><p>Removes stored values from <code>x</code> whose absolute value is less than or equal to <code>tol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.dropzeros!" href="#SparseArrays.dropzeros!"><code>SparseArrays.dropzeros!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropzeros!(A::AbstractSparseMatrixCSC;)</code></pre><p>Removes stored numerical zeros from <code>A</code>.</p><p>For an out-of-place version, see <a href="#SparseArrays.dropzeros"><code>dropzeros</code></a>. For algorithmic information, see <code>fkeep!</code>.</p></div></section><section><div><pre><code class="language-none">dropzeros!(x::SparseVector)</code></pre><p>Removes stored numerical zeros from <code>x</code>.</p><p>For an out-of-place version, see <a href="#SparseArrays.dropzeros"><code>dropzeros</code></a>. For algorithmic information, see <code>fkeep!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.dropzeros" href="#SparseArrays.dropzeros"><code>SparseArrays.dropzeros</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropzeros(A::AbstractSparseMatrixCSC;)</code></pre><p>Generates a copy of <code>A</code> and removes stored numerical zeros from that copy.</p><p>For an in-place version and algorithmic information, see <a href="#SparseArrays.dropzeros!"><code>dropzeros!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])
3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
 1.0   ⋅    ⋅
  ⋅   0.0   ⋅
  ⋅    ⋅   1.0

julia&gt; dropzeros(A)
3×3 SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 1.0   ⋅    ⋅
  ⋅    ⋅    ⋅
  ⋅    ⋅   1.0</code></pre></div></section><section><div><pre><code class="language-none">dropzeros(x::SparseVector)</code></pre><p>Generates a copy of <code>x</code> and removes numerical zeros from that copy.</p><p>For an in-place version and algorithmic information, see <a href="#SparseArrays.dropzeros!"><code>dropzeros!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])
3-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  0.0
  [3]  =  1.0

julia&gt; dropzeros(A)
3-element SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.permute" href="#SparseArrays.permute"><code>SparseArrays.permute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">permute(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{&lt;:Integer},
        q::AbstractVector{&lt;:Integer}) where {Tv,Ti}</code></pre><p>Bilaterally permute <code>A</code>, returning <code>PAQ</code> (<code>A[p,q]</code>). Column-permutation <code>q</code>&#39;s length must match <code>A</code>&#39;s column count (<code>length(q) == size(A, 2)</code>). Row-permutation <code>p</code>&#39;s length must match <code>A</code>&#39;s row count (<code>length(p) == size(A, 1)</code>).</p><p>For expert drivers and additional information, see <a href="../../base/arrays/#Base.permute!-Tuple{Any, AbstractVector}"><code>permute!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = spdiagm(0 =&gt; [1, 2, 3, 4], 1 =&gt; [5, 6, 7])
4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:
 1  5  ⋅  ⋅
 ⋅  2  6  ⋅
 ⋅  ⋅  3  7
 ⋅  ⋅  ⋅  4

julia&gt; permute(A, [4, 3, 2, 1], [1, 2, 3, 4])
4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:
 ⋅  ⋅  ⋅  4
 ⋅  ⋅  3  7
 ⋅  2  6  ⋅
 1  5  ⋅  ⋅

julia&gt; permute(A, [1, 2, 3, 4], [4, 3, 2, 1])
4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:
 ⋅  ⋅  5  1
 ⋅  6  2  ⋅
 7  3  ⋅  ⋅
 4  ⋅  ⋅  ⋅</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.permute!-Union{Tuple{Tq}, Tuple{Tp}, Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv, Ti}, SparseMatrixCSC{Tv, Ti}, AbstractVector{Tp}, AbstractVector{Tq}}} where {Tv, Ti, Tp&lt;:Integer, Tq&lt;:Integer}" href="#Base.permute!-Union{Tuple{Tq}, Tuple{Tp}, Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv, Ti}, SparseMatrixCSC{Tv, Ti}, AbstractVector{Tp}, AbstractVector{Tq}}} where {Tv, Ti, Tp&lt;:Integer, Tq&lt;:Integer}"><code>Base.permute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permute!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti},
         p::AbstractVector{&lt;:Integer}, q::AbstractVector{&lt;:Integer},
         [C::AbstractSparseMatrixCSC{Tv,Ti}]) where {Tv,Ti}</code></pre><p>Bilaterally permute <code>A</code>, storing result <code>PAQ</code> (<code>A[p,q]</code>) in <code>X</code>. Stores intermediate result <code>(AQ)^T</code> (<code>transpose(A[:,q])</code>) in optional argument <code>C</code> if present. Requires that none of <code>X</code>, <code>A</code>, and, if present, <code>C</code> alias each other; to store result <code>PAQ</code> back into <code>A</code>, use the following method lacking <code>X</code>:</p><pre><code class="language-none">permute!(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{&lt;:Integer},
         q::AbstractVector{&lt;:Integer}[, C::AbstractSparseMatrixCSC{Tv,Ti},
         [workcolptr::Vector{Ti}]]) where {Tv,Ti}</code></pre><p><code>X</code>&#39;s dimensions must match those of <code>A</code> (<code>size(X, 1) == size(A, 1)</code> and <code>size(X, 2) == size(A, 2)</code>), and <code>X</code> must have enough storage to accommodate all allocated entries in <code>A</code> (<code>length(rowvals(X)) &gt;= nnz(A)</code> and <code>length(nonzeros(X)) &gt;= nnz(A)</code>). Column-permutation <code>q</code>&#39;s length must match <code>A</code>&#39;s column count (<code>length(q) == size(A, 2)</code>). Row-permutation <code>p</code>&#39;s length must match <code>A</code>&#39;s row count (<code>length(p) == size(A, 1)</code>).</p><p><code>C</code>&#39;s dimensions must match those of <code>transpose(A)</code> (<code>size(C, 1) == size(A, 2)</code> and <code>size(C, 2) == size(A, 1)</code>), and <code>C</code> must have enough storage to accommodate all allocated entries in <code>A</code> (<code>length(rowvals(C)) &gt;= nnz(A)</code> and <code>length(nonzeros(C)) &gt;= nnz(A)</code>).</p><p>For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods <code>unchecked_noalias_permute!</code> and <code>unchecked_aliasing_permute!</code>.</p><p>See also <a href="#SparseArrays.permute"><code>permute</code></a>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Sockets/">« 套接字</a><a class="docs-footer-nextpage" href="../Statistics/">统计 »</a><div class="flexbox-break"></div><p class="footer-message">📢📢📢 JuliaCN 2022 冬季见面会 报告<a href="https://cn.julialang.org/meetup-website/2022/">征集</a></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2022 十月 10 周一 04:55">2022 十月 10 周一</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.8.2版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
