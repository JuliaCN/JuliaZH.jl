<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>单元测试 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/stdlib/Test/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../Base64/">Base64</a></li><li><a class="tocitem" href="../CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../Dates/">日期</a></li><li><a class="tocitem" href="../DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../Distributed/">分布式计算</a></li><li><a class="tocitem" href="../FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../InteractiveUtils/">交互式组件</a></li><li><a class="tocitem" href="../LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../Libdl/">动态链接器</a></li><li><a class="tocitem" href="../LinearAlgebra/">线性代数</a></li><li><a class="tocitem" href="../Logging/">日志记录</a></li><li><a class="tocitem" href="../Markdown/">Markdown</a></li><li><a class="tocitem" href="../Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../Pkg/">Pkg</a></li><li><a class="tocitem" href="../Printf/">Printf</a></li><li><a class="tocitem" href="../Profile/">性能分析</a></li><li><a class="tocitem" href="../REPL/">Julia REPL</a></li><li><a class="tocitem" href="../Random/">随机数</a></li><li><a class="tocitem" href="../SHA/">SHA</a></li><li><a class="tocitem" href="../Serialization/">序列化</a></li><li><a class="tocitem" href="../SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../Sockets/">套接字</a></li><li><a class="tocitem" href="../SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../Statistics/">统计</a></li><li class="is-active"><a class="tocitem" href>单元测试</a><ul class="internal"><li><a class="tocitem" href="#测试-Julia-Base-库-1"><span>测试 Julia Base 库</span></a></li><li><a class="tocitem" href="#基本的单元测试-1"><span>基本的单元测试</span></a></li><li><a class="tocitem" href="#Working-with-Test-Sets-1"><span>Working with Test Sets</span></a></li><li><a class="tocitem" href="#其他测试宏-1"><span>其他测试宏</span></a></li><li><a class="tocitem" href="#损坏的测试-1"><span>损坏的测试</span></a></li><li><a class="tocitem" href="#自定义-AbstractTestSet-类型-1"><span>自定义 <code>AbstractTestSet</code> 类型</span></a></li></ul></li><li><a class="tocitem" href="../UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Standard Library</a></li><li class="is-active"><a href>单元测试</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>单元测试</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/stdlib-zh_cn/translate/#zh_CN/Testmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="单元测试-1"><a class="docs-heading-anchor" href="#单元测试-1">单元测试</a><a class="docs-heading-anchor-permalink" href="#单元测试-1" title="Permalink"></a></h1><h2 id="测试-Julia-Base-库-1"><a class="docs-heading-anchor" href="#测试-Julia-Base-库-1">测试 Julia Base 库</a><a class="docs-heading-anchor-permalink" href="#测试-Julia-Base-库-1" title="Permalink"></a></h2><p>Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with <code>make test</code>. In a binary install, you can run the test suite using <code>Base.runtests()</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Base.runtests" href="#Base.runtests"><code>Base.runtests</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.runtests(tests=[&quot;all&quot;]; ncores=ceil(Int, Sys.CPU_THREADS / 2),
              exit_on_error=false, [seed])</code></pre><p>Run the Julia unit tests listed in <code>tests</code>, which can be either a string or an array of strings, using <code>ncores</code> processors. If <code>exit_on_error</code> is <code>false</code>, when one test fails, all remaining tests in other files will still be run; they are otherwise discarded, when <code>exit_on_error == true</code>. If a seed is provided via the keyword argument, it is used to seed the global RNG in the context where the tests are run; otherwise the seed is chosen randomly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/util.jl#L791-L801">source</a></section></article><h2 id="基本的单元测试-1"><a class="docs-heading-anchor" href="#基本的单元测试-1">基本的单元测试</a><a class="docs-heading-anchor-permalink" href="#基本的单元测试-1" title="Permalink"></a></h2><p>The <code>Test</code> module provides simple <em>unit testing</em> functionality. Unit testing is a way to see if your code is correct by checking that the results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a way of specifying the behaviors your code should have when complete.</p><p>Simple unit testing can be performed with the <code>@test</code> and <code>@test_throws</code> macros:</p><article class="docstring"><header><a class="docstring-binding" id="Test.@test" href="#Test.@test"><code>Test.@test</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@test ex
@test f(args...) key=val ...</code></pre><p>Tests that the expression <code>ex</code> evaluates to <code>true</code>. Returns a <code>Pass</code> <code>Result</code> if it does, a <code>Fail</code> <code>Result</code> if it is <code>false</code>, and an <code>Error</code> <code>Result</code> if it could not be evaluated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @test true
Test Passed

julia&gt; @test [1, 2] + [2, 1] == [3, 3]
Test Passed</code></pre><p>The <code>@test f(args...) key=val...</code> form is equivalent to writing <code>@test f(args..., key=val...)</code> which can be useful when the expression is a call using infix syntax such as approximate comparisons:</p><pre><code class="language-julia-repl">julia&gt; @test π ≈ 3.14 atol=0.01
Test Passed</code></pre><p>This is equivalent to the uglier test <code>@test ≈(π, 3.14, atol=0.01)</code>. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (<code>k=v</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Test.@test_throws" href="#Test.@test_throws"><code>Test.@test_throws</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@test_throws exception expr</code></pre><p>Tests that the expression <code>expr</code> throws <code>exception</code>. The exception may specify either a type, or a value (which will be tested for equality by comparing fields). Note that <code>@test_throws</code> does not support a trailing keyword form.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @test_throws BoundsError [1, 2, 3][4]
Test Passed
      Thrown: BoundsError

julia&gt; @test_throws DimensionMismatch [1, 2, 3] + [1, 2]
Test Passed
      Thrown: DimensionMismatch</code></pre></div></section></article><p>For example, suppose we want to check our new function <code>foo(x)</code> works as expected:</p><pre><code class="language-julia-repl">julia&gt; using Test

julia&gt; foo(x) = length(x)^2
foo (generic function with 1 method)</code></pre><p>如果条件为真，则返回 <code>Pass</code>：</p><pre><code class="language-julia-repl">julia&gt; @test foo(&quot;bar&quot;) == 9
Test Passed

julia&gt; @test foo(&quot;fizz&quot;) &gt;= 10
Test Passed</code></pre><p>如果条件为假，则返回 <code>Fail</code> 并抛出异常。</p><pre><code class="language-julia-repl">julia&gt; @test foo(&quot;f&quot;) == 20
Test Failed at none:1
  Expression: foo(&quot;f&quot;) == 20
   Evaluated: 1 == 20
ERROR: There was an error during testing</code></pre><p>If the condition could not be evaluated because an exception was thrown, which occurs in this case because <code>length</code> is not defined for symbols, an <code>Error</code> object is returned and an exception is thrown:</p><pre><code class="language-julia-repl">julia&gt; @test foo(:cat) == 1
Error During Test
  Test threw an exception of type MethodError
  Expression: foo(:cat) == 1
  MethodError: no method matching length(::Symbol)
  Closest candidates are:
    length(::SimpleVector) at essentials.jl:256
    length(::Base.MethodList) at reflection.jl:521
    length(::MethodTable) at reflection.jl:597
    ...
  Stacktrace:
  [...]
ERROR: There was an error during testing</code></pre><p>If we expect that evaluating an expression <em>should</em> throw an exception, then we can use <code>@test_throws</code> to check that this occurs:</p><pre><code class="language-julia-repl">julia&gt; @test_throws MethodError foo(:cat)
Test Passed
      Thrown: MethodError</code></pre><h2 id="Working-with-Test-Sets-1"><a class="docs-heading-anchor" href="#Working-with-Test-Sets-1">Working with Test Sets</a><a class="docs-heading-anchor-permalink" href="#Working-with-Test-Sets-1" title="Permalink"></a></h2><p>Typically a large number of tests are used to make sure functions work correctly over a range of inputs. In the event a test fails, the default behavior is to throw an exception immediately. However, it is normally preferable to run the rest of the tests first to get a better picture of how many errors there are in the code being tested.</p><p>The <code>@testset</code> macro can be used to group tests into <em>sets</em>. All the tests in a test set will be run, and at the end of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a <code>TestSetException</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Test.@testset" href="#Test.@testset"><code>Test.@testset</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@testset [CustomTestSet] [option=val  ...] [&quot;description&quot;] begin ... end
@testset [CustomTestSet] [option=val  ...] [&quot;description $v&quot;] for v in (...) ... end
@testset [CustomTestSet] [option=val  ...] [&quot;description $v, $w&quot;] for v in (...), w in (...) ... end</code></pre><p>Starts a new test set, or multiple test sets if a <code>for</code> loop is provided.</p><p>If no custom testset type is given it defaults to creating a <code>DefaultTestSet</code>. <code>DefaultTestSet</code> records all the results and, if there are any <code>Fail</code>s or <code>Error</code>s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.</p><p>Any custom testset type (subtype of <code>AbstractTestSet</code>) can be given and it will also be used for any nested <code>@testset</code> invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.</p><p>The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.</p><p>By default the <code>@testset</code> macro will return the testset object itself, though this behavior can be customized in other testset types. If a <code>for</code> loop is used then the macro collects and returns a list of the return values of the <code>finish</code> method, which by default will return a list of the testset objects used in each iteration.</p><p>Before the execution of the body of a <code>@testset</code>, there is an implicit call to <code>Random.seed!(seed)</code> where <code>seed</code> is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the <code>@testset</code>. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of <code>@testset</code>s regardless of their side-effect on the global RNG state.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @testset &quot;trigonometric identities&quot; begin
           θ = 2/3*π
           @test sin(-θ) ≈ -sin(θ)
           @test cos(-θ) ≈ cos(θ)
           @test sin(2θ) ≈ 2*sin(θ)*cos(θ)
           @test cos(2θ) ≈ cos(θ)^2 - sin(θ)^2
       end;
Test Summary:            | Pass  Total
trigonometric identities |    4      4</code></pre></div></section></article><p>We can put our tests for the <code>foo(x)</code> function in a test set:</p><pre><code class="language-julia-repl">julia&gt; @testset &quot;Foo Tests&quot; begin
           @test foo(&quot;a&quot;)   == 1
           @test foo(&quot;ab&quot;)  == 4
           @test foo(&quot;abc&quot;) == 9
       end;
Test Summary: | Pass  Total
Foo Tests     |    3      3</code></pre><p>测试集可以嵌套：</p><pre><code class="language-julia-repl">julia&gt; @testset &quot;Foo Tests&quot; begin
           @testset &quot;Animals&quot; begin
               @test foo(&quot;cat&quot;) == 9
               @test foo(&quot;dog&quot;) == foo(&quot;cat&quot;)
           end
           @testset &quot;Arrays $i&quot; for i in 1:3
               @test foo(zeros(i)) == i^2
               @test foo(fill(1.0, i)) == i^2
           end
       end;
Test Summary: | Pass  Total
Foo Tests     |    8      8</code></pre><p>In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:</p><pre><code class="language-julia-repl">julia&gt; @testset &quot;Foo Tests&quot; begin
           @testset &quot;Animals&quot; begin
               @testset &quot;Felines&quot; begin
                   @test foo(&quot;cat&quot;) == 9
               end
               @testset &quot;Canines&quot; begin
                   @test foo(&quot;dog&quot;) == 9
               end
           end
           @testset &quot;Arrays&quot; begin
               @test foo(zeros(2)) == 4
               @test foo(fill(1.0, 4)) == 15
           end
       end

Arrays: Test Failed
  Expression: foo(fill(1.0, 4)) == 15
   Evaluated: 16 == 15
[...]
Test Summary: | Pass  Fail  Total
Foo Tests     |    3     1      4
  Animals     |    2            2
  Arrays      |    1     1      2
ERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.</code></pre><h2 id="其他测试宏-1"><a class="docs-heading-anchor" href="#其他测试宏-1">其他测试宏</a><a class="docs-heading-anchor-permalink" href="#其他测试宏-1" title="Permalink"></a></h2><p>As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either <code>@test a ≈ b</code> (where <code>≈</code>, typed via tab completion of <code>\approx</code>, is the <a href="../../base/math/#Base.isapprox"><code>isapprox</code></a> function) or use <a href="../../base/math/#Base.isapprox"><code>isapprox</code></a> directly.</p><pre><code class="language-julia-repl">julia&gt; @test 1 ≈ 0.999999999
Test Passed

julia&gt; @test 1 ≈ 0.999999
Test Failed at none:1
  Expression: 1 ≈ 0.999999
   Evaluated: 1 ≈ 0.999999
ERROR: There was an error during testing</code></pre><article class="docstring"><header><a class="docstring-binding" id="Test.@inferred" href="#Test.@inferred"><code>Test.@inferred</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@inferred [AllowedType] f(x)</code></pre><p>Tests that the call expression <code>f(x)</code> returns a value of the same type inferred by the compiler. It is useful to check for type stability.</p><p><code>f(x)</code> can be any call expression. Returns the result of <code>f(x)</code> if the types match, and an <code>Error</code> <code>Result</code> if it finds different types.</p><p>Optionally, <code>AllowedType</code> relaxes the test, by making it pass when either the type of <code>f(x)</code> matches the inferred type modulo <code>AllowedType</code>, or when the return type is a subtype of <code>AllowedType</code>. This is useful when testing type stability of functions returning a small union such as <code>Union{Nothing, T}</code> or <code>Union{Missing, T}</code>.</p><pre><code class="language-julia-repl">julia&gt; f(a) = a &gt; 1 ? 1 : 1.0
f (generic function with 1 method)

julia&gt; typeof(f(2))
Int64

julia&gt; @code_warntype f(2)
Variables
  #self#::Core.Compiler.Const(f, false)
  a::Int64

Body::UNION{FLOAT64, INT64}
1 ─ %1 = (a &gt; 1)::Bool
└──      goto #3 if not %1
2 ─      return 1
3 ─      return 1.0

julia&gt; @inferred f(2)
ERROR: return type Int64 does not match inferred return type Union{Float64, Int64}
[...]

julia&gt; @inferred max(1, 2)
2

julia&gt; g(a) = a &lt; 10 ? missing : 1.0
g (generic function with 1 method)

julia&gt; @inferred g(20)
ERROR: return type Float64 does not match inferred return type Union{Missing, Float64}
[...]

julia&gt; @inferred Missing g(20)
1.0

julia&gt; h(a) = a &lt; 10 ? missing : f(a)
h (generic function with 1 method)

julia&gt; @inferred Missing h(20)
ERROR: return type Int64 does not match inferred return type Union{Missing, Float64, Int64}
[...]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Test.@test_logs" href="#Test.@test_logs"><code>Test.@test_logs</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@test_logs [log_patterns...] [keywords] expression</code></pre><p>Collect a list of log records generated by <code>expression</code> using <code>collect_test_logs</code>, check that they match the sequence <code>log_patterns</code>, and return the value of <code>expression</code>.  The <code>keywords</code> provide some simple filtering of log records: the <code>min_level</code> keyword controls the minimum log level which will be collected for the test, the <code>match_mode</code> keyword defines how matching will be performed (the default <code>:all</code> checks that all logs and patterns match pairwise; use <code>:any</code> to check that the pattern matches at least once somewhere in the sequence.)</p><p>The most useful log pattern is a simple tuple of the form <code>(level,message)</code>. A different number of tuple elements may be used to match other log metadata, corresponding to the arguments to passed to <code>AbstractLogger</code> via the <code>handle_message</code> function: <code>(level,message,module,group,id,file,line)</code>. Elements which are present will be matched pairwise with the log record fields using <code>==</code> by default, with the special cases that <code>Symbol</code>s may be used for the standard log levels, and <code>Regex</code>s in the pattern will match string or Symbol fields using <code>occursin</code>.</p><p><strong>Examples</strong></p><p>Consider a function which logs a warning, and several debug messages:</p><pre><code class="language-none">function foo(n)
    @info &quot;Doing foo with n=$n&quot;
    for i=1:n
        @debug &quot;Iteration $i&quot;
    end
    42
end</code></pre><p>We can test the info message using</p><pre><code class="language-none">@test_logs (:info,&quot;Doing foo with n=2&quot;) foo(2)</code></pre><p>If we also wanted to test the debug messages, these need to be enabled with the <code>min_level</code> keyword:</p><pre><code class="language-none">@test_logs (:info,&quot;Doing foo with n=2&quot;) (:debug,&quot;Iteration 1&quot;) (:debug,&quot;Iteration 2&quot;) min_level=Debug foo(2)</code></pre><p>The macro may be chained with <code>@test</code> to also test the returned value:</p><pre><code class="language-none">@test (@test_logs (:info,&quot;Doing foo with n=2&quot;) foo(2)) == 42</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Test.@test_deprecated" href="#Test.@test_deprecated"><code>Test.@test_deprecated</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@test_deprecated [pattern] expression</code></pre><p>When <code>--depwarn=yes</code>, test that <code>expression</code> emits a deprecation warning and return the value of <code>expression</code>.  The log message string will be matched against <code>pattern</code> which defaults to <code>r&quot;deprecated&quot;i</code>.</p><p>When <code>--depwarn=no</code>, simply return the result of executing <code>expression</code>.  When <code>--depwarn=error</code>, check that an ErrorException is thrown.</p><p><strong>Examples</strong></p><pre><code class="language-none"># Deprecated in julia 0.7
@test_deprecated num2hex(1)

# The returned value can be tested by chaining with @test:
@test (@test_deprecated num2hex(1)) == &quot;0000000000000001&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Test.@test_warn" href="#Test.@test_warn"><code>Test.@test_warn</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@test_warn msg expr</code></pre><p>Test whether evaluating <code>expr</code> results in <a href="../../base/io-network/#Base.stderr"><code>stderr</code></a> output that contains the <code>msg</code> string or matches the <code>msg</code> regular expression.  If <code>msg</code> is a boolean function, tests whether <code>msg(output)</code> returns <code>true</code>.  If <code>msg</code> is a tuple or array, checks that the error output contains/matches each item in <code>msg</code>. Returns the result of evaluating <code>expr</code>.</p><p>See also <a href="#Test.@test_nowarn"><code>@test_nowarn</code></a> to check for the absence of error output.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Test.@test_nowarn" href="#Test.@test_nowarn"><code>Test.@test_nowarn</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@test_nowarn expr</code></pre><p>Test whether evaluating <code>expr</code> results in empty <a href="../../base/io-network/#Base.stderr"><code>stderr</code></a> output (no warnings or other messages).  Returns the result of evaluating <code>expr</code>.</p></div></section></article><h2 id="损坏的测试-1"><a class="docs-heading-anchor" href="#损坏的测试-1">损坏的测试</a><a class="docs-heading-anchor-permalink" href="#损坏的测试-1" title="Permalink"></a></h2><p>If a test fails consistently it can be changed to use the <code>@test_broken</code> macro. This will denote the test as <code>Broken</code> if the test continues to fail and alerts the user via an <code>Error</code> if the test succeeds.</p><article class="docstring"><header><a class="docstring-binding" id="Test.@test_broken" href="#Test.@test_broken"><code>Test.@test_broken</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@test_broken ex
@test_broken f(args...) key=val ...</code></pre><p>Indicates a test that should pass but currently consistently fails. Tests that the expression <code>ex</code> evaluates to <code>false</code> or causes an exception. Returns a <code>Broken</code> <code>Result</code> if it does, or an <code>Error</code> <code>Result</code> if the expression evaluates to <code>true</code>.</p><p>The <code>@test_broken f(args...) key=val...</code> form works as for the <code>@test</code> macro.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @test_broken 1 == 2
Test Broken
  Expression: 1 == 2

julia&gt; @test_broken 1 == 2 atol=0.1
Test Broken
  Expression: ==(1, 2, atol=0.1)</code></pre></div></section></article><p><code>@test_skip</code> is also available to skip a test without evaluation, but counting the skipped test in the test set reporting. The test will not run but gives a <code>Broken</code> <code>Result</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Test.@test_skip" href="#Test.@test_skip"><code>Test.@test_skip</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@test_skip ex
@test_skip f(args...) key=val ...</code></pre><p>Marks a test that should not be executed but should be included in test summary reporting as <code>Broken</code>. This can be useful for tests that intermittently fail, or tests of not-yet-implemented functionality.</p><p>The <code>@test_skip f(args...) key=val...</code> form works as for the <code>@test</code> macro.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @test_skip 1 == 2
Test Broken
  Skipped: 1 == 2

julia&gt; @test_skip 1 == 2 atol=0.1
Test Broken
  Skipped: ==(1, 2, atol=0.1)</code></pre></div></section></article><h2 id="自定义-AbstractTestSet-类型-1"><a class="docs-heading-anchor" href="#自定义-AbstractTestSet-类型-1">自定义 <code>AbstractTestSet</code> 类型</a><a class="docs-heading-anchor-permalink" href="#自定义-AbstractTestSet-类型-1" title="Permalink"></a></h2><p>Packages can create their own <code>AbstractTestSet</code> subtypes by implementing the <code>record</code> and <code>finish</code> methods. The subtype should have a one-argument constructor taking a description string, with any options passed in as keyword arguments.</p><article class="docstring"><header><a class="docstring-binding" id="Test.record" href="#Test.record"><code>Test.record</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">record(ts::AbstractTestSet, res::Result)</code></pre><p>Record a result to a testset. This function is called by the <code>@testset</code> infrastructure each time a contained <code>@test</code> macro completes, and is given the test result (which could be an <code>Error</code>). This will also be called with an <code>Error</code> if an exception is thrown inside the test block but outside of a <code>@test</code> context.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Test.finish" href="#Test.finish"><code>Test.finish</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">finish(ts::AbstractTestSet)</code></pre><p>Do any final processing necessary for the given testset. This is called by the <code>@testset</code> infrastructure after a test block executes. One common use for this function is to record the testset to the parent&#39;s results list, using <code>get_testset</code>.</p></div></section></article><p><code>Test</code> takes responsibility for maintaining a stack of nested testsets as they are executed, but any result accumulation is the responsibility of the <code>AbstractTestSet</code> subtype. You can access this stack with the <code>get_testset</code> and <code>get_testset_depth</code> methods. Note that these functions are not exported.</p><article class="docstring"><header><a class="docstring-binding" id="Test.get_testset" href="#Test.get_testset"><code>Test.get_testset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_testset()</code></pre><p>Retrieve the active test set from the task&#39;s local storage. If no test set is active, use the fallback default test set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Test.get_testset_depth" href="#Test.get_testset_depth"><code>Test.get_testset_depth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_testset_depth()</code></pre><p>Returns the number of active test sets, not including the default test set</p></div></section></article><p><code>Test</code> also makes sure that nested <code>@testset</code> invocations use the same <code>AbstractTestSet</code> subtype as their parent unless it is set explicitly. It does not propagate any properties of the testset. Option inheritance behavior can be implemented by packages using the stack infrastructure that <code>Test</code> provides.</p><p>定义一个基本的 <code>AbstractTestSet</code> 子类：</p><pre><code class="language-julia">import Test: record, finish
using Test: AbstractTestSet, Result, Pass, Fail, Error
using Test: get_testset_depth, get_testset
struct CustomTestSet &lt;: Test.AbstractTestSet
    description::AbstractString
    foo::Int
    results::Vector
    # constructor takes a description string and options keyword arguments
    CustomTestSet(desc; foo=1) = new(desc, foo, [])
end

record(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)
record(ts::CustomTestSet, res::Result) = push!(ts.results, res)
function finish(ts::CustomTestSet)
    # just record if we&#39;re not the top-level parent
    if get_testset_depth() &gt; 0
        record(get_testset(), ts)
    end
    ts
end</code></pre><p>使用测试集：</p><pre><code class="language-julia">@testset CustomTestSet foo=4 &quot;custom testset inner 2&quot; begin
    # this testset should inherit the type, but not the argument.
    @testset &quot;custom testset inner&quot; begin
        @test true
    end
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Statistics/">« 统计</a><a class="docs-footer-nextpage" href="../UUIDs/">UUIDs »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2020 六月 18 周四 07:18">2020 六月 18 周四</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.3.1版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
