<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distributed Computing · Julia 中文文档</title><meta name="title" content="Distributed Computing · Julia 中文文档"/><meta property="og:title" content="Distributed Computing · Julia 中文文档"/><meta property="twitter:title" content="Distributed Computing · Julia 中文文档"/><meta name="description" content="Documentation for Julia 中文文档."/><meta property="og:description" content="Documentation for Julia 中文文档."/><meta property="twitter:description" content="Documentation for Julia 中文文档."/><meta property="og:url" content="https://juliacn.github.io/JuliaZH.jl/latest/stdlib/Distributed/"/><meta property="twitter:url" content="https://juliacn.github.io/JuliaZH.jl/latest/stdlib/Distributed/"/><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/stdlib/Distributed/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia 中文文档 logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">一维和多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">数值类型</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">任务</a></li><li><a class="tocitem" href="../../base/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/reflection/">反射与内省</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">标准库</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ArgTools/">ArgTools</a></li><li><a class="tocitem" href="../Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../Base64/">Base64</a></li><li><a class="tocitem" href="../CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../Dates/">日期</a></li><li><a class="tocitem" href="../DelimitedFiles/">分隔符文件</a></li><li class="is-active"><a class="tocitem" href>Distributed Computing</a><ul class="internal"><li><a class="tocitem" href="#Cluster-Manager-Interface"><span>Cluster Manager Interface</span></a></li></ul></li><li><a class="tocitem" href="../Downloads/">Downloads</a></li><li><a class="tocitem" href="../FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../Future/">Future</a></li><li><a class="tocitem" href="../InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../LibCURL/">LibCURL</a></li><li><a class="tocitem" href="../LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../Libdl/">动态链接器</a></li><li><a class="tocitem" href="../LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../Logging/">日志记录</a></li><li><a class="tocitem" href="../Markdown/">Markdown</a></li><li><a class="tocitem" href="../Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../NetworkOptions/">Network Options</a></li><li><a class="tocitem" href="../Pkg/">Pkg</a></li><li><a class="tocitem" href="../Printf/">Printf</a></li><li><a class="tocitem" href="../Profile/">性能分析</a></li><li><a class="tocitem" href="../REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../Random/">随机数</a></li><li><a class="tocitem" href="../SHA/">SHA</a></li><li><a class="tocitem" href="../Serialization/">序列化</a></li><li><a class="tocitem" href="../SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../Sockets/">套接字</a></li><li><a class="tocitem" href="../SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../Statistics/">统计</a></li><li><a class="tocitem" href="../TOML/">TOML</a></li><li><a class="tocitem" href="../Tar/">Tar</a></li><li><a class="tocitem" href="../Test/">单元测试</a></li><li><a class="tocitem" href="../UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">开发者文档</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/pkgimg/">Package Images</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../../devdocs/gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../../devdocs/precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../../devdocs/probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../../devdocs/build/linux/">Linux</a></li><li><a class="tocitem" href="../../devdocs/build/macos/">macOS</a></li><li><a class="tocitem" href="../../devdocs/build/windows/">Windows</a></li><li><a class="tocitem" href="../../devdocs/build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../../devdocs/build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../../devdocs/build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">标准库</a></li><li class="is-active"><a href>Distributed Computing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Distributed Computing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/zh_CN/stdlib/Distributed/docs/src/index.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-distributed"><a class="docs-heading-anchor" href="#man-distributed">Distributed Computing</a><a id="man-distributed-1"></a><a class="docs-heading-anchor-permalink" href="#man-distributed" title="Permalink"></a></h1><p>Tools for distributed parallel processing.</p><article><details class="docstring" open="true"><summary id="Distributed.addprocs"><a class="docstring-binding" href="#Distributed.addprocs"><code>Distributed.addprocs</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">addprocs(manager::ClusterManager; kwargs...) -&gt; List of process identifiers</code></pre><p>Launches worker processes via the specified cluster manager.</p><p>For example, Beowulf clusters are supported via a custom cluster manager implemented in the package <code>ClusterManagers.jl</code>.</p><p>The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable <code>JULIA_WORKER_TIMEOUT</code> in the worker process&#39;s environment. Relevant only when using TCP/IP as transport.</p><p>To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute <code>addprocs</code> in its own task.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># On busy clusters, call `addprocs` asynchronously
t = @async addprocs(...)</code></pre><pre><code class="language-julia hljs"># Utilize workers as and when they come online
if nprocs() &gt; 1   # Ensure at least one new worker is available
   ....   # perform distributed execution
end</code></pre><pre><code class="language-julia hljs"># Retrieve newly launched worker IDs, or any error messages
if istaskdone(t)   # Check if `addprocs` has completed to ensure `fetch` doesn&#39;t block
    if nworkers() == N
        new_pids = fetch(t)
    else
        fetch(t)
    end
end</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L403-L442">source</a></div><div><pre><code class="language-julia hljs">addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -&gt; List of process identifiers</code></pre><p>Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the <code>exename</code> keyword can be used to specify the path to the <code>julia</code> binary on the remote machine(s).</p><p><code>machines</code> is a vector of &quot;machine specifications&quot; which are given as strings of the form <code>[user@]host[:port] [bind_addr[:port]]</code>. <code>user</code> defaults to current user and <code>port</code> to the standard SSH port. If <code>[bind_addr[:port]]</code> is specified, other workers will connect to this worker at the specified <code>bind_addr</code> and <code>port</code>.</p><p>It is possible to launch multiple processes on a remote host by using a tuple in the <code>machines</code> vector or the form <code>(machine_spec, count)</code>, where <code>count</code> is the number of workers to be launched on the specified host. Passing <code>:auto</code> as the worker count will launch as many workers as the number of CPU threads on the remote host.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">addprocs([
    &quot;remote1&quot;,               # one worker on &#39;remote1&#39; logging in with the current username
    &quot;user@remote2&quot;,          # one worker on &#39;remote2&#39; logging in with the &#39;user&#39; username
    &quot;user@remote3:2222&quot;,     # specifying SSH port to &#39;2222&#39; for &#39;remote3&#39;
    (&quot;user@remote4&quot;, 4),     # launch 4 workers on &#39;remote4&#39;
    (&quot;user@remote5&quot;, :auto), # launch as many workers as CPU threads on &#39;remote5&#39;
])</code></pre><p><strong>Keyword arguments</strong>:</p><ul><li><p><code>tunnel</code>: if <code>true</code> then SSH tunneling will be used to connect to the worker from the master process. Default is <code>false</code>.</p></li><li><p><code>multiplex</code>: if <code>true</code> then SSH multiplexing is used for SSH tunneling. Default is <code>false</code>.</p></li><li><p><code>ssh</code>: the name or path of the SSH client executable used to start the workers. Default is <code>&quot;ssh&quot;</code>.</p></li><li><p><code>sshflags</code>: specifies additional ssh options, e.g. <code>sshflags=`-i /home/foo/bar.pem`</code></p></li><li><p><code>max_parallel</code>: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.</p></li><li><p><code>shell</code>: specifies the type of shell to which ssh connects on the workers.</p><ul><li><p><code>shell=:posix</code>: a POSIX-compatible Unix/Linux shell (sh, ksh, bash, dash, zsh, etc.). The default.</p></li><li><p><code>shell=:csh</code>: a Unix C shell (csh, tcsh).</p></li><li><p><code>shell=:wincmd</code>: Microsoft Windows <code>cmd.exe</code>.</p></li></ul></li><li><p><code>dir</code>: specifies the working directory on the workers. Defaults to the host&#39;s current directory (as found by <code>pwd()</code>)</p></li><li><p><code>enable_threaded_blas</code>: if <code>true</code> then  BLAS will run on multiple threads in added processes. Default is <code>false</code>.</p></li><li><p><code>exename</code>: name of the <code>julia</code> executable. Defaults to <code>&quot;$(Sys.BINDIR)/julia&quot;</code> or <code>&quot;$(Sys.BINDIR)/julia-debug&quot;</code> as the case may be. It is recommended that a common Julia version is used on all remote machines because serialization and code distribution might fail otherwise.</p></li><li><p><code>exeflags</code>: additional flags passed to the worker processes.</p></li><li><p><code>topology</code>: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.</p><ul><li><p><code>topology=:all_to_all</code>: All processes are connected to each other. The default.</p></li><li><p><code>topology=:master_worker</code>: Only the driver process, i.e. <code>pid</code> 1 connects to the workers. The workers do not connect to each other.</p></li><li><p><code>topology=:custom</code>: The <code>launch</code> method of the cluster manager specifies the connection topology via fields <code>ident</code> and <code>connect_idents</code> in <code>WorkerConfig</code>. A worker with a cluster manager identity <code>ident</code> will connect to all workers specified in <code>connect_idents</code>.</p></li></ul></li><li><p><code>lazy</code>: Applicable only with <code>topology=:all_to_all</code>. If <code>true</code>, worker-worker connections are setup lazily, i.e. they are setup at the first instance of a remote call between workers. Default is true.</p></li><li><p><code>env</code>: provide an array of string pairs such as <code>env=[&quot;JULIA_DEPOT_PATH&quot;=&gt;&quot;/depot&quot;]</code> to request that environment variables are set on the remote machine. By default only the environment variable <code>JULIA_WORKER_TIMEOUT</code> is passed automatically from the local to the remote environment.</p></li><li><p><code>cmdline_cookie</code>: pass the authentication cookie via the <code>--worker</code> commandline  option. The (more secure) default behaviour of passing the cookie via ssh stdio  may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions,  in which case <code>cmdline_cookie=true</code> offers a work-around.</p></li></ul><div class="admonition is-compat" id="Julia-1.6-d72108089dd6d679"><header class="admonition-header">Julia 1.6<a class="admonition-anchor" href="#Julia-1.6-d72108089dd6d679" title="Permalink"></a></header><div class="admonition-body"><p>The keyword arguments <code>ssh</code>, <code>shell</code>, <code>env</code> and <code>cmdline_cookie</code> were added in Julia 1.6.</p></div></div><p>Environment variables:</p><p>If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable <code>JULIA_WORKER_TIMEOUT</code>. The value of <code>JULIA_WORKER_TIMEOUT</code> on the master process specifies the number of seconds a newly launched worker waits for connection establishment.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/managers.jl#L51-L155">source</a></div><div><pre><code class="language-julia hljs">addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -&gt; List of process identifiers</code></pre><p>Launch <code>np</code> workers on the local host using the in-built <code>LocalManager</code>.</p><p>Local workers inherit the current package environment (i.e., active project, <a href="../../base/constants/#Base.LOAD_PATH"><code>LOAD_PATH</code></a>, and <a href="../../base/constants/#Base.DEPOT_PATH"><code>DEPOT_PATH</code></a>) from the main process.</p><p><strong>Keyword arguments</strong>:</p><ul><li><code>restrict::Bool</code>: if <code>true</code> (default) binding is restricted to <code>127.0.0.1</code>.</li><li><code>dir</code>, <code>exename</code>, <code>exeflags</code>, <code>env</code>, <code>topology</code>, <code>lazy</code>, <code>enable_threaded_blas</code>: same effect as for <code>SSHManager</code>, see documentation for <a href="#Distributed.addprocs"><code>addprocs(machines::AbstractVector)</code></a>.</li></ul><div class="admonition is-compat" id="Julia-1.9-88bc9a35601ed48b"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-88bc9a35601ed48b" title="Permalink"></a></header><div class="admonition-body"><p>The inheriting of the package environment and the <code>env</code> keyword argument were added in Julia 1.9.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/managers.jl#L445-L461">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.nprocs"><a class="docstring-binding" href="#Distributed.nprocs"><code>Distributed.nprocs</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">nprocs()</code></pre><p>Get the number of available processes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nprocs()
3

julia&gt; workers()
2-element Array{Int64,1}:
 2
 3</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L852-L867">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.nworkers"><a class="docstring-binding" href="#Distributed.nworkers"><code>Distributed.nworkers</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">nworkers()</code></pre><p>Get the number of available worker processes. This is one less than <a href="#Distributed.nprocs"><code>nprocs()</code></a>. Equal to <code>nprocs()</code> if <code>nprocs() == 1</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">$ julia -p 2

julia&gt; nprocs()
3

julia&gt; nworkers()
2</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L883-L899">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.procs-Tuple{}"><a class="docstring-binding" href="#Distributed.procs-Tuple{}"><code>Distributed.procs</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">procs()</code></pre><p>Return a list of all process identifiers, including pid 1 (which is not included by <a href="#Distributed.workers"><code>workers()</code></a>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">$ julia -p 2

julia&gt; procs()
3-element Array{Int64,1}:
 1
 2
 3</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L905-L920">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.procs-Tuple{Integer}"><a class="docstring-binding" href="#Distributed.procs-Tuple{Integer}"><code>Distributed.procs</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">procs(pid::Integer)</code></pre><p>Return a list of all process identifiers on the same physical node. Specifically all workers bound to the same ip-address as <code>pid</code> are returned.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L947-L952">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.workers"><a class="docstring-binding" href="#Distributed.workers"><code>Distributed.workers</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">workers()</code></pre><p>Return a list of all worker process identifiers.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">$ julia -p 2

julia&gt; workers()
2-element Array{Int64,1}:
 2
 3</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L967-L981">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.rmprocs"><a class="docstring-binding" href="#Distributed.rmprocs"><code>Distributed.rmprocs</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">rmprocs(pids...; waitfor=typemax(Int))</code></pre><p>Remove the specified workers. Note that only process 1 can add or remove workers.</p><p>Argument <code>waitfor</code> specifies how long to wait for the workers to shut down:</p><ul><li>If unspecified, <code>rmprocs</code> will wait until all requested <code>pids</code> are removed.</li><li>An <a href="../../base/base/#Core.ErrorException"><code>ErrorException</code></a> is raised if all workers cannot be terminated before the requested <code>waitfor</code> seconds.</li><li>With a <code>waitfor</code> value of 0, the call returns immediately with the workers scheduled for removal in a different task. The scheduled <a href="../../base/parallel/#Core.Task"><code>Task</code></a> object is returned. The user should call <a href="../../base/parallel/#Base.wait"><code>wait</code></a> on the task before invoking any other parallel calls.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">$ julia -p 5

julia&gt; t = rmprocs(2, 3, waitfor=0)
Task (runnable) @0x0000000107c718d0

julia&gt; wait(t)

julia&gt; workers()
3-element Array{Int64,1}:
 4
 5
 6</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L997-L1027">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.interrupt"><a class="docstring-binding" href="#Distributed.interrupt"><code>Distributed.interrupt</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">interrupt(pids::Integer...)</code></pre><p>Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L1204-L1209">source</a></div><div><pre><code class="language-julia hljs">interrupt(pids::AbstractVector=workers())</code></pre><p>Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L1212-L1217">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.myid"><a class="docstring-binding" href="#Distributed.myid"><code>Distributed.myid</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">myid()</code></pre><p>Get the id of the current process.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; myid()
1

julia&gt; remotecall_fetch(() -&gt; myid(), 4)
4</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L836-L849">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.pmap"><a class="docstring-binding" href="#Distributed.pmap"><code>Distributed.pmap</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">pmap(f, [::AbstractWorkerPool], c...; distributed=true, batch_size=1, on_error=nothing, retry_delays=[], retry_check=nothing) -&gt; collection</code></pre><p>Transform collection <code>c</code> by applying <code>f</code> to each element using available workers and tasks.</p><p>For multiple collection arguments, apply <code>f</code> elementwise.</p><p>Note that <code>f</code> must be made available to all worker processes; see <a href="../../manual/distributed-computing/#code-availability">Code Availability and Loading Packages</a> for details.</p><p>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</p><p>By default, <code>pmap</code> distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify <code>distributed=false</code>. This is equivalent to using <a href="../../base/parallel/#Base.asyncmap"><code>asyncmap</code></a>. For example, <code>pmap(f, c; distributed=false)</code> is equivalent to <code>asyncmap(f,c; ntasks=()-&gt;nworkers())</code></p><p><code>pmap</code> can also use a mix of processes and tasks via the <code>batch_size</code> argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length <code>batch_size</code> or less. A batch is sent as a single request to a free worker, where a local <a href="../../base/parallel/#Base.asyncmap"><code>asyncmap</code></a> processes elements from the batch using multiple concurrent tasks.</p><p>Any error stops <code>pmap</code> from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument <code>on_error</code> which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.</p><p>Consider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:</p><pre><code class="language-julia-repl hljs">julia&gt; pmap(x-&gt;iseven(x) ? error(&quot;foo&quot;) : x, 1:4; on_error=identity)
4-element Array{Any,1}:
 1
  ErrorException(&quot;foo&quot;)
 3
  ErrorException(&quot;foo&quot;)

julia&gt; pmap(x-&gt;iseven(x) ? error(&quot;foo&quot;) : x, 1:4; on_error=ex-&gt;0)
4-element Array{Int64,1}:
 1
 0
 3
 0</code></pre><p>Errors can also be handled by retrying failed computations. Keyword arguments <code>retry_delays</code> and <code>retry_check</code> are passed through to <a href="../../base/base/#Base.retry"><code>retry</code></a> as keyword arguments <code>delays</code> and <code>check</code> respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.</p><p>Note that if both <code>on_error</code> and <code>retry_delays</code> are specified, the <code>on_error</code> hook is called before retrying. If <code>on_error</code> does not throw (or rethrow) an exception, the element will not be retried.</p><p>Example: On errors, retry <code>f</code> on an element a maximum of 3 times without any delay between retries.</p><pre><code class="language-julia hljs">pmap(f, c; retry_delays = zeros(3))</code></pre><p>Example: Retry <code>f</code> only if the exception is not of type <a href="../../base/base/#Core.InexactError"><code>InexactError</code></a>, with exponentially increasing delays up to 3 times. Return a <code>NaN</code> in place for all <code>InexactError</code> occurrences.</p><pre><code class="language-julia hljs">pmap(f, c; on_error = e-&gt;(isa(e, InexactError) ? NaN : rethrow()), retry_delays = ExponentialBackOff(n = 3))</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/pmap.jl#L32-L98">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.RemoteException"><a class="docstring-binding" href="#Distributed.RemoteException"><code>Distributed.RemoteException</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">RemoteException(captured)</code></pre><p>Exceptions on remote computations are captured and rethrown locally.  A <code>RemoteException</code> wraps the <code>pid</code> of the worker and a captured exception. A <code>CapturedException</code> captures the remote exception and a serializable form of the call stack when the exception was raised.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/process_messages.jl#L54-L60">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.ProcessExitedException"><a class="docstring-binding" href="#Distributed.ProcessExitedException"><code>Distributed.ProcessExitedException</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">ProcessExitedException(worker_id::Int)</code></pre><p>After a client Julia process has exited, further attempts to reference the dead child will throw this exception.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L1077-L1082">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.Future"><a class="docstring-binding" href="#Distributed.Future"><code>Distributed.Future</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Future(w::Int, rrid::RRID, v::Union{Some, Nothing}=nothing)</code></pre><p>A <code>Future</code> is a placeholder for a single computation of unknown termination status and time. For multiple potential computations, see <code>RemoteChannel</code>. See <code>remoteref_id</code> for identifying an <code>AbstractRemoteRef</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L17-L24">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.RemoteChannel"><a class="docstring-binding" href="#Distributed.RemoteChannel"><code>Distributed.RemoteChannel</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">RemoteChannel(pid::Integer=myid())</code></pre><p>Make a reference to a <code>Channel{Any}(1)</code> on process <code>pid</code>. The default <code>pid</code> is the current process.</p><pre><code class="nohighlight hljs">RemoteChannel(f::Function, pid::Integer=myid())</code></pre><p>Create references to remote channels of a specific size and type. <code>f</code> is a function that when executed on <code>pid</code> must return an implementation of an <code>AbstractChannel</code>.</p><p>For example, <code>RemoteChannel(()-&gt;Channel{Int}(10), pid)</code>, will return a reference to a channel of type <code>Int</code> and size 10 on <code>pid</code>.</p><p>The default <code>pid</code> is the current process.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L38-L53">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.fetch-Tuple{Distributed.Future}"><a class="docstring-binding" href="#Base.fetch-Tuple{Distributed.Future}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">fetch(x::Future)</code></pre><p>Wait for and get the value of a <a href="../Future/#Future"><code>Future</code></a>. The fetched value is cached locally. Further calls to <code>fetch</code> on the same reference return the cached value. If the remote value is an exception, throws a <a href="#Distributed.RemoteException"><code>RemoteException</code></a> which captures the remote exception and backtrace.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L595-L601">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.fetch-Tuple{RemoteChannel}"><a class="docstring-binding" href="#Base.fetch-Tuple{RemoteChannel}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">fetch(c::RemoteChannel)</code></pre><p>Wait for and get a value from a <a href="#Distributed.RemoteChannel"><code>RemoteChannel</code></a>. Exceptions raised are the same as for a <a href="../Future/#Future"><code>Future</code></a>. Does not remove the item fetched.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L650-L655">source</a></div><div><pre><code class="language-julia hljs">fetch(x::Any)</code></pre><p>Return <code>x</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/95f30e51f4158dd3421cd5b8098849d24e97e497/base/task.jl#L364-L368">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><a class="docstring-binding" href="#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>Distributed.remotecall</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">remotecall(f, id::Integer, args...; kwargs...) -&gt; Future</code></pre><p>Call a function <code>f</code> asynchronously on the given arguments on the specified process. Return a <a href="../Future/#Future"><code>Future</code></a>. Keyword arguments, if any, are passed through to <code>f</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L440-L446">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.remotecall_wait-Tuple{Any, Integer, Vararg{Any}}"><a class="docstring-binding" href="#Distributed.remotecall_wait-Tuple{Any, Integer, Vararg{Any}}"><code>Distributed.remotecall_wait</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">remotecall_wait(f, id::Integer, args...; kwargs...)</code></pre><p>Perform a faster <code>wait(remotecall(...))</code> in one message on the <code>Worker</code> specified by worker id <code>id</code>. Keyword arguments, if any, are passed through to <code>f</code>.</p><p>See also <a href="../../base/parallel/#Base.wait"><code>wait</code></a> and <a href="#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L511-L518">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.remotecall_fetch-Tuple{Any, Integer, Vararg{Any}}"><a class="docstring-binding" href="#Distributed.remotecall_fetch-Tuple{Any, Integer, Vararg{Any}}"><code>Distributed.remotecall_fetch</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">remotecall_fetch(f, id::Integer, args...; kwargs...)</code></pre><p>Perform <code>fetch(remotecall(...))</code> in one message. Keyword arguments, if any, are passed through to <code>f</code>. Any remote exceptions are captured in a <a href="#Distributed.RemoteException"><code>RemoteException</code></a> and thrown.</p><p>See also <a href="../../base/parallel/#Base.fetch-Tuple{Task}"><code>fetch</code></a> and <a href="#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">$ julia -p 2

julia&gt; remotecall_fetch(sqrt, 2, 4)
2.0

julia&gt; remotecall_fetch(sqrt, 2, -4)
ERROR: On worker 2:
DomainError with -4.0:
sqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
...</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L468-L491">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.remote_do-Tuple{Any, Integer, Vararg{Any}}"><a class="docstring-binding" href="#Distributed.remote_do-Tuple{Any, Integer, Vararg{Any}}"><code>Distributed.remote_do</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">remote_do(f, id::Integer, args...; kwargs...) -&gt; nothing</code></pre><p>Executes <code>f</code> on worker <code>id</code> asynchronously. Unlike <a href="#Distributed.remotecall-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall</code></a>, it does not store the result of computation, nor is there a way to wait for its completion.</p><p>A successful invocation indicates that the request has been accepted for execution on the remote node.</p><p>While consecutive <code>remotecall</code>s to the same worker are serialized in the order they are invoked, the order of executions on the remote worker is undetermined. For example, <code>remote_do(f1, 2); remotecall(f2, 2); remote_do(f3, 2)</code> will serialize the call to <code>f1</code>, followed by <code>f2</code> and <code>f3</code> in that order. However, it is not guaranteed that <code>f1</code> is executed before <code>f3</code> on worker 2.</p><p>Any exceptions thrown by <code>f</code> are printed to <a href="../../base/io-network/#Base.stderr"><code>stderr</code></a> on the remote worker.</p><p>Keyword arguments, if any, are passed through to <code>f</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L537-L556">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.put!-Tuple{RemoteChannel, Vararg{Any}}"><a class="docstring-binding" href="#Base.put!-Tuple{RemoteChannel, Vararg{Any}}"><code>Base.put!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">put!(rr::RemoteChannel, args...)</code></pre><p>Store a set of values to the <a href="#Distributed.RemoteChannel"><code>RemoteChannel</code></a>. If the channel is full, blocks until space is available. Return the first argument.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L715-L721">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.put!-Tuple{Distributed.Future, Any}"><a class="docstring-binding" href="#Base.put!-Tuple{Distributed.Future, Any}"><code>Base.put!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">put!(rr::Future, v)</code></pre><p>Store a value to a <a href="../Future/#Future"><code>Future</code></a> <code>rr</code>. <code>Future</code>s are write-once remote references. A <code>put!</code> on an already set <code>Future</code> throws an <code>Exception</code>. All asynchronous remote calls return <code>Future</code>s and set the value to the return value of the call upon completion.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L660-L668">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.take!-Tuple{RemoteChannel, Vararg{Any}}"><a class="docstring-binding" href="#Base.take!-Tuple{RemoteChannel, Vararg{Any}}"><code>Base.take!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">take!(rr::RemoteChannel, args...)</code></pre><p>Fetch value(s) from a <a href="#Distributed.RemoteChannel"><code>RemoteChannel</code></a> <code>rr</code>, removing the value(s) in the process.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L755-L760">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.isready-Tuple{RemoteChannel, Vararg{Any}}"><a class="docstring-binding" href="#Base.isready-Tuple{RemoteChannel, Vararg{Any}}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">isready(rr::RemoteChannel, args...)</code></pre><p>Determine whether a <a href="#Distributed.RemoteChannel"><code>RemoteChannel</code></a> has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a <a href="../Future/#Future"><code>Future</code></a> since they are assigned only once.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L224-L231">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.isready-Tuple{Distributed.Future}"><a class="docstring-binding" href="#Base.isready-Tuple{Distributed.Future}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">isready(rr::Future)</code></pre><p>Determine whether a <a href="../Future/#Future"><code>Future</code></a> has a value stored to it.</p><p>If the argument <code>Future</code> is owned by a different node, this call will block to wait for the answer. It is recommended to wait for <code>rr</code> in a separate task instead or to use a local <a href="../../base/parallel/#Base.Channel"><code>Channel</code></a> as a proxy:</p><pre><code class="language-julia hljs">p = 1
f = Future(p)
errormonitor(@async put!(f, remotecall_fetch(long_computation, p)))
isready(f)  # will not block</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L196-L211">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.AbstractWorkerPool"><a class="docstring-binding" href="#Distributed.AbstractWorkerPool"><code>Distributed.AbstractWorkerPool</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">AbstractWorkerPool</code></pre><p>Supertype for worker pools such as <a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> and <a href="#Distributed.CachingPool"><code>CachingPool</code></a>. An <code>AbstractWorkerPool</code> should implement:</p><ul><li><a href="../../base/collections/#Base.push!"><code>push!</code></a> - add a new worker to the overall pool (available + busy)</li><li><a href="../../base/parallel/#Base.put!-Tuple{Channel, Any}"><code>put!</code></a> - put back a worker to the available pool</li><li><a href="../../base/io-network/#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a> - take a worker from the available pool (to be used for remote function execution)</li><li><a href="../../base/collections/#Base.length"><code>length</code></a> - number of workers available in the overall pool</li><li><a href="../../base/parallel/#Base.isready-Tuple{Channel}"><code>isready</code></a> - return false if a <code>take!</code> on the pool would block, else true</li></ul><p>The default implementations of the above (on a <code>AbstractWorkerPool</code>) require fields</p><ul><li><code>channel::Channel{Int}</code></li><li><code>workers::Set{Int}</code></li></ul><p>where <code>channel</code> contains free worker pids and <code>workers</code> is the set of all workers associated with this pool.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/workerpool.jl#L3-L18">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.WorkerPool"><a class="docstring-binding" href="#Distributed.WorkerPool"><code>Distributed.WorkerPool</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">WorkerPool(workers::Union{Vector{Int},AbstractRange{Int}})</code></pre><p>Create a <code>WorkerPool</code> from a vector or range of worker ids.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">$ julia -p 3

julia&gt; WorkerPool([2, 3])
WorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:2), Set([2, 3]), RemoteChannel{Channel{Any}}(1, 1, 6))

julia&gt; WorkerPool(2:4)
WorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:2), Set([4, 2, 3]), RemoteChannel{Channel{Any}}(1, 1, 7))</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/workerpool.jl#L35-L50">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.CachingPool"><a class="docstring-binding" href="#Distributed.CachingPool"><code>Distributed.CachingPool</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">CachingPool(workers::Vector{Int})</code></pre><p>An implementation of an <code>AbstractWorkerPool</code>. <a href="#Distributed.remote"><code>remote</code></a>, <a href="#Distributed.remotecall_fetch-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall_fetch</code></a>, <a href="#Distributed.pmap"><code>pmap</code></a> (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).</p><p>The remote cache is maintained for the lifetime of the returned <code>CachingPool</code> object. To clear the cache earlier, use <code>clear!(pool)</code>.</p><p>For global variables, only the bindings are captured in a closure, not the data. <code>let</code> blocks can be used to capture global data.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">const foo = rand(10^8);
wp = CachingPool(workers())
let foo = foo
    pmap(i -&gt; sum(foo) + i, wp, 1:100);
end</code></pre><p>The above would transfer <code>foo</code> only once to each worker.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/workerpool.jl#L306-L332">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.default_worker_pool"><a class="docstring-binding" href="#Distributed.default_worker_pool"><code>Distributed.default_worker_pool</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">default_worker_pool()</code></pre><p><a href="#Distributed.AbstractWorkerPool"><code>AbstractWorkerPool</code></a> containing idle <a href="#Distributed.workers"><code>workers</code></a> - used by <code>remote(f)</code> and <a href="#Distributed.pmap"><code>pmap</code></a> (by default). Unless one is explicitly set via <code>default_worker_pool!(pool)</code>, the default worker pool is initialized to a <a href="#Distributed.WorkerPool"><code>WorkerPool</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">$ julia -p 3

julia&gt; default_worker_pool()
WorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:3), Set([4, 2, 3]), RemoteChannel{Channel{Any}}(1, 1, 4))</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/workerpool.jl#L244-L258">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.clear!-Tuple{CachingPool}"><a class="docstring-binding" href="#Distributed.clear!-Tuple{CachingPool}"><code>Distributed.clear!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">clear!(pool::CachingPool) -&gt; pool</code></pre><p>Removes all cached functions from all participating workers.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/workerpool.jl#L341-L345">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.remote"><a class="docstring-binding" href="#Distributed.remote"><code>Distributed.remote</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">remote([p::AbstractWorkerPool], f) -&gt; Function</code></pre><p>Return an anonymous function that executes function <code>f</code> on an available worker (drawn from <a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> <code>p</code> if provided) using <a href="#Distributed.remotecall_fetch-Tuple{Any, Integer, Vararg{Any}}"><code>remotecall_fetch</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/workerpool.jl#L281-L286">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.remotecall-Tuple{Any, AbstractWorkerPool, Vararg{Any}}"><a class="docstring-binding" href="#Distributed.remotecall-Tuple{Any, AbstractWorkerPool, Vararg{Any}}"><code>Distributed.remotecall</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -&gt; Future</code></pre><p><a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> variant of <code>remotecall(f, pid, ....)</code>. Wait for and take a free worker from <code>pool</code> and perform a <code>remotecall</code> on it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">$ julia -p 3

julia&gt; wp = WorkerPool([2, 3]);

julia&gt; A = rand(3000);

julia&gt; f = remotecall(maximum, wp, A)
Future(2, 1, 6, nothing)</code></pre><p>In this example, the task ran on pid 2, called from pid 1.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/workerpool.jl#L169-L186">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.remotecall_wait-Tuple{Any, AbstractWorkerPool, Vararg{Any}}"><a class="docstring-binding" href="#Distributed.remotecall_wait-Tuple{Any, AbstractWorkerPool, Vararg{Any}}"><code>Distributed.remotecall_wait</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">remotecall_wait(f, pool::AbstractWorkerPool, args...; kwargs...) -&gt; Future</code></pre><p><a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> variant of <code>remotecall_wait(f, pid, ....)</code>. Wait for and take a free worker from <code>pool</code> and perform a <code>remotecall_wait</code> on it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">$ julia -p 3

julia&gt; wp = WorkerPool([2, 3]);

julia&gt; A = rand(3000);

julia&gt; f = remotecall_wait(maximum, wp, A)
Future(3, 1, 9, nothing)

julia&gt; fetch(f)
0.9995177101692958</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/workerpool.jl#L190-L210">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.remotecall_fetch-Tuple{Any, AbstractWorkerPool, Vararg{Any}}"><a class="docstring-binding" href="#Distributed.remotecall_fetch-Tuple{Any, AbstractWorkerPool, Vararg{Any}}"><code>Distributed.remotecall_fetch</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">remotecall_fetch(f, pool::AbstractWorkerPool, args...; kwargs...) -&gt; result</code></pre><p><a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> variant of <code>remotecall_fetch(f, pid, ....)</code>. Waits for and takes a free worker from <code>pool</code> and performs a <code>remotecall_fetch</code> on it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">$ julia -p 3

julia&gt; wp = WorkerPool([2, 3]);

julia&gt; A = rand(3000);

julia&gt; remotecall_fetch(maximum, wp, A)
0.9995177101692958</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/workerpool.jl#L214-L231">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.remote_do-Tuple{Any, AbstractWorkerPool, Vararg{Any}}"><a class="docstring-binding" href="#Distributed.remote_do-Tuple{Any, AbstractWorkerPool, Vararg{Any}}"><code>Distributed.remote_do</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">remote_do(f, pool::AbstractWorkerPool, args...; kwargs...) -&gt; nothing</code></pre><p><a href="#Distributed.WorkerPool"><code>WorkerPool</code></a> variant of <code>remote_do(f, pid, ....)</code>. Wait for and take a free worker from <code>pool</code> and perform a <code>remote_do</code> on it.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/workerpool.jl#L234-L239">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.@spawnat"><a class="docstring-binding" href="#Distributed.@spawnat"><code>Distributed.@spawnat</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@spawnat p expr</code></pre><p>Create a closure around an expression and run the closure asynchronously on process <code>p</code>. Return a <a href="../Future/#Future"><code>Future</code></a> to the result. If <code>p</code> is the quoted literal symbol <code>:any</code>, then the system will pick a processor to use automatically.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addprocs(3);

julia&gt; f = @spawnat 2 myid()
Future(2, 1, 3, nothing)

julia&gt; fetch(f)
2

julia&gt; f = @spawnat :any myid()
Future(3, 1, 7, nothing)

julia&gt; fetch(f)
3</code></pre><div class="admonition is-compat" id="Julia-1.3-dfc157f95bc88dc6"><header class="admonition-header">Julia 1.3<a class="admonition-anchor" href="#Julia-1.3-dfc157f95bc88dc6" title="Permalink"></a></header><div class="admonition-body"><p>The <code>:any</code> argument is available as of Julia 1.3.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/macros.jl#L54-L81">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.@fetch"><a class="docstring-binding" href="#Distributed.@fetch"><code>Distributed.@fetch</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@fetch expr</code></pre><p>Equivalent to <code>fetch(@spawnat :any expr)</code>. See <a href="../../base/parallel/#Base.fetch-Tuple{Task}"><code>fetch</code></a> and <a href="#Distributed.@spawnat"><code>@spawnat</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addprocs(3);

julia&gt; @fetch myid()
2

julia&gt; @fetch myid()
3

julia&gt; @fetch myid()
4

julia&gt; @fetch myid()
2</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/macros.jl#L99-L121">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.@fetchfrom"><a class="docstring-binding" href="#Distributed.@fetchfrom"><code>Distributed.@fetchfrom</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@fetchfrom</code></pre><p>Equivalent to <code>fetch(@spawnat p expr)</code>. See <a href="../../base/parallel/#Base.fetch-Tuple{Task}"><code>fetch</code></a> and <a href="#Distributed.@spawnat"><code>@spawnat</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addprocs(3);

julia&gt; @fetchfrom 2 myid()
2

julia&gt; @fetchfrom 4 myid()
4</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/macros.jl#L127-L143">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.@distributed"><a class="docstring-binding" href="#Distributed.@distributed"><code>Distributed.@distributed</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@distributed</code></pre><p>A distributed memory, parallel for loop of the form :</p><pre><code class="nohighlight hljs">@distributed [reducer] for var = range
    body
end</code></pre><p>The specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, <code>@distributed</code> performs local reductions on each worker with a final reduction on the calling process.</p><p>Note that without a reducer function, <code>@distributed</code> executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with <a href="../../base/parallel/#Base.@sync"><code>@sync</code></a>, like :</p><pre><code class="nohighlight hljs">@sync @distributed for var = range
    body
end</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/macros.jl#L309-L329">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.@everywhere"><a class="docstring-binding" href="#Distributed.@everywhere"><code>Distributed.@everywhere</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">@everywhere [procs()] expr</code></pre><p>Execute an expression under <code>Main</code> on all <code>procs</code>. Errors on any of the processes are collected into a <a href="../../base/base/#Base.CompositeException"><code>CompositeException</code></a> and thrown. For example:</p><pre><code class="nohighlight hljs">@everywhere bar = 1</code></pre><p>will define <code>Main.bar</code> on all current processes. Any processes added later (say with <a href="#Distributed.addprocs"><code>addprocs()</code></a>) will not have the expression defined.</p><p>Unlike <a href="#Distributed.@spawnat"><code>@spawnat</code></a>, <code>@everywhere</code> does not capture any local variables. Instead, local variables can be broadcast using interpolation:</p><pre><code class="nohighlight hljs">foo = 1
@everywhere bar = $foo</code></pre><p>The optional argument <code>procs</code> allows specifying a subset of all processes to have execute the expression.</p><p>Similar to calling <code>remotecall_eval(Main, procs, expr)</code>, but with two extra features:</p><pre><code class="nohighlight hljs">- `using` and `import` statements run on the calling process first, to ensure
  packages are precompiled.
- The current source file path used by `include` is propagated to other processes.</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/macros.jl#L165-L191">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.clear!-Tuple{Any, Any}"><a class="docstring-binding" href="#Distributed.clear!-Tuple{Any, Any}"><code>Distributed.clear!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">clear!(syms, pids=workers(); mod=Main)</code></pre><p>Clears global bindings in modules by initializing them to <code>nothing</code>. <code>syms</code> should be of type <a href="../../base/base/#Core.Symbol"><code>Symbol</code></a> or a collection of <code>Symbol</code>s . <code>pids</code> and <code>mod</code> identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under <code>mod</code> are cleared.</p><p>An exception is raised if a global constant is requested to be cleared.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/clusterserialize.jl#L234-L243">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.remoteref_id"><a class="docstring-binding" href="#Distributed.remoteref_id"><code>Distributed.remoteref_id</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">remoteref_id(r::AbstractRemoteRef) -&gt; RRID</code></pre><p><code>Future</code>s and <code>RemoteChannel</code>s are identified by fields:</p><ul><li><p><code>where</code> - refers to the node where the underlying object/storage referred to by the reference actually exists.</p></li><li><p><code>whence</code> - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling <code>RemoteChannel(2)</code> from the master process would result in a <code>where</code> value of 2 and a <code>whence</code> value of 1.</p></li><li><p><code>id</code> is unique across all references created from the worker specified by <code>whence</code>.</p></li></ul><p>Taken together,  <code>whence</code> and <code>id</code> uniquely identify a reference across all workers.</p><p><code>remoteref_id</code> is a low-level API which returns a <code>RRID</code> object that wraps <code>whence</code> and <code>id</code> values of a remote reference.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L142-L162">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.channel_from_id"><a class="docstring-binding" href="#Distributed.channel_from_id"><code>Distributed.channel_from_id</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">channel_from_id(id) -&gt; c</code></pre><p>A low-level API which returns the backing <code>AbstractChannel</code> for an <code>id</code> returned by <a href="#Distributed.remoteref_id"><code>remoteref_id</code></a>. The call is valid only on the node where the backing channel exists.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/remotecall.jl#L165-L171">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.worker_id_from_socket"><a class="docstring-binding" href="#Distributed.worker_id_from_socket"><code>Distributed.worker_id_from_socket</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">worker_id_from_socket(s) -&gt; pid</code></pre><p>A low-level API which, given a <code>IO</code> connection or a <code>Worker</code>, returns the <code>pid</code> of the worker it is connected to. This is useful when writing custom <a href="../Serialization/#Serialization.serialize"><code>serialize</code></a> methods for a type, which optimizes the data written out depending on the receiving process id.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L1108-L1115">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.cluster_cookie-Tuple{}"><a class="docstring-binding" href="#Distributed.cluster_cookie-Tuple{}"><code>Distributed.cluster_cookie</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">cluster_cookie() -&gt; cookie</code></pre><p>Return the cluster cookie.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L752-L756">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.cluster_cookie-Tuple{Any}"><a class="docstring-binding" href="#Distributed.cluster_cookie-Tuple{Any}"><code>Distributed.cluster_cookie</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">cluster_cookie(cookie) -&gt; cookie</code></pre><p>Set the passed cookie as the cluster cookie, then returns it.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L759-L763">source</a></div></details></article><h2 id="Cluster-Manager-Interface"><a class="docs-heading-anchor" href="#Cluster-Manager-Interface">Cluster Manager Interface</a><a id="Cluster-Manager-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-Manager-Interface" title="Permalink"></a></h2><p>This interface provides a mechanism to launch and manage Julia workers on different cluster environments. There are two types of managers present in Base: <code>LocalManager</code>, for launching additional workers on the same host, and <code>SSHManager</code>, for launching on remote hosts via <code>ssh</code>. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.</p><article><details class="docstring" open="true"><summary id="Distributed.ClusterManager"><a class="docstring-binding" href="#Distributed.ClusterManager"><code>Distributed.ClusterManager</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">ClusterManager</code></pre><p>Supertype for cluster managers, which control workers processes as a cluster. Cluster managers implement how workers can be added, removed and communicated with. <code>SSHManager</code> and <code>LocalManager</code> are subtypes of this.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L3-L9">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.WorkerConfig"><a class="docstring-binding" href="#Distributed.WorkerConfig"><code>Distributed.WorkerConfig</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">WorkerConfig</code></pre><p>Type used by <a href="#Distributed.ClusterManager"><code>ClusterManager</code></a>s to control workers added to their clusters. Some fields are used by all cluster managers to access a host:</p><ul><li><code>io</code> – the connection used to access the worker (a subtype of <code>IO</code> or <code>Nothing</code>)</li><li><code>host</code> – the host address (either a <code>String</code> or <code>Nothing</code>)</li><li><code>port</code> – the port on the host used to connect to the worker (either an <code>Int</code> or <code>Nothing</code>)</li></ul><p>Some are used by the cluster manager to add workers to an already-initialized host:</p><ul><li><code>count</code> – the number of workers to be launched on the host</li><li><code>exename</code> – the path to the Julia executable on the host, defaults to <code>&quot;$(Sys.BINDIR)/julia&quot;</code> or <code>&quot;$(Sys.BINDIR)/julia-debug&quot;</code></li><li><code>exeflags</code> – flags to use when launching Julia remotely</li></ul><p>The <code>userdata</code> field is used to store information for each worker by external managers.</p><p>Some fields are used by <code>SSHManager</code> and similar managers:</p><ul><li><code>tunnel</code> – <code>true</code> (use tunneling), <code>false</code> (do not use tunneling), or <a href="../../base/constants/#Core.nothing"><code>nothing</code></a> (use default for the manager)</li><li><code>multiplex</code> – <code>true</code> (use SSH multiplexing for tunneling) or <code>false</code></li><li><code>forward</code> – the forwarding option used for <code>-L</code> option of ssh</li><li><code>bind_addr</code> – the address on the remote host to bind to</li><li><code>sshflags</code> – flags to use in establishing the SSH connection</li><li><code>max_parallel</code> – the maximum number of workers to connect to in parallel on the host</li></ul><p>Some fields are used by both <code>LocalManager</code>s and <code>SSHManager</code>s:</p><ul><li><code>connect_at</code> – determines whether this is a worker-to-worker or driver-to-worker setup call</li><li><code>process</code> – the process which will be connected (usually the manager will assign this during <a href="#Distributed.addprocs"><code>addprocs</code></a>)</li><li><code>ospid</code> – the process ID according to the host OS, used to interrupt worker processes</li><li><code>environ</code> – private dictionary used to store temporary information by Local/SSH managers</li><li><code>ident</code> – worker as identified by the <a href="#Distributed.ClusterManager"><code>ClusterManager</code></a></li><li><code>connect_idents</code> – list of worker ids the worker must connect to if using a custom topology</li><li><code>enable_threaded_blas</code> – <code>true</code>, <code>false</code>, or <code>nothing</code>, whether to use threaded BLAS or not on the workers</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L12-L45">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.launch"><a class="docstring-binding" href="#Distributed.launch"><code>Distributed.launch</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">launch(manager::ClusterManager, params::Dict, launched::Array, launch_ntfy::Condition)</code></pre><p>Implemented by cluster managers. For every Julia worker launched by this function, it should append a <code>WorkerConfig</code> entry to <code>launched</code> and notify <code>launch_ntfy</code>. The function MUST exit once all workers, requested by <code>manager</code> have been launched. <code>params</code> is a dictionary of all keyword arguments <a href="#Distributed.addprocs"><code>addprocs</code></a> was called with.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/managers.jl#L526-L533">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.manage"><a class="docstring-binding" href="#Distributed.manage"><code>Distributed.manage</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">manage(manager::ClusterManager, id::Integer, config::WorkerConfig. op::Symbol)</code></pre><p>Implemented by cluster managers. It is called on the master process, during a worker&#39;s lifetime, with appropriate <code>op</code> values:</p><ul><li>with <code>:register</code>/<code>:deregister</code> when a worker is added / removed from the Julia worker pool.</li><li>with <code>:interrupt</code> when <code>interrupt(workers)</code> is called. The <code>ClusterManager</code> should signal the appropriate worker with an interrupt signal.</li><li>with <code>:finalize</code> for cleanup purposes.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/managers.jl#L536-L546">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.kill-Tuple{ClusterManager, Int64, WorkerConfig}"><a class="docstring-binding" href="#Base.kill-Tuple{ClusterManager, Int64, WorkerConfig}"><code>Base.kill</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">kill(manager::ClusterManager, pid::Int, config::WorkerConfig)</code></pre><p>Implemented by cluster managers. It is called on the master process, by <a href="#Distributed.rmprocs"><code>rmprocs</code></a>. It should cause the remote worker specified by <code>pid</code> to exit. <code>kill(manager::ClusterManager.....)</code> executes a remote <code>exit()</code> on <code>pid</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/managers.jl#L716-L724">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}"><a class="docstring-binding" href="#Sockets.connect-Tuple{ClusterManager, Int64, WorkerConfig}"><code>Sockets.connect</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">connect(manager::ClusterManager, pid::Int, config::WorkerConfig) -&gt; (instrm::IO, outstrm::IO)</code></pre><p>Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id <code>pid</code>, specified by <code>config</code> and return a pair of <code>IO</code> objects. Messages from <code>pid</code> to current process will be read off <code>instrm</code>, while messages to be sent to <code>pid</code> will be written to <code>outstrm</code>. The custom transport implementation must ensure that messages are delivered and received completely and in order. <code>connect(manager::ClusterManager.....)</code> sets up TCP/IP socket connections in-between workers.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/managers.jl#L556-L566">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.init_worker"><a class="docstring-binding" href="#Distributed.init_worker"><code>Distributed.init_worker</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">init_worker(cookie::AbstractString, manager::ClusterManager=DefaultClusterManager())</code></pre><p>Called by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument <code>--worker[=&lt;cookie&gt;]</code> has the effect of initializing a process as a worker using TCP/IP sockets for transport. <code>cookie</code> is a <a href="#Distributed.cluster_cookie-Tuple{}"><code>cluster_cookie</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L364-L371">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.start_worker"><a class="docstring-binding" href="#Distributed.start_worker"><code>Distributed.start_worker</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">start_worker([out::IO=stdout], cookie::AbstractString=readline(stdin); close_stdin::Bool=true, stderr_to_stdout::Bool=true)</code></pre><p><code>start_worker</code> is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.</p><p>host:port information is written to stream <code>out</code> (defaults to stdout).</p><p>The function reads the cookie from stdin if required, and  listens on a free port (or if specified, the port in the <code>--bind-to</code> command line option) and schedules tasks to process incoming TCP connections and requests. It also (optionally) closes stdin and redirects stderr to stdout.</p><p>It does not return.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L215-L230">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.process_messages"><a class="docstring-binding" href="#Distributed.process_messages"><code>Distributed.process_messages</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">process_messages(r_stream::IO, w_stream::IO, incoming::Bool=true)</code></pre><p>Called by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two <code>IO</code> objects, one for incoming messages and the other for messages addressed to the remote worker. If <code>incoming</code> is <code>true</code>, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.</p><p>See also <a href="#Distributed.cluster_cookie-Tuple{}"><code>cluster_cookie</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/process_messages.jl#L136-L149">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Distributed.default_addprocs_params"><a class="docstring-binding" href="#Distributed.default_addprocs_params"><code>Distributed.default_addprocs_params</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">default_addprocs_params(mgr::ClusterManager) -&gt; Dict{Symbol, Any}</code></pre><p>Implemented by cluster managers. The default keyword parameters passed when calling <code>addprocs(mgr)</code>. The minimal set of options is available by calling <code>default_addprocs_params()</code></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/v1.10.5/stdlib/Distributed/src/cluster.jl#L526-L532">source</a></div></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../DelimitedFiles/">« 分隔符文件</a><a class="docs-footer-nextpage" href="../Downloads/">Downloads »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>本文档在 <span class="colophon-date" title="2025 十一月 16 周日 19:43">2025 十一月 16 周日</span>用 <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> 1.16.0 版生成使用 1.10.10 版本的 Julia。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
