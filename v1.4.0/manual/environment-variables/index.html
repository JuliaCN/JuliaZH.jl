<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>环境变量 · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/environment-variables/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia中文文档</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><span class="tocitem">手册</span><ul><li><a class="tocitem" href="../getting-started/">入门</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../strings/">字符串</a></li><li><a class="tocitem" href="../functions/">函数</a></li><li><a class="tocitem" href="../control-flow/">流程控制</a></li><li><a class="tocitem" href="../variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../types/">类型</a></li><li><a class="tocitem" href="../methods/">方法</a></li><li><a class="tocitem" href="../constructors/">构造函数</a></li><li><a class="tocitem" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../interfaces/">接口</a></li><li><a class="tocitem" href="../modules/">模块</a></li><li><a class="tocitem" href="../documentation/">文档</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../arrays/">多维数组</a></li><li><a class="tocitem" href="../missing/">缺失值</a></li><li><a class="tocitem" href="../networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li class="is-active"><a class="tocitem" href>环境变量</a><ul class="internal"><li><a class="tocitem" href="#文件位置-1"><span>文件位置</span></a></li><li><a class="tocitem" href="#外部应用-1"><span>外部应用</span></a></li><li><a class="tocitem" href="#并行-1"><span>并行</span></a></li><li><a class="tocitem" href="#REPL-格式化输出-1"><span>REPL 格式化输出</span></a></li><li><a class="tocitem" href="#调试和性能分析-1"><span>调试和性能分析</span></a></li></ul></li><li><a class="tocitem" href="../embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../code-loading/">代码加载</a></li><li><a class="tocitem" href="../profile/">性能分析</a></li><li><a class="tocitem" href="../stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../performance-tips/">性能建议</a></li><li><a class="tocitem" href="../workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../faq/">常见问题</a></li><li><a class="tocitem" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="tocitem">Standard Library</span><ul><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">分布式计算</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">交互式组件</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">子数组</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">手册</a></li><li class="is-active"><a href>环境变量</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>环境变量</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/environment-variablesmd" title=" 完善 Transifex 上的翻译"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch"> 完善 Transifex 上的翻译</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="环境变量-1"><a class="docs-heading-anchor" href="#环境变量-1">环境变量</a><a class="docs-heading-anchor-permalink" href="#环境变量-1" title="Permalink"></a></h1><p>Julia 可以配置许多环境变量，一种常见的方式是直接配置操作系统环境变量，另一种更便携的方式是在 Julia 中配置。假设你要将环境变量 <code>JULIA_EDITOR</code> 设置为 <code>vim</code>，可以直接在 REPL 中输入 <code>ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;</code>（请根据具体情况对此进行修改），也可以将其添加到用户主目录中的配置文件 <code>~/.julia/config/startup.jl</code>，这样做会使其永久生效。环境变量的当前值是通过执行 <code>ENV[&quot;JULIA_EDITOR&quot;]</code> 来确定的。</p><p>Julia 使用的环境变量通常以 <code>JULIA</code> 开头。如果调用 <a href="../../stdlib/InteractiveUtils/#InteractiveUtils.versioninfo"><code>InteractiveUtils.versioninfo</code></a> 时关键字参数 <code>verbose = true</code>，那么输出的结果将列出与 Julia 相关的已定义环境变量，即包括那些名称中包含 <code>JULIA</code> 的环境变量。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Some variables, such as <code>JULIA_NUM_THREADS</code> and <code>JULIA_PROJECT</code>, need to be set before Julia starts, therefore adding these to <code>~/.julia/config/startup.jl</code> is too late in the startup process. In Bash, environment variables can either be set manually by running, e.g., <code>export JULIA_NUM_THREADS=4</code> before starting Julia, or by adding the same command to <code>~/.bashrc</code> or <code>~/.bash_profile</code> to set the variable each time Bash is started.</p></div></div><h2 id="文件位置-1"><a class="docs-heading-anchor" href="#文件位置-1">文件位置</a><a class="docs-heading-anchor-permalink" href="#文件位置-1" title="Permalink"></a></h2><h3 id="JULIA_BINDIR-1"><a class="docs-heading-anchor" href="#JULIA_BINDIR-1"><code>JULIA_BINDIR</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_BINDIR-1" title="Permalink"></a></h3><p>包含 Julia 可执行文件的目录的绝对路径，它会设置全局变量 <a href="../../base/constants/#Base.Sys.BINDIR"><code>Sys.BINDIR</code></a>。<code>$JULIA_BINDIR</code> 如果没有设置，那么 Julia 会在运行时确定 <code>Sys.BINDIR</code> 的值。</p><p>在默认情况下，可执行文件是指：</p><pre><code class="language-none">$JULIA_BINDIR/julia
$JULIA_BINDIR/julia-debug</code></pre><p>全局变量 <code>Base.DATAROOTDIR</code> 是一个从 <code>Sys.BINDIR</code> 到 Julia 数据目录的相对路径。</p><pre><code class="language-none">$JULIA_BINDIR/$DATAROOTDIR/julia/base</code></pre><p>上述路径是 Julia 最初搜索源文件的路径（通过 <code>Base.find_source_file()</code>）。</p><p>同样，全局变量 <code>Base.SYSCONFDIR</code> 是一个到配置文件目录的相对路径。在默认情况下，Julia 会在下列文件中搜索 <code>startup.jl</code> 文件（通过 <code>Base.load_julia_startup()</code>）</p><pre><code class="language-none">$JULIA_BINDIR/$SYSCONFDIR/julia/startup.jl
$JULIA_BINDIR/../etc/julia/startup.jl</code></pre><p>例如，一个 Linux 安装包的 Julia 可执行文件位于 <code>/bin/julia</code>，<code>DATAROOTDIR</code> 为 <code>../share</code>，<code>SYSCONFDIR</code> 为 <code>../etc</code>，<code>JULIA_BINDIR</code> 会被设置为 <code>/bin</code>，会有一个源文件搜索路径：</p><pre><code class="language-none">/share/julia/base</code></pre><p>和一个全局配置文件搜索路径：</p><pre><code class="language-none">/etc/julia/startup.jl</code></pre><h3 id="JULIA_PROJECT-1"><a class="docs-heading-anchor" href="#JULIA_PROJECT-1"><code>JULIA_PROJECT</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_PROJECT-1" title="Permalink"></a></h3><p>A directory path that indicates which project should be the initial active project. Setting this environment variable has the same effect as specifying the <code>--project</code> start-up option, but <code>--project</code> has higher precedence. If the variable is set to <code>@.</code> then Julia tries to find a project directory that contains <code>Project.toml</code> or <code>JuliaProject.toml</code> file from the current directory and its parents. See also the chapter on <a href="manual/@ref">Code Loading</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>JULIA_PROJECT</code> must be defined before starting julia; defining it in <code>startup.jl</code> is too late in the startup process.</p></div></div><h3 id="JULIA_LOAD_PATH-1"><a class="docs-heading-anchor" href="#JULIA_LOAD_PATH-1"><code>JULIA_LOAD_PATH</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_LOAD_PATH-1" title="Permalink"></a></h3><p>The <code>JULIA_LOAD_PATH</code> environment variable is used to populate the global Julia <a href="../../base/constants/#Base.LOAD_PATH"><code>LOAD_PATH</code></a> variable, which determines which packages can be loaded via <code>import</code> and <code>using</code> (see <a href="manual/@ref">Code Loading</a>).</p><p>Unlike the shell <code>PATH</code> variable, empty entries in <code>JULIA_LOAD_PATH</code> are expanded to the default value of <code>LOAD_PATH</code>, <code>[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]</code> when populating <code>LOAD_PATH</code>. This allows easy appending, prepending, etc. of the load path value in shell scripts regardless of whether <code>JULIA_LOAD_PATH</code> is already set or not. For example, to prepend the directory <code>/foo/bar</code> to <code>LOAD_PATH</code> just do</p><pre><code class="language-sh">export JULIA_LOAD_PATH=&quot;/foo/bar:$JULIA_LOAD_PATH&quot;</code></pre><p>If the <code>JULIA_LOAD_PATH</code> environment variable is already set, its old value will be prepended with <code>/foo/bar</code>. On the other hand, if <code>JULIA_LOAD_PATH</code> is not set, then it will be set to <code>/foo/bar:</code> which will expand to a <code>LOAD_PATH</code> value of <code>[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]</code>. If <code>JULIA_LOAD_PATH</code> is set to the empty string, it expands to an empty <code>LOAD_PATH</code> array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or if it must have a value, set it to the string <code>:</code>.</p><h3 id="JULIA_DEPOT_PATH-1"><a class="docs-heading-anchor" href="#JULIA_DEPOT_PATH-1"><code>JULIA_DEPOT_PATH</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_DEPOT_PATH-1" title="Permalink"></a></h3><p>The <code>JULIA_DEPOT_PATH</code> environment variable is used to populate the global Julia <a href="manual/@ref"><code>DEPOT_PATH</code></a> variable, which controls where the package manager, as well as Julia&#39;s code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, configuration files, and the default location of the REPL&#39;s history file.</p><p>Unlike the shell <code>PATH</code> variable but similar to <code>JULIA_LOAD_PATH</code>, empty entries in <code>JULIA_DEPOT_PATH</code> are expanded to the default value of <code>DEPOT_PATH</code>. This allows easy appending, prepending, etc. of the depot path value in shell scripts regardless of whether <code>JULIA_DEPOT_PATH</code> is already set or not. For example, to prepend the directory <code>/foo/bar</code> to <code>DEPOT_PATH</code> just do</p><pre><code class="language-sh">export JULIA_DEPOT_PATH=&quot;/foo/bar:$JULIA_DEPOT_PATH&quot;</code></pre><p>If the <code>JULIA_DEPOT_PATH</code> environment variable is already set, its old value will be prepended with <code>/foo/bar</code>. On the other hand, if <code>JULIA_DEPOT_PATH</code> is not set, then it will be set to <code>/foo/bar:</code> which will have the effect of prepending <code>/foo/bar</code> to the default depot path. If <code>JULIA_DEPOT_PATH</code> is set to the empty string, it expands to an empty <code>DEPOT_PATH</code> array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it must have a value, set it to the string <code>:</code>.</p><h3 id="JULIA_HISTORY-1"><a class="docs-heading-anchor" href="#JULIA_HISTORY-1"><code>JULIA_HISTORY</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_HISTORY-1" title="Permalink"></a></h3><p>REPL 历史文件中 <code>REPL.find_hist_file()</code> 的绝对路径。如果没有设置 <code>$JULIA_HISTORY</code>，那么 <code>REPL.find_hist_file()</code> 默认为</p><pre><code class="language-none">$(DEPOT_PATH[1])/logs/repl_history.jl</code></pre><h3 id="JULIA_PKGRESOLVE_ACCURACY-1"><a class="docs-heading-anchor" href="#JULIA_PKGRESOLVE_ACCURACY-1"><code>JULIA_PKGRESOLVE_ACCURACY</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_PKGRESOLVE_ACCURACY-1" title="Permalink"></a></h3><p>一个正的 <code>Int</code> 值，用于约束 <code>MaxSum.maxsum()</code> 的执行时间。此变量默认为 <code>1</code>，更大的值对应更大的时间量。<code>MaxSum.maxsum()</code> 是 <code>max-sum</code> 的子例程，它的作用是解析包的依赖性，在允许的时间内，它会尽可能满足约束，直到放弃。</p><p>假设 <code>$JULIA_PKGRESOLVE_ACCURACY</code> 的值是 <code>n</code>。那么</p><ul><li>预抽取的迭代次数为 <code>20*n</code>，</li><li>抽取步骤间的迭代次数是 <code>10*n</code>，并且</li><li>在抽取步骤中，每 <code>20*n</code> 包中至多有一个被抽取</li></ul><h2 id="外部应用-1"><a class="docs-heading-anchor" href="#外部应用-1">外部应用</a><a class="docs-heading-anchor-permalink" href="#外部应用-1" title="Permalink"></a></h2><h3 id="JULIA_SHELL-1"><a class="docs-heading-anchor" href="#JULIA_SHELL-1"><code>JULIA_SHELL</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_SHELL-1" title="Permalink"></a></h3><p>Julia 用来执行外部命令的 shell 的绝对路径（通过 <code>Base.repl_cmd()</code>）。默认为环境变量 <code>$SHELL</code>，如果 <code>$SHELL</code> 未设置，则为 <code>/bin/sh</code>。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>在 Windows 上，此环境变量将被忽略，并且外部命令会直接被执行。</p></div></div><h3 id="JULIA_EDITOR-1"><a class="docs-heading-anchor" href="#JULIA_EDITOR-1"><code>JULIA_EDITOR</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_EDITOR-1" title="Permalink"></a></h3><p><code>InteractiveUtils.editor()</code> 的返回值–编辑器，例如，<a href="../../stdlib/InteractiveUtils/#InteractiveUtils.edit-Tuple{AbstractString,Integer}"><code>InteractiveUtils.edit</code></a>，会启动偏好编辑器，比如 <code>vim</code>。</p><p><code>$JULIA_EDITOR</code> 优先于 <code>$VISUAL</code>，而后者优先于 <code>$EDITOR</code>。如果这些环境变量都没有设置，那么在 Windows 和 OS X 上会设置为 <code>open</code>，或者 <code>/etc/alternatives/editor</code>（如果存在的话），否则为 <code>emacs</code>。</p><h2 id="并行-1"><a class="docs-heading-anchor" href="#并行-1">并行</a><a class="docs-heading-anchor-permalink" href="#并行-1" title="Permalink"></a></h2><h3 id="JULIA_CPU_THREADS-1"><a class="docs-heading-anchor" href="#JULIA_CPU_THREADS-1"><code>JULIA_CPU_THREADS</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_CPU_THREADS-1" title="Permalink"></a></h3><p>改写全局变量 <a href="../../base/constants/#Base.Sys.CPU_THREADS"><code>Base.Sys.CPU_THREADS</code></a>，逻辑 CPU 核心数。</p><h3 id="JULIA_WORKER_TIMEOUT-1"><a class="docs-heading-anchor" href="#JULIA_WORKER_TIMEOUT-1"><code>JULIA_WORKER_TIMEOUT</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_WORKER_TIMEOUT-1" title="Permalink"></a></h3><p>一个 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> 值，用来确定 <code>Distributed.worker_timeout()</code> 的值（默认：<code>60.0</code>）。此函数提供 worker 进程在死亡之前等待 master 进程建立连接的秒数。</p><h3 id="JULIA_NUM_THREADS-1"><a class="docs-heading-anchor" href="#JULIA_NUM_THREADS-1"><code>JULIA_NUM_THREADS</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_NUM_THREADS-1" title="Permalink"></a></h3><p>一个无符号 64 位整数（<code>uint64_t</code>），用来设置 Julia 可用线程的最大数。如果 <code>$JULIA_NUM_THREADS</code> 超过可用的物理 CPU 核心数，那么线程数设置为核心数。如果 <code>$JULIA_NUM_THREADS</code> 不是正数或没有设置，或者无法通过系统调用确定 CPU 核心数，那么线程数就会被设置为 <code>1</code>。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>JULIA_NUM_THREADS</code> 必须在启动 julia 前定义；在启动过程中于 <code>startup.jl</code> 中定义它为时已晚。</p></div></div><h3 id="JULIA_THREAD_SLEEP_THRESHOLD-1"><a class="docs-heading-anchor" href="#JULIA_THREAD_SLEEP_THRESHOLD-1"><code>JULIA_THREAD_SLEEP_THRESHOLD</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_THREAD_SLEEP_THRESHOLD-1" title="Permalink"></a></h3><p>如果被设置为字符串，并且以大小写敏感的子字符串 <code>&quot;infinite&quot;</code> 开头，那么z自旋线程从不睡眠。否则，<code>$JULIA_THREAD_SLEEP_THRESHOLD</code> 被解释为一个无符号 64 位整数（<code>uint64_t</code>），并且提供以纳秒为单位的自旋线程睡眠的时间量。</p><h3 id="JULIA_EXCLUSIVE-1"><a class="docs-heading-anchor" href="#JULIA_EXCLUSIVE-1"><code>JULIA_EXCLUSIVE</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_EXCLUSIVE-1" title="Permalink"></a></h3><p>如果设置为 <code>0</code> 以外的任何值，那么 Julia 的线程策略与在专用计算机上一致：主线程在 proc 0 上且线程间是关联的。否则，Julia 让操作系统处理线程策略。</p><h2 id="REPL-格式化输出-1"><a class="docs-heading-anchor" href="#REPL-格式化输出-1">REPL 格式化输出</a><a class="docs-heading-anchor-permalink" href="#REPL-格式化输出-1" title="Permalink"></a></h2><p>决定 REPL 应当如何格式化输出的环境变量。通常，这些变量应当被设置为 <a href="http://ascii-table.com/ansi-escape-sequences.php">ANSI 终端转义序列</a>。Julia 提供了具有相同功能的高级接口；请参阅 <a href="../../stdlib/REPL/#Julia-REPL-1">Julia REPL</a> 章节。</p><h3 id="JULIA_ERROR_COLOR-1"><a class="docs-heading-anchor" href="#JULIA_ERROR_COLOR-1"><code>JULIA_ERROR_COLOR</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_ERROR_COLOR-1" title="Permalink"></a></h3><p><code>Base.error_color()</code>（默认值：亮红，<code>&quot;\033[91m&quot;</code>），errors 在终端中的格式。</p><h3 id="JULIA_WARN_COLOR-1"><a class="docs-heading-anchor" href="#JULIA_WARN_COLOR-1"><code>JULIA_WARN_COLOR</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_WARN_COLOR-1" title="Permalink"></a></h3><p><code>Base.warn_color()</code>（默认值：黄，<code>&quot;\033[93m&quot;</code>），warnings 在终端中的格式。</p><h3 id="JULIA_INFO_COLOR-1"><a class="docs-heading-anchor" href="#JULIA_INFO_COLOR-1"><code>JULIA_INFO_COLOR</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_INFO_COLOR-1" title="Permalink"></a></h3><p><code>Base.info_color()</code>（默认值：青，<code>&quot;\033[36m&quot;</code>），info 在终端中的格式。</p><h3 id="JULIA_INPUT_COLOR-1"><a class="docs-heading-anchor" href="#JULIA_INPUT_COLOR-1"><code>JULIA_INPUT_COLOR</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_INPUT_COLOR-1" title="Permalink"></a></h3><p><code>Base.input_color()</code>（默认值：标准，<code>&quot;\033[0m&quot;</code>），在终端中，输入应有的格式。</p><h3 id="JULIA_ANSWER_COLOR-1"><a class="docs-heading-anchor" href="#JULIA_ANSWER_COLOR-1"><code>JULIA_ANSWER_COLOR</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_ANSWER_COLOR-1" title="Permalink"></a></h3><p><code>Base.answer_color()</code>（默认值：标准，<code>&quot;\033[0m&quot;</code>），在终端中，输出应有的格式。</p><h3 id="JULIA_STACKFRAME_LINEINFO_COLOR-1"><a class="docs-heading-anchor" href="#JULIA_STACKFRAME_LINEINFO_COLOR-1"><code>JULIA_STACKFRAME_LINEINFO_COLOR</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_STACKFRAME_LINEINFO_COLOR-1" title="Permalink"></a></h3><p><code>Base.stackframe_lineinfo_color()</code>（默认值：粗体，<code>&quot;\033[1m&quot;</code>），栈跟踪时行信息在终端中的格式。</p><h3 id="JULIA_STACKFRAME_FUNCTION_COLOR-1"><a class="docs-heading-anchor" href="#JULIA_STACKFRAME_FUNCTION_COLOR-1"><code>JULIA_STACKFRAME_FUNCTION_COLOR</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_STACKFRAME_FUNCTION_COLOR-1" title="Permalink"></a></h3><p><code>Base.stackframe_function_color()</code>（默认值：粗体，<code>&quot;\033[1m&quot;</code>），栈跟踪期间函数调用在终端中的形式。</p><h2 id="调试和性能分析-1"><a class="docs-heading-anchor" href="#调试和性能分析-1">调试和性能分析</a><a class="docs-heading-anchor-permalink" href="#调试和性能分析-1" title="Permalink"></a></h2><h3 id="JULIA_GC_ALLOC_POOL,-JULIA_GC_ALLOC_OTHER,-JULIA_GC_ALLOC_PRINT-1"><a class="docs-heading-anchor" href="#JULIA_GC_ALLOC_POOL,-JULIA_GC_ALLOC_OTHER,-JULIA_GC_ALLOC_PRINT-1"><code>JULIA_GC_ALLOC_POOL</code>, <code>JULIA_GC_ALLOC_OTHER</code>, <code>JULIA_GC_ALLOC_PRINT</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_GC_ALLOC_POOL,-JULIA_GC_ALLOC_OTHER,-JULIA_GC_ALLOC_PRINT-1" title="Permalink"></a></h3><p>这些环境变量取值为字符串，可以以字符 <code>‘r’</code> 开头，后接一个由三个带符号 64 位整数（<code>int64_t</code>）组成的、以冒号分割的列表的插值字符串。这个整数的三元组 <code>a:b:c</code> 代表算术序列 <code>a</code>, <code>a + b</code>, <code>a + 2*b</code>, ... <code>c</code>。</p><ul><li>如果是第 <code>n</code> 次调用 <code>jl_gc_pool_alloc()</code>，并且 <code>n</code>   属于 <code>$JULIA_GC_ALLOC_POOL</code> 代表的算术序列，   那么垃圾回收是强制的。</li><li>如果是第 <code>n</code> 次调用 <code>maybe_collect()</code>，并且 <code>n</code> 属于   <code>$JULIA_GC_ALLOC_OTHER</code> 代表的算术序列，那么垃圾   回收是强制的。</li><li>如果是第 <code>n</code> 次调用 <code>jl_gc_alloc()</code>，并且 <code>n</code> 属于   <code>$JULIA_GC_ALLOC_PRINT</code> 代表的算术序列，那么   调用 <code>jl_gc_pool_alloc()</code> 和 <code>maybe_collect()</code> 的次数会   被打印。</li></ul><p>如果这些环境变量的值以字符 <code>‘r&#39;</code> 开头，那么垃圾回收事件间的间隔是随机的。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>这些环境变量生效要求 Julia 在编译时带有垃圾收集调试支持（也就是，在构建配置中将 <code>WITH_GC_DEBUG_ENV</code> 设置为 <code>1</code>）。</p></div></div><h3 id="JULIA_GC_NO_GENERATIONAL-1"><a class="docs-heading-anchor" href="#JULIA_GC_NO_GENERATIONAL-1"><code>JULIA_GC_NO_GENERATIONAL</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_GC_NO_GENERATIONAL-1" title="Permalink"></a></h3><p>如果设置为 <code>0</code> 以外的任何值，那么 Julia 的垃圾收集器将从不执行「快速扫描」内存。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>此环境变量生效要求 Julia 在编译时带有垃圾收集调试支持（也就是，在构建配置中将 <code>WITH_GC_DEBUG_ENV</code> 设置为 <code>1</code>）。</p></div></div><h3 id="JULIA_GC_WAIT_FOR_DEBUGGER-1"><a class="docs-heading-anchor" href="#JULIA_GC_WAIT_FOR_DEBUGGER-1"><code>JULIA_GC_WAIT_FOR_DEBUGGER</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_GC_WAIT_FOR_DEBUGGER-1" title="Permalink"></a></h3><p>如果设置为 <code>0</code> 以外的任何值，Julia 的垃圾收集器每当出现严重错误时将等待调试器连接而不是中止。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>此环境变量生效要求 Julia 在编译时带有垃圾收集调试支持（也就是，在构建配置中将 <code>WITH_GC_DEBUG_ENV</code> 设置为 <code>1</code>）。</p></div></div><h3 id="ENABLE_JITPROFILING-1"><a class="docs-heading-anchor" href="#ENABLE_JITPROFILING-1"><code>ENABLE_JITPROFILING</code></a><a class="docs-heading-anchor-permalink" href="#ENABLE_JITPROFILING-1" title="Permalink"></a></h3><p>如果设置为 <code>0</code> 以外的任何值，那么编译器将为即时（JIT）性能分析创建并注册一个事件监听器。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>此变量生效要求 Julia 编译时带有 JIT 性能分析支持，请使用</p><ul><li>英特尔的 <a href="https://software.intel.com/en-us/intel-vtune-amplifier-xe">VTune™ Amplifier</a>（在构建配置中将 <code>USE_INTEL_JITEVENTS</code> 设置为 <code>1</code>），或</li><li><a href="http://oprofile.sourceforge.net/news/">OProfile</a>（在构建配置中将 <code>USE_OPROFILE_JITEVENTS</code> 设置为 <code>1</code>）。</li></ul></div></div><h3 id="JULIA_LLVM_ARGS-1"><a class="docs-heading-anchor" href="#JULIA_LLVM_ARGS-1"><code>JULIA_LLVM_ARGS</code></a><a class="docs-heading-anchor-permalink" href="#JULIA_LLVM_ARGS-1" title="Permalink"></a></h3><p>传递给 LLVM 后端的参数。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../handling-operating-system-variation/">« 处理操作系统差异</a><a class="docs-footer-nextpage" href="../embedding/">嵌入 Julia »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>本文档在<span class="colophon-date" title="2020 六月 18 周四 17:29">2020 六月 18 周四</span>由<a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>使用1.3.1版本的Julia生成。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
