<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>子数组 · Julia 中文文档</title><meta name="title" content="子数组 · Julia 中文文档"/><meta property="og:title" content="子数组 · Julia 中文文档"/><meta property="twitter:title" content="子数组 · Julia 中文文档"/><meta name="description" content="Documentation for Julia 中文文档."/><meta property="og:description" content="Documentation for Julia 中文文档."/><meta property="twitter:description" content="Documentation for Julia 中文文档."/><meta property="og:url" content="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/subarrays/"/><meta property="twitter:url" content="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/subarrays/"/><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/subarrays/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia 中文文档 logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">一维和多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">标准数值类型</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/reflection/">反射 与 自我检查</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">标准库</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/ArgTools/">ArgTools</a></li><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibCURL/">LibCURL</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/NetworkOptions/">Network Options</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Tar/">Tar</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">开发者文档</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox" checked/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../types/">More about types</a></li><li><a class="tocitem" href="../object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../compiler/">本机代码生成过程的高级概述</a></li><li><a class="tocitem" href="../functions/">Julia 函数</a></li><li><a class="tocitem" href="../cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li class="is-active"><a class="tocitem" href>子数组</a><ul class="internal"><li><a class="tocitem" href="#Index-replacement"><span>Index replacement</span></a></li><li><a class="tocitem" href="#SubArray-design"><span>SubArray design</span></a></li></ul></li><li><a class="tocitem" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../sysimg/">System Image Building</a></li><li><a class="tocitem" href="../pkgimg/">Package Images</a></li><li><a class="tocitem" href="../llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../boundscheck/">边界检查</a></li><li><a class="tocitem" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../require/">Module loading</a></li><li><a class="tocitem" href="../inference/">类型推导</a></li><li><a class="tocitem" href="../ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../build/linux/">Linux</a></li><li><a class="tocitem" href="../build/macos/">macOS</a></li><li><a class="tocitem" href="../build/windows/">Windows</a></li><li><a class="tocitem" href="../build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">开发者文档</a></li><li><a class="is-disabled">Documentation of Julia&#39;s Internals</a></li><li class="is-active"><a href>子数组</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>子数组</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/zh_CN/doc/src/devdocs/subarrays.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="子数组"><a class="docs-heading-anchor" href="#子数组">子数组</a><a id="子数组-1"></a><a class="docs-heading-anchor-permalink" href="#子数组" title="Permalink"></a></h1><p>Julia 的 <code>SubArray</code> 类型是编码父类型 <a href="../../base/arrays/#Core.AbstractArray"><code>AbstractArray</code></a> 的“视图”的一个容器。本页介绍了 <code>SubArray</code> 的一些设计原则和实现。</p><p>One of the major design goals is to ensure high performance for views of both <a href="../../base/arrays/#Base.IndexLinear"><code>IndexLinear</code></a> and <a href="../../base/arrays/#Base.IndexCartesian"><code>IndexCartesian</code></a> arrays. Furthermore, views of <code>IndexLinear</code> arrays should themselves be <code>IndexLinear</code> to the extent that it is possible.</p><h2 id="Index-replacement"><a class="docs-heading-anchor" href="#Index-replacement">Index replacement</a><a id="Index-replacement-1"></a><a class="docs-heading-anchor-permalink" href="#Index-replacement" title="Permalink"></a></h2><p>Consider making 2d slices of a 3d array:</p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(2,3,4);

julia&gt; S1 = view(A, :, 1, 2:3)
2×2 view(::Array{Float64, 3}, :, 1, 2:3) with eltype Float64:
 0.839622  0.711389
 0.967143  0.103929

julia&gt; S2 = view(A, 1, :, 2:3)
3×2 view(::Array{Float64, 3}, 1, :, 2:3) with eltype Float64:
 0.839622  0.711389
 0.789764  0.806704
 0.566704  0.962715</code></pre><p><code>view</code> drops &quot;singleton&quot; dimensions (ones that are specified by an <code>Int</code>), so both <code>S1</code> and <code>S2</code> are two-dimensional <code>SubArray</code>s. Consequently, the natural way to index these is with <code>S1[i,j]</code>. To extract the value from the parent array <code>A</code>, the natural approach is to replace <code>S1[i,j]</code> with <code>A[i,1,(2:3)[j]]</code> and <code>S2[i,j]</code> with <code>A[1,i,(2:3)[j]]</code>.</p><p>The key feature of the design of SubArrays is that this index replacement can be performed without any runtime overhead.</p><h2 id="SubArray-design"><a class="docs-heading-anchor" href="#SubArray-design">SubArray design</a><a id="SubArray-design-1"></a><a class="docs-heading-anchor-permalink" href="#SubArray-design" title="Permalink"></a></h2><h3 id="Type-parameters-and-fields"><a class="docs-heading-anchor" href="#Type-parameters-and-fields">Type parameters and fields</a><a id="Type-parameters-and-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Type-parameters-and-fields" title="Permalink"></a></h3><p>The strategy adopted is first and foremost expressed in the definition of the type:</p><pre><code class="language-julia hljs">struct SubArray{T,N,P,I,L} &lt;: AbstractArray{T,N}
    parent::P
    indices::I
    offset1::Int       # for linear indexing and pointer, only valid when L==true
    stride1::Int       # used only for linear indexing
    ...
end</code></pre><p><code>SubArray</code> has 5 type parameters.  The first two are the standard element type and dimensionality.  The next is the type of the parent <code>AbstractArray</code>.  The most heavily-used is the fourth parameter, a <code>Tuple</code> of the types of the indices for each dimension. The final one, <code>L</code>, is only provided as a convenience for dispatch; it&#39;s a boolean that represents whether the index types support fast linear indexing. More on that later.</p><p>If in our example above <code>A</code> is a <code>Array{Float64, 3}</code>, our <code>S1</code> case above would be a <code>SubArray{Float64,2,Array{Float64,3},Tuple{Base.Slice{Base.OneTo{Int64}},Int64,UnitRange{Int64}},false}</code>. Note in particular the tuple parameter, which stores the types of the indices used to create <code>S1</code>. Likewise,</p><pre><code class="language-julia-repl hljs">julia&gt; S1.indices
(Base.Slice(Base.OneTo(2)), 1, 2:3)</code></pre><p>Storing these values allows index replacement, and having the types encoded as parameters allows one to dispatch to efficient algorithms.</p><h3 id="Index-translation"><a class="docs-heading-anchor" href="#Index-translation">Index translation</a><a id="Index-translation-1"></a><a class="docs-heading-anchor-permalink" href="#Index-translation" title="Permalink"></a></h3><p>Performing index translation requires that you do different things for different concrete <code>SubArray</code> types.  For example, for <code>S1</code>, one needs to apply the <code>i,j</code> indices to the first and third dimensions of the parent array, whereas for <code>S2</code> one needs to apply them to the second and third.  The simplest approach to indexing would be to do the type-analysis at runtime:</p><pre><code class="language-julia hljs">parentindices = Vector{Any}()
for thisindex in S.indices
    ...
    if isa(thisindex, Int)
        # Don&#39;t consume one of the input indices
        push!(parentindices, thisindex)
    elseif isa(thisindex, AbstractVector)
        # Consume an input index
        push!(parentindices, thisindex[inputindex[j]])
        j += 1
    elseif isa(thisindex, AbstractMatrix)
        # Consume two input indices
        push!(parentindices, thisindex[inputindex[j], inputindex[j+1]])
        j += 2
    elseif ...
end
S.parent[parentindices...]</code></pre><p>Unfortunately, this would be disastrous in terms of performance: each element access would allocate memory, and involves the running of a lot of poorly-typed code.</p><p>The better approach is to dispatch to specific methods to handle each type of stored index. That&#39;s what <code>reindex</code> does: it dispatches on the type of the first stored index and consumes the appropriate number of input indices, and then it recurses on the remaining indices. In the case of <code>S1</code>, this expands to</p><pre><code class="language-julia hljs">Base.reindex(S1, S1.indices, (i, j)) == (i, S1.indices[2], S1.indices[3][j])</code></pre><p>for any pair of indices <code>(i,j)</code> (except <a href="../../base/arrays/#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex</code></a>s and arrays thereof, see below).</p><p>This is the core of a <code>SubArray</code>; indexing methods depend upon <code>reindex</code> to do this index translation. Sometimes, though, we can avoid the indirection and make it even faster.</p><h3 id="Linear-indexing"><a class="docs-heading-anchor" href="#Linear-indexing">Linear indexing</a><a id="Linear-indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-indexing" title="Permalink"></a></h3><p>Linear indexing can be implemented efficiently when the entire array has a single stride that separates successive elements, starting from some offset. This means that we can pre-compute these values and represent linear indexing simply as an addition and multiplication, avoiding the indirection of <code>reindex</code> and (more importantly) the slow computation of the cartesian coordinates entirely.</p><p>For <code>SubArray</code> types, the availability of efficient linear indexing is based purely on the types of the indices, and does not depend on values like the size of the parent array. You can ask whether a given set of indices supports fast linear indexing with the internal <code>Base.viewindexing</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; Base.viewindexing(S1.indices)
IndexCartesian()

julia&gt; Base.viewindexing(S2.indices)
IndexLinear()</code></pre><p>This is computed during construction of the <code>SubArray</code> and stored in the <code>L</code> type parameter as a boolean that encodes fast linear indexing support. While not strictly necessary, it means that we can define dispatch directly on <code>SubArray{T,N,A,I,true}</code> without any intermediaries.</p><p>Since this computation doesn&#39;t depend on runtime values, it can miss some cases in which the stride happens to be uniform:</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(1:4*2, 4, 2)
4×2 reshape(::UnitRange{Int64}, 4, 2) with eltype Int64:
 1  5
 2  6
 3  7
 4  8

julia&gt; diff(A[2:2:4,:][:])
3-element Vector{Int64}:
 2
 2
 2</code></pre><p>A view constructed as <code>view(A, 2:2:4, :)</code> happens to have uniform stride, and therefore linear indexing indeed could be performed efficiently.  However, success in this case depends on the size of the array: if the first dimension instead were odd,</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(1:5*2, 5, 2)
5×2 reshape(::UnitRange{Int64}, 5, 2) with eltype Int64:
 1   6
 2   7
 3   8
 4   9
 5  10

julia&gt; diff(A[2:2:4,:][:])
3-element Vector{Int64}:
 2
 3
 2</code></pre><p>then <code>A[2:2:4,:]</code> does not have uniform stride, so we cannot guarantee efficient linear indexing.  Since we have to base this decision based purely on types encoded in the parameters of the <code>SubArray</code>, <code>S = view(A, 2:2:4, :)</code> cannot implement efficient linear indexing.</p><h3 id="A-few-details"><a class="docs-heading-anchor" href="#A-few-details">A few details</a><a id="A-few-details-1"></a><a class="docs-heading-anchor-permalink" href="#A-few-details" title="Permalink"></a></h3><ul><li><p>Note that the <code>Base.reindex</code> function is agnostic to the types of the input indices; it simply determines how and where the stored indices should be reindexed. It not only supports integer indices, but it supports non-scalar indexing, too. This means that views of views don&#39;t need two levels of indirection; they can simply re-compute the indices into the original parent array!</p></li><li><p>Hopefully by now it&#39;s fairly clear that supporting slices means that the dimensionality, given by the parameter <code>N</code>, is not necessarily equal to the dimensionality of the parent array or the length of the <code>indices</code> tuple.  Neither do user-supplied indices necessarily line up with entries in the <code>indices</code> tuple (e.g., the second user-supplied index might correspond to the third dimension of the parent array, and the third element in the <code>indices</code> tuple).</p><p>What might be less obvious is that the dimensionality of the stored parent array must be equal to the number of effective indices in the <code>indices</code> tuple. Some examples:</p><pre><code class="language-julia hljs">A = reshape(1:35, 5, 7) # A 2d parent Array
S = view(A, 2:7)         # A 1d view created by linear indexing
S = view(A, :, :, 1:1)   # Appending extra indices is supported</code></pre><p>Naively, you&#39;d think you could just set <code>S.parent = A</code> and <code>S.indices = (:,:,1:1)</code>, but supporting this dramatically complicates the reindexing process, especially for views of views. Not only do you need to dispatch on the types of the stored indices, but you need to examine whether a given index is the final one and &quot;merge&quot; any remaining stored indices together. This is not an easy task, and even worse: it&#39;s slow since it implicitly depends upon linear indexing.</p><p>Fortunately, this is precisely the computation that <code>ReshapedArray</code> performs, and it does so linearly if possible. Consequently, <code>view</code> ensures that the parent array is the appropriate dimensionality for the given indices by reshaping it if needed. The inner <code>SubArray</code> constructor ensures that this invariant is satisfied.</p></li><li><p><a href="../../base/arrays/#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex</code></a> and arrays thereof throw a nasty wrench into the <code>reindex</code> scheme. Recall that <code>reindex</code> simply dispatches on the type of the stored indices in order to determine how many passed indices should be used and where they should go. But with <code>CartesianIndex</code>, there&#39;s no longer a one-to-one correspondence between the number of passed arguments and the number of dimensions that they index into. If we return to the above example of <code>Base.reindex(S1, S1.indices, (i, j))</code>, you can see that the expansion is incorrect for <code>i, j = CartesianIndex(), CartesianIndex(2,1)</code>. It should <em>skip</em> the <code>CartesianIndex()</code> entirely and return:</p><pre><code class="language-julia hljs">(CartesianIndex(2,1)[1], S1.indices[2], S1.indices[3][CartesianIndex(2,1)[2]])</code></pre><p>Instead, though, we get:</p><pre><code class="language-julia hljs">(CartesianIndex(), S1.indices[2], S1.indices[3][CartesianIndex(2,1)])</code></pre><p>Doing this correctly would require <em>combined</em> dispatch on both the stored and passed indices across all combinations of dimensionalities in an intractable manner. As such, <code>reindex</code> must never be called with <code>CartesianIndex</code> indices. Fortunately, the scalar case is easily handled by first flattening the <code>CartesianIndex</code> arguments to plain integers. Arrays of <code>CartesianIndex</code>, however, cannot be split apart into orthogonal pieces so easily. Before attempting to use <code>reindex</code>, <code>view</code> must ensure that there are no arrays of <code>CartesianIndex</code> in the argument list. If there are, it can simply &quot;punt&quot; by avoiding the <code>reindex</code> calculation entirely, constructing a nested <code>SubArray</code> with two levels of indirection instead.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../meta/">« Talking to the compiler (the <code>:meta</code> mechanism)</a><a class="docs-footer-nextpage" href="../isbitsunionarrays/">isbits Union Optimizations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>本文档在 <span class="colophon-date" title="2024 十二月 21 周六 07:34">2024 十二月 21 周六</span>用 <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> 1.8.0 版生成使用 1.10.7 版本的 Julia。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
