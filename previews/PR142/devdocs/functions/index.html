<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Julia 函数 · Julia 中文文档</title><meta name="title" content="Julia 函数 · Julia 中文文档"/><meta property="og:title" content="Julia 函数 · Julia 中文文档"/><meta property="twitter:title" content="Julia 函数 · Julia 中文文档"/><meta name="description" content="Documentation for Julia 中文文档."/><meta property="og:description" content="Documentation for Julia 中文文档."/><meta property="twitter:description" content="Documentation for Julia 中文文档."/><meta property="og:url" content="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/functions/"/><meta property="twitter:url" content="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/functions/"/><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/functions/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-9"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-9', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Julia 中文文档 logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">主页</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">手册</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">入门</a></li><li><a class="tocitem" href="../../manual/variables/">变量</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="tocitem" href="../../manual/strings/">字符串</a></li><li><a class="tocitem" href="../../manual/functions/">函数</a></li><li><a class="tocitem" href="../../manual/control-flow/">流程控制</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="tocitem" href="../../manual/types/">类型</a></li><li><a class="tocitem" href="../../manual/methods/">方法</a></li><li><a class="tocitem" href="../../manual/constructors/">构造函数</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="tocitem" href="../../manual/interfaces/">接口</a></li><li><a class="tocitem" href="../../manual/modules/">模块</a></li><li><a class="tocitem" href="../../manual/documentation/">文档</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">元编程</a></li><li><a class="tocitem" href="../../manual/arrays/">一维和多维数组</a></li><li><a class="tocitem" href="../../manual/missing/">缺失值</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">异步编程</a></li><li><a class="tocitem" href="../../manual/multi-threading/">多线程</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">多进程和分布式计算</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="tocitem" href="../../manual/environment-variables/">环境变量</a></li><li><a class="tocitem" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">代码加载</a></li><li><a class="tocitem" href="../../manual/profile/">性能分析</a></li><li><a class="tocitem" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="tocitem" href="../../manual/performance-tips/">性能建议</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="tocitem" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="tocitem" href="../../manual/faq/">常见问题</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode 输入表</a></li><li><a class="tocitem" href="../../manual/command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">基本功能</a></li><li><a class="tocitem" href="../../base/collections/">集合和数据结构</a></li><li><a class="tocitem" href="../../base/math/">数学相关</a></li><li><a class="tocitem" href="../../base/numbers/">标准数值类型</a></li><li><a class="tocitem" href="../../base/strings/">字符串</a></li><li><a class="tocitem" href="../../base/arrays/">数组</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">常量</a></li><li><a class="tocitem" href="../../base/file/">文件系统</a></li><li><a class="tocitem" href="../../base/io-network/">I/O 与网络</a></li><li><a class="tocitem" href="../../base/punctuation/">运算符与记号</a></li><li><a class="tocitem" href="../../base/sort/">排序及相关函数</a></li><li><a class="tocitem" href="../../base/iterators/">迭代相关</a></li><li><a class="tocitem" href="../../base/reflection/">反射 与 自我检查</a></li><li><a class="tocitem" href="../../base/c/">C 接口</a></li><li><a class="tocitem" href="../../base/libc/">C 标准库</a></li><li><a class="tocitem" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">标准库</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">日期</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">日志记录</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">性能分析</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">随机数</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">序列化</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">套接字</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">统计</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">单元测试</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">开发者文档</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox" checked/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../init/">Julia 运行时的初始化</a></li><li><a class="tocitem" href="../ast/">Julia 的 AST</a></li><li><a class="tocitem" href="../types/">More about types</a></li><li><a class="tocitem" href="../object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../eval/">Julia 代码的 eval</a></li><li><a class="tocitem" href="../callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../compiler/">本机代码生成过程的高级概述</a></li><li class="is-active"><a class="tocitem" href>Julia 函数</a><ul class="internal"><li><a class="tocitem" href="#方法表"><span>方法表</span></a></li><li><a class="tocitem" href="#Function-calls"><span>函数调用</span></a></li><li><a class="tocitem" href="#添加方法"><span>添加方法</span></a></li><li><a class="tocitem" href="#创建泛型函数"><span>创建泛型函数</span></a></li><li><a class="tocitem" href="#闭包"><span>闭包</span></a></li><li><a class="tocitem" href="#构造函数"><span>构造函数</span></a></li><li><a class="tocitem" href="#内置函数"><span>内置函数</span></a></li><li><a class="tocitem" href="#关键字参数"><span>关键字参数</span></a></li><li><a class="tocitem" href="#compiler-efficiency-issues"><span>Compiler efficiency issues</span></a></li></ul></li><li><a class="tocitem" href="../cartesian/">笛卡尔</a></li><li><a class="tocitem" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../subarrays/">子数组</a></li><li><a class="tocitem" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../sysimg/">System Image Building</a></li><li><a class="tocitem" href="../pkgimg/">Package Images</a></li><li><a class="tocitem" href="../llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../boundscheck/">边界检查</a></li><li><a class="tocitem" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../require/">Module loading</a></li><li><a class="tocitem" href="../inference/">类型推导</a></li><li><a class="tocitem" href="../ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="tocitem" href="../debuggingtips/">gdb 调试提示</a></li><li><a class="tocitem" href="../valgrind/">在Julia中使用Valgrind</a></li><li><a class="tocitem" href="../external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../build/linux/">Linux</a></li><li><a class="tocitem" href="../build/macos/">macOS</a></li><li><a class="tocitem" href="../build/windows/">Windows</a></li><li><a class="tocitem" href="../build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">开发者文档</a></li><li><a class="is-disabled">Documentation of Julia&#39;s Internals</a></li><li class="is-active"><a href>Julia 函数</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Julia 函数</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl" title="View the repository"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCN/JuliaZH.jl/blob/master/zh_CN/doc/src/devdocs/functions.md" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Julia-函数"><a class="docs-heading-anchor" href="#Julia-函数">Julia 函数</a><a id="Julia-函数-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-函数" title="Permalink"></a></h1><p>本文档将解释函数、方法定义以及方法表是如何工作的。</p><h2 id="方法表"><a class="docs-heading-anchor" href="#方法表">方法表</a><a id="方法表-1"></a><a class="docs-heading-anchor-permalink" href="#方法表" title="Permalink"></a></h2><p>Julia 中的每个函数都是泛型函数。泛型函数在概念上是单个函数，但由许多定义或方法组成。泛型函数的方法储存在方法表中。方法表（类型 <code>MethodTable</code>）与 <code>TypeName</code> 相关。<code>TypeName</code> 描述了一系列参数化类型。例如，<code>Complex{Float32}</code> 和 <code>Complex{Float64}</code> 共享相同的 type name 对象 <code>Complex</code>。</p><p>Julia 中的所有对象都可能是可调用的，因为每个对象都有类型，而类型又有 <code>TypeName</code>。</p><h2 id="Function-calls"><a class="docs-heading-anchor" href="#Function-calls">函数调用</a><a id="Function-calls-1"></a><a class="docs-heading-anchor-permalink" href="#Function-calls" title="Permalink"></a></h2><p>给定调用 <code>f(x,y)</code>，会执行以下步骤：首先，用 <code>typeof(f).name.mt</code> 访问要使用的方法表。其次，生成一个参数元组类型 <code>Tuple{typeof(f), typeof(x), typeof(y)}</code>。请注意，函数本身的类型是第一个元素。这因为该类型可能有参数，所以需要参与派发。这个元组类型会在方法表中查找。</p><p>这个派发过程由 <code>jl_apply_generic</code> 执行，它有两个参数：一个指向由值 f、x 和 y 组成的数组的指针，以及值的数量（此例中是 3）。</p><p>在整个系统中，处理函数和参数列表的 API 有两种：一种单独接收函数和参数，一种接收一个单独的参数结构。在第一种 API 中，「参数」部分<em>不</em>包含函数的相关信息，因为它是单独传递的。在第二种 API 中，函数是参数结构的第一个元素。</p><p>例如，以下用于执行调用的函数只接收 <code>args</code> 指针，因此 args 数组的第一个元素将会是要调用的函数：</p><pre><code class="language-c hljs">jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)</code></pre><p>这个用于相同功能的入口点单独接收该函数，因此 <code>args</code> 数组中不包含该函数：</p><pre><code class="language-c hljs">jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);</code></pre><h2 id="添加方法"><a class="docs-heading-anchor" href="#添加方法">添加方法</a><a id="添加方法-1"></a><a class="docs-heading-anchor-permalink" href="#添加方法" title="Permalink"></a></h2><p>Given the above dispatch process, conceptually all that is needed to add a new method is (1) a tuple type, and (2) code for the body of the method. <code>jl_method_def</code> implements this operation. <code>jl_method_table_for</code> is called to extract the relevant method table from what would be the type of the first argument. This is much more complicated than the corresponding procedure during dispatch, since the argument tuple type might be abstract. For example, we can define:</p><pre><code class="language-julia hljs">(::Union{Foo{Int},Foo{Int8}})(x) = 0</code></pre><p>这是可行的，因为所有可能的匹配方法都属于同一方法表。</p><h2 id="创建泛型函数"><a class="docs-heading-anchor" href="#创建泛型函数">创建泛型函数</a><a id="创建泛型函数-1"></a><a class="docs-heading-anchor-permalink" href="#创建泛型函数" title="Permalink"></a></h2><p>因为每个对象都是可调用的，所以创建泛型函数不需要特殊的东西。因此，<code>jl_new_generic_function</code> 只是创建一个新的 <code>Function</code> 的单态类型（大小为 0）并返回它的实例。函数可有一个帮助记忆的「显示名称」，用于调试信息和打印对象。例如，<code>Base.sin</code> 的名称为 <code>sin</code>。按照约定，所创建<em>类型</em>的名称与函数名称相同，带前缀 <code>#</code>。所以 <code>typeof(sin)</code> 即 <code>Base.#sin</code>。</p><h2 id="闭包"><a class="docs-heading-anchor" href="#闭包">闭包</a><a id="闭包-1"></a><a class="docs-heading-anchor-permalink" href="#闭包" title="Permalink"></a></h2><p>闭包只是一个可调用对象，其字段名称对应于被捕获的变量。例如，以下代码：</p><pre><code class="language-julia hljs">function adder(x)
    return y-&gt;x+y
end</code></pre><p>（大致）降低为：</p><pre><code class="language-julia hljs">struct ##1{T}
    x::T
end

(_::##1)(y) = _.x + y

function adder(x)
    return ##1(x)
end</code></pre><h2 id="构造函数"><a class="docs-heading-anchor" href="#构造函数">构造函数</a><a id="构造函数-1"></a><a class="docs-heading-anchor-permalink" href="#构造函数" title="Permalink"></a></h2><p>构造函数调用只是对类型的调用。<code>Type</code> 的方法表包含所有的构造函数定义。<code>Type</code> 的所有子类型（<code>Type</code>、<code>UnionAll</code>、<code>Union</code> 和 <code>DataType</code>）目前通过特殊的安排方式共享一个方法表。</p><h2 id="内置函数"><a class="docs-heading-anchor" href="#内置函数">内置函数</a><a id="内置函数-1"></a><a class="docs-heading-anchor-permalink" href="#内置函数" title="Permalink"></a></h2><p>「内置」函数定义在 <code>Core</code> 模块中，有：</p><pre><code class="nohighlight hljs">&lt;: === _abstracttype _apply_iterate _apply_pure _call_in_world
_call_in_world_total _call_latest _compute_sparams _equiv_typedef _expr
_primitivetype _setsuper! _structtype _svec_ref _typebody! _typevar applicable
apply_type arrayref arrayset arraysize compilerbarrier const_arrayref donotdelete
fieldtype finalizer get_binding_type getfield getglobal ifelse invoke isa
isdefined modifyfield! nfields replacefield! set_binding_type! setfield!
setglobal! sizeof svec swapfield! throw tuple typeassert typeof</code></pre><p>这些都是单态对象，其类型为 <code>Builtin</code> 的子类型，而或后者为 <code>Function</code> 的子类型。它们的用处是在运行时暴露遵循「jlcall」调用约定的入口点。</p><pre><code class="language-c hljs">jl_value_t *(jl_value_t*, jl_value_t**, uint32_t)</code></pre><p>内建函数的方法表是空的。相反地，它们具有单独的 catch-all 方法缓存条目（<code>Tuple{Vararg{Any}}</code>），其 jlcall fptr 指向正确的函数。这是一种 hack，但效果相当不错。</p><h2 id="关键字参数"><a class="docs-heading-anchor" href="#关键字参数">关键字参数</a><a id="关键字参数-1"></a><a class="docs-heading-anchor-permalink" href="#关键字参数" title="Permalink"></a></h2><p>Keyword arguments work by adding methods to the kwcall function. This function is usually the &quot;keyword argument sorter&quot; or &quot;keyword sorter&quot;, which then calls the inner body of the function (defined anonymously). Every definition in the kwsorter function has the same arguments as some definition in the normal method table, except with a single <code>NamedTuple</code> argument prepended, which gives the names and values of passed keyword arguments. The kwsorter&#39;s job is to move keyword arguments into their canonical positions based on name, plus evaluate and substitute any needed default value expressions. The result is a normal positional argument list, which is then passed to yet another compiler-generated function.</p><p>理解该过程的最简单方法是查看关键字参数方法的定义的降低方式。代码：</p><pre><code class="language-julia hljs">function circle(center, radius; color = black, fill::Bool = true, options...)
    # draw
end</code></pre><p>实际上生成<em>三个</em>方法定义。第一个方法是一个接收所有参数（包括关键字参数）作为其位置参数的函数，其代码包含该方法体。它有一个自动生成的名称：</p><pre><code class="language-julia hljs">function #circle#1(color, fill::Bool, options, circle, center, radius)
    # draw
end</code></pre><p>第二个方法是原始 <code>circle</code> 函数的普通定义，负责处理没有传递关键字参数的情况：</p><pre><code class="language-julia hljs">function circle(center, radius)
    #circle#1(black, true, pairs(NamedTuple()), circle, center, radius)
end</code></pre><p>这只是派发到第一个方法，传递默认值。<code>pairs</code> 应用于其余的参数组成的具名元组，以提供键值对迭代。请注意，如果方法不接受其余的关键字参数，那么此参数不存在。</p><p>最后，kwsorter 定义为：</p><pre><code class="nohighlight hljs">function (::Core.kwftype(typeof(circle)))(kws, circle, center, radius)
    if haskey(kws, :color)
        color = kws.color
    else
        color = black
    end
    # etc.

    # put remaining kwargs in `options`
    options = structdiff(kws, NamedTuple{(:color, :fill)})

    # if the method doesn&#39;t accept rest keywords, throw an error
    # unless `options` is empty

    #circle#1(color, fill, pairs(options), circle, center, radius)
end</code></pre><p>函数 <code>Core.kwftype(t)</code> 创建字段 <code>t.name.mt.kwsorter</code>（如果它未被创建），并返回该函数的类型。</p><p>此设计的特点是不使用关键字参数的调用点不需要特殊处理；这一切的工作方式好像它们根本不是语言的一部分。不使用关键字参数的调用点直接派发到被调用函数的 kwsorter。例如，调用：</p><pre><code class="language-julia hljs">circle((0,0), 1.0, color = red; other...)</code></pre><p>降低为：</p><pre><code class="language-julia hljs">kwcall(merge((color = red,), other), circle, (0,0), 1.0)</code></pre><p><code>kwcall</code> (also in<code>Core</code>) denotes a kwcall signature and dispatch. The keyword splatting operation (written as <code>other...</code>) calls the named tuple <code>merge</code> function. This function further unpacks each <em>element</em> of <code>other</code>, expecting each one to contain two values (a symbol and a value). Naturally, a more efficient implementation is available if all splatted arguments are named tuples. Notice that the original <code>circle</code> function is passed through, to handle closures.</p><h2 id="compiler-efficiency-issues"><a class="docs-heading-anchor" href="#compiler-efficiency-issues">Compiler efficiency issues</a><a id="compiler-efficiency-issues-1"></a><a class="docs-heading-anchor-permalink" href="#compiler-efficiency-issues" title="Permalink"></a></h2><p>为每个函数生成新类型在与 Julia 的「默认专门化所有参数」这一设计理念结合使用时，可能对编译器资源的使用产生严重后果。实际上，此设计的初始实现经历了更长的测试和构造时间、高内存占用以及比基线大近乎 2 倍的系统镜像。在一个幼稚的实现中，该问题非常严重，以至于系统几乎无法使用。需要进行几项重要的优化才能使设计变得可行。</p><p>第一个问题是函数值参数的不同值导致函数的过度专门化。许多函数只是将参数「传递」到其它地方，例如，到另一个函数或存储位置。这种函数不需要为每个可能传入的闭包专门化。幸运的是，这种情况很容易区分，只需考虑函数是否<em>调用</em>它的某个参数（即，参数出现在某处的「头部位置」）。性能关键的高阶函数，如 <code>map</code>，肯定会直接调用它们的参数函数，因此仍然会按预期进行专门化。此优化通过在前端记录 <code>analyze-variables</code> 传递期间所调用的参数来实现。当 <code>cache_method</code> 看到某个在 <code>Function</code> 类型层次结构的参数传递到声明为 <code>Any</code> 或 <code>Function</code> 的槽时，它的行为就好像应用了 <code>@nospecialize</code> 注释一样。这种启发式方法在实践中似乎非常有效。</p><p>下一个问题涉及方法缓存哈希表的结构。经验研究表明，绝大多数动态分派调用只涉及一个或两个元素。反过来看，只考虑第一个元素便可解决许多这些情况。（旁白：单派发的支持者根本不会对此感到惊讶。但是，这个观点意味着「多重派发在实践中很容易优化」，因此我们应该使用它，而<em>不是</em>「我们应该使用单派发」！）因此，方法缓存使用第一个参数作为其主键。但请注意，这对应于函数调用的元组类型的<em>第二个</em>元素（第一个元素是函数本身的类型）。通常，头部位置的类型非常少变化——实际上，大多数函数属于没有参数的单态类型。但是，构造函数不是这种情况，一个方法表便保存了所有类型的构造函数。因此，<code>Type</code> 方法表是特殊的，使用元组类型的<em>第一个</em>元素而不是第二个。</p><p>前端为所有闭包生成类型声明。起初，这通过生成通常的类型声明来实现。但是，这产生了大量的构造函数，这些构造函数全都很简单（只是将所有参数传递给 <a href="../../base/base/#new"><code>new</code></a>）。因为方法是部分排序的，所以插入所有这些方法是 O(n^2)，此外要保留的方法实在太多了。这可通过直接生成 <code>struct_type</code> 表达式（绕过默认的构造函数生成）并直接使用 <code>new</code> 来创建闭包的实例来优化。这事并不漂亮，但你需要做你该做的。</p><p>下个问题是 <code>@test</code> 宏，它为每个测试用例生成一个 0 参数闭包。这不是必需的，因为每个用例只需运行一次。因此，<code>@test</code> 被改写以展开到一个 try-catch 块中，该块记录测试结果（true、false 或所引发的异常）并对它调用测试套件处理程序。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../compiler/">« 本机代码生成过程的高级概述</a><a class="docs-footer-nextpage" href="../cartesian/">笛卡尔 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">设置</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">选择主题</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>本文档在 <span class="colophon-date" title="2024 十二月 16 周一 16:55">2024 十二月 16 周一</span>用 <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> 1.8.0 版生成使用 1.10.7 版本的 Julia。</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
